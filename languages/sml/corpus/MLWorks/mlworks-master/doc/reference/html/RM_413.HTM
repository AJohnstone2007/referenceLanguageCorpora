<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1977) -->
<HEAD>
<LINK REL=TOP HREF="RM_1.HTM">
<LINK REL=UP HREF="RM_411.HTM">
<LINK REL=PREV HREF="RM_412.HTM">
<LINK REL=NEXT HREF="RM_414.HTM">
<TITLE>7.10.2   The C.Type structure </TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1977)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING413></A>

<DIV>
<P><A HREF="RM_414.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="RM_412.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="RM_411.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="RM_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="RM_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="RM_418.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>7.10   The C structure</P>

</DIV>
<A NAME=HEADING413-0></A>
<H1>7.10.2   The <A NAME=MARKER-2-838></A>C.Type <A NAME=MARKER-2-839></A>structure </H1>
<P>This structure provides support for representing C type information in a manipulable form as ML data.</P>
<STRONG>enum_value</STRONG>
<P><I>Type abbreviation</I></P>
<DL>
<DT><A NAME=MARKER-2-840></A>Specification:<DD><P> <CODE>type enum_value </CODE></P>
<DT>Description:<DD>
<DT><DD>This type is used to model enumerated values. There are conversion functions to and from integers. Equivalent to <CODE>string</CODE>.
</DL>
<STRONG>tag</STRONG>
<P><I>Type abbreviation</I></P>
<DL>
<DT><A NAME=MARKER-2-841></A>Specification:<DD><P> <CODE>type tag </CODE></P>
<DT>Description:<DD>
<DT><DD>This is used to provide convenient 'type' tags. Equivalent to <CODE>string</CODE>.
</DL>
<STRONG>pointer_kind</STRONG>
<P><I>Datatype</I></P>
<DL>
<DT><A NAME=MARKER-2-842></A>Specification:<DD><P> <CODE>datatype pointer_kind = LOCAL_PTR | RELATIVE_PTR | REMOTE_PTR</CODE> </P>
<DT>Description:<DD>
<DT><DD>As described in earlier sections, machine pointers need to be treated with special care. To provide this care, the idea of a 'pointer kind' is introduced. This provides qualification of pointer values and determines how they can be used. A pointer kind is one of the following: 
<DT><CODE>LOCAL_PTR</CODE><DD><P> Machine address pointing within the associated store.</P>
<DT><CODE>REMOTE_PTR</CODE><DD><P> Machine address pointing within user-accessible memory. </P>
<DT><CODE>RELATIVE_PTR</CODE><DD><P> Index value accessing location within associated store.</P>
</DL>
<STRONG><A NAME=MARKER-9-843></A>c_type</STRONG>
<P><I>Datatype</I></P>
<DL>
<DT><A NAME=MARKER-2-844></A>Specification:<DD><P> <CODE>datatype c_type = <BR>&nbsp;&nbsp;&nbsp;&nbsp;VOID_TYPE | CHAR_TYPE | ...</CODE></P>
<DT>Description:<DD>
<DT><DD>The ML type <CODE>c_type</CODE> provides a representation of C type information accessible as an ML value. These values are used to provide information on how to interpret the value parts of <CODE>c_object</CODE> objects used to represent foreign data.
<DT><CODE><A NAME=MARKER-10-845></A>VOID_TYPE</CODE><DD><P> This represents the C type <CODE>void</CODE>. Its size is zero bytes. </P>
<DT><CODE>CHAR_TYPE</CODE><DD><P> This represents the C type <CODE>char</CODE>. Its size is 1 byte. It may be associated with either signed or unsigned chars by the particular C compiler used.</P>
<DT><CODE>UNSIGNED_CHAR_TYPE</CODE><DD>
<DT><DD>This represents the C type <CODE>unsigned char</CODE>.
<DT><CODE>SIGNED_CHAR_TYPE</CODE> <DD>
<DT><DD>This represents the C type <CODE>signed char</CODE>. 
<DT><CODE>SHORT_TYPE</CODE><DD><P> This represents the C type <CODE>short int</CODE>.</P>
<DT><CODE>INT_TYPE</CODE><DD><P> This represents the C type <CODE>int</CODE>.</P>
<DT><CODE>LONG_TYPE</CODE><DD><P> This represents the C type <CODE>long int</CODE>.</P>
<DT><CODE>UNSIGNED_SHORT_TYPE</CODE> <DD>
<DT><DD>This represents the C type <CODE>unsigned short int</CODE>.
<DT><CODE>UNSIGNED_INT_TYPE</CODE> <DD>
<DT><DD>This represents the C type <CODE>unsigned int</CODE>.
<DT><CODE>UNSIGNED_LONG_TYPE</CODE> <DD>
<DT><DD>This represents the C type <CODE>unsigned long int</CODE>.
<DT><CODE>FLOAT_TYPE</CODE> <DD><P> This represents the C type <CODE>float</CODE>.</P>
<DT><CODE>DOUBLE_TYPE</CODE><DD><P> This represents the C type <CODE>double</CODE>.</P>
<DT><CODE>LONG_DOUBLE_TYPE</CODE> <DD>
<DT><DD>This represents the C type <CODE>long double</CODE>.
<DT><CODE>STRING_TYPE of { length : int }</CODE> <DD>
<DT><DD>This represents C string type <CODE>char*</CODE> where each string has an explicit amount of storage allocated for it. This length should include room for the null byte sentinel.
<DT><CODE>TYPENAME of { name : name, defn : c_type, size : int }</CODE> <DD>
<DT><DD>This represents the use of a named type (that is, a name created with <CODE>typedef</CODE>) within a C type.
<DT><CODE>POINTER_TYPE of { ctype : c_type, mode : pointer_kind ref }</CODE> <DD>
<DT><DD>This represents ANSI C's idea of typed pointers. The additional pointer mode information concerns how ML encodes and treats this pointer information. In particular, 'relative' pointers are simply small indices which make indirection within a store workspace more direct and efficient. The representation also caters for 'remote' pointers which can refer to arbitrary places in memory, and 'local' pointers are remote pointers which are known to refer to places in the associated store workspace. 
<DT><DD><A NAME=MARKER-10-846></A> 
<DT><CODE>STRUCT_TYPE of { tag : tag option, fields : c_field list, size : int }</CODE> <DD>
<DT><DD>This represents the structured record type in C. Such types may be tagged or untagged.
<DT><CODE>UNION_TYPE of { tag : tag option, variants : c_variant list ref, size : int, current : c_variant }</CODE> <DD>
<DT><DD>This represents the union type in C. Such types may be tagged or untagged.
<DT><CODE>ARRAY_TYPE of { length : int, ctype : c_type }</CODE> <DD>
<DT><DD>This represents the array type in C.
<DT><CODE>ENUM_TYPE of { tag : tag option, elems : enum_value list, card : int }</CODE> <DD>
<DT><DD>This represents (simple) enumerated types as provided by C. Such types may be tagged or untagged.
</DL>
<STRONG>c_variant</STRONG>
<P><I>Datatype</I></P>
<DL>
<DT><A NAME=MARKER-2-847></A>Specification:<DD><P> <CODE>datatype c_variant = VARIANT of { name : name, ctype : c_type, size : int }</CODE> </P>
<DT>Description:<DD>
<DT><DD>Used to encode members of C unions. Note that each variant object contains its size.
</DL>
<STRONG>c_field</STRONG>
<P><I>Datatype</I></P>
<DL>
<DT><A NAME=MARKER-2-848></A>Specification:<DD><P> <CODE>datatype c_field = FIELD of { name : name, ctype : c_type, size : int, padding : int, offset : int }</CODE> </P>
<DT>Description:<DD>
<DT><DD>This is used to encode field components of C structs. In addition to its size, this representation also has the offset for the field from the start of the record (useful for indexing) and also takes account of any 'padding' required within each field. This padding depends upon the particular compiler used to compile foreign code.
</DL>
<STRONG><A NAME=MARKER-9-849></A>sizeOf</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-850></A>Signature:<DD><P> <CODE>val sizeOf : c_type -&gt; int</CODE> </P>
<DT>Description:<DD>
<DT><DD>This function computes the size of a <CODE>c_type</CODE> object and fills in any size attributes that have not already been computed. Clearly, this requires named types to have had declarations filled in -- with failure if they are not.
</DL>
<STRONG>equalType</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-851></A>Signature:<DD><P> <CODE>val equalType : c_type * c_type -&gt; bool</CODE> </P>
<DT>Description:<DD>
<DT><DD>Because <CODE>c_type</CODE> values can contain size attribute (which may be set to <CODE>NONE</CODE>), this function is used to make equality comparisons between two <CODE>c_types</CODE> which disregard the attribute components they may possess.
</DL>
<P>Some convenience functions for building compound <CODE>c_type</CODE> objects:</P>
<STRONG>structType</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-852></A>Signature:<DD><P> <CODE>val structType : string * (string * c_type) list -&gt; c_type</CODE> </P>
<DT>Description:<DD>
<DT><DD>Builds C struct type representations. Note that these C type objects are tagged.
</DL>
<STRONG>unionType</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-853></A>Signature:<DD><P> <CODE>val unionType : string * (string * c_type) list -&gt; c_type</CODE> </P>
<DT>Description:<DD>
<DT><DD>Builds C union type representations. Note that these C type objects are tagged.
</DL>
<STRONG>ptrType</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-854></A>Signature:<DD><P> <CODE>val ptrType : c_type -&gt; c_type</CODE> </P>
<DT>Description:<DD>
<DT><DD>Builds C pointer type representations.
</DL>
<STRONG>typeName</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-855></A>Signature:<DD><P> <CODE>val typeName : string -&gt; c_type</CODE> </P>
<DT>Description:<DD>
<DT><DD>Builds C named type objects.
</DL>
<STRONG>enumType</STRONG>
<P><I>Function</I></P>
<DL>
<DT><A NAME=MARKER-2-856></A>Signature:<DD><P> <CODE>val enumType : string * string list -&gt; c_type</CODE> </P>
<DT>Description:<DD>
<DT>Builds C enumerated type representations<A NAME=MARKER-2-857></A><DD>
</DL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>MLWorks Reference Manual version 2.0 - 29 Jul 1998</ADDRESS>
<P><A HREF="RM_414.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="RM_412.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="RM_411.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="RM_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="RM_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="RM_418.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>Generated with <A HREF="http://www.harlequin.com/webmaker/">Harlequin WebMaker</A></P>

</DIV>
</BODY>
</HTML>
