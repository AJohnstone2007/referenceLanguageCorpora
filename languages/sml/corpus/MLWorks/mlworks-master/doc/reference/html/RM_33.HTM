<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1977) -->
<HEAD>
<LINK REL=TOP HREF="RM_1.HTM">
<LINK REL=UP HREF="RM_29.HTM">
<LINK REL=PREV HREF="RM_32.HTM">
<LINK REL=NEXT HREF="RM_34.HTM">
<TITLE>3.4.4   Specifying scan frequency and profiling manner details </TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1977)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING33></A>

<DIV>
<P><A HREF="RM_34.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="RM_32.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="RM_29.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="RM_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="RM_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="RM_418.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>3.4   Profiling: the Profile structure </P>

</DIV>
<A NAME=HEADING33-0></A>
<H1>3.4.4   Specifying scan frequency and profiling manner details </H1>
<P>As we have seen, the <A NAME=MARKER-2-187></A><CODE>profile</CODE> function takes an argument <I>options</I>, which is a value of type <CODE>options</CODE>:</P>
<PRE>
datatype options =
&nbsp;&nbsp;Options of
&nbsp;&nbsp;{scan : int,
&nbsp;&nbsp;&nbsp;selector : function_id -&gt; manner}
</PRE>
<P>The fields are:</P>
<DL>
<DT><CODE>scan</CODE><DD><P> The interval in "user" milliseconds between scans of the stack. If <CODE>scan</CODE> is 0, no scans will occur. (By "user" milliseconds, we mean milliseconds of execution time that are devoted solely to running your program, rather than on MLWorks internals.) </P>
<DT><DD>The profiler may not be able to respect very small values for <CODE>scan</CODE>, because it relies on the underlying operating system clock. See <A HREF="RM_44.HTM#MARKER-9-207"><CODE>options</CODE>,  page 34</A>, for details of choosing a realistic value for <CODE>scan</CODE>. 
<DT><CODE>selector</CODE><DD><P> A function that determines the manner that will be used when profiling a particular function. When the profiler is invoked, the <CODE>selector</CODE> function is applied to every function in the MLWorks heap -- including those of MLWorks internals. </P>
</DL>
<P>The <CODE>selector</CODE> function should take a value of type <CODE>function_id</CODE>. Function IDs are strings that begin with the name of the function they identify, but that also contain source and, possibly, compilation information. MLWorks generates a function ID for every function it compiles; you do not have to generate them yourself. The <CODE>selector</CODE> function should return a value of type <CODE>manner</CODE>. </P>
<P>An example best explains how manners and selectors are used. Suppose that an application contains a set of functions for writing data to disk. The functions write data in differing quantities: <CODE>write_element</CODE>, <CODE>write_line</CODE>, and <CODE>write_record</CODE>. Being involved in disk I/O, these functions spend a lot of time in execution. On the other hand, they are not called very often. You might construct a specific profiling manner for these functions, <CODE>write_fns_manner</CODE>, which ensures that time-profiling and space-profiling data is collected for <CODE>write</CODE> functions, but that call counts are not. </P>
<P>To construct the manner:</P>
<PRE>
val write_fns_manner = make_manner { 
&nbsp;&nbsp;time = true, 
&nbsp;&nbsp;space = true, 
&nbsp;&nbsp;calls = false,
&nbsp;&nbsp;copies = true,
&nbsp;&nbsp;depth = 1,
&nbsp;&nbsp;breakdown = [ TOTAL ] 
};
</PRE>
<P>See <A HREF="RM_40.HTM#MARKER-9-200"><CODE>make_manner</CODE>,  page 30</A>, for more details. A suitable selector function might be:</P>
<PRE>
local 
&nbsp;&nbsp;fun is_write_fn s = String.size s &gt;= 5
&nbsp;&nbsp;&nbsp;&nbsp;andalso String.substring (s,0,5) = &quot;write&quot;
in
&nbsp;&nbsp;fun my_selector s = if is_write_fns s then write_fns_manner 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else generic_manner
end;
</PRE>
<P>This selector returns <CODE>write_fns_manner</CODE> for profiling any function whose identifier has the prefix <CODE>write</CODE>. Any other function will be profiled with the manner <CODE>generic_manner</CODE>. </P>
<P>Now you can construct a set of options to pass to <CODE>profile</CODE>. A <CODE>scan</CODE> value of 10 (100 clock ticks per second) or so is typical on both UNIX and Windows.</P>
<PRE>
val my_options = Options { scan = 10, selector = my_selector };<A NAME=MARKER-2-188></A>
</PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>MLWorks Reference Manual version 2.0 - 29 Jul 1998</ADDRESS>
<P><A HREF="RM_34.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="RM_32.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="RM_29.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="RM_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="RM_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="RM_418.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>Generated with <A HREF="http://www.harlequin.com/webmaker/">Harlequin WebMaker</A></P>

</DIV>
</BODY>
</HTML>
