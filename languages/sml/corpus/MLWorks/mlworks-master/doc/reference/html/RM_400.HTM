<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1977) -->
<HEAD>
<LINK REL=TOP HREF="RM_1.HTM">
<LINK REL=UP HREF="RM_397.HTM">
<LINK REL=PREV HREF="RM_399.HTM">
<LINK REL=NEXT HREF="RM_401.HTM">
<TITLE>7.2.3   On the ML side... </TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1977)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING400></A>

<DIV>
<P><A HREF="RM_401.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="RM_399.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="RM_397.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="RM_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="RM_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="RM_418.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>7.2   Overview of the FI</P>

</DIV>
<A NAME=HEADING400-0></A>
<H1>7.2.3   On the ML side... </H1>
<P>Having constructed a shared library in C, we want to make use of it from ML. To do this within MLWorks, we use the tools provided by the <CODE>Interface</CODE> structure. </P>
<P><B>Note:</B> For ease of presentation, we assume that the <CODE>Interface</CODE> structure and its substructures have all been opened with <CODE>open</CODE>. However, we do not advise the use of <CODE>open</CODE> in programs because it makes them difficult to debug.</P>
<P>The ML side of the interface now goes as follows; note that system responses will be prefixed by the greater-than (<CODE>&gt;</CODE>) sign. All of the ML code here is available in <CODE>foreign/samples/hello.sml</CODE>.</P>
<P>The first step is to the foreign code itself. This action creates an ML object called a <CODE>c_structure</CODE>. For example:</P>
<PRE>
val hello_struct =
&nbsp;Interface.C.Structure.loadObjectFile(&quot;hello.so&quot;, Interface.C.Structure.IMMEDIATE_LOAD);
&gt; val hello_struct : c_structure = _
</PRE>
<P>Once this action is complete, raw foreign code will have been loaded into MLWorks. We now want to feed data as arguments to functions in the foreign code -- in this case, the <CODE>hello</CODE> function in the C program -- and then to accept the results of the foreign computations as they are returned to ML. However, there is no means of accessing the foreign code from ML yet. </P>
<P>To access the foreign code we must build ML entities which can access and manipulate foreign data. The FI provides a range of features to help us do so. </P>
<P>The FI requires that foreign data be associated with an ML type. Moreover, there must also be some way of describing how foreign data is to be interpreted and, as it were, "understood". From an operational point of view, this understanding amounts to a qualification of what operations the foreign data may participate in, and hence what form that participation could take.</P>
<P>So, in the FI, each piece of foreign data comes equipped with a <A NAME=MARKER-2-739></A><I>certificate</I> which describes what the interpretation of the data is at any given time. Since these certificates bear information, they must themselves be represented in terms of ML values.</P>
<P>However, the FI further separates the data storage of data values from their representation, by mapping the actual values into "workspace" objects called <I>stores</I>. The interpretation of these data values is then contained in another kind of ML entity called a <CODE>c_object</CODE>, which is rather like a disembodied "container". The idea is that objects are generally associated with a place within some store containing the object's data value. This indirection between object value and the interpretation of that value provides considerable flexibility, even within a strongly typed framework such as ML. Such flexibility is necessary for mimicing enough of a foreign data-typing scheme.</P>
<P>So the next step is to build a store object which will contain the data values, such as the arguments to, and the results from, foreign calls. For example:</P>
<PRE>
val hello_store =	Interface.Store.store{alloc = Interface.Store.ALIGNED_4, overflow = Interface.Store.BREAK, size = 60, status = Interface.Store.RDWR_STATUS }; 
&gt; val hello_store : store = _
</PRE>
<P>We now have a workspace for storing data values relating to the foreign code. The parameters in the call above say that:</P>
<UL>
<LI>Allocation is 4-byte aligned.
<LI>An exception is raised if too much memory is requested.
<LI>The store is 60 bytes in size.
<LI>The store permits both reading and writing of data. 
</UL>
<P>The next step is to build some objects through which foreign data can be manipulated and accessed:</P>
<PRE>
<A NAME=MARKER-10-740></A>val void_object = Interface.C.Value.object { ctype = Interface.C.Type.VOID_TYPE, store = hello_store };
&gt; val void_object : c_type object = _ 

val str_object = Interface.C.Value.object { ctype = Interface.C.Type.STRING_TYPE{ length = 30 }, store = hello_store };
&gt; val str_object : c_type object = _ 

val int_object1 = Interface.C.Value.object { ctype = Interface.C.Type.INT_TYPE, store = hello_store };
&gt; val int_object1 : c_type object = _ 

val int_object2 = Interface.C.Value.object { ctype = Interface.C.Type.INT_TYPE, store = hello_store };
&gt; val int_object2 : c_type object = _ 

val ptr_object = Interface.C.Value.object { ctype = Interface.C.Type.ptrType(Interface.C.Type.VOID_TYPE), store = hello_store };
&gt; val ptr_object : c_type object = _
</PRE>
<P>These objects are associated with particular places in the <CODE>hello_store</CODE>. However, because no values have yet been bound to these objects, read operations upon them are assumed to be invalid. Once they have been written to, they can then be read safely. The following code initializes some of these objects:</P>
<PRE>
Interface.C.Value.setString(str_object, &quot;What is 65 - 42? ---- Ans is &quot;);
Interface.C.Value.setInt(int_object1, 23);
</PRE>
<P>The following code extracts their values: </P>
<PRE>
Interface.C.Value.getString(str_object); 
&gt; val it : string = &quot;What is 65 - 42? ---- Ans is &quot;

Interface.C.Value.getInt(int_object1); 
&gt; val it : int = 23
</PRE>
<P>Having set this data up, we need to use it in conjunction with the foreign code we have already loaded. To do this, we need some signature information concerning the foreign functions we want to use. This requires an empty <CODE>c_signature</CODE> object: </P>
<PRE>
val hello_sig = Interface.C.Signature.newSignature(); 
&gt; val hello_sig : c_signature = _
</PRE>
<P>Next add the following entry to the signature. The entry corresponds to the foreign function we wish to use:</P>
<PRE>
Interface.C.Signature.defEntry(hello_sig, Interface.C.Signature.FUN_DECL { name = &quot;hello&quot;, 
	source = [Interface.C.Type.ptrType(Interface.C.Type.CHAR_TYPE), 
	Interface.C.Type.INT_TYPE] : Interface.C.Type.c_type list, 
	target = Interface.C.Type.INT_TYPE }
);
</PRE>
<P>Note how the form of the signature information follows the structure of the ANSI C prototype for the function. <A NAME=MARKER-10-741></A></P>
<P>We can now use the <CODE>c_signature</CODE> and <CODE>c_structure</CODE> information we have obtained to extract <I>callable entries</I> for the foreign functions they provide.</P>
<PRE>
val def_hello = Interface.C.Function.defineForeignFun(hello_struct, hello_sig); 
&gt; val def_hello : filename -&gt; c_function = fn
</PRE>
<P>Using this, we can obtain a <CODE>c_function</CODE> object that can then be called directly:</P>
<PRE>
val hello = def_hello &quot;hello&quot;; 
&gt; val hello : c_function = _
</PRE>
<P>The above allows foreign functions to be extracted as ML values and bound to ML identifiers in the usual way.</P>
<P>We have almost reached the point at which we can call our foreign function. Before we do, we need to set up the first argument as a character pointer to some string data: </P>
<PRE>
Interface.C.Value.setPtrType { ptr = ptr_object, data = str_object };
Interface.C.Value.setPtrAddrOf { ptr = ptr_object, data = str_object };
Interface.C.Value.castPtrType { ptr = ptr_object, ctype = Interface.C.Type.CHAR_TYPE };
</PRE>
<P>First, the pointer was set to the appropriate type, <CODE>str_object</CODE>. Then it was set to point at the <CODE>str_object</CODE> data. Finally, the pointer was cast to the required argument type. In fact, because strings are such a frequent case, the FI can accept <CODE>STRING_TYPE</CODE> values directly and convert them into an appropriate <CODE>CHAR_TYPE</CODE> pointer, for both argument and result from a foreign function.</P>
<P>Finally, we can call our foreign function <CODE>hello()</CODE> using all we have put together:</P>
<PRE>
Interface.C.Function.call hello ([ptr_object,int_object1], int_object2); 
&gt; val it : unit = ()
</PRE>
<P>The above call required two objects to give the argument values and an object to accept the result. The string</P>
<PRE>
&gt; What is 65 - 42? ---- Ans is 23 
</PRE>
<P>is printed to the standard output.</P>
<P>After the call the result value is deposited in <CODE>int_object2</CODE>. We can extract this value with the following: </P>
<PRE>
getInt(int_object2); 
&gt; val it : int = 65
</PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>MLWorks Reference Manual version 2.0 - 29 Jul 1998</ADDRESS>
<P><A HREF="RM_401.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="RM_399.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="RM_397.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="RM_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="RM_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="RM_418.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>Generated with <A HREF="http://www.harlequin.com/webmaker/">Harlequin WebMaker</A></P>

</DIV>
</BODY>
</HTML>
