Doc No: N1905=05-0165 
Date: 2005-10-19 
Reply to: Pete Becker 

Dinkumware, Ltd. 
petebecker@acm.org 

Working Draft, StandardforProgramming
Language C++


Note: thisisanearly draft.It’sknowntobe incompletand incorrekt,andithaslotsofbad formatting. 


Draft 


Contents 

1 General 1 

1.1 Scope .................................................... 1


1.2 Normative references ............................................ 1


1.3 Definitions.................................................. 1


1.4 Implementationcompliance......................................... 3


1.5 Structureofthis International Standard ................................... 4


1.6 Syntax notation ............................................... 5


1.7 TheC++ memorymodel........................................... 5


1.8 TheC++ objectmodel ............................................ 5


1.9 Programexecution ............................................. 6


1.10 Acknowledgments ............................................. 9


2 Lexical conventions 11 

2.1 Phasesof translation ............................................ 11


2.2 Charactersets ................................................ 12


2.3Trigraph sequences ............................................. 13


2.4 Preprocessingtokens ............................................ 14


2.5 Alternativetokens .............................................. 14


2.6Tokens .................................................... 15


2.7 Comments.................................................. 15


2.8 Header names ................................................ 15


2.9 Preprocessing numbers ........................................... 16


2.10 Identifiers .................................................. 16


2.11Keywords .................................................. 17


2.12 Operatorsand punctuators ......................................... 17


2.13 Literals ................................................... 18


3 Basic concepts 25 

3.1 Declarationsand definitions ........................................ 25


3.2 One definitionrule ............................................. 27


3.3 Declarativeregionsandscopes ....................................... 29


3.4 Namelookup ................................................ 34


3.5 Programandlinkage ............................................ 48


3.6 Startand termination ............................................ 51



CONTENTS CONTENTS iv 

3.7 Storage duration ............................................... 54


3.8 Object Lifetime ............................................... 56


3.9Types .................................................... 60


3.10Lvaluesandrvalues ............................................. 65


4 Standard conversions 67 

4.1 Lvalue-to-rvalueconversion ........................................ 68


4.2 Array-to-pointerconversion......................................... 68


4.3 Function-to-pointerconversion ....................................... 68


4.4 Qualificationconversions .......................................... 68


4.5 Integral promotions ............................................. 70


4.6 Floatingpoint promotion .......................................... 70


4.7 Integralconversions ............................................. 70


4.8 Floatingpointconversions ......................................... 70


4.9 Floating-integralconversions ........................................ 71


4.10 Pointerconversions ............................................. 71


4.11 Pointerto memberconversions ....................................... 71


4.12 Booleanconversions ............................................ 72


5 Expressions 73 

5.1 Primaryexpressions ............................................. 74


5.2 Postfixexpressions ............................................. 76


5.3 Unaryexpressions .............................................. 88


5.4 Explicittypeconversion(cast notation) .................................. 95


5.5 Pointer-to-memberoperators ........................................ 96


5.6 Multiplicative operators........................................... 97


5.7 Additive operators .............................................. 97


5.8 Shift operators ................................................ 98


5.9 Relational operators ............................................. 99


5.10 Equality operators .............................................. 100


5.11 BitwiseAND operator ........................................... 101


5.12 BitwiseexclusiveORoperator ....................................... 101


5.13 Bitwise inclusiveORoperator ....................................... 101


5.14 LogicalAND operator ........................................... 101


5.15 LogicalOR operator ............................................ 102


5.16 Conditional operator ............................................ 102


5.17 Assignmentand compoundassignment operators ............................. 103


5.18 Comma operator .............................................. 104


5.19 Constantexpressions ............................................ 104


6 Statements 107 

6.1 Labeled statement .............................................. 107


6.2 Expression statement ............................................ 107


6.3 Compound statementorblock ....................................... 107


6.4 Selection statements ............................................. 108


6.5 Iteration statements ............................................. 110


Draft 


v CONTENTS CONTENTS 

6.6 Jump statements ............................................... 112


6.7 Declaration statement ............................................ 113


6.8 Ambiguity resolution ............................................ 114


7 Declarations 117 

7.1 Specifiers .................................................. 118


7.2 Enumeration declarations .......................................... 128


7.3 Namespaces................................................. 130


7.4 The asm declaration............................................. 144


7.5 Linkage specifications ........................................... 144


8 Declarators 149 

8.1Type names ................................................. 150


8.2 Ambiguity resolution ............................................ 151


8.3 Meaningof declarators ........................................... 152


8.4 Function definitions ............................................. 164


8.5 Initializers.................................................. 165


9 Classes 175 

9.1 Class names ................................................. 176


9.2 Class members ............................................... 178


9.3 Member functions .............................................. 180


9.4 Static members ............................................... 184


9.5 Unions.................................................... 186


9.6 Bit-fields .................................................. 187


9.7 Nestedclass declarations .......................................... 188


9.8 Localclass declarations........................................... 189


9.9 Nestedtype names ............................................. 190


10 Derived classes 191 

10.1 Multiplebase classes ............................................ 192


10.2 Member namelookup ............................................ 194


10.3Virtual functions .............................................. 198


10.4 Abstract classes ............................................... 202


11 Member access control 205 

11.1 Access specifiers .............................................. 207


11.2 Accessibilityofbaseclassesandbaseclass members ........................... 208


11.3 Access declarations ............................................. 210


11.4 Friends ................................................... 211


11.5 Protectedmemberaccess .......................................... 215


11.6 Accessto virtual functions ......................................... 216


11.7 Multiple access ............................................... 217


11.8 Nested classes ................................................ 217


12 Special member functions 219 

12.1 Constructors................................................. 219


Draft 


CONTENTS CONTENTS vi 

12.2Temporaryobjects ............................................. 221


12.3 Conversions ................................................. 223


12.4 Destructors ................................................. 226


12.5 Free store .................................................. 229


12.6 Initialization................................................. 231


12.7 Constructionand destruction ........................................ 236


12.8Copyingclassobjects ............................................ 239


13 Overloading 245 

13.1Overloadable declarations ......................................... 245


13.2 Declaration matching ............................................ 248


13.3Overload resolution ............................................. 249


13.4 Addressofoverloadedfunction ....................................... 265


13.5Overloaded operators ............................................ 267


13.6 Built-in operators .............................................. 270


14 Templates 275 

14.1Template parameters ............................................ 276


14.2 Namesof templatespecializations ..................................... 279


14.3Templatearguments ............................................. 281


14.4Typeequivalence .............................................. 286


14.5Template declarations ............................................ 287


14.6 Name resolution ............................................... 301


14.7Template instantiationand specialization .................................. 314


14.8 Function templatespecializations ...................................... 327


15 Exception handling 345 

15.1 Throwinganexception ........................................... 346


15.2 Constructorsand destructors ........................................ 348


15.3 Handlinganexception ........................................... 349


15.4 Exception specifications .......................................... 351


15.5 Special functions .............................................. 353


15.6 Exceptionsand access ............................................ 355


16 Preprocessing directives 357 

16.1 Conditional inclusion ............................................ 359


16.2 Sourcefile inclusion ............................................ 360


16.3 Macro replacement ............................................. 361


16.4 Line control ................................................. 367


16.5 Error directive................................................ 367


16.6 Pragma directive .............................................. 367


16.7 Null directive ................................................ 368


16.8 Predefined macro names .......................................... 368


16.9 Pragma operator ............................................... 369


17 Library introduction 371 

Draft 


vii CONTENTS CONTENTS 

17.1 Definitions.................................................. 371


17.2 Additional definitions ............................................ 374


17.3 Methodof description(Informative) .................................... 374


17.4 Library-wide requirements ......................................... 380


18 Language support library 389 

18.1Types .................................................... 389


18.2 Implementation properties ......................................... 390


18.3 Startand termination ............................................ 399


18.4 Dynamicmemorymanagement ....................................... 401


18.5Type identification ............................................. 405


18.6 Exception handling ............................................. 408


18.7 Other runtime support ............................................ 411


19 Diagnostics library 415 

19.1 Exception classes .............................................. 415


19.2 Assertions.................................................. 419


19.3 Error numbers ................................................ 419


20 General utilities library 421 

20.1 Requirements................................................ 421


20.2 Utility components ............................................. 425


20.3 Functionobjects ............................................... 427


20.4 Memory................................................... 437


20.5 Dateandtime ................................................ 445


21 Strings library 447 

21.1 Character traits ............................................... 447


21.2 String classes ................................................ 452


21.3 Class template basic_string ....................................... 454


21.4 Null-terminated sequence utilities ..................................... 480


22 Localization library 485 

22.1 Locales ................................................... 485


22.2 Standard locale categories ........................................ 495


22.3CLibrary Locales .............................................. 537


23 Containers library 539 

23.1 Container requirements ........................................... 539


23.2 Sequences.................................................. 548


23.3 Associative containers ........................................... 574


24 Iterators library 597 

24.1 Iterator requirements ............................................ 597


24.2 Header <iterator> synopsis ....................................... 602


24.3 Iteratorprimitives .............................................. 605


24.4 Predefined iterators ............................................. 608


Draft 


CONTENTS CONTENTS viii 

24.5 Stream iterators ............................................... 619


25 Algorithms library 627 

25.1 Non-modifying sequence operations .................................... 637


25.2 Mutating sequenceoperations ....................................... 640


25.3 Sortingand relatedoperations ....................................... 648


25.4Clibrary algorithms ............................................. 660


26 Numerics library 663 

26.1 Numerictype requirements ......................................... 663


26.2 Complex numbers .............................................. 664


26.3 Numeric arrays ............................................... 672


26.4 Generalized numericoperations ...................................... 694


26.5CLibrary .................................................. 697


27 Input/output library 701 

27.1 Iostreams requirements ........................................... 701


27.2Forward declarations ............................................ 701


27.3 Standard iostreamobjects.......................................... 704


27.4 Iostreamsbase classes............................................ 706


27.5 Streambuffers................................................ 724


27.6Formattingandmanipulators ........................................ 734


27.7 String-based streams ............................................ 759


27.8 File-based streams ............................................. 768


A Grammar summary 781 

A.1Keywords .................................................. 781


A.2 Lexicalconventions ............................................. 781


A.3 Basic concepts ............................................... 785


A.4 Expressions................................................. 785


A.5 Statements.................................................. 788


A.6 Declarations................................................. 789


A.7 Declarators ................................................. 792


A.8 Classes ................................................... 793


A.9 Derived classes ............................................... 794


A.10 Special member functions.......................................... 794


A.11Overloading ................................................. 795


A.12Templates .................................................. 795


A.13 Exception handling ............................................. 796


A.14 Preprocessing directives .......................................... 796


B Implementation quantities 799 

C Compatibility 801 

C.1 C++ andISOC ............................................... 801


C.2 StandardClibrary .............................................. 811


Draft 


ix CONTENTS CONTENTS 

D Compatibility features 817 

D.1 Increment operator with bool operand................................... 817


D.2 statickeyword................................................ 817


D.3 Access declarations ............................................. 817


D.4 Implicitconversionfromconststrings ................................... 817


D.5 StandardClibraryheaders ......................................... 817


D.6 Old iostreams members........................................... 818


D.7 char* streams................................................ 819


E Universal-character-names 831 

Draft 


CONTENTS CONTENTS 

Draft 


List ofTables 

1 trigraph sequences ............................................. 13
2 alternativetokens .............................................. 15
3 keywords .................................................. 17
4 alternative representations ......................................... 17
5 TypesofInteger Constants ......................................... 20
6 escape sequences .............................................. 21


7 relations on const and volatile ..................................... 65


8 simple-type-specifier sandthetypestheyspecify .............................. 126


9 relationship betweenoperatorand functioncall notation .......................... 254
10 conversions ................................................. 261


11 LibraryCategories ............................................. 374
12 C++ Library Headers ............................................ 381
13 C++ HeadersforCLibraryFacilities .................................... 381
14 C++ Headersfor FreestandingImplementations .............................. 382


15 Language supportlibrary summary ..................................... 389
16 Header <cstddef> synopsis ........................................ 390
17 Header <climits> synopsis ........................................ 399
18 Header <cfloat> synopsis......................................... 399
19 Header <cstdlib> synopsis ........................................ 399
20 Header <cstdarg> synopsis ........................................ 411
21 Header <csetjmp> synopsis ........................................ 412
22 Header <ctime> synopsis ......................................... 412
23 Header <csignal> synopsis ........................................ 412
24 Header <cstdlib> synopsis ........................................ 412


25 Diagnosticslibrarysummary ........................................ 415
26 Header <cassert> synopsis ........................................ 419
27 Header <cerrno> synopsis......................................... 419



LISTOFTABLES LISTOFTABLES xii 

28 General utilitieslibrary summary ...................................... 421
29 EqualityComparable requirements.................................... 421
30 LessThanComparable requirements.................................... 422
31 CopyConstructible requirements .................................... 422
32 Swappable requirements.......................................... 422
33 Descriptivevariabledefinitions ....................................... 423
34 Allocator requirements ........................................... 424
35 Header <cstdlib> synopsis ........................................ 444
36 Header <cstring> synopsis ........................................ 444
37 Header <ctime> synopsis ......................................... 445


38 Stringslibrary summary .......................................... 447
39Traits requirements ............................................. 448
40 basic_string(const Allocator&) effects ............................... 459
41 basic_string(basic_string, size_type, size_type, const Allocator&) effects ..... 460
42 basic_string(const charT*, size_type, const Allocator&) effects ............. 460
43 basic_string(const charT*, const Allocator&) effects ..................... 461
44 basic_string(size_t, charT, const Allocator&) effects .................... 461
45 operator=(const basic_string<charT, traits, Allocator>&) effects ............ 461
46 compare() results ............................................. 474
47 Header <cctype> synopsis......................................... 480
48 Header <cwctype> synopsis ........................................ 480
49 Header <cstring> synopsis ........................................ 480
50 Header <cwchar> synopsis......................................... 481
51 Header <cstdlib> synopsis ........................................ 481


52 Localizationlibrarysummary........................................ 485
53 LocaleCategoryFacets ........................................... 489
54 Required Specializations .......................................... 490
55 do_in/do_out resultvalues ........................................ 505
56 do_unshift resultvalues ......................................... 506
57 IntegerConversions ............................................. 509
58 Length Modifier ............................................... 510
59 IntegerConversions ............................................. 514
60 Floating-pointConversions ......................................... 514
61 Length Modifier ............................................... 514
62 Numericconversions ............................................ 514
63 Fillpadding ................................................. 515
64 do_get_date effects ............................................ 522
65 Header <clocale> synopsis ........................................ 537


66 Containerslibrarysummary ........................................ 539
67 Assignable requirements ......................................... 539
68 Container requirements ........................................... 540
69 Reversible containerrequirements ..................................... 542
70 Sequence requirements(in additionto container) ............................. 543


Draft 


xiii LISTOFTABLES LISTOFTABLES 

71 Optional sequenceoperations ........................................ 545 
72 Associative container requirements (in addition to container) . . . . . . . . . . . . . . . . . . . . . . . 546 

73 Iteratorslibrarysummary .......................................... 597 
74 Relationsamongiteratorcategories..................................... 597 
75 Input iterator requirements ......................................... 599 
76 Output iterator requirements ........................................ 599 
77Forward iteratorrequirements ....................................... 600 
78 Bidirectional iterator requirements (in addition to forward iterator) . . . . . . . . . . . . . . . . . . . . 601 
79 Random access iterator requirements (in addition to bidirectional iterator) . . . . . . . . . . . . . . . . 602 

80 Algorithmslibrarysummary ........................................ 627
81 Header <cstdlib> synopsis ........................................ 660


82 Numericslibrarysummary ......................................... 663
83 Header <cmath> synopsis ......................................... 697
84 Header <cstdlib> synopsis ........................................ 697


85 Input/outputlibrarysummary ........................................ 701
86 fmtflags effects .............................................. 711
87 fmtflags constants............................................. 711
88 iostate effects ............................................... 711
89 openmode effects .............................................. 711
90 seekdir effects ............................................... 712
91 Positiontype requirements ......................................... 717
92 basic_ios::init() effects ........................................ 719
93 seekoff positioning ............................................ 763
94 newoff values................................................ 763
95 Fileopenmodes ............................................... 771
96 seekoff effects ............................................... 774
97 Header <cstdio> synopsis......................................... 779


98 Standard Macros .............................................. 811
99 StandardValues ............................................... 812
100 StandardTypes ............................................... 812
101 Standard Structs ............................................... 812
102 Standard Functions ............................................. 813


103CHeaders .................................................. 817
104 strstreambuf(streamsize) effects ................................... 821
105 strstreambuf(void* (*)(size_t), void (*)(void*)) effects .................. 822
106 strstreambuf(charT*, streamsize, charT*) effects ........................ 822
107 seekoff positioning ............................................ 825
108 newoff values................................................ 825


Draft 


LISTOFTABLES LISTOFTABLES xiv 

Draft 


Chapter1 General [intro]


1.1 Scope [intro.scope] 
1 ThisInternational Standard specifies requirementsfor implementationsoftheC++programming language. The first such 
requirementisthattheyimplementthe language,andsothisInternational Standardalso definesC++. Other requirements 
and relaxations of the first requirement appear at various places within this International Standard. 

2C++ is a general purpose programming language based on the C programming language as described in ISO/IEC 
9899:1990 Programming languages -C(1.2).In additiontothefacilitiesprovidedbyC,C++ provides additional data 
types, classes, templates, exceptions, namespaces, inline functions, operator overloading, function name overloading, 
references, free store management operators, and additional libraryfacilities. 

1.2 Normative references [intro.refs] 
1 The following standards contain provisions which, through reference in this text, constitute provisions of this International Standard.Atthetimeof publication,the editions indicated werevalid.All standardsaresubjecttorevision,and 
parties to agreements based on this International Standard are encouragedto investigate the possibility of applying the 
most recent editions of the standards indicated below. Members of IEC and ISO maintain registers of currently valid 
International Standards. 

— ISO/IEC 2382 (all parts), Information technology -Vocabulary 
— ISO/IEC 9899:1990, Programming languages -C 
— ISO/IEC 9899/Amd.1:1995, Programming languages -C, AMENDMENT1:CIntegrity 
— ISO/IEC 10646-1:1993 Information technology -Universal Multiple-OctetCoded Character Set (UCS) -Part1: 
Architecture and Basic Multilingual Plane 
2 The library describedin clause7of ISO/IEC 9899:1990and clause7of ISO/IEC9899/Amd.1:1995is hereinafter called 
the StandardCLibrary.1) 

1.3 Definitions [intro.defs] 
1 For the purposes of this International Standard, the definitions given in ISO/IEC 2382 and the following definitions 
apply. 17.1 defines additional termsthat are used onlyin clauses 17 through27 and Annex D. 

1)With the qualifications notedin clauses17 through27, andin C.2, the StandardClibraryisa subsetof the StandardC++library. 


1.3 Definitions General 2 
Terms that are used only in a small portion of this International Standard are defined where theyare used and italicized 
where they are defined. 

1.3.1 argument [defns.argument] 
an expression in the comma-separated list bounded by the parentheses in a function call expression, a sequence of 
preprocessing tokensinthe comma-separated list boundedby the parenthesesina function-like macroinvocation, the 
operand of throw,or anexpression,type-id or template-name in the comma-separated list boundedbythe angle brackets 
in a template instantiation. Also known as an actual argument or actual parameter. 

1.3.2 conditionally-supported [defns.cond.supp] 
a program construct that an implementation is not required to support. [Note: Each implementation documents all 
conditionally-supported constructs that it does not support. — end note ] 

1.3.3 diagnostic message [defns.diagnostic] 
a message belonging to an implementation-defined subset of the implementation’s output messages. 

1.3.4 dynamic type [defns.dynamic.type] 
thetypeofthemostderivedobject(1.8)towhichthelvalue denotedbyanlvalueexpression refers. [Example: if a 
pointer(8.3.1)p whose static type is “pointer to class B” is pointing to an object of class D, derived from B (clause 10), 
the dynamic type of the expression *p is “D.” References(8.3.2)are treatedsimilarly. — end example ]The dynamic 
type of an rvalue expression is its static type. 

1.3.5 ill-formed program [defns.ill.formed] 
input toaC++ implementation thatis notawell-formed program(1.3.15). 

1.3.6 implementation-defined behavior [defns.impl.defined] 
behavior, for a well-formed program construct and correct data, that depends on the implementation and that each 
implementation documents. 

1.3.7 implementation limits [defns.impl.limits] 
restrictions imposed upon programs by the implementation. 

1.3.8 locale-specific behavior [defns.locale.specific] 
behavior that depends on local conventions of nationality, culture, and language that each implementation documents. 

1.3.9 multibyte character [defns.multibyte] 
asequenceofoneormorebytes representingamemberoftheextended charactersetofeitherthe sourceortheexecution 
environment. Theextended character setisa supersetof the basic character set(2.2). 

1.3.10 parameter [defns.parameter] 
an object or reference declared as part of a function declaration or definition, or in the catch clause of an exception 
handler, that acquires a value on entry to the function or handler; an identifier from the comma-separated list bounded 

Draft 


3 General 1.4 Implementation compliance 

by the parentheses immediately following the macro name in a function-like macro definition; or a template-parameter. 
Parameters are also known asformal arguments or formal parameters. 

1.3.11 signature [defns.signature] 
the information abouta function that participatesinoverload resolution(13.3): its parameter-type-list(8.3.5)and,if the 
functionisa class member, the cv-qualifiers (if any) on the function itself and the class in which the member function is 
declared.2) The signatureofa function template specialization includes the typesof its template arguments(14.5.5.1). 

1.3.12 static type [defns.static.type] 
thetypeofanexpression(3.9),whichtyperesultsfromanalysisoftheprogramwithoutconsideringexecution semantics. 
The static type of an expression depends only on the form of the program in which the expression appears, and does not 
change while the program is executing. 

1.3.13 undefined behavior [defns.undefined] 
behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International 
Standardimposesno requirements. Undefinedbehaviormayalsobeexpectedwhenthis International Standard omits 
the descriptionofany explicit definitionof behavior.[Note: permissible undefined behavior ranges from ignoring the 
situation completelywith unpredictable results, to behaving during translation or program execution in a documented 
manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). Many erroneous program constructs do not engender 
undefined behavior; theyare required to be diagnosed. — end note ] 

1.3.14 unspecified behavior [defns.unspecified] 
behavior, for a well-formed program construct and correct data, that depends on the implementation. The implementationisnot requiredto documentwhichbehavior occurs.[ Note: usually, the rangeof possible behaviorsis delineatedby 
this International Standard. — end note ] 

1.3.15 well-formed program [defns.well.formed] 
aC++program constructed according to the syntax rules, diagnosable semantic rules, and the One Definition Rule(3.2). 

1.4 Implementation compliance [intro.compliance] 
1 The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except for those 
rules containing an explicit notation that “no diagnostic is required” or which are described as resulting in “undefined 
behavior.” 

2 Although this International Standard states only requirements onC++ implementations, those requirements are often 
easierto understandiftheyare phrasedas requirementson programs, partsof programs,orexecutionof programs. Such 
requirements have the following meaning: 

— Ifa program containsno violationsof the rulesin this InternationalStandard,a conforming implementation shall, 
within its resource limits, accept and correctly execute3) that program. 
2) Function signatures do not include return type, because that does not participate in overload resolution.
3) “Correct execution” can include undefined behavior, depending on the data being processed; see 1.3 and 1.9.


Draft 


1.5 Structure of this International Standard General 4 
— Ifa program containsa violationofanydiagnosableruleoran occurrenceofa construct describedinthis Standard 
as “conditionally-supported” when the implementation does not support that construct, a conforming implementation shall issue at leastone diagnostic message, except that 
— If a program contains a violation of a rule for which no diagnostic is required, this International Standard places 
no requirement on implementations with respect to that program. 
3 For classes and class templates, the library clauses specify partial definitions. Private members (clause 11)are not 
specified,but each implementation shall supply them to complete the definitions according to thedescriptionin the 
library clauses. 

4 For functions, function templates, objects, and values, the library clauses specify declarations. Implementations shall 
supply definitions consistentwith the descriptions in the library clauses. 

5 The namesdefinedin the libraryhave namespace scope(7.3).AC++translation unit(2.1)obtains access to these names 
by including the appropriate standard library header(16.2). 

6 The templates, classes, functions,and objectsinthe libraryhaveexternal linkage(3.5). The implementationprovides 
definitionsforstandardlibraryentities,asnecessary,whilecombining translationunitstoformacompleteC++program 
(2.1). 

7 Two kinds of implementations are defined: hosted and freestanding. For a hosted implementation, this International 
Standard defines the setofavailable libraries.Afreestanding implementationis onein whichexecution may take place 
without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain 
language-support libraries(17.4.1.3). 

8 Aconformingimplementation may have extensions (including additional library functions), provided theydo not alter 
the behavior of anywell-formed program. Implementations are required to diagnose programs that use such extensions 
that are ill-formed according to this International Standard. Having done so, however, they can compile and execute 
such programs. 

9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not 
support and defines all locale-specific characteristics.4) 

1.5 Structure of this International Standard [intro.structure] 
1 Clauses2through16 describetheC++programming language. That description includes detailed syntactic specifications 
ina form describedin 1.6.For convenience, Annex Arepeats all such syntacticspecifications. 

2 Clauses17 through27 and Annex D(the library clauses)describe the StandardC++ library, which provides definitions 
for the following kindsof entities: macros(16.3),values (clause 3), types(8.1, 8.3), templates (clause 14), classes 
(clause9), functions(8.3.5), and objects (clause 7). 

3 Annex Brecommendslower bounds onthe capacityof conforming implementations. 

4 Annex C summarizes theevolutionofC++ since its first published description, and explains in detail the differences 
betweenC++ andC. Certain featuresofC++ exist solely for compatibility purposes; Annex Ddescribes those features. 

5 Finally, Annex Esays what characters arevalidin universal-character namesinC++ identifiers(2.10). 

4)This documentation also defines implementation-defined behavior; see 1.9. 

Draft 


5 General 1.6 Syntax notation 

6 Throughout this International Standard, each example is introduced by “[ Example:” and terminated by “ — end example ]”. Each noteis introducedby“[ Note:” and terminatedby “ — end note ]”. Examples and notes may be nested. 

1.6 Syntax notation [syntax] 
1 In the syntax notation used in this International Standard, syntactic categories are indicated by italic type, and literal 
words and characters in constant width type. Alternatives are listed on separate lines except in a few cases where a 
long set of alternatives is presented on one line, marked by the phrase “one of.” An optional terminal or nonterminal 
symbol is indicated by the subscript “opt”, so 

{ expression opt } 

indicates an optional expression enclosed in braces. 
2 Names for syntactic categories have generally been chosen according to the following rules: 

— X-name is a use of an identifier in a context that determines its meaning (e.g. class-name, typedef-name). 
— X-id is an identifier with no context-dependent meaning (e.g. qualified-id). 
— X-seq is one or more X’s without intervening delimiters (e.g. declaration-seq is a sequence of declarations). 
— X-list is one or more X’s separated by intervening commas (e.g. expression-list is a sequence of expressions 
separated by commas). 
1.7 TheC++ memory model [intro.memory] 
1 The fundamental storage unit in the C++ memory model is the byte. A byte is at least large enough to contain any 
member of the basic execution character set and is composed of a contiguous sequence of bits, the number of which 
is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the 
high-order bit. The memoryavailabletoaC++ program consists of one or more sequences of contiguous bytes. Every 
byte has a unique address. 

2 [Note: the representation of types is described in 3.9. — end note ] 

1.8 TheC++ object model [intro.object] 
1 The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is a region of 
storage. [Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects 
do. — end note ]An object is created by adefinition (3.1), by a new-expression (5.3.4)orby the implementation(12.2) 
when needed. The properties of an object are determined when the object is created. An object can have a name (clause 
3). An object has a storage duration (3.7)which influences itslifetime (3.8). An object has a type (3.9). The term 
object type refers to the type with which the object is created. Some objects are polymorphic (10.3); the implementation 
generates information associated with each such object that makes it possible to determine that object’s type during 
program execution. For other objects, the interpretation of the values found therein is determined by the type of the 
expressions (clause 5)used to access them. 

2 Objects can contain other objects, called subobjects.Asubobject canbea member subobject (9.2),abase class subobject 
(clause 10), or an array element. An object that is not a subobject of anyother object is called a complete object. 

3 For every objectx, there is some object called the complete object of x, determined as follows: 

— If x is a complete object, then x is the complete object of x. 
Draft 


1.9 Program execution General 6 
— Otherwise, the complete object of x is the complete object of the (unique) object that contains x. 
4 Ifa complete object,a data member(9.2), or an array elementisof class type, its typeis considered the most derived 
class, to distinguish it from the class type of anybase class subobject; an object of a most derived class type is called a 
most derived object. 

5 Unlessitisa bit-field(9.6),a most derived objectshallhavea non-zero size and shall occupy one or more bytesof 
storage. Base class subobjects may have zero size. An object of POD5) type(3.9)shall occupy contiguous bytes of 
storage. 

6 [Note: C++ providesavarietyofbuilt-in types and severalwaysof composing new types fromexisting types(3.9). 

— end note ] 
1.9 Program execution [intro.execution] 
1 The semantic descriptionsin this International Standarddefinea parameterized nondeterministic abstract machine. This 
International Standard places no requirement on the structure of conforming implementations. In particular, theyneed 
not copy or emulate the structure of the abstract machine. Rather, conforming implementations are required to emulate 
(only) the observable behavior of the abstract machine as explained below.6) 

2 Certain aspects andoperations of the abstract machine are described in this International Standard as implementation-
defined (for example, sizeof(int)). These constitute the parameters of the abstract machine. Each implementation 
shall include documentation describing its characteristics and behavior in these respects.7) Such documentation shall 
define the instance of the abstract machine that corresponds to that implementation (referred to as the “corresponding 
instance” below). 

3 Certain other aspects and operations of the abstract machine are describedin this International Standard as unspecified 
(for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set 
of allowable behaviors.These definethe nondeterministic aspectsofthe abstract machine.Aninstanceofthe abstract 
machine can thus have more than one possible execution sequence for a given program and a given input. 

4 Certain other operations are described in this International Standard as undefined (for example, the effect of dereferencing the null pointer).[ Note: this International Standard imposes no requirements on the behavior of programs that 
contain undefined behavior. — end note ] 

5 A conforming implementation executing a well-formed program shall produce the same observable behavior as one 
ofthepossibleexecution sequencesofthe corresponding instanceofthe abstract machinewiththe same programand 
the same input. However, if anysuch execution sequence contains an undefined operation, this International Standard 
places no requirement on the implementation executing that program with that input (not even with regard to operations 
preceding the first undefined operation). 

6 The observablebehaviorofthe abstract machineisits sequenceof readsand writesto volatile data and calls to library 
I/O functions.8) 

5) The acronym POD stands for “plain old data.” 

6)Thisprovisionis sometimescalledthe“as-if”rule,becauseanimplementationisfreetodisregardanyrequirementofthis InternationalStandard 
as long as the result is as if the requirement had been obeyed, asfar as canbe determined from the observable behaviorof the program.For instance, 
an actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no side effects affecting the 
observable behavior of the program are produced. 

7)This documentation also includes conditonally-supported constructs and locale-specific behavior. See 1.4.
8) An implementation can offer additional library I/O functions as an extension. Implementations that do so should treat calls to those functions as


Draft 


7 General 1.9 Program execution 

7 Accessing an object designated by a volatile lvalue(3.10), modifying an object, callinga library I/O function, or 
calling a function that does anyof those operations are all side effects, which are changes in the state of the execution 
environment. Evaluation of an expression might produce side effects. At certain specified points in the execution sequence called sequence points,allsideeffectsofpreviousevaluationsshallbecompleteandnosideeffectsof subsequent 
evaluations shallhave takenplace.9) 

8 Once the execution of a function begins, no expressions from the calling function are evaluated until execution of the 
called function has completed.10) 

9 When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects with type other 
than volatile std::sig_atomic_t are unspecified, and the value of any object not of volatile std::sig_
atomic_t that is modified by the handler becomes undefined. 

10 An instanceof each object with automatic storage duration(3.7.2)is associated with each entry into its block. Such an 
object exists and retains its last-stored value during the execution of the block and while the block is suspended (by a 
call of a function or receipt of a signal). 

11 The least requirements on a conforming implementation are: 

— At sequence points, volatile objects are stable in the sense that previous evaluations are complete and subsequent 
evaluations have not yet occurred. 
— At program termination,alldata writtenintofilesshallbe identicaltooneofthepossible resultsthatexecutionof 
the program according to the abstract semantics would have produced. 
— Theinputandoutput dynamicsof interactivedevicesshalltakeplaceinsuchafashionthat prompting messages 
actually appear prior to a program waiting for input. What constitutes an interactive device is implementation-
defined. 
[Note: more stringent correspondences between abstract and actual semantics may be defined by each implementation. 

— end note ] 
12 Afull-expression isanexpressionthatisnotasubexpressionof anotherexpression.Ifa language constructis definedto 
produce an implicit call of a function, a use of the language construct is considered to be an expression for the purposes 
ofthis definition.Conversionsappliedtotheresultofanexpressioninordertosatisfytherequirementsofthelanguage 
constructinwhichtheexpression appearsarealso consideredtobepartofthe full-expression.[ Example: 

struct S {
S(int i): I(i) { }
int& v() { return I; }


private :
int I;
};


S s1 (1); // full-expression is call of S::S(int)
Ss2 =2; // full-expression is call of S::S(int)


“observable behavior” as well. 

9) Note that some aspects of sequencing in the abstract machine are unspecified; the preceding restriction upon side effects applies to that particular 

execution sequence in which the actual code is generated. Also note that when a call to a library I/O function returns, the side effect is considered 

complete, even though some external actions implied by the call (such as the I/O itself) may not have completed yet. 

10) In other words, function executions do not “interleave” with each other. 

Draft 


1.9 Program execution General 8 
void f() { 

if (S(3).v()) // full-expression includes lvalue-to-rvalue and
// int to bool conversions, performed before
// temporary is deleted at end of full-expression


{}
}


— end example ] 
13 [Note: the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically part of the 
full-expression.Forexample, subexpressionsinvolvedinevaluatingdefaultargumentexpressions(8.3.6)are considered 
to be createdin the expression that calls the function, not the expression that defines the default argument. — end note ] 

14 [Note: operators can be regroupedaccording to the usual mathematical rules only where the operators really are associative or commutative.11)Forexample,in the following fragment 

int a, b; 

/* ... * / 

a=a+32760 + b+5; 

the expression statement behaves exactly the same as 

a = (((a + 32760) + b) + 5); 

due to the associativity and precedence of these operators. Thus, the result of the sum (a + 32760) is next added to 
b,andthatresultisthen addedto5which resultsinthevalue assignedto a.On a machine in which overflows produce 
an exception and in which the range of values representable by an int is [-32768,+32767], the implementation cannot 
rewrite this expression as 

a = ((a + b) + 32765); 

sinceif thevaluesfor a and b were, respectively, -32754 and -15, the sum a+b would produce an exception while the 
original expression would not; nor can the expression be rewritten either as 

a = ((a + 32765) + b); 

or 

a = (a + (b + 32765)); 

since thevalues for a and b mighthave been, respectively,4and-8or-17and12.Howeveronamachineinwhichoverflows do not produce an exception and in which the results of overflows are reversible, the above expression statement 
can be rewritten by the implementation in anyof the above ways because the same result will occur. — end note ] 

15 Thereisa sequence pointatthe completionofevaluationof each full-expression12). 

16 When calling a function (whether or not the function is inline), there is a sequence point after the evaluation of all 
function arguments (if any)which takes place before execution of any expressions or statements in the function body. 

11) Overloaded operators are never assumed to be associative or commutative.
12) As specified in 12.2, after the “end-of-full-expression” sequence point, a sequence of zero or more invocations of destructor functions for


temporary objects takes place, usually in reverse order of the construction of each temporary object. 

Draft 


9 General 1.10 Acknowledgments 

There is also a sequence point after the copying of a returned value and before the execution of any expressions outside 
the function13).Several contextsinC++ cause evaluation of a function call, even though no corresponding function call 
syntax appears in the translation unit. [Example: evaluation of a new expression invokes one or more allocation and 
constructor functions; see 5.3.4.For anotherexample,invocationofa conversionfunction(12.3.2)can arisein contexts 
in which no function call syntax appears. — end example ]The sequence points at function-entry and function-exit 
(as described above) are features of the function calls as evaluated, whatever the syntax of the expression that calls the 
function might be. 

17 In the evaluation of each of the expressions 

a && b
a || b
a?b:c
a ,b


usingthebuilt-in meaningofthe operatorsin theseexpressions(5.14, 5.15, 5.16, 5.18),thereisa sequencepointafter 
the evaluation of the first expression14). 

1.10 Acknowledgments [intro.ack] 
1 TheC++ programming language as described in this International Standard is based on the language as described in 
ChapterR(Reference Manual)of Stroustrup: TheC++ Programming Language (second edition, Addison-WesleyPublishing Company, ISBN 0-201-53992-6, copyright 1991AT&T). That, in turn, is based on theCprogramming lan

cguageas describedin AppendixAofKernighanand Ritchie: TheCProgramming Language (Prentice-Hall, 1978, ISBN 
0-13-110163-3, copyright c

1978AT&T). 
2 Portionsof the library clausesof this International Standard are based onworkbyP.J. Plauger, whichwas published as 
TheDraft StandardC++ Library (Prentice-Hall, ISBN 0-13-117003-1, copyright 1995P.J. Plauger). 

c

3 All rights in these originals are reserved. 

13) The sequence point at the function return is not explicitly specified in ISO C, and can be considered redundant with sequence points at full-
expressions,buttheextra clarityis importantinC++. InC++, there are more ways in which a called function can terminate its execution, such as 
the throw of an exception. 

14)The operators indicatedinthisparagrapharethebuilt-in operators,as describedinclause 5.Whenoneofthese operatorsisoverloaded(clause 
13)in a valid context, thus designating a user-defined operator function, the expression designates a function invocation, and the operands form an 
argument list, without an implied sequence point between them. 

Draft 


1.10 Acknowledgments General 10 
Draft 


Chapter2 Lexical conventions [lex]


1 Thetextofthe programiskeptin units called source files in this International Standard. A source file together with all 
the headers(17.4.1.2)and source files included(16.2)via the preprocessing directive#include, less any source lines 
skippedby anyof the conditional inclusion(16.1)preprocessing directives,is calledatranslation unit.[Note: aC++ 
program need not all be translated at the same time. — end note ] 

2[Note: previously translated translation units and instantiation units can be preserved individually or in libraries. The 
separate translation unitsofa program communicate(3.5)by(forexample) callsto functions whose identifiershaveexternallinkage, manipulationof objects whose identifiershaveexternal linkage,ormanipulationofdata files.Translation 
unitscanbe separatelytranslatedandthenlaterlinkedtoproduceanexecutableprogram(3.5). — end note ] 

2.1 Phases of translation [lex.phases] 
1 The precedence among the syntax rules of translation is specified by the following phases.15) 

1. Physical source file characters are mapped, in an implementation-defined manner, to the basic source character 
set (introducingnew-line charactersfor end-of-line indicators)if necessary.Trigraph sequences(2.3)arereplaced 
by corresponding single-character internal representations. Any source file character not in the basic source 
characterset(2.2)is replacedbytheuniversal-character-namethat designatesthat character.(Animplementation 
mayuseanyinternalencoding,solongasanactualextended character encounteredinthe sourcefile,andthesame 
extended characterexpressedin the source file asa universal-character-name (i.e. using the \uXXXX notation), are 
handled equivalently.) 
2. Each instance of a new-line character and an immediately preceding backslash character a backslash character 
(\) immediately followed by a new-line character is deleted, splicing physical source lines to form logical source 
lines. Only the last backslash on any physical source line shall be eligible for being part of such a splice. If, as 
a result, a character sequence that matches the syntax of a universal-character-name is produced, the behavior is 
undefined. If a source file that is not empty does not end in a new-line character, or ends in a new-line character 
immediately preceded by a backslash character before any such splicing takes place, the behavior is undefined. 
3. The source file is decomposed into preprocessing tokens(2.4)and sequences of white-space characters (including 
comments).Asourcefileshallnotendinapartialpreprocessingtokenor inapartial comment.16)Each comment 
isreplacedbyonespace character.New-line charactersare retained. Whethereachnonempty sequenceofwhitespace characters other than new-line is retained or replaced by one space character is implementation-defined. 
15) Implementations must behave as if these separate phases occur, although in practice different phases might be folded together. 

16) A partial preprocessing token would arise from a source file ending in the first portion of a multi-character token that requires a terminating 

sequence of characters, such as a header-name that is missing the closing " or >. Apartial comment would arise from a source file ending with an 

unclosed /* comment. 


2.2 Character sets Lexical conventions 12 
Theprocessofdividinga source file’s charactersinto preprocessingtokensis context-dependent.[ Example: see 
the handling of < within a #include preprocessing directive. — end example ] 

4. Preprocessing directives are executed and, macro invocations ar expanded, and _Pragma unary operator expressions are executed. If a character sequence that matches the syntax of a universal-character-name is produced by 
token concatenation(16.3.3), the behavioris undefined. A#include preprocessing directive causes the named 
headeror sourcefiletobe processedfromphase1throughphase4, recursively. Allpreprocessingdirectives are 
then deleted. 
5. Each source character set member, escape sequence, or universal-character-name in character literals and string 
literalsis convertedto athe corresponding memberoftheexecution characterset(2.13.2, 2.13.4).;if thereisno 
corresponding member, it is converted to an implementation-defined member other than the null (wide) character.17) 
6. Adjacent ordinary string literal tokens are concatenated. Adjacent wide string literal tokensare concatenated. 
7. White-space characters separating tokens are no longer significant. Each preprocessing token is converted into 
a token. (2.6). The resulting tokens are syntactically and semantically analyzed and translated as a translation 
unit.[ Note: Source files, translation units and translated translation units need not necessarily be stored as files, 
nor need there be any one-to-one correspondence between these entities and any external representation. The 
description is conceptual only, and does not specify anyparticular implementation. — end note ] 
8.Translated translation units and instantiation units are combined as follows:[ Note: some or all of these may be 
supplied from a library. — end note ]Each translated translation unit is examined to produce a list of required 
instantiations.[ Note: thismay includeinstantiationswhichhavebeenexplicitlyrequested(14.7.2). — end note ] 
The definitions of the required templates are located. It is implementation-defined whether the source of the 
translation units containing these definitionsis requiredtobeavailable.[ Note: an implementation could encode 
sufficient information into the translated translation unit so as to ensure the source is not required here. — end 
note ]All the required instantiations are performed to produce instantiation units.[Note: these are similar to 
translated translation units, but contain no references to uninstantiated templates and no template definitions. 
— end note ]The programis ill-formedifanyinstantiationfails. 
9. All external object and function references are resolved. Library components are linked to satisfy external references to functions and objects not defined in the current translation. All such translator output is collected into a 
program image which contains information needed for execution in its execution environment. 
2.2 Character sets [lex.charset] 
1 The basic source character set consists of 96 characters: the space character, the control characters representing horizontal tab, vertical tab, form feed, and new-line, plus the following 91 graphical characters:18) 

a bcdefghijklmnopqrstuvwxyz 

A BCDEFGHIJKLMNOPQRSTUVWXYZ 

17)An implementation need not convert all non-corresponding source characters to the same execution character. 

18) The glyphs for the members of the basic source character set are intended to identify characters from the subset of ISO/IEC 10646 which 
corresponds to the ASCII character set. However, because the mapping from source file characters to the source character set (described in translation 
phase1)is specified as implementation-defined, an implementationis requiredto documenthow the basic source characters are representedin source 
files. 

Draft 


13 Lexical conventions 2.3 Trigraph sequences 

0 123456789 

_ {}[]#() < >%:;.?*+ -/^&| !=,\"’

~ 

2 The universal-character-name construct provides a way to name other characters. 

hex-quad:
hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit


universal-character-name:
\u hex-quad
\U hex-quad hex-quad


The character designated by the universal-character-name \UNNNNNNNN is that character whose character short name in 
ISO/IEC 10646 is NNNNNNNN;the character designated by the universal-character-name\uNNNN is that character whose 
character short name in ISO/IEC 10646 is 0000NNNN. If the hexadecimal value for a universal character name is less 
than 0x20 or in the range 0x7F-0x9F (inclusive), or if the universal character name designates a character in the basic 
source character set, then the program is ill-formed. 

3 The basic execution character set and the basic execution wide-character set shall each contain all the members of the 
basic source characterset,plus control characters representingalert,backspace,andcarriage return,plusa nullcharacter 
(respectively, null wide character), whose representation has all zero bits. For each basic execution character set, the 
values of the members shall be non-negative and distinct from one another. In both the source and execution basic 
character sets, the value of each character after 0 intheabove listofdecimal digits shallbe one greater thanthevalue 
of the previous. The execution character set and the execution wide-character set are supersetsofthebasicexecution 
character set and the basic execution wide-character set, respectively. The values of the members of the execution 
character sets are implementation-defined, and anyadditional members are locale-specific. 

2.3 Trigraph sequences [lex.trigraph] 
1 Beforeanyother processingtakesplace,each occurrenceofoneofthefollowingsequencesofthree characters(“trigraph 
sequences”)is replacedby the singlecharacter indicatedinTable 1. 

Table 1: trigraph sequences 

trigraph replacement trigraph replacement trigraph replacement 
??= # ??( [ ??< { 
??/ \ ??) ] ??> } 
??’ ^ ??! | ??~ 

2 [Example: 

?? =define arraycheck(a,b) a??(b??) ??!??! b??(a??) 

becomes 

#define arraycheck(a,b) a[b] || b[a] 

— end example ] 
3 No other trigraph sequence exists. Each ? that does notbegin oneof thetrigraphs listed aboveis not changed. 
Draft 


2.4 Preprocessing tokens Lexical conventions 14 
2.4 Preprocessing tokens [lex.pptoken] 
preprocessing-token:
header-name
identifier
pp-number
character-literal
string-literal
preprocessing-op-or-punc


each non-white-space character that cannotbe one of the above 
1 Each preprocessingtokenthatisconvertedtoatoken(2.6)shallhavethelexicalformofakeyword,an identifier,a 
literal, an operator, or a punctuator. 

2A preprocessing token is the minimal lexical element of the language in translation phases 3 through 6. The categories of preprocessing token are: header names, identifiers, preprocessing numbers, character literals, string literals, 
preprocessing-op-or-punc, and single non-white-space characters that do notlexically match the other preprocessing 
token categories. If a ’ or a " character matches the last category, the behavior is undefined. Preprocessing tokens can 
be separatedby white space;this consists of comments(2.7), orwhite-spacecharacters (space, horizontal tab, new-line, 
vertical tab, and form-feed), or both. As described in clause 16, in certain circumstances during translationphase 4, 
white space (or the absence thereof) serves as more than preprocessing token separation. White space can appear within 
a preprocessingtokenonlyaspartofa header nameor betweenthe quotation charactersina character literalorstring 
literal. 

3 If the input stream has been parsed into preprocessing tokens up to a given character, the next preprocessing token is 
the longest sequence of characters that could constitute a preprocessing token, even if that would cause further lexical 
analysis tofail. 

4[Example: The program fragment 1Ex is parsed as a preprocessing number token (one that is not a valid floating or 
integer literaltoken),eventhoughaparseasthepairof preprocessingtokens 1 and Ex might produceavalidexpression 
(for example, if Ex were a macro defined as +1). Similarly, the program fragment 1E1 is parsed as a preprocessing 
number (one that is a valid floating literal token), whether or not E is a macro name. — end example ] 

5[Example: Theprogram fragment x+++++y is parsed as x ++ ++ + y, which, if x and y areofbuilt-in types, violates 
a constraint on increment operators, even though the parse x ++ + ++ y might yield a correct expression. — end 
example] 

2.5 Alternative tokens [lex.digraph] 
1 Alternative token representations are provided for some operators and punctuators.19)
2 In all respects of the language, each alternative token behaves the same, respectively, as its primary token, except for its


Draft 


15 Lexical conventions 2.6 Tokens 

Table 2: alternative tokens 

alternative primary alternative primary alternative primary 
<% { and && and_eq &= 
%> } bitor | or_eq |= 
<: [ or || xor_eq ^= 
:> ] xor ^ not ! 
%: # compl ~ not_eq != 
%:%: ## bitand & 

spelling.20) The setof alternative tokensis definedinTable 2. 

2.6 Tokens [lex.token] 
token:
identifier
keyword
literal
operator
punctuator


1 There arefivekindsof tokens: identifiers,keywords, literals,21) operators, and other separators. Blanks, horizontal and 
verticaltabs,newlines, formfeeds,and comments(collectively,“whitespace”),as describedbelow,areignoredexceptas 
theyserve to separate tokens.[ Note: Some white spaceis requiredto separate otherwise adjacent identifiers,keywords, 
numeric literals, and alternative tokens containing alphabetic characters. — end note ] 

2.7 Comments [lex.comment] 
1 The characters /* startacomment, which terminateswith the characters */. These comments do not nest. The characters 
// starta comment,which terminateswiththenextnew-line character.Ifthereisa form-feedoravertical-tab character 
in such a comment, only white-space characters shall appear between it and the new-line that terminates the comment; 
no diagnosticis required.[ Note: The comment characters //, /*, and*/ have no special meaning withina // comment 
and are treated just like other characters. Similarly, the comment characters // and /* have no special meaning within 
a /* comment. — end note ] 

2.8 Header names [lex.header] 
header-name:
< h-char-sequence >
" q-char-sequence "


h-char-sequence:
h-char
h-char-sequence h-char


19) These include “digraphs” and additional reserved words. The term “digraph” (token consisting of two characters) is not perfectly descriptive, 
since one of the alternative preprocessing-tokens is %:%: and of course several primary tokens contain two characters. Nonetheless, those alternative 
tokens that aren’tlexicalkeywords are colloquially known as “digraphs”. 

20) Thus the “stringized” values(16.3.2)of[ and <: will be different, maintaining the source spelling, but the tokens can otherwise be freely 
interchanged. 
21) Literals include strings and character and numeric literals. 

Draft 


2.9 Preprocessing numbers Lexical conventions 16 
h-char: 

anymemberof the source character setexcept new-line and> 

q-char-sequence:
q-char
q-char-sequence q-char


q-char: 

anymember of the source character set except new-line and " 

1 Header name preprocessing tokens shall only appear within a #include preprocessing directive(16.2). Thesequences 
in both forms of header-names are mapped in an implementation-defined manner to headers or to external source file 
names as specified in 16.2. 

2 If either of the characters ’ or \, or either of the character sequences /* or // appears in a q-char-sequence or a 
h-char-sequence, or the character " appears in a h-char-sequence, the behavior is undefined.22) 

2.9 Preprocessing numbers [lex.ppnumber] 
pp-number:
digit
. digit
pp-number digit
pp-number nondigit
pp-number e sign
pp-number E sign
pp-number .


1 Preprocessing number tokens lexically include all integral literal tokens(2.13.1)and all floating literal tokens(2.13.3). 

2 A preprocessing number does not have a type or a value; it acquires both after a successful conversion (as part of 
translation phase 7, 2.1)to an integral literal token or a floating literal token. 

2.10 Identifiers [lex.name] 
identifier: 

nondigitidentifier-nondigit
identifier nondigitidentifier-nondigit
identifier digit


identifier-nondigit:
nondigit
universal-character-name


other implementation-defined characters 

nondigit: one of 

universal-character-name 

abcdefghijklm
nopqrstuvwxyz
ABCDEFGHIJKLM
NOPQRSTUVWXYZ_


digit: one of 

0123456789 

22) Thus, sequences of characters that resemble escape sequences cause undefined behavior. 

Draft 


17 Lexical conventions 2.11 Keywords 

1 An identifier is an arbitrarily long sequence of letters and digits. Each universal-character-name in an identifier shall 
designate a character whose encoding in ISO 10646 falls into one of the ranges specified in Annex E. Upper-and 
lower-case letters are different. All characters are significant.23) 

2 In addition, some identifiers are reserved for usebyC++ implementations and standard libraries(17.4.3.1.2)and shall 
not be used otherwise; no diagnostic is required. 

2.11 Keywords [lex.key] 
1 The identifiersshowninTable 3are reservedforuseaskeywords(thatis,they are unconditionally treatedaskeywords 
in phase 7): 

Table 3:keywords 

asm do if return try 
auto double inline short typedef 
bool dynamic_cast int signed typeid 
break else long sizeof typename 
case enum mutable static union 
catch explicit namespace static_assert unsigned 
char export new static_cast using 
class extern operator struct virtual 
const false private switch void 
const_cast float protected template volatile 
continue for public this wchar_t 
default friend register throw while 
delete goto reinterpret_cast true 

Furthermore, the alternative representations showninTable 4forcertain operators and punctuators(2.5)are reserved 
and shall not be used otherwise: 

Table 4: alternative representations 

and and_eq bitand bitor compl not 
not_eq or or_eq xor xor_eq 

2.12 Operators and punctuators [lex.operators] 
1 ThelexicalrepresentationofC++ programs includes a number of preprocessing tokens which are used in the syntax of 
the preprocessor or are converted into tokens for operators and punctuators: 

23) On systems in which linkers cannot accept extended characters, an encoding of the universal-character-name may be used in forming valid 
external identifiers.Forexample, some otherwise unused characteror sequenceof charactersmaybe usedto encodethe \u in a universal-charactername. Extended characters may producea longexternal identifier,butC++ does not place a translation limit on significant characters for external 
identifiers. InC++, upper-andlower-case letters are considered different for all identifiers, includingexternal identifiers. 

Draft 


2.13 Literals Lexical conventions 18 
preprocessing-op-or-punc: one of
{} [ ] # ## ( )
<: :> <% %> %: %:%: ; : ...
new delete ? :: . .*
+-* / % ^ & |


~ 

!= < > += -= *= /= %=
^= &= |= << >> >>= <<= == !=
<= >= && || ++ --, ->* ->
and and_eq bitand bitor compl not not_eq
or or_eq xor xor_eq


Each preprocessing-op-or-punc isconvertedtoasingletokenin translationphase7(2.1). 

2.13 Literals [lex.literal] 
1 There are several kinds of literals.24) 

literal:
integer-literal
character-literal
floating-literal
string-literal
boolean-literal


2.13.1 Integer literals [lex.icon] 
integer-literal:
decimal-literal integer-suffixopt
octal-literal integer-suffixopt
hexadecimal-literal integer-suffixopt


decimal-literal:
nonzero-digit
decimal-literal digit


octal-literal: 

0 

octal-literal octal-digit 

hexadecimal-literal:
0x hexadecimal-digit
0X hexadecimal-digit
hexadecimal-literal hexadecimal-digit


nonzero-digit: one of 

123456789 

octal-digit: one of 

01234567 

hexadecimal-digit: one of 

0123456789
abcdef
ABCDEF


24) The term “literal” generally designates, in this International Standard, those tokens that are called “constants” in ISO C. 

Draft 


19 Lexical conventions 2.13 Literals 

integer-suffix:
unsigned-suffix long-suffixopt


unsigned-suffix long-long-suffixopt 

long-suffix unsigned-suffixopt 

long-long-suffix unsigned-suffixopt 

unsigned-suffix: one of 

uU 

long-suffix: one of 

lL 

long-long-suffix: one of 

ll LL 

1 An integer literal is a sequence of digits that has no period or exponent part. An integer literal may have a prefix 
that specifies itsbase anda suffix that specifies itstype. Thelexically first digitof the sequenceof digitsis the most 
significant. Adecimal integer literal (base ten) begins with a digit other than 0 and consists of a sequence of decimal 
digits. An octal integer literal (base eight) begins with the digit 0 and consists of a sequence of octal digits.25) A 
hexadecimal integer literal (base sixteen) begins with 0x or 0X and consists of a sequence of hexadecimal digits, which 
include the decimal digits and the letters a through f and A through F with decimalvalues ten through fifteen.[ Example: 
the number twelve can be written 12, 014, or 0XC. — end example ] 

2 The type of an integer literal depends on its form, value, and suffix. If it is decimal and has no suffix, it has the first of 
these types in which its value can be represented: int, long int;if the value cannot be represented as a long int, the 
behavior is undefined. If it is octal or hexadecimal and has no suffix, it has the first of these types in which its value can 
be represented: int, unsigned int, long int, unsigned long int. If it is suffixed by u or U, its type is the first of 
these types in which its value can be represented: unsigned int, unsigned long int. If it is suffixed by l or L, its 
type is the first of these types in which its value can be represented: long int, unsigned long int. If it is suffixed 
by ul, lu, uL, Lu, Ul, lU, UL, or LU, its type is unsigned long int.The type of an integer constant is the first of the 
corresponding listinTable5in which itsvalue canbe represented. 

3 Aprogramis ill-formedifoneof its translation units contains an integer literal that cannotbe representedby anyof the 
allowed types. 

2.13.2 Character literals [lex.ccon] 
character-literal:
’ c-char-sequence ’
L’ c-char-sequence ’


c-char-sequence:
c-char
c-char-sequence c-char


c-char: 

anymember of the source character set except
the single-quote ’, backslash \, or new-line character


escape-sequence
universal-character-name


25) The digits 8 and 9 are not octal digits. 

Draft 


2.13 Literals Lexical conventions 20 
Table5:Typesof Integer Constants 

Suffix Decimal Constant Octal or Hexadecimal Constant 
none int 
long int 
long long int 
int 
unsigned int 
long int 
unsigned long int 
long long int 
unsigned long long int 
u or U unsigned int 
unsigned long int 
unsigned long long int 
unsigned int 
unsigned long int 
unsigned long long int 
l or L long int 
long long int 
long int 
unsigned long int 
long long int 
unsigned long int 
Both u or U 
and l or L 
unsigned long int 
unsigned long long int 
unsigned long int 
unsigned long long int 
ll or LL long long int long long int 
unsigned long int 
Both u or U 
and ll or LL 
unsigned long long int unsigned long long int 

escape-sequence:
simple-escape-sequence
octal-escape-sequence
hexadecimal-escape-sequence


simple-escape-sequence: one of 

\’ \" \? \\
\a \b \f \n \r \t \v


octal-escape-sequence:
\ octal-digit
\ octal-digit octal-digit
\ octal-digit octal-digit octal-digit


hexadecimal-escape-sequence:
\x hexadecimal-digit
hexadecimal-escape-sequence hexadecimal-digit


1 Acharacter literal is one or more characters enclosed in single quotes, as in’x’,optionally precededbythe letterL,as in 
L’x’.Acharacter literal that does not begin with L is an ordinary characterliteral, also referred to asa narrow-character 
literal. An ordinary character literal that containsa single c-char has type char, with value equal to the numerical value 
of the encoding of the c-char in the execution character set. An ordinary character literal that contains more than one 
c-char is a multicharacter literal.Amulticharacter literal has type int and implementation-defined value. 

2 Acharacter literal that begins with the letterL,such asL’x’,isa wide-character literal.Awide-character literal has type 

Draft 


21 Lexical conventions 2.13 Literals 

wchar_t.26) The value of a wide-character literal containing a single c-char has value equal to the numerical value of 
the encoding of the c-char in the execution wide-character set. The value of a wide-character literal containing multiple 
c-chars is implementation-defined. 

Certain nongraphic characters, the single quote ’, the double quote ", the question mark ?, and the backslash \, can 
be represented according toTable 6. The double quote " and the question mark ?, can be represented as themselves 
or by the escape sequences \" and \? respectively,but the single quote ’ and the backslash \ shall be represented by 
the escape sequences \’ and \\ respectively. If the character following a backslash is not one of those specified, the 
behavior is undefined. An escape sequence specifies a single character. 

Table 6: escape sequences 

new-line NL(LF) \n 
horizontal tab HT \t 
vertical tab VT \v 
backspace BS \b 
carriage return CR \r 
form feed FF \f 
alert BEL \a 
backslash \ \\ 
question mark ? \? 
single quote ’ \’ 
double quote " \" 
octal number ooo \ooo 
hex number hhh \xhhh 

4 The escape \ooo consists of the backslash followed by one, two, or three octal digits that are taken to specify the 
value of the desired character. The escape \xhhh consists of the backslash followed by x followed by one or more 
hexadecimal digits that are taken to specify the value of the desired character. There is no limit to the number of digits 
in a hexadecimal sequence. A sequence of octal or hexadecimal digits is terminated by the first character that is not 
an octaldigit orahexadecimal digit, respectively. Thevalueofa character literalis implementation-definedifitfalls 
outside of the implementation-defined range defined for char (for ordinary literals) or wchar_t (for wide literals). 

5 A universal-character-name is translated to the encoding, in the execution character set, of the character named. If 
thereisnosuch encoding,theuniversal-character-nameis translatedtoan implementation-defined encoding.[ Note: in 
translation phase 1, a universal-character-name is introduced whenever an actual extended character is encountered in 
the source text. Therefore, all extended characters are described in terms of universal-character-names. However, the 
actual compiler implementation may use its own native character set, so long as the same results are obtained. — end 
note ] 

2.13.3 Floating literals [lex.fcon] 
floating-literal:
fractional-constant exponent-partopt floating-suffixopt
digit-sequence exponent-part floating-suffixopt


26) Theyare intended for character sets where a character does not fit into a single byte. 

Draft 


2.13 Literals Lexical conventions 22 
fractional-constant:
digit-sequenceopt . digit-sequence
digit-sequence .


exponent-part:
e signopt digit-sequence
E signopt digit-sequence


sign: one of 

+

digit-sequence:
digit
digit-sequence digit


floating-suffix: one of 

flFL 

1 A floating literal consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed integer 
exponent, and an optional type suffix. The integer and fraction parts both consist of a sequence of decimal (base ten) 
digits. Either the integer part orthe fraction part (not both) can be omitted; either the decimal point or the letter e (or 
E )and the exponent (not both) can be omitted. The integer part, the optional decimal point and the optional fraction 
part form the significant part of the floating literal. The exponent, if present, indicates the power of 10 by which the 
significant part is to be scaled. If the scaled value is in the range of representable values for its type, the result is 
the scaled value if representable, else the larger or smaller representable value nearest the scaled value, chosen in an 
implementation-defined manner. The type of a floating literal is double unless explicitly specified by a suffix. The 
suffixes f and F specify float, the suffixes l and L specify long double. If the scaled value is not in the range of 
representable values for its type, the program is ill-formed. 

2.13.4 String literals [lex.string] 
string-literal:
"s-char-sequenceopt"
L"s-char-sequenceopt"


s-char-sequence:
s-char
s-char-sequence s-char


s-char: 

anymember of the source character set except
the double-quote ", backslash \, or new-line character


escape-sequence
universal-character-name


1 Astring literalisa sequenceof characters(as definedin2.13.2)surroundedby double quotes, optionallybeginning with 
the letter L, as in "..." or L"...".Astring literal thatdoes notbegin with L is an ordinary string literal, also referred 
to as a narrow stringliteral. An ordinary string literal has type “array of n const char” and static storage duration 
(3.7), where n is the size of the string as defined below, and is initialized with the given characters. Astring literal that 
begins with L, such as L"asdf",isa wide stringliteral.Awide string literal has type “arrayof n const wchar_t” and 
has static storage duration, where n is the sizeof the string as defined below, andis initialized with thegiven characters. 

2 Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation-defined. The 
effect of attempting to modify a string literal is undefined. 

Draft 


23 Lexical conventions 2.13 Literals 

3 In translation phase6(2.1), adjacentnarrow string literals are concatenated and adjacent wide string literals are concatenated. If a narrow string literal token is adjacent to a wide string literal token, the behavior is undefined.result is a wide 
string literal. Charactersin concatenatedstrings arekept distinct.[ Example: 

"\xA" "B" 

contains the two characters ’\xA’ and ’B’ after concatenation (and not the single hexadecimal character ’\xAB’). 

— end example ] 
4 After anynecessary concatenation,in translationphase7(2.1), ’\0’ is appendedto every string literal so that programs 
that scan a string can find its end. 

5 Escape sequences and universal-character-names in string literals havethe same meaning as in character literals(2.13.2), 
except that the single quote ’ is representable eitherbyitself orby the escape sequence \’, and the double quote " shall 
be precededbya \.Ina narrowstring literal,auniversal-character-namemaymaptomorethanone char element due to 
multibyte encoding. The sizeofa wide string literalis the total numberof escape sequences, universal-character-names, 
and other characters, plus one for the terminating L’\0’. The size of a narrow string literal is the total number of escape 
sequences and other characters, plus at least one for the multibyte encoding of each universal-character-name, plus one 
for the terminating ’\0’. 

2.13.5 Boolean literals [lex.bool] 
boolean-literal: 

false
true


1 The Boolean literals are thekeywords false and true. Such literals have type bool. They are not lvalues. 

Draft 


2.13 Literals Lexical conventions 24 
Draft 


Chapter3 Basic concepts [basic]


1[Note: this clause presents the basic concepts of theC++ language. It explains the difference between an object and 
a name and how they relate to the notion of an lvalue. It introduces the concepts of a declaration and a definition 
and presentsC++ ’s notion of type, scope, linkage, and storage duration. The mechanisms for starting and terminating 
a program are discussed. Finally, this clause presents the fundamental types of the language and lists the ways of 
constructing compound types from these. 

2 This clause does not cover concepts that affect only a single part of the language. Such concepts are discussed in the 
relevant clauses. — end note ] 

3 An entity is a value, object, subobject, base class subobject, array element, variable, function, instance of a function, 
enumerator, type, class member, template, or namespace. 

4A name is a use of an identifier(2.10)that denotes an entity or label (6.6.4, 6.1). A variable is introduced by the 
declaration of an object. The variable’s name denotes the object. 

5 Every name that denotes an entity is introduced by a declaration. Every name that denotes a label is introduced either 
by a goto statement(6.6.4)ora labeled-statement (6.1). 

6 Some names denote types, classes, enumerations, or templates. In general, it is necessary to determine whether or not a 
name denotes one of these entities before parsing the program that contains it. The process that determines this is called 
name lookup (3.4). 

7 Two names arethe same if 

— they are identifiers composed of the same character sequence; or 
— they are the names of overloaded operator functions formed with the same operator; or 
— they are the names of user-defined conversion functions formed with the same type. 
8 An identifier used in more than one translation unit can potentially refer to the same entity in these translation units 
depending on the linkage(3.5)of the identifier specifiedin each translation unit. 

3.1 Declarations and definitions [basic.def] 
1Adeclaration(clause7)introduces namesintoatranslationunitor redeclares names introducedbypreviousdeclarations. 
Adeclaration specifies theinterpretation and attributesof these names. 

2 A declaration is a definition unlessit declaresa function without specifying the function’s body(8.4),it contains the 


3.1 Declarations and definitions Basic concepts 26 
extern specifier(7.1.1)ora linkage-specification 27)(7.5)and neither aninitializer nor a function-body, it declares a 
staticdata memberina classdefinition(9.4),itisa class name declaration(9.1),oritisa typedef declaration(7.1.3), 
a using-declaration (7.3.3), or a using-directive(7.3.4). 

[Example: allbut oneof the following are definitions: 

int a; // defines a
extern const int c = 1; // defines c
int f(int x) { return x+a; } // defines f and defines x
struct S { int a; int b; }; // defines S, S::a, and S::b
struct X { // defines X


int x; // defines non-static data member x
static int y; // declares static data member y
X(): x(0) { } // defines a constructor of X


};
int X::y = 1; // defines X::y
enum { up, down }; // defines up and down
namespace N { int d ; } // defines N and N::d
namespace N1 = N; // defines N1
X anX ; // defines anX


whereas these are just declarations: 

extern int a; // declares a
extern const int c; // declares c
int f(int); // declares f
struct S; // declares S
typedef int Int ; // declares Int
extern X anotherX ; // declares anotherX
using N::d; // declares N::d


— end example ] 
3 [Note: in some circumstances,C++ implementations implicitly define the default constructor(12.1), copyconstructor 
(12.8), assignment operator(12.8), or destructor(12.4)member functions.[Example: given 

# include < string > 

struct C { 
std::string s; // std::string is the standardlibrary class (clause 21) 
}; 

int main () 

{
C a;
C b = a;
b = a;


} 

the implementation will implicitly define functions to make the definition of C equivalent to 

27) Appearing inside the braced-enclosed declaration-seq in a linkage-specification does notaffect whethera declarationisa definition. 

Draft 


27 Basic concepts 3.2 One definition rule 

struct C {
std::string s;
C(): s() {}
C(const C& x): s(x.s) { }
C& operator= (const C& x) { s = x.s; return *this; }
~C() { }


}; 

— end example ] — end note ] 
4[Note: a class name can alsobe implicitly declaredby an elaborated-type-specifier (3.3.1). — end note ] 
5 Aprogramis ill-formedifthe definitionof anyobjectgives the object an incomplete type(3.9). 
3.2 One definition rule [basic.def.odr] 
1 No translation unit shall contain more than one definition of any variable, function, class type, enumeration type or 
template. 

2 An expression is potentially evaluated unless it appears where an integral constant expression is required (see 5.19), 
is the operand of the sizeof operator(5.3.3),oris the operandof the typeid operator and the expression does not 
designateanlvalueof polymorphic classtype(5.2.8).An objector non-overloaded functionis used ifits nameappears 
inapotentially-evaluatedexpression.Avirtualmember functionisusedifitisnotpure.Anoverloaded functionisused 
ifitis selectedbyoverload resolution when referredto froma potentially-evaluatedexpression.[ Note: this covers calls 
to named functions(5.2.2), operatoroverloading (clause 13), user-defined conversions(12.3.2), allocation functionfor 
placementnew(5.3.4),aswellas non-default initialization(8.5).Acopyconstructorisusedevenifthecallis actually 
elidedbythe implementation. — end note ]An allocationor deallocation functionforaclassisusedbyanewexpression 
appearingina potentially-evaluatedexpressionas specifiedin 5.3.4and12.5.Adeallocation functionforaclassisused 
by a delete expression appearing in a potentially-evaluated expression as specified in 5.3.5 and 12.5. Anon-placement 
allocation or deallocation function for a class is used by the definition of a constructor of that class. Anon-placement 
deallocation function for a class is used by the definition of the destructor of that class, or by being selected by the 
lookupatthe pointof definitionofa virtual destructor(12.4).28)Acopy-assignment functionfora classis usedbyan 
implicitly-defined copy-assignment function for another class as specified in 12.8. Adefault constructor for a class is 
used by default initialization or value initialization as specified in 8.5. Aconstructor for a class is used as specified in 

8.5.Adestructor fora classis used as specifiedin 12.4. 
3 Every program shall containexactly onedefinitionofevery non-inline functionor object thatis usedin that program;no 
diagnosticrequired.The definitioncanappearexplicitlyinthe program,itcanbefoundinthestandardorauser-defined 
library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). An inline function shall be defined in 
every translation unit in whichit is used. 

4 Exactly one definition of a class is required in a translation unit if the class is used in a way that requires the class type 
tobe complete.[ Example: the following complete translation unit is well-formed, even though it never defines X : 

struct X; // declare X as a struct type
struct X* x1; // use X in pointer formation
X* x2; // use X in pointer formation


28) An implementation is not required to call allocation and deallocation functions from constructors or destructors; however, thisis a permissible 
implementation technique. 

Draft 


3.2 One definition rule Basic concepts 28 
— end example ][Note: the rules for declarations and expressions describe in which contexts complete class types are 
required.Aclass type T must be complete if: 
— an object of type T is defined(3.1), or 
— a non-static class data member of type T is declared(9.2), or 
— T is used as the object type or array element type in a new-expression (5.3.4), or 
— an lvalue-to-rvalue conversion is applied to an lvalue referring to an object of type T (4.1), or 
— an expression is converted (either implicitly or explicitly) to type T (clause4, 5.2.3, 5.2.7, 5.2.9, 5.4), or 
— an expression that is not a null pointer constant, and has type other than void *, is converted to the type pointer 
to T or reference to T using an implicit conversion (clause 4),a dynamic_cast (5.2.7)or astatic_cast (5.2.9), 
or 
— a class member access operator is applied to an expression of type T (5.2.5), or 
— the typeid operator(5.2.8)or the sizeof operator(5.3.3)is applied to an operand of typeT, or 
— a function with a return type or argument type of type T is defined(3.1)or called(5.2.2), or 
— a class with a base class of type T is defined(10), or 
— an lvalue of type T is assigned to(5.17). — end note ] 
Therecanbe more than one definitionofa class type (clause 9), enumeration type(7.2), inline function withexternal 
linkage(7.1.2), class template (clause 14), non-static function template(14.5.5), static data memberofa class template 
(14.5.1.3), member functionofa class template(14.5.1.1),or template specializationfor which some template parametersarenot specified(14.7, 14.5.4)ina programprovidedthateach definition appearsinadifferent translationunit, 
and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one 
translation unit, then 

— each definition of D shall consist of the same sequence of tokens; and 
— in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined within 
the definition of D,or shall refertothe same entity, afteroverload resolution(13.3)and after matchingof partial 
templatespecialization(14.8.3),exceptthata namecan refertoa const object with internal or no linkage if the 
object has the same integral or enumeration type in all definitions of D,andthe objectis initialized witha constant 
expression(5.19),andthevalue(butnotthe address)oftheobjectisused,andtheobjecthasthesamevalueinall 
definitions of D;and 
— in each definition of D,theoverloaded operators referredto,the implicit callsto conversion functions, constructors, 
operator new functions and operator delete functions, shall refer to the same function, or to a function defined 
within the definition of D;and 
— in each definition of D, a default argument used by an (implicit or explicit) function call is treated as if its token 
sequence were present in the definition of D; that is, the default argument is subject to the three requirements 
described above(and, if the default argument has sub-expressions with default arguments, this requirement applies 
recursively).29) 
29) 8.3.6 describes how default argument names are looked up. 

Draft 


29 Basic concepts 3.3 Declarative regions and scopes 

— if D isa class with an implicitly-declaredconstructor(12.1),itis asif the constructor was implicitly definedin 
every translation unit where it is used, and the implicit definition in every translation unit shall call the same 
constructor for a base class or a class member of D.[ Example: 
//translation unit 1: 

struct X {
X( int );
X(int , int);


}; 

X::X(int = 0) { }
class D: public X { };
D d2; // X(int) calledby D()
//translation unit 2: 

struct X {
X( int );
X(int , int);


}; 

X::X(int =0, int =0) {} 
class D: public X { }; // X(int, int) calledby D();
// D()’s implicit definition
// violates the ODR


— endexample ]IfD isa template,andis definedin morethanone translationunit,thenthelastfour requirements 
from the list above shall apply to names from the template’s enclosing scope used in the template definition 
(14.6.3),andalsoto dependent namesatthepointof instantiation(14.6.2).Ifthe definitionsof D satisfy all these 
requirements, then the program shall behave as if there were a single definition of D.Ifthe definitions of D do not 
satisfy these requirements, then the behavior is undefined. 
3.3 Declarative regions and scopes [basic.scope] 
1 Every name is introduced in some portion of program text called a declarative region, which is the largest part of the 
program in which that name is valid, that is, in which that name may be used as an unqualified name to refer to the 
same entity. In general, each particular name is valid only within some possibly discontiguous portion of program text 
called its scope. To determine the scope of a declaration, it is sometimes convenient to refer to the potential scope of 
a declaration. The scope of a declaration is the same as its potential scope unless the potential scope contains another 
declaration of the same name. In that case, the potential scope of the declaration in the inner (contained) declarative 
region is excluded from the scope of the declaration in the outer (containing) declarative region. 

2 [Example: in 

int j =24; 

int main () 

{ 

int i =j, j;
j = 42;


} 

the identifier j is declared twice as a name (and used twice). The declarative region of the first j includes the entire 
example. The potential scope of the first j begins immediately after that j andextendstotheendofthe program,but 

Draft 


3.3 Declarative regions and scopes Basic concepts 30 
its (actual) scope excludes the text between the , and the }. The declarative region of the second declaration of j (the j 
immediately before the semicolon) includes all the text between { and },but its potential scopeexcludes the declaration 
of i. The scope of the second declaration of j is the same as its potential scope. — end example ] 

3 The names declared by a declaration are introduced into the scope in which the declaration occurs, except that the 
presence of a friend specifier(11.4), certain uses of the elaborated-type-specifier (3.3.1), and using-directives(7.3.4) 
alter this general behavior. 

4 Given a set of declarations in a single declarative region, each of which specifies the same unqualified name, 

— theyshall all refer to the same entity, or all refer to functions and function templates; or 
— exactly one declaration shall declare a class name or enumeration name that is not a typedef name and the other 
declarations shall all refer to the same object or enumerator, or all refer to functions and function templates; in 
this case the class name or enumeration nameis hidden(3.3.7).[Note: a namespace name or a class template 
name mustbe uniquein its declarative region(7.3.2, clause 14). — end note ] 
[Note: these restrictions apply to the declarative region into which a name is introduced, which is not necessarily 
the same as the region in which the declaration occurs. In particular, elaborated-type-specifier s(3.3.1)and friend 
declarations(11.4)may introducea (possibly not visible) name into an enclosing namespace; these restrictions apply 
to that region. Localextern declarations(3.5)may introducea name into the declarative region where the declaration 
appears and also introduce a (possibly not visible) name into an enclosing namespace; these restrictions apply to both 
regions. — end note ] 

5 [Note: the name lookup rules are summarized in 3.4. — end note ] 

3.3.1 Point of declaration [basic.scope.pdecl] 
1 The point of declaration fora nameis immediately afterits complete declarator (clause 8)and beforeitsinitializer (if 
any),except as noted below.[ Example: 

int x =12;
{ int x = x; }


Here the second x is initialized with its own (indeterminate) value. — end example ] 
2[Note: a nonlocal name remains visibleuptothepointof declarationofthe local namethathidesit.[Example: 

const int i = 2;
{ int i[i]; }


declares a local array of two integers. — end example ] — end note ] 

3 Thepointof declarationfora class first declaredbya class-specifier is immediately after the identifier or template-id (if 
any) inits class-head (Clause9). The pointof declaration for an enumerationis immediately after the identifier (if any) 
in its enum-specifier (7.2). 

4 The point of declaration for an enumerator is immediately after its enumerator-definition.[ Example: 

const int x = 12;
{ enum { x = x }; }


Draft 


31 Basic concepts 3.3 Declarative regions and scopes 

Here, the enumerator x is initialized with the value ofthe constant x, namely 12. — end example ] 

5 Afterthepointof declarationofaclassmember,themembernamecanbelookedupinthescopeofitsclass.[ Note: 
thisis trueevenif the classis an incomplete class.Forexample, 

struct X {
enum E{z=16 };
int b[X::z]; // OK


}; 

— end note ] 
6 The point of declaration of a class first declared in an elaborated-type-specifier is as follows: 
— foradeclaratonoftheform class-keyidentifier ;
the identifier is declared to be a class-name in the scope that contains the declaration, otherwise
— for an elaborated-type-specifier of the form class-keyidentifier 
if the elaborated-type-specifier is used in the decl-specifier-seq or parameter-declaration-clause of a function defined in namespace scope, the identifier is declared as a class-name in the namespace that contains the declaration; otherwise, except as a friend declaration, the identifier is declared in the smallest non-class, non-functionprototype scope that contains the declaration. [Note: These rules also apply within templates. — end note ] 
[Note: Other forms of elaborated-type-specifier do not declare a new name, and therefore mustrefer to an existing type-name. See 3.4.4 and 7.1.5.3. — end note ] 
7 The point of declaration for an injected-class-name (9)is immediately following the opening brace of the class definition. 

8[Note: friend declarations refer to functions or classes that are members of the nearest enclosing namespace,but they 
do not introduce new names into that namespace(7.3.1.2). Function declarations at blockscope and object declarations 
with the extern specifierat block scope referto delarations that are membersofan enclosing namespace,buttheydo 
not introduce new names into that scope. — end note ] 

9 [Note: For pointof instantiationofatemplate, see14.6.4.1. — end note ] 

3.3.2 Local scope [basic.scope.local] 
1Aname declaredinablock(6.3)islocaltothat block.Its potentialscopebeginsatitspointof declaration(3.3.1)and 
ends at the end of its declarative region. 

2 The potentialscopeofa function parameter nameina function definition(8.4)beginsatitspointofdeclaration.Ifthe 
function has a function-try-block the potential scope of a parameter ends at the end of the last associated handler, else 
it ends at the end of the outermost block of the function definition. A parameter name shall not be redeclared in the 
outermostblockofthe function definitionnorintheoutermostblockofanyhandler associatedwitha function-try-block. 

3 The name in a catch exception-declaration is local to the handler and shall not be redeclared in the outermost block of 
the handler. 

4 Names declared in the for-init-statement, andin thecondition of if, while, for, andswitch statements are localto the 
if, while, for, or switch statement (including the controlled statement), and shall not be redeclared in a subsequent 

Draft 


3.3 Declarative regions and scopes Basic concepts 32 
condition of that statement nor in the outermost block (or, for the if statement, any of the outermost blocks) of the 
controlled statement; see 6.4. 

3.3.3 Function prototype scope [basic.scope.proto] 
1 Ina function declaration, orin any function declaratorexcept the declaratorofa function definition(8.4), names of 
parameters (if supplied) have function prototype scope, which terminates at the end of the nearest enclosing function 
declarator. 

3.3.4 Function scope [basic.funscope] 
1 Labels(6.1)havefunction scope andmaybeusedanywhereinthe functionin whichtheyare declared.Only labelshave 
function scope. 

3.3.5 Namespace scope [basic.scope.namespace] 
1 The declarative region of a namespace-definition is its namespace-body. The potential scope denoted by an originalnamespace-name is the concatenation of the declarative regions established by each of the namespace-definitions in 
the same declarative region with that original-namespace-name. Entities declared in a namespace-body are said to be 
members of the namespace, and names introduced by these declarations into the declarative region of the namespace 
are said to be member names of the namespace. Anamespace member name has namespace scope. Its potential scope 
includes its namespace from the name’s point of declaration(3.3.1)onwards; and for each using-directive (7.3.4)that 
nominates the member’s namespace, the member’s potential scope includes that portion of the potential scope of the 
using-directive that follows the member’spointof declaration.[ Example: 

namespace N {
int i;
int g(int a) { return a; }
int j ();
void q ();


}
namespace { int l =1; }
// the potential scope of l is from its point of declaration
// to the end of the translation unit


namespace N {
int g(char a) // overloads N::g(int)
{


return l+a; // l is from unnamed namespace
}


int i; // error: duplicate definition
int j (); // OK: duplicate function declaration


int j() // OK: definition of N::j()
{


return g(i); // calls N::g(int)
}
int q (); // error: different return type


} 

Draft 


33 Basic concepts 3.3 Declarative regions and scopes 

— end example ] 
2 A namespace member can also be referred to after the :: scope resolution operator(5.1)applied to the name of its 
namespace or the name of a namespace which nominates the member’s namespace in a using-directive; see 3.4.3.2. 

3 The outermost declarativeregionofatranslationunitisalsoanamespace, calledthe global namespace.Aname declared 
in the global namespace has global namespace scope (also called global scope ). The potential scope of such a name 
begins at itspoint of declaration(3.3.1)and ends at the end of the translation unit that is its declarative region. Names 
with global namespace scope are said to be global. 

3.3.6 Class scope [basic.scope.class] 
1 The following rules describe the scope of names declared in classes. 

1) The potential scope of a name declared in a class consists not only of the declarative region following the name’s 
point of declaration, but also of all function bodies, default arguments, and constructor ctor-initializers in that 
class (including such things in nested classes). 

2) AnameN usedinaclass S shall refer to the same declaration in its context and when re-evaluated in the completed 
scope of S. No diagnostic is required for a violation of this rule. 

3) If reordering member declarations in a class yields an alternate valid program under (1) and (2), the program is 
ill-formed, no diagnosticis required. 

4) A name declared within a member function hides a declaration of the same name whose scope extends to or past 
the end of the member function’s class. 

5) The potential scope of a declaration that extends to or past the end of a class definition also extends to the regions 
defined by its member definitions, even if the members are defined lexicallyoutside the class (this includes static 
data member definitions, nested class definitions, member function definitions (including the member function 
body and, for constructor functions(12.1), the ctor-initializer(12.6.2)) and anyportion of the declarator part of 
such definitions which follows the identifier, includinga parameter-declaration-clause and anydefault arguments 
(8.3.6).[Example: 

typedef int c;
enum { i =1};


class X {
char v[i]; // error: i refers to ::i


// but when reevaluated isX::i 
int f() { return sizeof(c); } // OK: X::c 
char c; 
enum { i =2}; 

}; 

typedef char * T;
struct Y {
T a; // error: T refers to ::T


// but when reevaluated isY::T 
typedef long T; 
T b; 

}; 

Draft 


3.4 Name lookup Basic concepts 34 
typedef int I; 
class D { 
typedef I I; // error, even though no reordering involved 
}; 

— end example ] 
2 The name of a class member shall only be used as follows: 
— in the scope of its class (as described above) or a class derived (clause 10)from its class, 
— after the . operatorappliedtoanexpressionofthetypeofitsclass(5.2.5)ora classderivedfromits class, 
— after the -> operator appliedtoa pointertoanobjectofits class(5.2.5)ora classderivedfromits class, 
— after the :: scope resolution operator(5.1)applied to the name of its class or a class derived from its class. 
3.3.7 Name hiding [basic.scope.hiding] 
1 Aname canbe hiddenbyanexplicit declarationof that same nameina nested declarativeregionor derived class(10.2). 

2Aclassname(9.1)or enumerationname(7.2)canbehiddenbythenameofanobject,function,or enumerator declared 
in the same scope. If a class or enumeration name and an object, function, or enumerator are declared in the same scope 
(inanyorder)withthesamename,theclassor enumerationnameishiddenwherevertheobject, function,or enumerator 
name is visible. 

3 In a member function definition, the declaration of a local name hides the declaration of a member of the class with the 
same name; see 3.3.6. The declaration of a member in a derived class (clause 10)hides the declaration of a member of 
a base class of the same name; see 10.2. 

4 During the lookup of a name qualified by a namespace name, declarations that would otherwise be made visible by a 
using-directive can be hidden by declarations with the same name in the namespace containing the using-directive; see 
(3.4.3.2). 

5 If a name is in scope and is not hidden it is said to be visible. 

3.4 Name lookup [basic.lookup] 
1 The name lookup rules apply uniformly to all names (including typedef-names (7.1.3), namespace-names (7.3)and 
class-names (9.1))whereverthegrammarallowssuch namesinthecontext discussedbya particularrule.Namelookup 
associates the useofa name witha declaration(3.1)of that name. Name lookup shall find an unambiguous declaration 
for the name (see 10.2). Name lookup may associate more than one declaration with a name if it finds the name to be a 
functionname;the declarationsaresaidtoformasetofoverloaded functions(13.1).Overloadresolution(13.3)takes 
place after name lookuphas succeeded.The access rules (clause 11)are consideredonly once name lookupand function 
overload resolution(if applicable)have succeeded.Only after name lookup, functionoverload resolution(if applicable) 
and access checkinghave succeeded are the attributes introduced by the name’s declaration used further in expression 
processing (clause 5). 

2Aname“lookedupinthecontextofanexpression”islookedupasan unqualifiednameinthescopewheretheexpression 
is found. 

Draft 


35 Basic concepts 3.4 Name lookup 

3 The injected-class-nameofa class (clause 9)is also consideredtobea memberofthat classforthe purposesof name 
hiding and lookup. 

4 [Note: 3.5 discusses linkage issues. The notions of scope, point of declaration and name hiding are discussed in 3.3. 

— end note ] 
3.4.1 Unqualified name lookup [basic.lookup.unqual] 
1 In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the respective 
categories;namelookupendsassoonasa declarationisfoundforthe name. Ifno declarationisfound,theprogramis 
ill-formed. 

2 The declarations from the namespace nominated by a using-directive become visible in a namespace enclosing the 
using-directive;see7.3.4.Forthe purposeofthe unqualified name lookup rules describedin 3.4.1,the declarations from 
the namespace nominatedby the using-directive are considered members of that enclosing namespace. 

3 The lookup for an unqualified name used as the postfix-expression of a function call is described in 3.4.2. [Note: for 
purposesof determining (duringparsing) whether anexpressionisa postfix-expression for a function call, the usual 
namelookuprulesapply.Therulesin 3.4.2havenoeffectonthe syntactic interpretationofanexpression.Forexample, 

typedef int f;
namespace N {
struct A {
friend void f(A &);


operator int ();
void g(A a) {
int i = f(a); 
// f is the typedef, not the friend 
// function: equivalent to int(a) 

}
};
}


Becausetheexpressionisnota functioncall,theargument-dependent namelookup(3.4.2)doesnotapplyandthe friend 
function f is not found. — end note ] 

4 Aname used in globalscope, outside of anyfunction, class or user-declared namespace, shall be declared before its use 
in global scope. 

5 Aname used in a user-declared namespace outside of the definition of anyfunction or class shall be declared before its 
use in that namespace or before its use in a namespace enclosing its namespace. 

6 Aname used in the definition of a function following the function’s declarator-id30) that is a member of namespace N 
(where, only for the purpose of exposition, N could represent the global scope) shall be declared before its use in the 
blockin whichitis used orin oneof its enclosing blocks(6.3)or, shallbe declared before its usein namespace N or, if 
N is a nested namespace, shall be declared before its use in one of N ’s enclosing namespaces. 

[Example: 

30) This refers to unqualified names that occur, for instance, in a type or default argument expression in the parameter-declaration-clause or used in 
the function body. 

Draft 


3.4 Name lookup Basic concepts 36 
namespace A {
namespace N {
void f ();


}
}
void A::N::f() {


i =5;
// The following scopes are searched for a declaration of i:
// 1) outermost blockscope ofA::N::f, before the use of i
// 2) scope of namespaceN
// 3) scope of namespaceA
// 4) global scope, before the definition ofA::N::f


} 

— end example ] 
A name used in the definition of a class X outside of a member function body or nested class definition31) shall be 
declared in one of the following ways: 

— before its use in class X or be a member of a base class of X (10.2), or 
— if X is a nested class of class Y (9.7), before thedefinitionof X in Y, or shall be a member of a base class of Y (this 
lookup applies in turn to Y ’s enclosing classes, startingwith the innermost enclosing class),32) 
— if X isa local class(9.8)orisa nested classofa local class, beforethe definitionof class X in a block enclosing 
the definition of class X, or 
— if X is a member of namespace N,orisa nested classofa class thatisa memberof N,orisa local class ora nested 
class within a local class of a function that is a member of N, before the definition of class X in namespace N or in 
one of N ’s enclosing namespaces. 
[Example: 

namespace M {
class B{};
}


namespace N {
class Y : public M::B {
class X {
int a[i];
};
};
}


// The following scopes are searched for a declaration of i:
// 1) scope of classN::Y::X, before the use of i
// 2) scope of classN::Y, before the definition of N::Y::X


31) This refers to unqualified names following the class name; such a name may be used in the base-clause or maybe usedin the class definition. 
32) This lookup applies whether the definition of X is nested within Y ’s definition or whether X ’s definition appears in a namespace scope enclosing 
Y ’s definition(9.7). 

Draft 


37 Basic concepts 3.4 Name lookup 

// 3) scope ofN::Y’s base class M::B
// 4) scope of namespaceN, before the definition of N::Y
// 5) global scope, before the definition ofN


— end example ][Note: when looking fora prior declarationofa classor function introducedbya friend declaration, 
scopes outside of the innermost enclosing namespace scope are not considered; see 7.3.1.2. — end note ][Note: 3.3.6 
further describesthe restrictionsonthe useof namesina class definition. 9.7 further describesthe restrictionsonthe use 
of names in nested class definitions. 9.8 further describes the restrictions on the use of names in local class definitions. 
— end note ] 
Aname usedinthe definitionofa member function(9.3)of classX following the function’s declarator-id 33) shall be 
declared in one of the following ways: 

— before its use in the block in which it is used or in an enclosing block(6.3), or 
— shall be a member of class X or be a member of a base class of X (10.2), or 
— if X isa nested classof class Y (9.7), shallbea memberof Y, or shallbea memberofa base classof Y (this lookup 
applies in turn to Y ’s enclosing classes, starting with the innermost enclosing class),34) or 
— if X isa local class(9.8)orisa nested classofa local class, beforethe definitionof class X in a block enclosing 
the definition of class X, or 
— if X is a member of namespace N,orisa nested classofa class thatisa memberof N,orisa local class ora nested 
class withina local classofa function thatisa memberof N, before the member function definition, in namespace 
N orin oneof N ’s enclosing namespaces. 
[Example: 

class B {}; 

namespace M { 

namespace N { 

class X : public B { 

void f (); 

}; 

} 

} 

void M::N::X::f() { 

i = 16; 

} 

// The following scopes are searched for a declaration of i:
// 1) outermost blockscope ofM::N::X::f, before the use of i
// 2) scope of classM::N::X
// 3) scope ofM::N::X’s base class B
// 4) scope of namespaceM::N
// 5) scope of namespaceM
// 6) global scope, before the definition ofM::N::X::f


33) That is, an unqualified name that occurs, for instance, in a type or default argument expression in the parameter-declaration-clause, in the 

function body, or in an expression of a mem-initializer ina constructor definition. 

34) This lookup applies whether the member function is defined within the definition of class X or whether the member function is defined in a 

namespace scope enclosing X ’s definition. 

Draft 


3.4 Name lookup Basic concepts 38 
— endexample ][Note: 9.3 and 9.4 further describe the restrictions on the use of names in member function definitions. 
9.7 further describes the restrictions on the use of names in the scope of nested classes. 9.8 further describes the 
restrictions on the use of names in local class definitions. — end note ] 
9 Namelookupfora nameusedinthe definitionofa friend function(11.4)defined inline in the class granting friendship 
shall proceed as described for lookup in member function definitions. If the friend function is not defined in the class 
granting friendship, name lookup in the friend function definition shall proceed as described for lookup in namespace 
member function definitions. 

10 Ina friend declaration naming a member function, a name usedin the function declarator and not part of a template-
argument in a template-id is first looked up in the scope of the member function’s class. If it is not found, or if the name 
is partofa template-argument in a template-id, the look up is as described for unqualified names in the definition of the 
class granting friendship.[ Example: 

struct A {
typedef int AT;
void f1(AT);
void f2(float);


}; 

struct B {
typedef float BT;
friend void A::f1(AT); // parameter type is A::AT
friend void A::f2(BT); // parameter type is B::BT


}; 

— end example ] 
11 During the lookup fora name used asa default argument(8.3.6)ina functionparameter-declaration-clause or used 
in the expression of a mem-initializer fora constructor(12.6.2), the function parameter names are visible and hide the 
names of entities declared in the block, class or namespace scopes containing the function declaration. [Note: 8.3.6 
further describes the restrictions on the use of names in default arguments. 12.6.2 further describesthe restrictions on 
the use of names in a ctor-initializer. — end note ] 

12 Aname used in the definition of astatic data member of class X (9.4.2)(after thequalified-id of the static member) is 
looked up as if the name was used in a member function of X.[ Note: 9.4.2 further describes the restrictions on the use 
of names in the definition of a static data member. — end note ] 

13 Aname used in the handler for a function-try-block (clause 15)is looked up as if the name was used in the outermost 
block of the function definition. In particular, the function parameter names shall not be redeclared in the exception-
declaration nor in the outermost block of a handler for the function-try-block. Names declared in the outermost block 
of the function definition are not found when looked up in the scope of a handler for the function-try-block.[ Note: but 
function parameter names are found. — end note ] 

14 [Note: the rules for name lookup in template definitions are described in 14.6. — end note ] 

3.4.2 Argument-dependent name lookup [basic.lookup.argdep] 
1 When an unqualified name is used as the postfix-expression ina function call(5.2.2), other namespaces not considered 
during the usual unqualified lookup(3.4.1)may be searched, and in those namespaces, namespace-scope friend function 

Draft 


39 Basic concepts 3.4 Name lookup 

declarations(11.4)nototherwise visiblemaybe found. These modificationstothesearchdependonthetypesofthe 
arguments (and for template template arguments, the namespace of the template argument). 

2 For each argument typeT in the function call, there is a set of zero or more associated namespaces and a set of zero 
or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of 
thefunctionarguments(andthe namespaceofanytemplatetemplateargument).Typedef namesand using-declarations 
usedtospecifythetypesdonot contributetothisset.Thesetsof namespacesand classesaredeterminedinthefollowing 
way: 

— If T is a fundamental type, its associated sets of namespaces and classes are both empty. 
— If T isaclasstype (includingunions),its associated classesare:theclassitself;theclassofwhichitisamember,if 
any; and its direct and indirect base classes. Its associated namespaces are the namespaces in which its associated 
classes are defined. 
— If T is an enumeration type, its associated namespace is the namespace in which it is defined. If it is class member, 
its associated classisthe member’s class; elseit has no associated class. 
— If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with U. 
— If T is a function type, its associated namespaces and classes are those associated with the function parameter 
types and those associated with the return type. 
— If T isa pointertoa member functionofaclass X, its associated namespaces and classes are those associated with 
the function parameter types and return type, together with those associated with X. 
— If T is a pointer to a data member of class X, its associated namespaces and classes are those associated with the 
member type together with those associated with X. 
— If T is a class template specialization its associated namespaces and classes are the namespace in which the 
template is defined; for member templates, the member template’s class; the namespaces and classes associated 
with the types of the template arguments provided for template type parameters (excluding template template 
parameters); the namespaces in which anytemplate template arguments are defined; and the classes in which any 
member templates used as template template arguments are defined.[ Note: non-type template arguments do not 
contribute to the set of associated namespaces. — end note ] 
In addition, if the argument is the name or address of a set of overloaded functions and/or function templates, its 
associated classes and namespaces are the union of those associated with each of the members of the set: the namespace 
in which the function or function template is defined and the classes and namespaces associated with its (non-dependent) 
parameter types and return type. 

3 If the ordinary unqualified lookup of the name finds the declaration of a class member function, or a block-scope 
function declaration that is not a using-declaration, the associated namespaces are not considered. Otherwise the set 
of declarations found by the lookup of the function name is the union of the set of declarations found using ordinary 
unqualified lookup and the setof declarations foundin the namespaces associated with the argument types.[ Note: the 
namespaces and classes associated with the argument types can include namespaces and classes already considered by 
the ordinary unqualified lookup. — end note ][Example: 

namespace NS {
class T {};
void f(T);


void g(T, int); 

Draft 


3.4 Name lookup Basic concepts 40 
}
NS::T parm;
void g(NS::T, float);
int main () {


f( parm ); // OK: calls NS::f
extern void g(NS::T, float);
g(parm , 1); // OK: calls g(NS::T, float)


} 

— end example ] 
4 When considering an associated namespace, the lookup is the same as the lookup performed when the associated namespaceis used asa qualifier(3.4.3.2)except that: 

— Any using-directive s in the associated namespace are ignored. 
— Anynamespace-scope friend functions declared in associated classes are visible within their respective namespacesevenif they are not visible during an ordinary lookup(11.4). 
3.4.3 Qualified name lookup [basic.lookup.qual] 
1 The name of a class or namespace member can be referred to after the :: scope resolution operator(5.1)applied to 
a nested-name-specifier that nominates its class or namespace. During the lookup for a name preceding the :: scope 
resolution operator, object,function,and enumerator namesare ignored.Ifthe name foundisnota class-name (clause 
9)or namespace-name (7.3.1), the programis ill-formed.[Example: 

class A {
public :


static int n;
};
int main ()
{


int A; 

A::n = 42; // OK 
A b; // ill-formed: A does not name a type
}


— end example ] 
2[Note: Multiply qualifiednames, such as N1::N2::N3::n, canbe usedto referto membersof nestedclasses(9.7)or 
members of nested namespaces. — end note ] 

3 Ina declarationin whichthe declarator-id isa qualified-id, names usedbefore thequalified-id being declared are looked 
up in the defining namespace scope; names following the qualified-id are looked up in the scope of the member’s class 
or namespace.[ Example: 

class X {}; 

class C {
class X{};
static const int number = 50;
static X arr [ number ];


Draft 


41 Basic concepts 3.4 Name lookup 

}; 

X C::arr[number]; // ill-formed:
// equivalent to:::X C::arr[C::number];
// not to: C::X C::arr[C::number];
— end example ] 
4 Aname prefixedbythe unary scope operator :: (5.1)is looked up in global scope, in the translation unit where it is 
used. The name shall be declared in global namespace scope or shall be a name whose declaration is visible in global 
scope because of a using-directive (3.4.3.2). The use of :: allows a global name to be referred to even if its identifier 
has been hidden(3.3.7). 

5 Ifa pseudo-destructor-name (5.2.4)containsanested-name-specifier,thetype-namesare looked up as types in the scope 
designated by the nested-name-specifier. Similarly, in a qualified-id of the form: 

::opt nested-name-specifieropt class-name :: ~ class-name 

the second class-name is lookedupin the same scope as the first.[ Example: 

struct C { 

typedef int I;
};
typedef int I1 , I2;
extern int* p;
extern int* q;
p->C::I::~ I (); // I is looked up in the scope of C
q->I1 ::~ I2 (); // I2 is looked up in the scope of


// the postfix-expression 

struct A { 

~A ();
};
typedef A AB;
int main ()
{


AB *p;
p ->AB ::~ AB (); // explicitly calls the destructor for A
}


— end example ][Note: 3.4.5 describes how name lookup proceeds after the . and -> operators. — end note ] 
3.4.3.1 Class members [class.qual] 
1 If the nested-name-specifier of a qualified-id nominates a class, the name specified after the nested-name-specifier is 
lookedupin the scopeof the class(10.2),except for thecases listed below. The name shall represent one ormore 
members of that class or of one of its base classes (clause 10). [Note: a class member can be referred to using a 
qualified-id atanypointinits potentialscope(3.3.6). — end note ]The exceptions to the name lookup rule above are 
the following: 

— a destructor name is lookedup as specified in 3.4.3; 
Draft 


3.4 Name lookup Basic concepts 42 
— a conversion-type-id of an operator-function-id is looked up both in the scope of the class and in the context in 
which the entire postfix-expression occurs and shall refer to the same type in both contexts; 
— the template-arguments ofa template-id are looked up in the context in which the entire postfix-expression occurs. 
— the lookupfora name specifiedina using-declaration (7.3.3)also finds class or enumeration names hidden within 
the same scope(3.3.7). 
2 Ina lookupin whichthe constructorisan acceptable lookup result,ifthe nested-name-specifier nominatesa class C, and 
the name specified after the nested-name-specifier, when looked up in C, isthe injected-class-name of C (clause9),the 
name is instead considered to name the constructor of class C.[ Note: For example, the constructor is not an acceptable 
lookup result in an elaborated-type-specifier so the constructor would not be used in place of the injected-class-name. 

— end note ]Such a constructor name shall be used only in thedeclarator-id of a declaration that names a constructor. 
[Example: 
struct A { A(); };
struct B: public A { B(); };


A::A() { } 
B::B() { } 
B::A ba; // object of typeA 
A::A a; // error, A::A is not a type name
struct A::A a2; // object of typeA
— end example ] 
3 Aclass member name hidden by a name in a nested declarative region or by the name of a derived class member can 
stillbe foundif qualifiedbythe nameof its class followedby the :: operator. 

3.4.3.2 Namespace members [namespace.qual] 
1 If the nested-name-specifier ofa qualified-id nominatesa namespace, the name specified after the nested-name-specifier 
is looked up in the scope of the namespace, except that the template-arguments of a template-id are looked up in the 
context in which the entire postfix-expression occurs. 

2 Given X::m (where X is a user-declared namespace), or given ::m (whereXis the global namespace), let S be the set of 
all declarations of m in X and in the transitive closure of all namespaces nominated by using-directives in X and its used 
namespaces, except that using-directives are ignored in any namespace, including X, directly containing one or more 
declarations of m. No namespace is searched more than once in the lookupof a name. If S is the empty set, the program 
is ill-formed. Otherwise, if S has exactly one member, or if the context of the reference is a using-declaration (7.3.3), S 
is the required set of declarations of m. Otherwise if the use of m is not one that allows a unique declaration to be chosen 
from S, the programis ill-formed.[Example: 

int x; 

namespace Y {
void f(float);
void h(int);


} 

Draft 


43 Basic concepts 3.4 Name lookup 

n a m e s p a c e Z { 
v o i d h ( d o u b l e ) ; 
} 
n a m e s p a c e A { 
u s i n g n a m e s p a c e Y ; 
v o i d f ( i n t ) ; 
v o i d g ( i n t ) ; 
i n t i ; 
} 
n a m e s p a c e B { 
u s i n g n a m e s p a c e Z ; 
v o i d f ( c h a r ) ; 
i n t i ; 
} 
n a m e s p a c e A B { 
u s i n g n a m e s p a c e A ; 
u s i n g n a m e s p a c e B ; 
v o i d g ( ) ; 
} 
v o i d h ( ) 
{ 
A B : : g ( ) ; // g is declared directly in AB, 
// therefore S is { AB::g() }andAB::g() is chosen 
A B : : f ( 1 ) ; // f is not declared directly in AB so the rules are 
// applied recursively toA and B; 
// namespace Y is not searched and Y::f(float) 
// is not considered; 
// S is { A::f(int) , B::f(char) }and overload 
// resolution chooses A::f(int) 
A B : : f ( ’ c ’ ) ; // as above but resolution chooses B::f(char) 
A B : : x + + ; // x is not declared directly in AB, and 
// is not declared in A or B , so the rules are 
// applied recursively toY and Z, 
// S is {} so the program is ill-formed 
A B : : i + + ; // i is not declared directly in AB so the rules are 
// applied recursively toA and B, 
// S is { A::i , B::i }so the use is ambiguous 
// and the program is ill-formed 
A B : : h ( 1 6 . 8 ) ; // h is not declared directly in AB and 
// not declared directly in A or B so the rules are 
// applied recursively toY and Z, 
// S is { Y::h(int) , Z::h(double) }and overload 
// resolution chooses Z::h(double) 
} 
Draft 


3.4 Name lookup Basic concepts 44 
3 The same declaration foundmore than onceis not an ambiguity (becauseitis stilla unique declaration).Forexample: 

namespace A {
int a;
}


namespace B {
using namespace A;
}


namespace C {
using namespace A;
}


namespace BC { 

using namespace B; 

using namespace C; 

} 

void f()
{
BC ::a ++; // OK: S is{ A::a, A::a }
}


namespace D {
using A::a;
}


namespace BD { 

using namespace B; 

using namespace D; 

} 

void g()
{
BD ::a ++; // OK:Sis{ A::a, A::a }
}


4 Because each referenced namespace is searched at most once, the following is well-defined: 

namespace B {
int b;
}


namespace A { 

using namespace B; 

int a; 

} 

namespace B {
using namespace A;


Draft 


45 Basic concepts 3.4 Name lookup 

} 

void f()
{


A:: a ++; // OK: a declared directly in A, S is{A::a} 
B:: a ++; // OK: both A and B searched (once), S is{A::a} 
A:: b ++; // OK: both A and B searched (once), S is{B::b} 
B:: b ++; // OK: b declared directly in B, S is{B::b}
}
— end example ] 
5 Duringthe lookupofa qualified namespace member name,ifthe lookup finds more than one declarationofthe member, 
andifone declaration introducesa class nameorenumeration nameandthe other declarations either introducethe same 
object, the same enumerator or a set offunctions, the non-type name hides the class or enumeration name if and onlyif 
the declarations are from the same namespace; otherwise (the declarations are from different namespaces), the program 
is ill-formed.[ Example: 

namespace A { 

struct x { }; 

int x; 

int y; 

} 

namespace B {
struct y {};
}


namespace C { 

using namespace A; 

using namespace B; 

int i = C::x; // OK, A::x (of type int ) 

int j = C::y; // ambiguous,A::y or B::y 

} 

— end example ] 
6 In a declaration for a namespace member in which the declarator-id is a qualified-id, given that the qualified-id for the 
namespace member has theform nested-name-specifier unqualified-id 
the unqualified-id shall name a member of the namespace designated by the nested-name-specifier.[ Example: 

namespace A { 

namespace B { 

void f1(int); 

} 

using namespace B; 

} 

void A::f1(int) { } // ill-formed, f1 is not a member of A 

— end example ]However, in such namespace member declarations, the nested-name-specifier may rely on using-
directives to implicitly provide the initial part of the nested-name-specifier.[ Example: 
Draft 


3.4 Name lookup Basic concepts 46 
namespace A {
namespace B {
void f1(int);
}
}


namespace C {
namespace D {
void f1(int);
}
}


using namespace A;
using namespace C::D;
void B::f1(int){} // OK, defines A::B::f1(int)


— end example ] 
3.4.4 Elaborated type specifiers [basic.lookup.elab] 
1 An elaborated-type-specifier (7.1.5.3)may be used to refer to a previously declaredclass-name or enum-name even 
though the name has been hiddenbya non-type declaration(3.3.7). 

2 If the elaborated-type-specifier has no nested-name-specifier, and unless the elaborated-type-specifier appears in a declaration with the followingform: 

class-keyidentifier ; 

the identifier islookedup accordingto 3.4.1but ignoringanynon-type namesthathavebeen declared.Iftheelaboratedtype-specifier is introduced by the enum keyword and this lookup does not find a previously declared type-name, the 
elaborated-type-specifier is ill-formed. If the elaborated-type-specifier is introduced by the class-key and this lookup 
does not finda previously declared type-name, or if the elaborated-type-specifier appearsina declaration withthe form: 

class-keyidentifier ; 

the elaborated-type-specifier is a declaration that introduces the class-nam as described in 3.3.1. 

3 If the elaborated-type-specifier has a nested-name-specifier, qualified name lookup is performed, as described in 3.4.3, 
but ignoring any non-type names that have been declared. If the name lookup does not find a previously declared 
type-name, the elaborated-type-specifier is ill-formed.[ Example: 

struct Node {
struct Node * Next ; // OK: Refers to Node at global scope
struct Data * Data ; // OK: Declares type Data


// at global scope and member Data
};


struct Data {
struct Node * Node ; // OK: Refers to Node at global scope
friend struct :: Glob ; // error: Glob is not declared


// cannot introduce a qualified type(7.1.5.3) 
friend struct Glob ; // OK: Refers to (as yet) undeclared Glob 

Draft 


47 Basic concepts 3.4 Name lookup 

// at global scope.
...


/* / 

}; 

struct Base {
struct Data ; // OK: Declares nested Data
struct :: Data * thatData ; // OK: Refers to ::Data
struct Base :: Data * thisData ; // OK: Refers to nested Data
friend class :: Data ; // OK: global Data is a friend
friend class Data ; // OK: nested Data is a friend
struct Data { /* ... * / }; // Defines nested Data


}; 

struct Data ; // OK: Redeclares Data at global scope
struct :: Data ; // error: cannot introducea qualified type(7.1.5.3)
struct Base :: Data ; // error: cannot introducea qualified type(7.1.5.3)
struct Base :: Datum ; // error: Datum undefined
struct Base :: Data * pBase ; // OK: refers to nested Data


— end example ] 
3.4.5 Class member access [basic.lookup.classref] 
1 Ina classmember accessexpression(5.2.5),ifthe . or -> token is immediately followed by an identifier followed by 
a <, the identifier must be looked up to determine whether the < isthebeginningofa templateargumentlist(14.2)or 
a less-than operator. The identifier is first looked up in the class of the object expression. If the identifier is not found, 
it is then looked up in the context of the entire postfix-expression and shall name a class or function template. If the 
lookup in the class of the object expression finds a template, the name is also looked up in the context of the entire 
postfix-expression and 

— if the name is not found, the name found in the class of the object expression is used, otherwise 
— ifthenameis foundinthe contextoftheentire postfix-expression and does not name a class template, the name 
found in the class of the object expression is used, otherwise 
— if the name found is a class template, it must refer to the same entity as the one found in the class of the object 
expression, otherwise theprogramis ill-formed. 
2 If the id-expression ina class member access(5.2.5)is anunqualified-id, and the type of the object expression is of a 
class type C (orof pointertoaclasstype C),theunqualified-id is looked up in the scope of class C. If the type of the object 
expression is of pointer to scalar type, the unqualified-id is looked up in the context of the complete postfix-expression. 

3 If the unqualified-id is ˜type-name, and the type of the object expression is of a class type C (or of pointer to a class type 
C), the type-name is looked up in the context of the entire postfix-expression and in the scope of class C. The type-name 
shall refertoa class-name. If type-name isfoundinbothcontexts,the nameshallrefertothe sameclasstype.Ifthetype 
of the object expression is of scalar type, the type-name is looked up in the scope of the complete postfix-expression. 

4 If the id-expression in a class member access is a qualified-id of the form 

class-name-or-namespace-name::... 

Draft 


3.5 Program and linkage Basic concepts 48 
the class-name-or-namespace-name following the . or -> operator is looked up both in the context of the entire postfix-
expression and in the scope of the class of the object expression. If the name is found only in the scope of the class 
of the object expression, the name shall refer to a class-name. If the name is found only in the context of the entire 
postfix-expression, the name shall refer to a class-name or namespace-name. If the name is found in both contexts, the 
class-name-or-namespace-name shall refer to the same entity. 

5 If the qualified-id has the form 

::class-name-or-namespace-name::... 

the class-name-or-namespace-name is looked up in global scope as a class-name or namespace-name. 

6 If the nested-name-specifier contains a class template-id (14.2), its template-arguments are evaluated in the context in 
which the entire postfix-expression occurs. 

7 If the id-expression is a conversion-function-id, its conversion-type-id shall denote the same type in both the context in 
which the entire postfix-expression occursandinthe contextoftheclassoftheobjectexpression(ortheclasspointedto 
by the pointer expression). 

3.4.6 Using-directives and namespace aliases [basic.lookup.udir] 
1 When looking up a namespace-name in a using-directive or namespace-alias-definition, only namespace names are 
considered. 

3.5 Program and linkage [basic.link] 
1Aprogram consists of one or more translation units (clause2)linked together.Atranslation unit consistsofa sequence 
of declarations. 

translation-unit:
declaration-seqopt


2 Aname is said to have linkage when it might denote the same object, reference, function, type, template, namespace or 
value asa name introducedbya declarationin another scope: 

— When a name has external linkage, the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit. 
— Whena name has internal linkage,theentityit denotescanbe referredtoby namesfromotherscopesinthesame 
translation unit. 
— When a name has no linkage, the entity it denotes cannot be referred to by names from other scopes. 
3 Anamehaving namespace scope(3.3.5)has internal linkageifitis the nameof 
— an object, reference, function or function template that is explicitly declared static or, 
— an object or reference that is explicitly declared const and neither explicitly declared extern nor previously 
declared to have external linkage; or 
— a data member of an anonymous union. 
4 Aname having namespace scope has external linkage if it is the name of 
— an object or reference, unless it has internal linkage; or 
Draft 


49 Basic concepts 3.5 Program and linkage 

— a function, unless it has internal linkage; or 
— a named class (clause 9), or an unnamed class definedina typedef declarationin which the class has the typedef 
name for linkage purposes(7.1.3); or 
— a named enumeration(7.2),oran unnamed enumeration definedinatypedef declarationin whichthe enumeration 
has the typedef name forlinkage purposes(7.1.3); or 
— an enumerator belonging to an enumeration with external linkage; or 
— a template, unless it is a function template that has internal linkage (clause 14); or 
— a namespace(7.3), unlessitis declared within an unnamed namespace. 
5 In addition, a member function, static data member, a named class or enumeration of class scope, or an unnamed class 
or enumeration defined in a class-scope typedef declaration such that the class or enumeration has the typedef name for 
linkage purposes(7.1.3), hasexternal linkageifthe nameof the class hasexternal linkage. 

6 The nameofafunction declaredin block scope,andthe nameofanobject declaredbyablock scope extern declaration, 
have linkage. If there is a visible declaration of an entity with linkage having the same name and type, ignoring entities 
declared outside the innermost enclosing namespace scope, the block scope declaration declares that same entity and 
receives the linkage of the previous declaration. If there is more than one such matching entity,the program is ill-formed. 
Otherwise, if no matching entity is found, the block scope entity receives external linkage. 

[Example: 

static void f (); 

static int i = 0; // 1 

void g() { 

extern void f (); // internal linkage 

int i; // 2: i has no linkage 

{ 

extern void f (); // internal linkage
extern int i; // 3: external linkage
}
}


There are three objects named i in thisprogram. The object with internal linkage introducedby the declarationin 
global scope (line //1 ), the object with automatic storage duration and no linkage introducedby the declaration on line 
//2, and the object withstatic storage duration andexternal linkage introducedby thedeclaration on line //3. — end 
example] 

7 When a block scope declaration of an entity with linkage is not found to refer to some other declaration, then that entity 
is a member of the innermost enclosing namespace. However such a declaration does not introduce the member name 
in its namespace scope.[ Example: 

namespace X {
void p()
{


q (); // error: q not yet declared 
extern void q (); // q is a member of namespace X 

} 

Draft 


3.5 Program and linkage Basic concepts 50 
void middle () 
{ 
q (); // error: q not yet declared 
} 

void q() { /* ... * / } // definition of X::q
}


void q() { /* ... * / } // some other, unrelated q 

— end example ] 
8 Names not coveredby these ruleshave no linkage. Moreover,except as noted,a name declaredina local scope(3.3.2) 
hasno linkage.Atypeissaidtohave linkageifandonlyif: 

— itisa class or enumeration type thatis named(or hasa name for linkage purposes(7.1.3)and the namehas 
linkage; or 
— itisa specializationofa class template(14)35);or 
— itisa fundamental type(3.9.1); or 
— itisa compound type(3.9.2)other thana class or enumeration, compoundedexclusively from typesthathave 
linkage; or 
— itisa cv-qualified(3.9.3)versionofa type that has linkage. 
Atype without linkage shallnotbeusedasthetypeofavariableor functionwith linkage,unlessthevariableor function 
hasextern "C" linkage(7.5).[Note: in other words, a type without linkage contains a class or enumeration that cannot 
be named outside its translation unit. An entity with external linkage declared using such a type could not correspond to 
anyother entity in another translation unit of the program and thus is not permitted. Also note that classes with linkage 
may contain members whose types do not have linkage, and that typedef names are ignored in the determination of 
whether a type has linkage. — end note ][Example: 

void f() 

{
struct A { int x; }; // no linkage
extern A a; // ill-formed
typedef A B;
extern B b; // ill-formed


} 

— end example ]This implies that names with no linkage cannotbe used as template arguments(14.3). 
9 Two namesthat are the same (clause3)and that are declaredin different scopes shall denotethe same object, reference, 
function, type, enumerator, template or namespace if 

— both nameshaveexternal linkageor elsebothnameshave internal linkageand are declaredinthe same translation 
unit; and 
35) a class template always has external linkage, and the requirements of 14.3.1 and 14.3.2 ensure that the template arguments will also have 
appropriate linkage. 

Draft 


51 Basic concepts 3.6 Start and termination 

— both names refer to members of the same namespace or to members, not by inheritance, of the same class; and 
— when both names denote functions, the parameter-type-listsof the functions(8.3.5)are identical; and 
— when both names denote function templates, the signatures(14.5.5.1)are the same. 
10 After all adjustmentsof types (during which typedefs(7.1.3)are replacedby their definitions), the types specifiedby 
all declarations referring to a given object or function shall be identical, except that declarations for an array object can 
specifyarraytypesthatdifferbythe presenceor absenceofamajorarraybound(8.3.4).Aviolationofthisruleontype 
identity does not require a diagnostic. 

11 [Note: linkage to non-C++ declarations can be achieved using a linkage-specification (7.5). — end note ] 

3.6 Start and termination [basic.start] 
3.6.1 Main function [basic.start.main] 
1 Aprogram shall containaglobal function calledmain,which is the designated start of the program. It is implementation-
defined whethera programina freestandingenvironmentis requiredto definea main function.[ Note: ina freestanding 
environment, start-up and termination is implementation-defined; start-up contains the execution of constructors for 
objects ofnamespace scope with static storage duration; termination contains the execution of destructors for objects 
with static storage duration. — end note ] 

2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return 
type of type int,but otherwise its type is implementation-defined. All implementations shall allowboth of the following 
definitions of main : 

int main () { /* ... * / } 

and 

int main ( int argc , char * argv []) { /* ... * / } 

In the latter form argc shall be the number of arguments passed to the program from the environment in which the 
program is run. If argc is nonzero these arguments shall be supplied in argv[0] through argv[argc-1] as pointers to 
the initial charactersof null-terminated multibyte strings(NTMBSs)(17.3.2.1.3.2)andargv[0] shall be the pointer to 
the initial characterofa NTMBS that representsthe nameusedtoinvokethe programor "". The value of argc shall be 
nonnegative. The value of argv[argc] shall be 0.[ Note: it is recommended that anyfurther (optional) parameters be 
added after argv. — end note ] 

3 The function main shall notbe used(3.2)withina program. The linkage(3.5)ofmain is implementation-defined. A 
program that declares main to be inline or static is ill-formed. The name main is not otherwise reserved.[ Example: 
member functions, classes, and enumerations can be called main, as can entities in other namespaces. — end example ] 

4 Calling the function std::exit(int) declared in <cstdlib> (18.3)terminates the program without leaving the current 
block and hence without destroying anyobjects with automatic storage duration(12.4). If std::exit is called to end a 
program during the destructionof an object with static storage duration, the programhas undefined behavior. 

5 Areturn statement inmain has the effect of leaving the main function (destroying anyobjects with automatic storage 
duration) and calling std::exit with the return value as the argument. If control reaches the end of main without 
encountering a return statement, the effect is that of executing 

Draft 


3.6 Start and termination Basic concepts 52 
return 0; 

3.6.2 Initialization of non-local objects [basic.start.init] 
1 Objects with static storage duration(3.7.1)shallbe zero-initialized(8.5)beforeanyother initializationtakes place.A 
reference with static storage duration and an object of POD type withstatic storage duration can be initialized with a 
constantexpression(5.19); thisis called constant initialization. Together, zero-initialization and constant initialization 
are called static initialization; all other initialization isdynamic initialization. Static initialization shall be performed 
before anydynamic initialization takes place. Dynamic initialization of an object is either ordered or unordered. Definitions of explicitly specialized class template static data members have ordered initialization. Other class template 
static data members (i.e., implicitly or explicitly instantiated specializations) have unordered initialization. Other objects defined in namespace scope have ordered initialization. Objects defined within a single translation unit and with 
ordered initialization shall be initialized in the order of their definitions in the translation unit. The order of initialization 
is unspecifiedforobjectswith unordered initializationandforobjects definedindifferent translation units.[ Note: 8.5.1 
describes the order in which aggregate members are initialized. The initialization of local static objects is described in 

6.7. — end note ] 
2 An implementationis permittedtoperformthe initializationofanobjectof namespacescopewithstaticstorage duration 
as a static initialization even if such initialization is not required to be done statically, provided that 

— the dynamic version of the initialization does not change the value of anyother object of namespace scope with 
static storage duration prior to its initialization, and 
— the static version of the initialization produces the same value in the initialized object as would be produced by 
the dynamic initialization if all objects not required to be initialized statically were initialized dynamically. 
— [Note: as a consequence, if the initialization of an object obj1 refers to an object obj2 of namespace scope with 
static storage duration potentially requiring dynamic initialization and defined later in the same translation unit, it 
is unspecified whether the value of obj2 used will be the value of the fully initialized obj2 (because obj2 was 
statically initialized) or will be the value of obj2 merely zero-initialized.Forexample, 
inline double fd () { return 1.0; }
extern double d1;
double d2 = d1 ; // unspecified:


// may be statically initialized to 0.0 or
// dynamically initialized to1.0
double d1 = fd (); // may be initialized statically to 1.0


— end note ] 
3 Itis implementation-defined whether or not the dynamic initialization(8.5, 9.4, 12.1, 12.6.1)of an objectof namespace 
scope is done before the first statement of main. If the initialization is deferred to some point in time after the first 
statement of main, it shall occur before the first use of anyfunction or object defined in the same translation unit as the 
objecttobe initialized.36)[Example: 

// -File1

#include "a.h"
#include "b.h"
B b;


36) An object defined in namespace scope having initialization with side-effects must be initialized even if it is not used(3.7.1). 

Draft 


53 Basic concepts 3.6 Start and termination 

A::A(){ 
b. Use ();
}
// -File2

#include "a.h"
A a;


// -File3

#include "a.h" 

#include "b.h" 

extern A a; 

extern B b; 

int main () { 

a. Use (); 
b. Use ();
}
It is implementation-defined whether either a or b is initialized before main is entered or whether the initializations are 
delayed until a is first used in main. In particular, if a is initialized before main is entered,it is not guaranteedthat b 
willbe initialized beforeitis usedby theinitializationof a, that is, before A::A is called. If, however, a is initialized at 
some point after the first statement of main, b will be initialized prior to its use in A::A. — end example ] 

4 If construction or destruction of a non-local static object ends in throwing an uncaught exception, the result is to call 
std::terminate (18.6.3.3). 

3.6.3 Termination [basic.start.term] 
1 Destructors(12.4)for initialized objects of static storage duration (declared at block scope or at namespace scope) are 
called as a result of returning from main and as a result of calling std::exit (18.3). These objects are destroyed in the 
reverse order of the completion of their constructor or of the completion of their dynamic initialization. If an object is 
initialized statically, the objectis destroyedin the same order asif the objectwas dynamically initialized.For an object 
of array or class type, all subobjects of that object are destroyed before any local object with static storage duration 
initialized during the construction of the subobjects is destroyed. 

2 If a function contains a local object of static storage duration that has been destroyed and the function is called during 
the destruction of an object with static storage duration, the program has undefined behavior if the flow of control passes 
through the definition of the previously destroyed local object. 

3 If a function is registered with std::atexit (see <cstdlib>, 18.3)then following the call tostd::exit, anyobjects 
with static storage duration initialized prior to the registration of that function shall not be destroyed until the registered 
functionis calledfromthe termination processandhas completed.Foranobjectwith static storageduration constructed 
after a function is registered with std::atexit, then following the call to std::exit, the registered function is not 
called until the execution of the object’s destructor has completed. If std::atexit is called during the construction of 
an object, the complete objectto which it belongs shall be destroyed before the registered function is called. 

4 Calling the function std::abort() declared in <cstdlib> terminates the program without executing destructors for 

Draft 


3.7 Storage duration Basic concepts 54 
objects of automatic or static storage duration and without calling the functions passed to std::atexit(). 

3.7 Storage duration [basic.stc] 
1 Storage duration is the property of an object that defines the minimum potential lifetime of the storage containing the 
object.The storage durationis determinedbythe constructusedto createtheobjectandisoneofthefollowing: 

— static storage duration 
— automatic storage duration 
— dynamic storage duration 
2 Static andautomatic storage durations are associated with objects introducedbydeclarations(3.1)and implicitly created 
bythe implementation(12.2). Thedynamicstoragedurationis associated with objects created with operator new 
(5.3.4). 
3 The storage class specifiers static and auto are related to storage duration as described below. 
4 The storage duration categories apply to references as well. The lifetime of a reference is its storage duration. 

3.7.1 Static storage duration [basic.stc.static] 
1 All objects whichneitherhave dynamic storage duration nor are localhave static storage duration. Thestorage for these 
objects shall last for thedurationof the program(3.6.2, 3.6.3). 

2 If an object of static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if 
it appears to be unused, except that a class object or its copymay be eliminated as specified in 12.8. 

3 The keyword static can be used to declare a local variable with static storage duration. [Note: 6.7 describes the 
initialization of local static variables; 3.6.3 describes the destruction oflocal static variables. — end note ] 

4 Thekeyword static appliedtoaclassdata memberinaclass definitiongivesthedata member static storageduration. 

3.7.2 Automatic storage duration [basic.stc.auto] 
1 Local objectsexplicitly declared auto or register or notexplicitly declared static or extern have automatic storage 
duration. The storage for these objects lasts until the block in which they are created exits. 

2 [Note: these objects are initialized and destroyed as described in 6.7. — end note ] 

3 If a named automatic object has initialization or a destructor with side effects, it shallnot be destroyed before the end 
ofitsblock,norshallitbe eliminatedasan optimizationevenifit appearstobeunused,exceptthataclassobjectorits 
copymay be eliminated as specified in 12.8. 

3.7.3 Dynamic storage duration [basic.stc.dynamic] 
1 Objects can be created dynamically during program execution(1.9), using new-expressions(5.3.4), and destroyed using 
delete-expressions(5.3.5).AC++implementation provides access to, and management of, dynamic storage via the global 
allocation functions operator new and operator new[] and the global deallocation functions operator delete 
and operator delete[]. 

2 The library providesdefault definitions for the global allocation and deallocation functions. Some global allocation and 
deallocation functions are replaceable(18.4.1). AC++ program shall provide at most one definition of a replaceable 

Draft 


55 Basic concepts 3.7 Storage duration 

allocation or deallocation function. Any such function definition replaces the default version provided in the library 
(17.4.3.4). Thefollowingallocation and deallocation functions(18.4)are implicitly declaredin global scopein each 
translation unit of a program 

void* operator new(std::size _t) throw(std::bad_alloc);
void* operator new[](std::size_ t) throw(std::bad_alloc);
void operator delete ( void *) throw ();
void operator delete []( void *) throw ();


These implicit declarations introduce only the function names operator new, operator new[], operator delete, 
operator delete[].[Note: the implicit declarations do not introduce the names std, std::bad_alloc, and std 
::size_t, or anyother names that the library uses to declare these names. Thus, a new-expression, delete-expression 
or function call that refers to one of these functions without including the header <new> is well-formed. However, 
referring to std, std::bad_alloc, and std::size_t is ill-formed unless the name has been declared by including 
the appropriate header. — end note ]Allocation and/or deallocation functions can alsobedeclared and defined for any 
class(12.5). 

3 Anyallocationand/or deallocation functions definedinaC++program, includingthedefaultversionsinthe library,shall 
conform to the semantics specified in 3.7.3.1 and 3.7.3.2. 

3.7.3.1 Allocation functions [basic.stc.dynamic.allocation] 
1 An allocation function shall be a class member function or a global function; a program is ill-formed if an allocation 
functionis declaredinanamespacescopeotherthanglobalscopeor declaredstaticinglobalscope.The returntypeshall 
be void*. The first parameter shall have type std::size_t (18.1). The first parameter shall not have an associated 
default argument(8.3.6). Thevalueof the first parameter shallbe interpreted as the requested sizeof the allocation. 
An allocation function canbea function template. Sucha template shall declare its return type and firstparameter as 
specifiedabove(thatis,template parametertypesshallnotbeusedinthereturntypeandfirstparametertype).Template 
allocation functions shallhave two or more parameters. 

2 The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall return the 
address of the start of a block of storage whose length in bytes shall be at least as large as the requested size. There are 
no constraints on the contents of the allocated storage on return from the allocation function. The order, contiguity, and 
initial value of storage allocated by successive calls to an allocation function is unspecified. The pointer returned shall 
be suitablyalignedsothatitcanbeconvertedtoapointerofanycompleteobjecttypeandthenusedto accesstheobject 
or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation 
function).Evenifthesizeofthespacerequestediszero,therequestcanfail.Iftherequest succeeds,thevalue returned 
shallbea non-nullpointervalue(4.10)p0 different from anypreviously returned value p1, unless that value p1 was 
subsequently passed to an operator delete. The effect of dereferencing a pointer returned as a request for zero size 
is undefined.37) 

3 An allocation function thatfails to allocate storage can invoke the currently installed new-handler function(18.4.2.2), 
if any.[Note: Aprogram-supplied allocation function can obtain the address of the currently installednew_handler 
using the std::set_new_handler function(18.4.2.3). — end note ]If an allocation function declared with an empty 
exception-specification (15.4), throw(), fails to allocate storage, it shall return a null pointer. Any other allocation 
function thatfailsto allocate storage shallonly indicatefailureby throwinganexceptionof class std::bad_alloc 
(18.4.2.1)or a class derived from std::bad_alloc. 

37) The intent is to have operator new() implementable by calling std::malloc() or std::calloc(), so the rules are substantially the same. 
C++differs fromCin requiringa zero requestto returna non-null pointer. 

Draft 


3.8 Object Lifetime Basic concepts 56 
4 Aglobal allocation function is only called as the result of a new expression(5.3.4), or called directly using the function 
call syntax(5.2.2), or called indirectly through callsto the functionsin theC++ standard library.[ Note: in particular, a 
global allocation function is not called to allocate storage for objects with static storage duration(3.7.1), for objects of 
type std::type_info (5.2.8), for the copyof an object thrown by a throw expression(15.1). — end note ] 

3.7.3.2 Deallocation functions [basic.stc.dynamic.deallocation] 
1 Deallocation functions shall be class member functions or global functions; a program is ill-formed if deallocation 
functions are declared in a namespace scope other than global scope or declared static in global scope. 

2 Each deallocation function shall return void and its first parameter shall be void*. Adeallocation function can have 
more than one parameter. If a class T has a member deallocation function named operator delete with exactly 
one parameter, then that function is a usual (non-placement) deallocation function. If class T does not declare such 
an operator delete but does declare a member deallocation function named operator delete with exactly two 
parameters, the second of which has type std::size_t (18.1), then this function is a usual deallocation function. 
Similarly,ifa class T hasa member deallocation function named operator delete[] withexactly one parameter, then 
thatfunctionisa usual(non-placement) deallocation function.If class T does not declare such an operator delete[] 
but does declare a member deallocation function namedoperator delete[] with exactly two parameters, the second 
of which has type std::size_t,then this function is a usual deallocation function. Adeallocation function can be an 
instance of a function template. Neither the first parameter nor the return type shall depend on a template parameter. 
[Note: that is, a deallocation function template shall have a first parameter of type void* and a return type of void (as 
specified above). — end note ]Adeallocation function template shallhavetwoor more functionparameters.Atemplate 
instance is never a usual deallocation function, regardless of its signature. 

3 The value of the first argument supplied to one of thea deallocation functions provided in the standard library may 
be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call to the 
deallocation function has no effect. Otherwise, the value supplied to operator delete(void*) in the standard library shallbe oneofthevalues returnedbyapreviousinvocationof either operator new(std::size_t) or operator new(std::size_t, const std::nothrow_t&) in the standard library, and the value supplied to operator 
delete[](void*) in the standard library shall be one of the values returned by a previous invocation of either operator new[](std::size_t) or operator new[](std::size_t, const std::nothrow_t&) in the standard library. 

4 Iftheargumentgiventoadeallocation functioninthe standardlibraryisapointerthatisnotthenullpointervalue(4.10), 
the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid all pointers referring 
to anypart of the deallocated storage. The effect of using an invalid pointer value (including passing it to a deallocation 
function) is undefined.38) 

3.7.4 Duration of subobjects [basic.stc.inherit] 
1 The storage duration of member subobjects, base class subobjects and array elements is that of their complete object 
(1.8). 

3.8 Object Lifetime [basic.life] 
1 The lifetime of an object is a runtime property of the object. The lifetime of an object of type T begins when: 

— storage with the proper alignment and size for type T is obtained, and 
38)On some implementations,it causesa system-generated runtimefault. 

Draft 


57 Basic concepts 3.8 Object Lifetime 

— if T isaclasstypeandthe constructorinvokedto createtheobjectis non-trivial(12.1),the constructorcallhas 
completed. the initializationis complete.[ Note: the initializationcanbeperformedbya constructorcallor,inthe 
case of an aggregate with an implicitly-declared non-trivial default constructor, an aggregate initialization 8.5.1. 
— end note ]
The lifetime of an object of type T ends when:
— if T isa class type witha non-trivial destructor(12.4), the destructor call starts, or 
— the storage which the objectoccupies is reused or released. 
2 [Note: the lifetimeof an array object orof anobjectofPOD type(3.9)starts as soon as storage with proper size and 
alignment is obtained, and its lifetime ends when the storage which the array or object occupies is reused or released. 

12.6.2 describes the lifetime of base and member subobjects. — end note ] 
3 The properties ascribedto objects throughoutthis International Standardapplyforagivenobjectonlyduringits lifetime. 
[Note: in particular, before the lifetime of an object starts and after its lifetime ends there are significant restrictions on 
the use ofthe object, as described below, in 12.6.2 and in 12.7. Also, the behavior of an object under construction and 
destruction might not be the same as the behavior of an object whose lifetime has started and not ended. 12.6.2 and 12.7 
describe the behavior of objects during the construction and destruction phases. — end note ] 

4 Aprogram may end the lifetime of anyobject by reusing the storage which the object occupies or by explicitly calling 
the destructor for an object of a class type with a non-trivial destructor. For an object of a class type with a non-trivial 
destructor,the programisnot requiredtocallthe destructorexplicitlybeforethe storagewhichtheobject occupiesis 
reused or released; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5)is not used 
to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects 
produced by the destructor has undefined behavior. 

5 Before the lifetime of an objecthas startedbut after the storage which the object will occupyhas been allocated39) or, 
after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any 
pointerthatreferstothestorage locationwheretheobjectwillbeorwas locatedmaybeusedbutonlyinlimitedways. 
Sucha pointer refersto allocated storage(3.7.3.2),andusingthe pointerasifthepointer wereoftype void*, is well-
defined. Sucha pointermaybe dereferencedbutthe resultinglvaluemayonlybeusedin limitedways,as described 
below. If the object will be or was of a class type with a non-trivial destructor, and the pointer is used as the operand 
of a delete-expression, the program has undefined behavior. If the object will be or was of a non-POD class type, the 
program has undefined behavior if: 

— the pointer is used to access a non-static data member or call a non-static member function of the object, or 
— thepointeris implicitlyconverted(4.10)toapointertoabaseclasstype,or 
— the pointerisusedastheoperandofa static_cast (5.2.9)(except whenthe conversionistovoid*, or tovoid* 
and subsequently to char*, or unsigned char* ). 
— the pointer is used as the operand of a dynamic_cast (5.2.7).[Example: 
# include < cstdlib > 

struct B {
virtual void f();


39)Forexample, before the constructionofa global objectof non-POD class type(12.7). 

Draft 


3.8 Object Lifetime Basic concepts 58 
void mutate ();
virtual ~B();
};


struct D1 : B { void f(); };
struct D2 : B { void f(); };


void B::mutate() { 
new (this) D2; // reuses storage — ends the lifetime of *this 
f (); // undefined behavior 
... = this; // OK, this points to valid memory 

} 

void g() { 
void* p = std::malloc(sizeof(D1) + sizeof(D2)); 
B* pb = new (p) D1; 
pb -> mutate (); 
&pb ; // OK: pb points to valid memory 
void* q = pb; // OK: pb points to valid memory 
pb ->f (); // undefined behavior, lifetime of *pb has ended 

} 

— end example ] 
6 Similarly,beforethelifetimeofanobjecthasstartedbutafterthestoragewhichtheobjectwilloccupyhasbeenallocated 
or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any 
lvaluewhichreferstotheoriginalobjectmaybeusedbutonlyin limitedways.Suchanlvaluereferstoallocatedstorage 
(3.7.3.2), and using the properties of the lvalue which do not depend on its value is well-defined. If an lvalue-to-rvalue 
conversion(4.1)isappliedtosuchanlvalue,theprogramhas undefinedbehavior;iftheoriginalobjectwillbeorwas 
ofa non-POD class type, theprogram has undefined behavior if: 

— the lvalue is used to access a non-static data member or call a non-static member function of the object, or 
— thelvalueis implicitlyconverted(4.10)toa referencetoabaseclasstype,or 
— the lvalue is used as the operand of a static_cast (5.2.9)except when the conversion is ultimately to cv char& 
or cv unsigned char& ), or 
— the lvalue is used as the operand of a dynamic_cast (5.2.7)or as the operand of typeid. 
7 If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new 
objectis createdatthestoragelocationwhichtheoriginalobjectoccupied,apointerthatpointedtotheoriginalobject,a 
referencethat referredtothe originalobject,orthe nameofthe originalobjectwill automaticallyrefertothenewobject 
and, once the lifetime of the new object has started, can be used to manipulate the new object, if: 

— the storage for the new object exactly overlays the storage location which the originalobject occupied, and 
— the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and 
— the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data 
member whose type is const-qualified or a reference type, and 
Draft 


59 Basic concepts 3.8 Object Lifetime 

— the original objectwasamost derived object(1.8)of typeT and the new object is a most derived object of type T 
(thatis,they arenotbaseclass subobjects).[ Example: 
struct C { 

int i; 

void f (); 

const C & operator =( const C & ); 

}; 

const C& C::operator= ( const C& other) 

{ 

if ( this != &other ) { 

this -> ~C(); // lifetime of *this ends 

new (this) C(other); // new object of type C created 

f (); // well-defined 

} 

return * this ; 

} 

C c1;
C c2;
c1 = c2; // well-defined
c1.f (); // well-defined; c1 refers to a new object of type C


— end example ] 
8 If a program ends the lifetime of an object of type T with static(3.7.1)or automatic(3.7.2)storage duration and ifT 
has a non-trivial destructor,40) the program must ensure that an object of the original type occupies that same storage 
location when the implicit destructor call takes place; otherwise the behavior ofthe program is undefined. This is true 
evenif the blockisexited with anexception.[ Example: 

class T {}; 

struct B { 

~B (); 

}; 

void h() { 

B b; 

new (&b) T; 

} // undefined behavior at blockexit 

— end example ] 
9 Creating a new object at the storage location that a const object with static or automatic storage duration occupies or, 
at the storage location that such a const object used to occupybefore its lifetime ended results in undefined behavior. 
[Example: 

struct B {
B ();


40) that is, an object for which a destructor will be called implicitly–either either upon exit from the block for an object with automatic storage 
duration or upon exit from the program for an object with static storage duration. 

Draft 


3.9 Types Basic concepts 60 
~B ();
};


const B b; 

void h() { 

b. ~ B (); 
new (&b) const B; // undefined behavior
}


— end example ] 
3.9 Types [basic.types] 
1[Note: 3.9 and the subclauses thereof impose requirements on implementations regarding the representation of types. 
There aretwo kindsof types: fundamental typesand compound types.Types describe objects(1.8), references(8.3.2), 
or functions(8.3.5). — end note ] 

2Foranyobject(otherthana base-class subobject)ofPODtypeT, whetherornottheobjectholdsavalidvalueoftype T, 
the underlying bytes(1.7)making up the object can be copied into an array ofchar or unsigned char.41) If the content 
of the array of char or unsigned char is copied back into the object, the object shall subsequently hold its original 
value.[Example: 

#define N sizeof(T) 

char buf[N]; 

T obj ; // obj initialized to its original value 

std::memcpy(buf, &obj, N); // between these two calls to std::memcpy, 

// obj might be modified
std::memcpy(&obj, buf, N); // at this point, eachsubobject of obj of scalar type
// holds its original value


— end example ] 
3 For anyPOD typeT, if two pointers to T point to distinct T objects obj1 and obj2, where neither obj1 nor obj2 is 
a base-class subobject, if the value of obj1 is copied into obj2, using the std::memcpy library function, obj2 shall 
subsequently hold the same value as obj1.[ Example: 

T* t1p;
T* t2p;
// provided that t2p points to an initialized object ...
std::memcpy(t1p, t2p, sizeof(T)); // at this point, every subobject of POD type in *t1p contains
// the same value as the corresponding subobject in *t2p


— end example ] 
4 The object representation of an object of type T is the sequence of Nunsigned char objects taken up by the object of 
type T, where Nequals sizeof(T). The value representation of an object is the set of bits that hold the value of type T. 

41)By using, forexample, the library functions(17.4.1.2)std::memcpy or std::memmove. 

Draft 


61 Basic concepts 3.9 Types 

For POD types, the value representation is a set of bits in the object representation that determines avalue, which is one 
discrete element of an implementation-defined set of values.42) 

5 Object types have alignment requirements (3.9.1, 3.9.2). The alignment ofa complete object typeis an implementation-
defined integer value representing a number of bytes; an object is allocated at an address that meets the alignment 
requirementsof its objecttype. 

6 A class that has been declared but not defined, or an array of unknown size or of incomplete element type, is an 
incompletely-defined object type.43) Incompletely-defined object types and thevoid types are incompletetypes(3.9.1). 
Objects shall not be defined to have an incomplete type. 

7 Aclass type (such as “class X”) might be incomplete at one point in a translation unit and complete later on; the type 
“class X” isthe same type at both points. The declared type of an array object might be an array of incomplete class 
type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes 
complete; the array type at those two points is the same type. The declared type of an array object might be an array 
of unknown size and therefore be incomplete at one point in a translation unit and complete later on; the array types at 
those two points (“array of unknown bound of T” and “arrayofN T”) are different types. The type of a pointer to array 
of unknown size, or of a type defined by a typedef declaration to be an array of unknown size, cannot be completed. 
[Example: 

class X; // X is an incomplete type
extern X* xp; // xp is a pointer to an incomplete type
extern int arr []; // the type of arr is incomplete
typedef int UNKA []; // UNKA is an incomplete type
UNKA * arrp ; // arrp is a pointer to an incomplete type
UNKA ** arrpp ;


void foo () 

{
xp ++; // ill-formed: X is incomplete
arrp ++; // ill-formed: incomplete type
arrpp ++; // OK: sizeof UNKA* is known


} 

struct X { int i; }; // now X is a complete type
int arr [10]; // now the type of arr is complete


X x;
void bar ()
{


xp =&x; // OK; type is “pointer to X”
arrp = &arr; // ill-formed: different types
xp ++; // OK: X is complete
arrp ++; // ill-formed: UNKA can’tbe completed


} 

— end example ] 
42) The intentis that the memory modelofC++is compatible with that of ISO/IEC 9899 Programming Language C.
43) The size and layoutof an instanceof an incompletely-defined object typeis unknown.


Draft 


3.9 Types Basic concepts 62 
8[Note: the rules for declarations and expressions describe in which contexts incomplete types are prohibited. — end 
note ] 

9 An object type is a (possibly cv-qualified) type that is not a function type, not a reference type, and not a void type. 

10 Arithmetic types(3.9.1),enumeration types, pointer types, and pointer to member types(3.9.2),andcv-qualified versions 
of these types(3.9.3)are collectively called scalar types. Scalar types, POD-struct types, POD-union types (clause 9), 
arrays of such types and cv-qualified versionsof these types(3.9.3)are collectively called POD types. 

11 If two types T1 and T2 are the same type, then T1 and T2 are layout-compatible types. [Note: Layout-compatible 
enumerations are described in 7.2. Layout-compatible POD-structs and POD-unions are described in 9.2. — end note ] 

3.9.1 Fundamental types [basic.fundamental] 
1 Objects declared as characters(char)shall be large enough to store anymember of the implementation’s basic character 
set. If a character from this set is stored in a character object, the integral value of that character object is equal to the 
value of the single character literal form of that character. It is implementation-defined whether a char object canhold 
negativevalues. Characters canbeexplicitly declared unsigned or signed. Plain char, signed char, and unsigned 
char are three distinct types. A char,a signed char, and an unsigned char occupythe same amount ofstorage 
andhavethe same alignment requirements(3.9); thatis,theyhavethe same object representation.For character types, 
all bitsof the object representation participatein thevalue representation.For unsigned character types, all possible bit 
patternsofthevalue representation represent numbers. These requirementsdonotholdforothertypes.Inanyparticular 
implementation, a plain char object can take on either the same values as a signed char or an unsigned char; 
which one is implementation-defined. 

2 There are fourfive signed integer types :“signed char”, “short int”,“int”, and “long int”.,and “long long int”. 
Inthislist,eachtypeprovidesatleastasmuchstorageasthose precedingitinthelist. Plain ints have the natural size 
suggestedbythe architectureoftheexecutionenvironment44);theothersignedintegertypesareprovidedtomeetspecial 
needs. 

3 For each of the signed integer types, there exists a corresponding (but different) unsigned integer type:“unsigned 
char”, “unsigned short int”, “unsigned int”, and“unsigned long int”, and “unsigned long long int”, 
each of which occupies the same amount of storage and has the same alignment requirements(3.9)as the corresponding 
signed integertype45);that is, each signed integer type has the same object representation as its corresponding unsigned 
integer type. The range of nonnegative values of a signed integer type is a subrange of the corresponding unsigned 
integer type, and the value representation of each corresponding signed/unsigned type shall be the same. 

4 Unsigned integers, declared unsigned, shallobeythelawsof arithmetic modulo2n where n is the number of bits in the 
value representation of that particular size of integer.46) 

5 Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest extended 
character set specified among the supported locales(22.1.1).Type wchar_t shall have the same size, signedness, and 
alignment requirements(3.9)asoneoftheotherintegraltypes,calledits underlying type. 

6 Values of typebool are either true or false.47)[Note: there are no signed, unsigned, short, or long bool types 

44) that is, large enough to contain anyvalue in the range of INT_MIN and INT_MAX, as defined in the header <climits>.
45) See 7.1.5.2 regarding the correspondence between types and the sequences of type-specifiers that designate them.
46) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is


reduced modulo the number thatis one greater than the largestvalue that canbe representedby the resulting unsigned integer type. 
47) Usinga bool valueinways describedby this International Standardas “undefined,” suchasbyexaminingthevalueofan uninitialized automatic 

variable, might cause it to behave as if it is neither true nor false. 

Draft 


63 Basic concepts 3.9 Types 

or values. — end note ]As described below,bool values behave as integral types. Values of type bool participate in 
integral promotions(4.5). 

7 Types bool, char, wchar_t, and the signed and unsigned integer types are collectively called integral types.48) A 
synonym for integral type is integer type. The representationsof integral types shall definevaluesby useofapure 
binary numeration system.49) [Example: this International Standard permits 2’s complement, 1’s complement and 
signed magnitude representations for integral types. — end example ] 

8 There are three floating point types: float, double, and long double. The type double provides at least as much 
precision as float, and the type long double provides at least as much precision as double. The set of values of the 
type float is a subset of the set of values ofthe type double;the set of values of the typedouble is a subset of the set 
of values of the type long double. Thevalue representationof floating-point typesis implementation-defined. Integral 
and floating types are collectively called arithmetic types. Specializations of the standard template std::numeric_
limits (18.2)shall specify the maximum and minimum values of each arithmetic type for an implementation. 

9 The void type has an empty set of values. The void type is an incomplete type that cannot be completed. It is used as 
thereturntypefor functionsthatdonot returnavalue.Anyexpressioncanbeexplicitlyconvertedtotype cv void (5.4). 
An expression of type void shallbe usedonlyasanexpression statement(6.2),asan operandofa commaexpression 
(5.18), as a second or third operand of ?: (5.16), as the operand of typeid, or as the expression in a return statement 
(6.6.3)for a function with the return typevoid. 

10 [Note: even if the implementation defines two or more basic types to have the same value representation, they are 
nevertheless different types. — end note ] 

3.9.2 Compound types [basic.compound] 
1 Compound types can be constructed in the following ways: 

— arrays of objects of a given type, 8.3.4; 
— functions, which have parameters of given types and return void or references or objects of a given type, 8.3.5; 
— pointers to void or objects or functions (includingstatic members of classes) of a given type, 8.3.1; 
— references to objects or functionsofagiven type, 8.3.2; 
— classes containinga sequenceofobjectsofvarioustypes(clause 9),asetoftypes, enumerationsandfunctionsfor 
manipulating these objects(9.3),andasetof restrictionsonthe accessto these entities (clause 11); 
— unions, which are classes capable of containing objects of different types at different times, 9.5; 
— enumerations, which comprise a set of named constant values. Each distinct enumeration constitutes a different 
enumerated type, 7.2; 
— pointers to non-static 50) class members, which identify members of a given type within objects of a given class, 
8.3.3. 
48) Therefore, enumerations(7.2)are not integral;however, enumerations canbe promotedto int, unsigned int, long, or unsigned long,integral types as specified in 4.5. 

49)Apositionalrepresentationforintegersthat usesthebinarydigits0and1,inwhichthevalues representedby successivebitsare additive,begin 

with1,andare multipliedbysuccessiveintegralpowerof2,exceptperhapsforthebitwiththehighest position. (Adaptedfromthe American National 

Dictionary for Information Processing Systems.) 

50) Static class members are objects or functions, and pointers to them are ordinary pointers to objects or functions. 

Draft 


3.9 Types Basic concepts 64 
2 These methods of constructing types can be applied recursively; restrictions are mentioned in 8.3.1, 8.3.4, 8.3.5, and 

8.3.2. 
3 Apointer to objects of typeT is referred to as a “pointer to T.”[ Example: a pointer to an object of type int is referred 
to as “pointer to int ” and a pointer to an object of class X is called a “pointer to X.” — end example ]Except for 
pointers to static members, text referring to “pointers” does not apply to pointers to members. Pointers to incomplete 
types are allowed although there are restrictions on what canbe done with them(3.9).Avalidvalueof an object pointer 
type represents either theaddressofabytein memory(1.7)ora null pointer(4.10). If an objectof type T is located 
at an address A, a pointer of type cv T* whose value is the address A is said to point to that object, regardless of how 
the value was obtained. [Note: for instance, the address one past the end of an array(5.7)would be considered to 
point to an unrelated object of the array’s element type that might be located at that address. — end note ]The value 
representationof pointer typesis implementation-defined. Pointersto cv-qualified and cv-unqualifiedversions(3.9.3) 
of layout-compatible typesshallhave the samevalue representation and alignmentrequirements(3.9). 

4 Objects of cv-qualified(3.9.3)or cv-unqualified typevoid* (pointertovoid), canbe usedto pointto objectsof unknown 
type. A void* shallbeabletoholdanyobjectpointer.Acv-qualifiedor cv-unqualified(3.9.3)void* shall have the 
same representation and alignment requirements as a cv-qualified or cv-unqualified char*. 

3.9.3 CV-qualifiers [basic.type.qualifier] 
1 Atype mentionedin3.9.1and 3.9.2isa cv-unqualified type. Eachtype whichisacv-unqualified completeor incomplete 
object typeor is void (3.9)hasthree corresponding cv-qualifiedversionsofitstype:aconst-qualified version,avolatilequalified version, and a const-volatile-qualified version. The term object type (1.8)includes the cv-qualifiers specified 
whentheobjectis created. The presenceofa const specifier ina decl-specifier-seq declares an object of const-qualified 
object type;such object is called aconst object. The presence of a volatile specifier in a decl-specifier-seq declares 
an object of volatile-qualified object type;such object is called avolatile object. The presence of both cv-qualifiers in a 
decl-specifier-seq declares an object of const-volatile-qualified object type;such object is called aconst volatile object. 
The cv-qualifiedor cv-unqualifiedversionsofatypeare distincttypes;however,theyshallhavethesame representation 
and alignment requirements(3.9).51) 

2Acompoundtype(3.9.2)isnot cv-qualifiedbythe cv-qualifiers(ifany)ofthetypesfromwhichitis compounded.Any 
cv-qualifiers appliedtoanarraytypeaffectthe array element type,notthe arraytype(8.3.4). 

3 Each non-static, non-mutable, non-reference data member of a const-qualified class object is const-qualified, each non-
static,non-referencedatamemberofavolatile-qualifiedclassobjectisvolatile-qualifiedandsimilarlyfor membersofa 
const-volatile class. See 8.3.5 and 9.3.2 regarding cv-qualified functiontypes. 

4 There is a (partial) ordering on cv-qualifiers, so that a type can be said to be more cv-qualified than another. Table7 
shows the relations that constitute this ordering. 

5 In this International Standard, the notation cv (or cv1, cv2, etc.), used in the description of types, represents an arbitrary 
set of cv-qualifiers, i.e., one of{const },{volatile },{const, volatile}, or the empty set. Cv-qualifiers applied to 
an array type attachto the underlying element type, so the notation “cv T,” where T is an array type, refers to an array 
whose elements are so-qualified. Such array types can be said to be more (or less) cv-qualified than other types based 

51) The same representation and alignment requirements are meant to imply interchangeability as arguments to functions, return values from functions, and members of unions. 

Draft 


65 Basic concepts 3.10 Lvalues andrvalues 

Table 7: relations onconst and volatile 

no cv-qualifier < const 
no cv-qualifier < volatile 
no cv-qualifier < const volatile 
const < const volatile 
volatile < const volatile 

on the cv-qualification of the underlying element types. 

3.10 Lvalues and rvalues [basic.lval] 
1 Every expression is either an lvalue or an rvalue. 

2 Anlvalue referstoanobjector function. Somervalueexpressions—thoseof (possiblycv-qualified) classorcv-qualified 
class typeor array type—also refer to objects.52) 

3[Note: somebuilt-in operators and function calls yieldlvalues.[ Example: if E is an expression of pointer type, then *E 
is an lvalue expression referring to the object or function to which E points. As another example, the function 

int& f(); 

yields an lvalue, so the call f() is an lvalue expression. — end example ] — end note ] 

4[Note: somebuilt-inoperatorsexpectlvalue operands.[ Example: built-in assignment operators all expect their left-
hand operands to be lvalues. — end example ]Otherbuilt-in operators yield rvalues, and someexpectthem.[Example: 
the unary and binary + operators expect rvalue arguments and yield rvalue results. — end example ]The discussion of 
eachbuilt-in operatorin clause 5indicates whetheritexpectslvalue operandsand whetherit yieldsanlvalue. — end 
note ] 

5 The result of calling a function that does not return a reference is an rvalue. User defined operators are functions, and 
whether such operators expect or yield lvalues is determined by their parameter and return types. 

6 Anexpressionwhichholdsa temporaryobject resultingfromacasttoa nonreferencetypeisanrvalue(this includesthe 
explicit creation of an object using functional notation(5.2.3)). 

7 Whenever an lvalue appears in a context where an rvalue is expected, the lvalue is converted to an rvalue; see 4.1, 4.2, 
and 4.3. 

8 The discussion of reference initialization in 8.5.3 and of temporaries in 12.2 indicates the behavior of lvalues and rvalues 
in other significant contexts. 

9 Class rvalues can have cv-qualified types; non-class rvalues always have cv-unqualified types. Rvalues shall always 
have complete types or the void type; in addition to these types, lvalues can also have incomplete types. 

10 An lvalue for an object is necessary in order to modify the object except that an rvalue of class type can also be used to 
modify its referent under certain circumstances.[ Example: a member function called for an object(9.3)can modify the 
object. — end example ] 

11 Functions cannotbe modified,but pointersto functions canbe modifiable. 

52) Expressions such as invocations of constructors and of functions that return a class type refer to objects, and the implementation can invoke a 
member function upon such objects,but theexpressions are notlvalues. 

Draft 


3.10 Lvalues and rvalues Basic concepts 66 
12 Apointer to an incomplete type can be modifiable. At some point in the program when the pointed to type is complete, 
the object at which the pointer points can also be modified. 

13 The referent of a const-qualified expression shall not be modified (through that expression), except that if it is of class 
type and has a mutable component, that component canbe modified(7.1.5.1). 

14 If an expression can be used to modify the object to which it refers, the expression is called modifiable.Aprogram that 
attempts to modify an objectthrough a nonmodifiable lvalue or rvalue expression is ill-formed. 

15 If a program attempts to access the stored value of an object through an lvalue of other than one of the following types 
the behavior is undefined53) 

— the dynamic type of the object, 
— a cv-qualified version of the dynamic type of the object, 
— a type similar (as defined in 4.4)to the dynamic type of the object, 
— a type that is the signed or unsigned type corresponding to the dynamic type of the object, 
— atypethatisthesignedor unsignedtype correspondingtoacv-qualifiedversionofthedynamictypeoftheobject, 
— an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), 
— a type that is a (possibly cv-qualified) base class type of the dynamic type of the object, 
— a char or unsigned char type. 
53) The intent of this list is to specify those circumstances in which an object may or may not be aliased. 
Draft 


Chapter4 Standard conversions [conv]


1 Standard conversions are implicit conversions definedforbuilt-in types. Clause 4enumerates the full set of such conversions.A standard conversion sequence is a sequence of standard conversions in the following order: 

— Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and 
function-to-pointer conversion. 
— Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, 
floating pointconversions, floating-integral conversions, pointer conversions, pointer to member conversions, and 
boolean conversions. 
— Zero or one qualification conversion. 
[Note: a standard conversion sequence can be empty,i.e., it can consist of no conversions. — end note ]A standard 
conversion sequence will be applied to an expression if necessary to convert it to a required destination type. 
2[Note: expressions with a given type will be implicitly converted to other types in several contexts: 

— When used as operands of operators. The operator’s requirements for its operands dictate the destination type 
(clause5). 
— When used in the condition of an if statement or iteration statement(6.4, 6.5). The destination typeis bool. 
— When used in the expression of a switch statement. The destination typeis integral(6.4). 
— Whenusedasthe sourceexpressionforan initialization(which includesuseasanargumentina functioncalland 
use astheexpressionina return statement). The type of the entity being initialized is (generally) the destination 
type. See 8.5, 8.5.3. 
— end note ] 
3 An expression e can be implicitly converted to a type T if and only if thedeclaration T t=e; is well-formed, for some 
invented temporary variable t (8.5). The effect of the implicit conversion is the same as performing the declaration 
and initialization and then using the temporary variable as the result of the conversion. The result is an lvalue if T is a 
referencetype(8.3.2), and an rvalue otherwise. Theexpression e is used as an lvalue if and only if the initialization uses 
it as an lvalue. 

4[Note: For user-defined types, user-defined conversions are considered as well; see12.3. In general, an implicit conversion sequence(13.3.3.1)consistsofa standard conversion sequence followedbya user-defined conversion followedby 
another standard conversion sequence. 

5 There are some contexts where certain conversions are suppressed. For example, the lvalue-to-rvalue conversion is not 
done on the operand of the unary & operator. Specific exceptions are given in the descriptions of those operators and 


4.1 Lvalue-to-rvalue conversion Standard conversions 68 
contexts. — end note ] 

4.1 Lvalue-to-rvalue conversion [conv.lval] 
1 Anlvalue(3.10)ofa non-function, non-array typeT can be converted to an rvalue. If T is an incomplete type,a program 
that necessitates this conversion is ill-formed. If the object to which the lvalue refers is not an object of type T and is 
not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has 
undefined behavior. If T isa non-class type, the typeof the rvalueis the cv-unqualifiedversionof T. Otherwise, the type 
of the rvalue is T.54) 

2 Thevalue containedintheobjectindicatedbythelvalue isthervalue result.Whenanlvalue-to-rvalueconversion occurs 
within the operand of sizeof (5.3.3)thevalue containedin the referenced objectis not accessed, since that operator 
does not evaluate its operand. Otherwise, if the lvalue has a class type, the conversion copy-initializes a temporary of 
type T from the lvalue and the result of the conversion is an rvalue for the temporary. Otherwise, the value contained in 
the object indicated by the lvalue is the rvalue result. 

3 [Note: See also 3.10. — end note ] 

4.2 Array-to-pointer conversion [conv.array] 
1 An lvalue or rvalue of type “array of NT” or “array of unknown bound of T” can be converted to an rvalue of type 
“pointer to T”. The result is a pointer to the first element of the array. 

2Astring literal(2.13.4)thatisnotawidestring literalcanbeconvertedtoanrvalueoftype“pointertochar”; a wide 
string literal can be converted to an rvalue of type “pointer to wchar_t”. In either case, the result is a pointer to the 
first element of the array. This conversion is considered only when there is an explicit appropriate pointer target type, 
andnotwhen thereisageneralneedto convertfromanlvaluetoanrvalue.[ Note: this conversion is deprecated. See 
Annex D. — end note ]For the purposeof rankinginoverload resolution(13.3.3.1.1), this conversionis considered 
an array-to-pointer conversion followedbya qualification conversion(4.4).[Example: "abc" is converted to “pointer 
to const char” as an array-to-pointer conversion, and then to “pointer to char” as a qualification conversion. — end 
example] 

4.3 Function-to-pointer conversion [conv.func] 
1 An lvalue of function type T canbe convertedtoanrvalueoftype “pointerto T .”The resultisapointertothefunction.55) 
2[Note: See 13.4 for additional rules for the case where the function is overloaded. — end note ] 

4.4 Qualification conversions [conv.qual] 
1 An rvalue of type “pointer to cv1 T ” can be converted to an rvalue of type “pointer to cv2 T ”if “cv2 T ” is more 
cv-qualified than “cv1 T .” 

2 An rvalue of type “pointer to member of X of type cv1 T ” can be converted to an rvalue of type “pointer to member of 
X of type cv2 T ”if “cv2 T ” is more cv-qualified than “cv1 T .” 

3[Note: Functiontypes (includingthoseusedinpointertomember functiontypes)arenever cv-qualified(8.3.5). — end 
note ] 

54) InC++classrvaluescanhavecv-qualifiedtypes(becausetheyareobjects).ThisdiffersfromISOC,inwhichnon-lvaluesneverhavecv-qualified 
types. 
55) This conversion never applies to non-static member functions because an lvalue that refers to a non-static member function cannot be obtained. 

Draft 


69 Standard conversions 4.4 Qualification conversions 

4 Aconversion can add cv-qualifiers at levels other than the first in multi-level pointers, subject to the following rules:56) 

Two pointer types T1 and T2 aresimilar if there exists a type T and integer n > 0such that: 

T1 is cv1,0 pointer to cv1,1 pointer to cv1,n-1 pointer to cv1,nT

··· 

and 

T2 is cv2,0 pointer to cv2,1 pointer to cv2,n-1 pointer to cv2,nT

··· 

where each cvi, j is const, volatile, const volatile, or nothing. The n-tuple of cv-qualifiers after the first 
in a pointer type, e.g., cv1,1, cv1,2, , cv1,n in the pointer type T1, is called the cv-qualification signature of the 

···

pointer type. An expression of type T1 can be converted to type T2 if and only if the following conditions are 
satisfied: 

— the pointer types are similar. 
— for every j> 0, if const is in cv1, jthen const is in cv2, j, and similarly for volatile. 
— if the cv1, jand cv2, j are different, then const is in every cv2,k for0 < k< j. 
[Note: if a program could assign a pointer of type T** to a pointer of type const T** (that is, if line //1 below was 
allowed), a program could inadvertently modify a const object (as it is done on line //2).For example, 

int main () {
const char c = ’c’;
char* pc;
const char** pcc = &pc; // 1: not allowed


*pcc = &c; 
*pc = ’C’; // 2: modifies a const object
}
— end note ] 
5 Amulti-level pointer to member type, or a multi-level mixed pointer and pointer to member type has the form: 

cv0P0 to cv1P1 to cvn-1Pn-1 to cvnT

··· 

where Pi is eithera pointer or pointerto member and where T is not a pointer type or pointer to member type. 

6 Two multi-level pointer to member types or two multi-level mixed pointer and pointer to member types T1 and T2 are 
similar if there exists a type T and integer n > 0such that: 

T1 is cv1,0P0 to cv1,1P1 to cv1,n-1Pn-1 to cv1,nT

··· 

and 

T2 is cv2,0P0 to cv2,1P1 to cv2,n-1Pn-1 to cv2,nT

··· 

7 For similar multi-level pointer to member types and similar multi-level mixed pointer and pointer to member types, the 
rules for adding cv-qualifiers are the same as those used for similar pointer types. 

56) These rules ensure that const-safetyis preservedby the conversion. 

Draft 


4.5 Integral promotions Standard conversions 70 
4.5 Integral promotions [conv.prom] 
1 An rvalue of type char, signed char, unsigned char, short int, or unsigned short int can be converted to 
an rvalue of type int if int rvalue can be converted to an rvalue of type int if int can represent all the values of the 
source type; otherwise, the source rvalue can be converted to an rvalue of type unsigned int. 

2 An rvalue of type wchar_t (3.9.1)can be converted to an rvalue of the first of the following types that can represent 
all the values of its underlying type: int, unsigned int, long, orint, unsigned long int, long long int, or 
unsigned long long int. An rvalue of an enumeration type(7.2)can be converted to an rvalue of the first of the 
followingtypesthatcan representallthevaluesofthe enumeration(i.e.thevaluesintherange bmin to bmax as described 
in 7.2: int, unsigned int, long, orint, unsigned long int, long long int, or unsigned long long int. 

3 An rvalue for an integral bit-field(9.6)can be converted to an rvalue of typeint if int can representallthevaluesofthe 
bit-field; otherwise, it can be converted to unsigned int if unsigned int can represent all the values of the bit-field. 
If the bit-field is larger yet, no integral promotion applies to it. If the bit-field has an enumerated type, it is treated as any 
other value of that type for promotion purposes. 

4 An rvalue of type bool can be converted to an rvalue of type int, with false becoming zero and true becoming one. 

5 These conversions are called integral promotions. 

4.6 Floating point promotion [conv.fpprom] 
1 An rvalue of type float canbe convertedtoanrvalueoftype double. The value is unchanged. 
2 This conversion is called floating point promotion. 

4.7 Integral conversions [conv.integral] 
1 An rvalue of an integer type can be converted to an rvalue of another integer type. An rvalue of an enumeration type can 
be convertedtoanrvalueofanintegertype. 

2 Ifthedestinationtypeis unsigned,the resultingvalueistheleast unsignedinteger congruenttothe sourceinteger(modulo2n where n isthe numberofbitsusedto representthe unsignedtype).[Note: In a two’s complement representation, 
this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). — end note ] 

3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field 
width); otherwise, the value is implementation-defined. 

4 If the destination type is bool, see 4.12. If the source type is bool, the value false is converted to zero and the value 
true is converted to one. 

5 The conversions allowed as integral promotions are excluded from the set of integral conversions. 

4.8 Floating point conversions [conv.double] 
1 An rvalue of floating point type can be converted to an rvalue of another floating point type. If the source value can be 
exactly represented in the destination type, the result of the conversion is that exact representation. If the source value 
is between two adjacent destination values, the result of the conversion is an implementation-defined choice of either of 
those values. Otherwise, the behavior is undefined. 

Draft 


71 Standard conversions 4.9 Floating-integral conversions 

2 The conversions allowed as floating point promotions are excluded from the set of floating point conversions. 

4.9 Floating-integral conversions [conv.fpint] 
1 An rvalue of a floating point type can be converted to an rvalue of an integer type. The conversion truncates; that is, 
the fractional part is discarded. The behavior is undefined if the truncated value cannotbe represented in the destination 
type.[ Note: If the destination type is bool, see 4.12. — end note ] 

2 An rvalue of an integer type or of an enumeration type can be converted to an rvalue of a floating point type. The result 
is exact if possible. Otherwise, it is an implementation-defined choice of either the next lower or higher representable 
value.[Note: loss of precision occurs if the integral value cannot be represented exactly as a value of the floating type. 

— end note ]If the source type isbool, the value false is converted to zero and the value true is converted to one. 
4.10 Pointer conversions [conv.ptr] 
1A null pointer constant isanintegral constant expression(5.19)rvalueofintegertypethatevaluatesto zero. Anull 
pointer constant can be converted to a pointer type; the result is the null pointer value of that type and is distinguishable 
from every other value of pointer to object or pointer to function type. Two nullpointer values of the same type shall 
compareequal.Theconversionofanullpointerconstanttoapointerto cv-qualifiedtypeisasingleconversion,andnot 
the sequenceofa pointer conversion followedbya qualification conversion(4.4). 

2 Anrvalueoftype “pointerto cv T ,” whereT is an object type, can be converted to an rvalue of type “pointer to cv void”. 
The result of converting a “pointer to cv T” to a “pointer to cv void” points to the start of the storage location where the 
object of type T resides, asif the objectisa most derived object(1.8)of typeT (that is, not a base class subobject). 

3 An rvalue of type “pointer to cv D”, where D is a class type, can be converted to an rvalue of type “pointer to cv B”, 
where B isa base class (clause 10)ofD. If B is an inaccessible (clause 11)or ambiguous(10.2)base class ofD,a program 
that necessitates this conversion is ill-formed. The result of the conversion is a pointer to the base class subobject of the 
derived class object. The null pointer value is converted to the null pointer value of the destination type. 

4.11 Pointer to member conversions [conv.mem] 
1 A null pointer constant(4.10)can be converted to a pointer to member type; the result is the null member pointer 
value ofthattypeandis distinguishablefromanypointerto membernot createdfromanull pointer constant.Twonull 
member pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to 
member of cv-qualified type is a single conversion, and not the sequence of a pointer to member conversion followed 
bya qualification conversion(4.4). 

2 An rvalue of type “pointer to member of B of type cv T”, where B is a class type, can be converted to an rvalue of type 
“pointer to member of D of type cv T”, where D is a derived class (clause 10)ofB. If B is an inaccessible (clause 11), 
ambiguous(10.2)or virtual(10.1)base class ofD, a program that necessitates this conversion is ill-formed. The result 
oftheconversion referstothe same memberasthepointerto member beforetheconversiontookplace,butit refersto 
the base class member as if it were a member of the derived class. The result refers to the member in D’s instance of B. 
Since the result has type “pointer to member of D of type cv T”, it can be dereferenced with a D object. The resultis the 
same as if the pointer to member of B were dereferenced with the B subobject of D.The null member pointer value is 

Draft 


4.12 Boolean conversions Standard conversions 72 
converted to the null member pointer value of the destination type.57) 

4.12 Boolean conversions [conv.bool] 
1 An rvalue of arithmetic, enumeration, pointer, or pointer to member type can be converted to an rvalue of type bool.A 
zero value, null pointer value, or null member pointer value is converted to false anyother value is converted to true. 

57) The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears inverted compared to 
the rule for pointers to objects (from pointer to derived to pointer to base)(4.10, clause 10). This inversion is necessary to ensure type safety. Note 
that a pointer to member is not a pointer to object or a pointer to function and the rules for conversions of such pointers do not apply to pointers to 
members. In particular, a pointer to member cannot be converted to a void*. 

Draft 


Chapter5 Expressions [expr]


1[Note: Clause5definesthe syntax, orderofevaluation,and meaningofexpressions. Anexpressionisasequenceof 
operators and operands that specifies a computation. An expression can result in a value and can cause side effects. 

2 Operatorscanbeoverloaded,thatis,givenmeaningwhenappliedtoexpressionsofclasstype(clause 9)or enumeration 
type(7.2).Usesofoverloaded operatorsare transformedinto functioncallsas describedin 13.5.Overloaded operators 
obeythe rulesfor syntax specifiedin clause 5,buttherequirementsofoperandtype,lvalue,andevaluation order are 
replaced by the rules for function call. Relations between operators, such as ++a meaning a+=1, are not guaranteed for 
overloaded operators(13.5), and are not guaranteed foroperandsof type bool. — end note ] 

3 Clause 5 defines the effects of operators when applied to types for which they have not been overloaded. Operator 
overloading shall not modify the rules for the built-in operators, that is, for operators applied to types for which theyare 
definedbythis Standard.However,thesebuilt-in operators participateinoverload resolution,andaspartofthat process 
user-defined conversionswillbe considered where necessaryto converttheoperandsto types appropriateforthebuiltin operator.Ifabuilt-in operatoris selected,suchconversionswillbeappliedtothe operands beforethe operationis 
consideredfurtheraccordingtotherulesinclause 5;see 13.3.1.2,13.6. 

4 Exceptwherenoted,theorderofevaluationof operandsofindividualoperatorsandsubexpressionsofindividualexpressions, and the order in which side effects take place, is unspecified.58) Between the previous and next sequence point a 
scalarobjectshallhaveitsstoredvalue modifiedatmostoncebytheevaluationofanexpression. Furthermore,theprior 
value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for 
each allowable orderingofthe subexpressionsofa fullexpression; otherwise the behavioris undefined.[ Example: 

i = v[i++]; // the behavior is undefined
i = 7, i++, i++; // i becomes 9


i =++i +1; // the behavior is undefined
i=i +1; // the value of i is incremented


— end example ] 
5 If during theevaluationof anexpression, the resultis not mathematically defined or notinthe rangeof representable 
valuesforitstype,thebehavioris undefined,unlesssuchanexpressionisaconstantexpressionappearswhereanintegral 
constantexpressionisrequired(5.19),inwhich casethe programis ill-formed.[Note: most existing implementations 
ofC++ignoreintegeroverflows.Treatmentofdivisionbyzero, forminga remainderusinga zerodivisor,andall floating 
point exceptions vary among machines, and is usually adjustable by a library function. — end note ] 

6 If an expression initially has the type “reference to T (8.3.2, 8.5.3), the type is adjusted to T prior to anyfurther analysis, 
theexpression designates the object or function denotedby the reference, and theexpressionis anlvalue. 

58) The precedenceof operatorsis not directly specified,butit canbe derived from the syntax. 


5.1 Primary expressions Expressions 74 
7 An expression designating an object is called an object-expression. 

8 Wheneveranlvalueexpression appearsasan operandofan operatorthatexpectsanrvalueforthatoperand,thelvalue-torvalue(4.1),array-to-pointer(4.2),or function-to-pointer(4.3)standardconversionsareappliedtoconverttheexpression 
to an rvalue. [Note: because cv-qualifiers are removed from the type of an expression of non-class type when the 
expression is converted to an rvalue, an lvalue expression of type const int can, forexample,be used where an rvalue 
expression of type int is required. — end note ] 

9 Manybinary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types 
in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the 
usual arithmetic conversions, which are defined as follows: 

— If either operand is of type long double, the other shall be converted to long double. 
— Otherwise, if either operand is double, the other shallbe convertedto double. 
— Otherwise, if either operand is float, the other shall be converted to float. 
— Otherwise, the integral promotions(4.5)shallbe performed on both operands.59) 
— Then if either operand is unsigned long long int, the other shall be converted to unsigned long long int. 
— Otherwise, if one operand is long long int and the other unsigned long int or unsigned int, then if a 
long long int can represent all the values of the unsigned operand type, the unsigned operand shall be converted to long long int;otherwise both operands shall be converted to unsigned long long int. 
— Otherwise, if either operand is long long int, the other shall be converted to long long int. 
— ThenOtherwise, if either operand is unsigned long the other shallbe convertedto unsigned long. 
— Otherwise, if one operand is a long int and the other unsigned int, then if a long int can represent all the 
values of an unsigned int, the unsigned int shall be converted to a long int otherwise both operands shall 
be converted to unsigned long int. 
— Otherwise, if either operand is long, the other shall be converted to long. 
— Otherwise, if either operand is unsigned, the other shall be converted to unsigned.
[Note: otherwise, the only remaining case is that both operands are int — end note ]
10 The values of the floating operands and the results of floating expressions may be represented in greater precision and 
range than that required by the type; the types are not changed thereby.60) 

5.1 Primary expressions [expr.prim] 
1 Primary expressions are literals, names, and names qualified by the scope resolution operator ::. 

59) As a consequence, operands of type bool, wchar_t, or an enumerated type are converted to some integral type.
60) The cast and assignment operators must still perform their specific conversions as described in 5.4, 5.2.9 and 5.17.


Draft 


75 Expressions 5.1 Primary expressions 

primary-expression:
literal


this
( expression )
id-expression


id-expression:
unqualified-id
qualified-id


unqualified-id:
identifier
operator-function-id
conversion-function-id
~ class-name
template-id


2Aliteral isaprimaryexpression. Itstypedependsonitsform(2.13).Astring literalisanlvalue;allother literalsare 
rvalues. 

3 Thekeyword this namesapointertotheobjectforwhichanon-staticmember function(9.3.2)isinvoked.Thekeyword 
this shallbeusedonly insideanon-staticclassmember functionbody(9.3)orina constructormem-initializer (12.6.2). 
Thetypeoftheexpressionisapointertothe function’sclass(9.3.2),possiblywithcv-qualifiersontheclasstype.The 
expression is an rvalue. 

4 The operator :: followed by an identifier,a qualified-id, or an operator-function-id is a primary-expression. Its type 
is specified by the declaration of the identifier, qualified-id, or operator-function-id. The result is the entity denoted by 
the identifier, qualified-id, or operator-function-id. The result is an lvalue if the entity is a function or variable. The 
identifier, qualified-id, or operator-function-id shall have global namespace scope or be visible in global scope because 
of a using-directive (7.3.4).[Note: the use of :: allows a type, an object, a function, an enumerator, or a namespace 
declaredintheglobal namespacetobe referredtoevenifits identifierhasbeenhidden(3.4.3). — end note ] 

5 Aparenthesized expression is a primary expression whose type and value are identical to those of the enclosed expression. The presenceof parentheses does notaffectwhether theexpressionis anlvalue. The parenthesizedexpression can 
be used in exactly the same contexts as those where the enclosed expression can be used, and with the same meaning, 
except as otherwise indicated. 

6 An id-expression is a restricted form of a primary-expression.[Note: an id-expression can appear after . and -> 
operators(5.2.5). — end note ] 

7 An identifier is an id-expression providedit has been suitablydeclared (clause 7).[Note: for operator-function-ids, 
see 13.5; for conversion-function-ids, see 12.3.2; for template-ids, see 14.2. A class-name prefixed by ~ denotes a 
destructor;see 12.4.Withinthe definitionofa non-static member function,an identifier that namesa non-static member 
is transformedtoa class member accessexpression(9.3.1). — end note ]The type of the expression is the type of the 
identifier. The result is the entity denoted by the identifier. The result is an lvalue if the entity is a function, variable, or 
data member. 

qualified-id:
::opt nested-name-specifier templateopt unqualified-id
:: identifier
:: operator-function-id
:: template-id


Draft 


5.2 Postfix expressions Expressions 76 
nested-name-specifier:
type-name ::
namespace-name ::
nested-name-specifier identifier ::
nested-name-specifier templateopt template-id ::


Anested-name-specifier that namesa class, optionally followedby thekeyword template (14.2), and then followedby 
the nameofa memberof either that class(9.2)or oneof its base classes (clause 10),isa qualified-id;3.4.3.1 describes 
name lookupfor class members thatappearin qualified-ids. The result is the member. The type of the result is the 
typeof the member. The resultis anlvalueif thememberisa static member function ora data member.[ Note: a class 
member can be referred to using a qualified-id at anypoint in its potential scope(3.3.6). — end note ]Whereclassname :: class-name is used, and the two class-names refer to the same class, this notation names the constructor(12.1). 
Where class-name ::~ class-name is used, the two class-names shall refer to the same class; this notation names the 
destructor(12.4).[Note: a typedef-name that names a class is a class-name (9.1). — end note ] 

8Anested-name-specifier that namesa namespace(7.3), followedby the nameofa memberof that namespace(or the 
name of a member of a namespace made visible by a using-directive )isaqualified-id;3.4.3.2 describes name lookup 
for namespace members that appear in qualified-ids.The resultisthe member.Thetypeofthe resultisthetypeofthe 
member. The result is an lvalue if the member is a function or a variable. 

9 Ina qualified-id,if theid-expression isa conversion-function-id,itsconversion-type-id shall denote the same type in both 
the context in which the entire qualified-id occurs andin the contextof theclass denotedby the nested-name-specifier. 

10 An id-expression that denotesa non-staticdata member or non-static member functionofa class can onlybe used: 

— aspartofa class member access(5.2.5)in whichthe object-expression referstothe member’sclassora class 
derived from that class, or 
— toforma pointerto member(5.3.1),or 
— in the bodyofa non-staticmember functionof that class orofa class derived fromthat class(9.3.1), or 
— ina mem-initializer fora constructor for that class or fora class derived from that class(12.6.2). 
5.2 Postfix expressions [expr.post] 
1 Postfix expressions group left-to-right. 

Draft 


77 Expressions 5.2 Postfix expressions 

postfix-expression:
primary-expression
postfix-expression [ expression ]
postfix-expression ( expression-listopt )
simple-type-specifier ( expression-listopt )
typename-specifier ( expression-listopt )
postfix-expression . templateopt id-expression
postfix-expression -> templateopt id-expression
postfix-expression . pseudo-destructor-name
postfix-expression -> pseudo-destructor-name
postfix-expression ++
postfix-expression -
dynamic_cast < type-id >( expression )
static_cast < type-id >( expression )
reinterpret_cast < type-id >( expression )
const_cast < type-id >( expression )
typeid ( expression )
typeid ( type-id )


expression-list:
assignment-expression
expression-list , assignment-expression


pseudo-destructor-name:
::opt nested-name-specifieropt type-name :: ~ type-name
::opt nested-name-specifier template template-id :: ~ type-name
::opt nested-name-specifieropt ~ type-name


5.2.1 Subscripting [expr.sub] 
1 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions 
shall have the type “pointer to T and the other shall have enumeration or integral type. The result is an lvalue of type 
“T.” The type “T” shall be a completely-defined object type.61) The expression E1[E2] is identical (by definition) to 
*((E1)+(E2)) [Note: see 5.3 and 5.7 for details of * and + and 8.3.4 for details of arrays. — end note ] 

5.2.2 Function call [expr.call] 
1 Therearetwokindsof functioncall: ordinary functioncallandmemberfunction62)(9.3)call.Afunctioncallisapostfix 
expression followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute 
theargumentstothe function.Foranordinary functioncall,thepostfixexpressionshallbeeitheranlvaluethatrefersto 
a function (in which case the function-to-pointer standard conversion(4.3)is suppressed on the postfix expression), or it 
shallhavepointerto functiontype.Callinga functionthroughanexpressionwhose functiontypehasalanguagelinkage 
thatis different from the language linkageof the function typeof the called function’s definitionis undefined(7.5).For 
a member function call, the postfixexpressionshallbe an implicit(9.3.1, 9.4)orexplicit class member access(5.2.5) 
whose id-expression isa function member name,orapointer-to-memberexpression(5.5)selectinga function member. 
Thefirstexpressioninthepostfixexpressionisthen calledthe objectexpression,andthecallisasa memberoftheobject 
pointedtoorreferredto.Inthecaseofanimplicitclassmember access,theimpliedobjectistheonepointedtoby this 
[Note: a member function call of the form f() is interpretedas (*this).f() (see 9.3.1). — end note ]If a function or 
member function nameis used, the name canbeoverloaded(clause 13),in which case the appropriate functionshallbe 

61) This is true even if the subscript operator is used in the following common idiom: &x[0].
62)Astatic member function(9.4)is an ordinary function.


Draft 


5.2 Postfix expressions Expressions 78 
selected according to the rules in 13.3. The function called in a member function call is normally selected according to 
the static typeof the objectexpression(clause 10),butif that functionis virtual and is not specified using a qualified-
id thenthe functionactuallycalledwillbethefinaloverrider(10.3)oftheselected functioninthedynamictypeofthe 
object expression[ Note: the dynamic type is the type of the object pointed or referred to by the current value of the 
object expression. 12.7 describes the behavior of virtual function calls when the object-expression refers to an object 
under construction or destruction. — end note ] 

2[Note: ifa function or member function nameis used, and name lookup(3.4)does not findadeclarationof that name, 
the programis ill-formed.No functionis implicitly declaredby sucha call. — end note ] 

3 Thetypeofthe functioncallexpressionisthe returntypeofthe statically chosenfunction(i.e., ignoringthe virtual 
keyword), even if the type of the function actually called is different. This type shall be a complete object type, a 
reference type or the type void. 

4 Whena functionis called,each parameter(8.3.5)shallbe initialized(8.5,12.8,12.1)withits correspondingargument.If 
the functionisa non-static member function,the this parameterofthe function(9.3.2)shallbeinitializedwitha pointer 
to the objectof the call, converted asifby anexplicit type conversion(5.4).[Note: There is no access or ambiguity 
checking on this conversion; the access checking and disambiguation are done as part of the (possibly implicit) class 
member access operator. See 10.2, 11.2, and 5.2.5. — end note ]When a function is called, the parameters that have 
object type shall have completely-defined object type.[ Note: this still allows a parameter to be a pointer or reference 
to an incomplete class type. However, it prevents a passed-by-value parameter to have an incomplete class type. — end 
note ]Duringthe initializationofaparameter,an implementationmayavoidthe constructionofextra temporariesby 
combining the conversions on the associated argument and/or the construction of temporaries with the initialization 
of the parameter (see 12.2). The lifetime of a parameter ends when the function in which it is defined returns. The 
initializationand destructionofeach parameter occurswithinthecontextofthecalling function.[ Example: the access of 
the constructor, conversion functions or destructor is checked at the point of call in the calling function. If a constructor 
or destructor for a function parameter throws an exception, the search for a handler starts in the scope of the calling 
function; in particular, if the function called has a function-try-block (clause15)withahandler that could handle the 
exception, this handler is not considered. — end example ]The value of a function call is the value returned by the 
called functionexceptina virtual functioncallifthe returntypeofthefinaloverriderisdifferentfromthe returntypeof 
the statically chosen function, the value returned from the final overrider is converted to the return type of the statically 
chosen function. 

5[Note: a function can changethevaluesofits non-const parameters,but these changes cannotaffectthevaluesofthe 
argumentsexcept wherea parameterisofa referencetype(8.3.2);ifthe referenceistoa const-qualified type, const_
cast is required to be used to cast away the constness in order to modify the argument’s value. Where a parameter is 
of const reference typea temporary objectisintroducedif needed(7.1.5, 2.13, 2.13.4, 8.3.4, 12.2). In addition,itis 
possible to modify the values of nonconstant objects through pointer parameters. — end note ] 

6 Afunction can be declared to accept fewer arguments (by declaring default arguments(8.3.6)) or more arguments (by 
using the ellipsis, ... 8.3.5)than the numberof parametersin the function definition(8.4).[Note: this implies that, 
except where the ellipsis(...)is used, a parameter is available for each argument. — end note ] 

7 Whenthereisnoparameterforagivenargument,theargumentispassedinsuchawaythatthereceiving function 
can obtain the value of the argumentby invoking va_arg (18.7).Thelvalue-to-rvalue(4.1), array-to-pointer(4.2), and 
function-to-pointer(4.3)standard conversions are performedontheargumentexpression. After these conversions,ifthe 
argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. If 
theargumenthasanon-PODclasstype(clause 9),thebehavioris undefined.Iftheargumenthasintegralor enumeration 
typethatissubjecttotheintegral promotions(4.5),ora floatingpointtypethatissubjecttothe floatingpoint promotion 

Draft 


79 Expressions 5.2 Postfix expressions 

(4.6),thevalueoftheargumentis convertedtothepromotedtype beforethecall. These promotions are referredtoas 
the default argument promotions. 

8 The order of evaluation of arguments is unspecified. All side effects of argument expression evaluations take effect 
before the function is entered. The order of evaluation of the postfix expression and the argument expression list is 
unspecified. 

9 Recursive calls are permitted, except to the function named main (3.6.1). 

10 Afunction callis anlvalueifand onlyif the result typeisa reference. 

5.2.3 Explicit type conversion (functional notation) [expr.type.conv] 
1Asimple-type-specifier (7.1.5)followedbya parenthesizedexpression-list constructsavalueof thespecified typegiven 
the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in definedness,andif definedin meaning)tothe corresponding castexpression(5.4).Ifthe simple-type-specifier specifies a 
class type, the class type shall be complete. If the expression list specifies more than a single value, the type shall be 
a class witha suitablydeclared constructor(8.5, 12.1), and theexpression T(x1, x2, ...) is equivalent in effect to 
the declaration T t(x1, x2, ...); for some invented temporary variable t, with the result being the value of t as an 
rvalue. 

2 The expression T(), where T isa simple-type-specifier(7.1.5.2)fora non-array complete object type or the (possibly 
cv-qualified)voidtype, createsanrvalueofthe specifiedtype, whichisvalue-initialized(8.5;no initializationisdonefor 
the void() case).[ Note: if T isa non-class type thatis cv-qualified, the cv-qualifiers are ignored when determining 
the type of the resulting rvalue(3.10). — end note ] 

5.2.4 Pseudo destructor call [expr.pseudo] 
1 The use of a pseudo-destructor-name after a dot . or arrow -> operator represents the destructor for the non-class type 
named by type-name. The result shall only be used as the operand for the function call operator (), and the result of 
such a call has type void. The only effect is the evaluation of the postfix-expression before the dot or arrow. 

2 The left-hand side of the dot operator shall be of scalar type. The left-hand side of the arrow operator shall be of pointer 
to scalar type. This scalar type is the object type. The type designated by the pseudo-destructor-name shall be the same 
as the object type. Furthermore, the two type-names in a pseudo-destructor-name of the form 

::opt nested-name-specifieropt type-name :: ~ type-name 

shall designate the same scalar type. The cv-unqualified versions of the object type and of the type designated by the 
pseudo-destructor-name shall be the same type. 

5.2.5 Class member access [expr.ref] 
1 Apostfix expression followed by a dot. or an arrow ->, optionally followedby thekeyword template (14.8.1), and 
then followedbyan id-expression,isa postfixexpression.The postfixexpression beforethedotor arrowisevaluated;63) 
the result of that evaluation, together with the id-expression, determine the result of the entire postfix expression. 

2 For the first option (dot) the type of the first expression (theobject expression )shall be “class object” (of a complete 
type). For the second option (arrow) the type of the first expression (the pointer expression )shall be “pointer to class 
object” (of a complete type). In these cases, the id-expression shall name a member of the class or of one of its base 

63) This evaluation happens even if the result is unnecessary to determine the value of the entire postfix expression, for example if the id-expression 
denotes a static member. 

Draft 


5.2 Postfix expressions Expressions 80 
classes.[ Note: becausethenameofaclassis insertedinitsclassscope(clause 9),thenameofaclassisalsoconsidered 
a nested member of that class. — end note ][Note: 3.4.5 describes how names are looked up after the . and -> 
operators. — end note ] 

3 If E1 has the type “pointer to class X,” then the expression E1->E2 is convertedto the equivalent form (*(E1)).E2;the 
remainder of 5.2.5 will address only the first option (dot)64). Abbreviating object-expression.id-expression as E1.E2, 
then the type and lvalue properties of this expression are determined as follows. In the remainder of 5.2.5, cq represents 
either const or the absence of const vq represents either volatile or the absence of volatile. cv represents an 
arbitrary set of cv-qualifiers, as defined in 3.9.3. 

4 If E2 is declared to have type “reference to T,” then E1.E2 is an lvalue; the type of E1.E2 is T. Otherwise, one of the 
following rules applies. 

— If E2 isa static data member,andthetypeof E2 is T,then E1.E2 isanlvalue;theexpression designatesthenamed 
memberof the class. Thetypeof E1.E2 is T. 
— If E2 is a non-static data member, and the type of E1 is “cq1 vq1 X”, and the type of E2 is “cq2 vq2 T”, the 
expression designates the named member of the object designated by the first expression. If E1 is an lvalue, then 
E1.E2 is an lvalue; otherwise, it is an rvalue. Let the notation vq12 stand for the “union” of vq1 and vq2;that is, 
if vq1 or vq2 is volatile, then vq12 is volatile. Similarly, let the notation cq12 stand for the “union” of cq1 
and cq2;that is, ifcq1 or cq2 is const, then cq12 is const. If E2 is declared to be a mutable member, then the 
type of E1.E2 is “vq12 T”. If E2 is not declared to be a mutable member, then the type of E1.E2 is “cq12 vq12 
T”. 
— If E2 isa(possiblyoverloaded) member function, functionoverload resolution(13.3)is usedto determine whether 
E1.E2 refers to a static or a non-static member function. 
— If it refers to a static member function, and the type of E2 is “function of parameter-type-list returning T”, 
then E1.E2 is an lvalue; the expression designates the static member function. The type of E1.E2 is the 
same type as that of E2, namely “function of parameter-type-list returning T”. 
— Otherwise, if E1.E2 refers to a non-static member function, and the type of E2 is “function of parameter-
type-list cv returning T”, then E1.E2 is not an lvalue. The expression designates a non-static member function. Theexpression canbe used onlyas the left-hand operandofa member function call(9.3).[Note: any 
redundant set of parentheses surrounding the expression is ignored(5.1). — end note ]The type ofE1.E2 is 
“function of parameter-type-list cv returning T”. 
— If E2 is a nested type, the expression E1.E2 is ill-formed. 
— If E2 is a member enumerator, and the type of E2 is T, the expression E1.E2 is not an lvalue. The type of E1.E2 
is T. 
[Note: “class objects” canbe structures(9.2)and unions(9.5). Classes are discussedin clause 9. — end note ] 

5 If E2 is a non-static data member or a non-static member function, the program is ill-formed if the class of which E2 is 
directlya memberis an ambiguous base(10.2)of the naming class(11.2)ofE2. 

64) Note that if E1 has the type “pointer to class X,” then (*(E1)) is an lvalue. 

Draft 


81 Expressions 5.2 Postfix expressions 

5.2.6 Increment and decrement [expr.post.incr] 
1 Thevalue obtainedby applyingapostfix ++ isthevalue thatthe operandhadbefore applyingthe operator.[ Note: the 
value obtained is a copyof the original value — end note ]The operand shall be a modifiable lvalue. The type of the 
operand shall be an arithmetic type or a pointer to a complete object type. After the result is noted, the value of the 
object is modified by adding 1 toit, unlessthe objectisoftype bool, in which case it is set to true.[ Note: this use is 
deprecated, see Annex D. — end note ]The result is an rvalue. The type of the result is the cv-unqualified version of 
the type of the operand. See also 5.7 and 5.17. 

The operand of postfix -is decremented analogously to the postfix ++ operator,exceptthatthe operand shallnotbeof 
type bool.[ Note: For prefix increment and decrement, see5.3.2. — end note ] 

5.2.7 Dynamic cast [expr.dynamic.cast] 
1 The result of the expression dynamic_cast<T>(v) is the result of converting the expression v to type T. T shall be a 
pointer or reference to a complete class type, or “pointer to cv void.” Types shall not be defined in adynamic_cast. 
The dynamic_cast operator shall not castawayconstness(5.2.11). 

2 If T is a pointer type, v shall be an rvalue of a pointer to complete class type, and the result is an rvalue of type T. If T is 
a reference type, v shall be an lvalue of a complete class type, and the result is an lvalue of the type referred to by T. 

3 If the type of v is the same as the required result type (which, for convenience, will be called R in this description), or it 
is the same as R except that the class object type in R is more cv-qualified than the class object type in v, the result is v 
(converted if necessary). 

4 If the value of v isanull pointervalueinthe pointer case,the resultisthenull pointervalueoftype R. 

5 If T is “pointer to cv1 B” and v has type “pointer to cv2 D” such that B is a base class of D, the result is a pointer to the 
unique B subobject of the D object pointed to by v. Similarly, if T is “reference to cv1 B” and v has type cv2 D such that 
B is a base class of D, the result is an lvalue for the unique B subobject of the D object referred to by v. 65) In both the 
pointer and reference cases, cv1 shall be the same cv-qualification as, or greater cv-qualification than, cv2, and B shall 
be an accessible unambiguous base class of D.[ Example: 

struct B {}; 

struct D : B {}; 

void foo(D* dp) 

{ 

B* bp = dynamic_cast <B*>(dp); // equivalent toB* bp = dp;
}


— end example ] 
6 Otherwise, v shallbea pointertooranlvalueofa polymorphictype(10.3). 
7 If T is “pointer to cv void,” then the result is a pointer to the most derived object pointed to by v. Otherwise, a run-time 
check is applied to see if the object pointed or referred to by v can be converted to the type pointed or referred to by T. 
8 The run-time check logically executes as follows: 

65)Themostderivedobject(1.8)pointedor referredtobyv can contain other B objects as base classes,but these are ignored. 

Draft 


5.2 Postfix expressions Expressions 82 
— If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class subobject of a 
T object, and if only one object of type T is derived from the subobject pointed (referred) to by v the result is a 
pointer (an lvalue referring)to that T object. 
— Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the type of the 
most derived object has a base class, of type T, that is unambiguous and public, the result is a pointer (an lvalue 
referring) to the T subobject of the most derived object. 
— Otherwise, the run-time check fails. 
9 Thevalueofafailedcasttopointertypeisthenullpointervalueofthe required resulttype.Afailedcastto reference 
type throws std::bad_cast (18.5.2). 
[Example: 

class A { virtual void f (); };
class B { virtual void g (); };
class D : public virtual A , private B {};
void g()
{


D d;
B* bp = (B*)&d; // cast needed to break protection
A* ap =&d; // public derivation, no cast needed
D& dr = dynamic_cast <D&>(*bp); // fails
ap = dynamic_cast <A*>(bp); // fails
bp = dynamic_cast <B*>(ap); // fails
ap = dynamic_cast <A*>(&d); //succeeds
bp = dynamic_cast <B*>(&d); //fails


} 

class E : public D , public B {};
class F : public E , public D {};
void h()
{


F f;
A* ap =&f; // succeeds: finds unique A
D* dp = dynamic_cast <D*>(ap); // fails: yields 0


// f has two D subobjects
E* ep = (E*)ap; // ill-formed:
// cast from virtual base
E* ep1 = dynamic_cast <E*>(ap); // succeeds
}


— end example ][Note: 12.7 describes the behavior of a dynamic_cast applied to an object under construction or 
destruction. — end note ] 
5.2.8 Type identification [expr.typeid] 
1 The result of a typeid expression is an lvalue of static type const std::type_info (18.5.1)anddynamic typeconst 
std::type_info or const name where name is an implementation-defined class derived from std :: type_info 

Draft 


83 Expressions 5.2 Postfix expressions 

which preserves the behavior described in 18.5.1.66) The lifetime of the object referred to by the lvalue extends to the 
end of the program. Whether or not the destructor is called for the std::type_info object at the end of the program is 
unspecified. 

2 When typeid is appliedtoanlvalueexpression whosetypeisa polymorphic classtype(10.3),the result referstoa 
std::type_info object representingthetypeofthemostderivedobject(1.8)(thatis,thedynamictype)towhichthe 
lvalue refers. If the lvalue expression is obtained by applying the unary * operator to a pointer67) and the pointer is a 
null pointer value(4.10), the typeid expression throws the std::bad_typeid exception(18.5.3). 

3 When typeid is applied to an expression other than an lvalue of a polymorphic class type, the result refers to a 
std::type_info object representing the static typeof theexpression. Lvalue-to-rvalue(4.1), array-to-pointer(4.2), 
and function-to-pointer(4.3)conversionsarenotappliedtotheexpression.Ifthetypeoftheexpressionisaclasstype, 
the class shall be completely-defined. The expression is not evaluated. 

4 When typeid is applied to a type-id, the result refers to a std::type_info object representing the type of the type-id. 
If the type of the type-id is a reference type, the result of the typeid expression refers to a std::type_info object 
representing the referenced type. If the type of the type-id is a class type or a reference to a class type, the class shall be 
completely-defined.Typesshall notbe definedin the type-id. 

5 The top-level cv-qualifiers of the lvalue expression or the type-id that is the operand of typeid are always ignored. 
[Example: 

class D { ... }; 

D d1; 

const D d2; 

typeid(d1) == typeid(d2); // yieldstrue
typeid(D) == typeid(const D); // yieldstrue
typeid(D) == typeid(d2); // yieldstrue
typeid(D) == typeid(const D&); // yieldstrue


— end example ] 
6 If the header <typeinfo> (18.5.1)is not included prior to a use oftypeid, the program is ill-formed. 
7[Note: 12.7 describes the behavior of typeid applied to an object under construction or destruction. — end note ] 
5.2.9 Static cast [expr.static.cast] 
1 The result of the expression static_cast<T>(v) is the result of converting the expression v to type T. If T is a 
reference type, the result is an lvalue; otherwise, the result is an rvalue. Types shall not be defined in a static_cast. 
The static_cast operator shall not castawayconstness(5.2.11). 

2 An lvalue of type cv1 B, where B is a class type, can be cast to type “reference to cv2 D, where D is a class derived 
(clause 10)fromB, if a valid standard conversion from “pointer to D” to “pointer to B” exists(4.10), cv2 is the same 
cv-qualification as, or greater cv-qualification than, cv1, and B is not a virtual base class of D. The result is an lvalue of 
type cv2 D. If the lvalue of type cv1 B is actually a subobject of an object of type D, the lvalue refers to the enclosing 
object of type D. Otherwise, the resultof the castis undefined.[ Example: 

66) The recommended name for such a class is extended_type_info.
67) If p is an expression of pointer type, then *p, (*p), *(p), ((*p)), *((p)), and so on all meet this requirement.


Draft 


5.2 Postfix expressions Expressions 84 
struct B {}; 

struct D : public B {}; 

D d; 

B &br = d; 

static_cast <D&>(br); // produces lvalue to the original d object 

— end example ] 
3 Otherwise, an expression e can be explicitly converted to a type T using a static_cast of the form static_
cast<T>(e) if the declaration T t(e); is well-formed, for some invented temporary variable t (8.5). The effect 
of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary 
variable as the result of the conversion. The result is an lvalueif T isa reference type(8.3.2), and an rvalue otherwise. 
The expression e is used as an lvalue if and only if the initialization uses it as an lvalue. 

4 Otherwise, the static_cast shall perform one of the conversions listed below. No other conversion shall be performed 
explicitly using a static_cast. 

5 Any expression can be explicitly converted to type cv void. The expression value is discarded. [Note: however, if 
thevalueisina temporaryvariable(12.2),the destructorforthatvariableisnotexecuted untilthe usualtime,andthe 
value of the variable is preserved for the purpose of executing the destructor. — end note ]The lvalue-to-rvalue(4.1), 
array-to-pointer(4.2),and function-to-pointer(4.3)standard conversions arenotappliedtotheexpression. 

6 Theinverseof anystandard conversion sequence (clause 4), other thanthelvalue-to-rvalue(4.1), array-to-pointer(4.2), 
function-to-pointer(4.3), and boolean(4.12)conversions, canbe performedexplicitly using static_cast.Aprogram 
is ill-formed if it uses static_cast to performtheinverseofan ill-formed standard conversion sequence.[ Example: 

struct B {}; 

struct D : private B {}; 

void f() { 

static_cast <D*>((B*)0); // Error:Bisa private baseofD.
static_cast < int B ::* >(( int D ::*)0); // Error:Bisa private baseofD.


} 

— end example ] 
7 The lvalue-to-rvalue(4.1), array-to-pointer(4.2), and function-to-pointer(4.3)conversions are applied to the operand. 
Such a static_cast issubjecttothe restrictionthattheexplicitconversiondoesnotcastaway constness(5.2.11),and 
the following additional rules for specific cases: 

8 A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged 
ifthe originalvalueis withinthe rangeofthe enumerationvalues(7.2). Otherwise,the resulting enumerationvalueis 
unspecified. 

9 An rvalue of type “pointer to cv1 B,” where B is a class type, can be converted to an rvalue of type “pointer to cv2 D,” 
where D is a class derived (clause 10)fromB,ifavalid standard conversion from “pointerto D” to “pointer to B” exists 
(4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and B is nota virtual base classof D. The 
null pointervalue(4.10)is convertedtothe nullpointervalueofthe destination type.Ifthervalueoftype “pointerto 
cv1 B” points to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object 
of type D. Otherwise, the result of the cast is undefined. 

Draft 


85 Expressions 5.2 Postfix expressions 

10 An rvalue of type “pointer to member of D of type cv1 T” can be converted to an rvalue of type “pointer to member 
of B” of type cv2 T, where B is a base class (clause 10)ofD, if a valid standard conversion from “pointer to member 
of B of type T” to “pointer to member of D of type T”exists(4.11), and cv2 is the same cv-qualification as, or greater 
cv-qualification than, cv1.68)Thenull memberpointervalue(4.11)isconvertedtothenullmemberpointervalueofthe 
destination type. If class B contains the original member, or is a base or derived class of the class containing the original 
member, the resulting pointer to member points to the original member. Otherwise, the result of the cast is undefined. 
[Note: although class B need not contain the original member, the dynamic type of the object on which the pointer to 
member is dereferenced mustcontain the original member; see 5.5. — end note ] 

11 An rvalue of type “pointer to cv1 void” can be converted to an rvalue of type “pointer to cv2 T,” whereT is an object type 
and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1.Avalue of type pointer to object converted 
to “pointer to cv void” and back, possibly with different cv-qualification, shall have its original value.[ Example: 

T* p1 = new T; 

const T* p2 = static _cast <const T*>(static_cast <void*>(p1)); 

bool b= p1 == p2; // b will have the value true. 

— end example ] 
5.2.10 Reinterpret cast [expr.reinterpret.cast] 
1 The result of the expression reinterpret_cast<T>(v) is the result of converting the expression v to type T. If T is a 
reference type, the result is an lvalue; otherwise, the result is an rvalue and the lvalue-to-rvalue(4.1), array-to-pointer 
(4.2), and function-to-pointer(4.3)standard conversions are performed on the the expression v. Types shall not be 
defined in a reinterpret_cast. Conversions that can be performed explicitly using reinterpret_cast are listed 
below.No other conversion canbe performedexplicitly using reinterpret_cast. 

2 The reinterpret_cast operator shall not castaway constness. [Note: see 5.2.11 for the definition of “casting away 
constness”. Subjecttothe restrictionsinthis section,anexpressionmaybecasttoitsowntypeusinga reinterpret_
cast operator. — end note ] 

3 The mapping performed by reinterpret_cast is implementation-defined.[ Note: it might, or might not, produce a 
representation different from the original value. — end note ] 

4Apointercanbeexplicitlyconvertedtoanyintegraltypelargeenoughtoholdit.Themapping functionis implementation-
defined.[ Note: it is intended to be unsurprising to those who know the addressing structure of the underlying machine. 

— end note ] 
5Avalueofintegraltypeor enumerationtypecanbeexplicitlyconvertedtoapointer.69)Apointerconvertedtoaninteger 
ofsufficientsize(ifanysuchexistsonthe implementation)andbacktothe same pointertypewillhaveits originalvalue; 
mappings between pointers and integers are otherwise implementation-defined. 

6 Apointertoa function canbeexplicitly convertedtoa pointertoafunctionofadifferent type. Theeffectof callinga 
function through a pointer to a function type(8.3.5)that is not the same as the type used in the definition of the function 
is undefined. Except that converting an rvalue of type “pointer to T1” to the type “pointer to T2” (where T1 and T2 are 
function types)and backtoits originaltype yieldsthe original pointervalue,the resultof sucha pointer conversionis 
unspecified.[ Note: see also 4.10 for more details of pointer conversions. — end note ] 

68) Function types (including those used in pointer to member function types) are never cv-qualified; see 8.3.5.
69) Converting an integral constantexpression(5.19)withvalue zeroalways yieldsanull pointer(4.10),but converting otherexpressions that happen


to have value zero need not yield a null pointer. 

Draft 


5.2 Postfix expressions Expressions 86 
7 Apointer to an object can be explicitly convertedto a pointer to an object of different type.70) Except that converting 
an rvalue of type “pointer to T1” to the type “pointer to T2” (where T1 and T2 are object types and wherethe alignment 
requirements of T2 are no stricter than those of T1)and back to its original type yields the original pointer value, the 
result of such a pointer conversion is unspecified. 

8 Converting a pointer to a function into a pointer to an object type or vice versa is conditionally-supported. The meaning 
ofsuchaconversionis implementation defined,exceptthatifan implementationsupportsconversionsinboth directions, 
converting an rvalue of one type to the other type and back, possibly with different cv-qualification, shall yield the 
original pointer value. 

9 The null pointer value(4.10)is converted to the null pointer value of the destination type. 

10 An rvalue of type “pointer to member of X of type T1” can be explicitly converted to an rvalue of type “pointer to 
member of Y of type T2” if T1 and T2 are both function types or both object types.71) The null member pointer value 
(4.11)is converted to the null member pointer value of the destination type. The result of this conversion is unspecified, 
except in the following cases: 

— convertinganrvalueoftype “pointerto member function”toadifferent pointerto member functiontypeandback 
to its original type yields the original pointer to member value. 
— converting an rvalue of type “pointer to data member of X of type T1” to the type “pointer to data member of Y 
of type T2 (where the alignment requirements of T2 are no stricter than those of T1)and back to its original type 
yields the original pointer to member value. 
11 An lvalue expression of type T1 can be castto the type “reference to T2” if an expression of type “pointer to T1” can be 
explicitly converted to the type “pointer to T2” using a reinterpret_cast. That is, a reference cast reinterpret_
cast<T&>(x) has the same effect as the conversion *reinterpret_cast<T*>(&x) with thebuilt-in & and * operators. 
The resultisanlvaluethat referstothe sameobjectasthe sourcelvalue,butwithadifferenttype. No temporaryis 
created, no copyis made, and constructors(12.1)or conversion functions(12.3)are not called.72) 

5.2.11 Const cast [expr.const.cast] 
1 The result of the expression const_cast<T>(v) is of type T. If T is a reference type, the result is an lvalue; otherwise, the resultis an rvalue and, thelvalue-to-rvalue(4.1), array-to-pointer(4.2), and function-to-pointer(4.3)standard 
conversions are performed on the expression v. Types shall not be defined in a const_cast. Conversions that can 
be performed explicitly using const_cast are listed below. No other conversion shall be performed explicitly using 
const_cast. 

2 [Note: Subjecttothe restrictionsinthis section,anexpressionmaybecasttoitsowntypeusinga const_cast operator. 

— end note ]
3 For two pointer typesT1 and T2 where
T1 is cv1,0 pointer to cv1,1 pointer to cv1,n-1 pointer to cv1,nT

···

and 

T2 is cv2,0 pointer to cv2,1 pointer to cv2,n-1 pointer to cv2,nT

···

70) The types may have different cv-qualifiers, subject to the overall restriction that a reinterpret_cast cannot cast away constness. 
71) T1 and T2 may have different cv-qualifiers, subject to the overall restriction that a reinterpret_cast cannot cast away constness. 
72) This is sometimes referred to as a type pun. 

Draft 


87 Expressions 5.2 Postfix expressions 

where T is anyobject type or the void type and where cv1,k and cv2,k may be different cv-qualifications, an rvalue of 
type T1 may be explicitly converted to the type T2 using a const_cast. The result of a pointer const_cast refers to 
the original object. 

4 An lvalue of type T1 can be explicitly converted to an lvalue of type T2 using the cast const_cast<T2&> (where T1 
and T2 are object types)ifa pointerto T1 canbeexplicitly convertedtothetype pointerto T2 usinga const_cast. The 
result of a reference const_cast refers to the original object. 

5 For a const_cast involving pointers to data members, multi-level pointers to data members and multi-level mixed 
pointers and pointers to data members(4.4), the rules for const_cast are the same as those used for pointers; the 
“member” aspect of a pointer to member is ignored when determining where the cv-qualifiers are added or removed 
by the const_cast. The result of a pointer to data member const_cast refers to the same member as the original 
(uncast) pointer to data member. 

6Anullpointervalue(4.10)isconvertedtothenullpointervalueofthe destinationtype.Thenullmemberpointervalue 
(4.11)is converted to the null member pointer value of the destination type. 

7[Note: Depending on the type of the object, a write operation through the pointer, lvalue or pointer to data member 
resulting from a const_cast that castsaway a const-qualifier73) may produce undefined behavior(7.1.5.1). — end 
note ] 

8 The following rules define the process known as casting away constness. In these rules Tn and Xn represent types. 
For two pointer types: 

X1 is T1cv1,1 * cv1,N * where T1 is not a pointer type 

··· 

X2 is T2cv2,1 * cv2,M * where T2 is not a pointer type 

··· 

Kis min(N,M) 

casting from X1 to X2 castsaway constnessif,fora non-pointertype T theredoesnotexistan implicitconversion(clause 
4)from: 

Tcv1,(N-K+1) * cv1,(N-K+2) * cv1,N * 

··· 

to 

Tcv2,(M-K+1) * cv2,(M-K+2) * cv2,M * 

··· 

9 Casting from an lvalue of type T1 to an lvalue of type T2 using a reference cast casts away constness if a cast from an 
rvalue of type “pointer to T1” to the type “pointer to T2” casts away constness. 

10 Casting from an rvalue of type “pointer todata member of X of type T1” to the type “pointer to data member of Y of 
type T2” casts away constness if a cast from an rvalue of type “pointer to T1” to the type “pointer to T2” casts away 
constness. 

11 For multi-level pointer to members and multi-level mixed pointers and pointer to members(4.4), the “member” aspect 
ofa pointerto memberlevelis ignored when determiningifa const cv-qualifier has been cast away. 

12 [Note: some conversions which involve only changes in cv-qualification cannot be done using const_cast. For 
instance,conversionsbetweenpointersto functionsarenotcovered becausesuchconversionsleadtovalueswhoseuse 
causes undefinedbehavior.Forthe same reasons,conversions between pointersto member functions,andin particular, 

73) const_cast isnot limitedtoconversionsthatcastawaya const-qualifier. 

Draft 


5.3 Unary expressions Expressions 88 
the conversion from a pointer to a const member function to a pointer to a non-const member function, are not covered. 

— end note ] 
5.3 Unary expressions [expr.unary] 
1 Expressions with unary operators group right-to-left. 

unary-expression:
postfix-expression
++ cast-expression
--cast-expression
unary-operator cast-expression
sizeof unary-expression
sizeof ( type-id )
new-expression
delete-expression


unary-operator: one of 

* &+-! ~ 
5.3.1 Unary operators [expr.unary.op] 
1 The unary * operator performs indirection: the expression to whichit is applied shall be a pointer to an object type, or 
a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. 
If the type of the expression is “pointer to T,” the type of the result is “T.”[ Note: a pointer to an incomplete type (other 
than cv void )can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for 
example); this lvalue must not be converted to an rvalue, see 4.1. — end note ] 

2 The result of the unary & operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id. Inthe first 
case, if the type of the expression is “T,” the type of the result is “pointer to T.” In particular, the address of an object of 
type “cv T” is “pointer to cv T,” with the same cv-qualifiers.Fora qualified-id, if the member is a static member of type 
“T”, the type of the result is plain “pointer to T.” If the member is a non-static member of class C of type T, the type of 
the result is “pointer to member of class C of type T.”[ Example: 

struct A { int i; };
struct B : A {};
... &B::i ... // has type int A::*


— end example ][Note: a pointer to member formed from a mutable non-static data member(7.1.1)does not reflect 
the mutable specifier associated with the non-static data member. — end note ] 
3 Apointer to member is only formed when an explicit& is used and its operand is a qualified-id not enclosed in parentheses. [Note: that is, the expression &(qualified-id), where the qualified-id is enclosed in parentheses, does not 
form anexpressionof type “pointerto member.” Neither does qualified-id, because there is no implicit conversion 
from a qualified-id for a non-static member function to the type “pointer to member function” as there is from an lvalue 
of functiontypetothetype “pointerto function”(4.3).Noris &unqualified-id a pointer to member, even within the 
scope of the unqualified-id’s class. — end note ] 

4 The address of an object of incomplete type can be taken, but if the complete type of that object is a class type that 
declares operator&() as a member function, then the behavior is undefined (and no diagnostic is required). The 
operand of & shall not be a bit-field. 

Draft 


89 Expressions 5.3 Unary expressions 

5 The addressofanoverloaded function(clause 13)canbetakenonlyina context that uniquely determines whichversion 
oftheoverloaded functionis referredto(see 13.4).[Note: since the context might determine whether the operand is a 
static or non-static member function, the context can also affect whether the expression has type “pointer to function” 
or “pointer to member function.” — end note ] 

6 The operand of the unary + operator shall have arithmetic, enumeration, or pointer type and the result is the value of the 
argument. Integral promotion is performed on integral or enumeration operands. The type of the result is the type of the 
promoted operand. 

7 The operand of the unary -operator shall have arithmetic or enumeration type and the result is the negation of its 
operand. Integral promotionis performed onintegral or enumeration operands. The negativeof an unsigned quantityis 
computedby subtractingitsvalue from2n, where n isthe numberofbitsinthe promotedoperand.Thetypeofthe result 
is the type of the promoted operand. 

8 The operand of the logical negation operator ! is implicitly converted to bool (clause 4); its value is true if the 
converted operand is false and false otherwise. The type of the result is bool. 

9 The operand of ~ shall have integral or enumeration type; the result is the one’s complement of its operand. Integral 
promotionsare performed.Thetypeoftheresultisthetypeofthepromotedoperand. Thereisanambiguityinthe unary-
expression ~X(), whereX isa class-name.The ambiguityis resolvedinfavorof treating ~ asa unary complement rather 
than treating ~X as referring to a destructor. 

5.3.2 Increment and decrement [expr.pre.incr] 
1 The operand of prefix ++ is modifiedby adding 1, or set to true if it is bool (this use is deprecated). The operand shall 
be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a completely-defined object 
type. The result is the updated operand; it is an lvalue, and it is a bit-field if the operand is a bit-field. If x is not of type 
bool, the expression ++x is equivalent to x+=1 [Note: see the discussions of addition(5.7)and assignment operators 
(5.17)for information on conversions. — end note ] 

2 The operand of prefix -is modified by subtracting 1. The operand shall not be of type bool. The requirements on 
the operand of prefix -and the properties of its result are otherwise the same as those of prefix ++.[ Note: For postfix 
increment and decrement, see 5.2.6. — end note ] 

5.3.3 Sizeof [expr.sizeof] 
1 The sizeof operator yields the number of bytesin the object representation of its operand. The operand is either an 
expression, whichisnotevaluated,oraparenthesizedtype-id. The sizeof operatorshallnotbe appliedtoanexpression 
that has function or incomplete type, or to an enumeration type before all its enumerators have been declared, or to 
the parenthesized name of such types, or to an lvalue that designates a bit-field. sizeof(char), sizeof(signed 
char) and sizeof(unsigned char) are 1. The result of sizeof applied to any other fundamental type(3.9.1)is 
implementation-defined. [ Note: in particular, sizeof(bool) and sizeof(wchar_t) are implementation-defined.74) 

— end note ][Note: See 1.7 for the definition of byte and 3.9 for the definition of object representation. — end note ] 
2 When applied to a reference or a reference type, the result is the size of the referenced type. When applied to a class, 
the result is the number of bytes in an object of that class including anypadding required for placing objects of that type 
inan array. The sizeofa most derived classshallbe greater than zero(1.8). The resultof applying sizeof to a base 

74) sizeof(bool) is not required to be 1. 

Draft 


5.3 Unary expressions Expressions 90 
class subobject is the size of the base classtype.75) When applied to an array, the result is the total number of bytes in 
the array. This implies that the size of an array of n elements is n times the size of an element. 
3 The sizeof operator canbe appliedtoa pointertoa function,but shallnotbe applied directlytoa function. 
4 The lvalue-to-rvalue(4.1), array-to-pointer(4.2), and function-to-pointer(4.3)standard conversions are not applied to 
the operand of sizeof. 
5 Types shall not be defined in asizeof expression. 
6 The result is a constant of type std::size_t.[Note: std::size_t is defined in the standard header <cstddef> 
(18.1). — end note ] 

5.3.4 New [expr.new] 
1 The new-expression attempts to create an object of the type-id (8.1)ornew-type-id to which it is applied. The type of that 
object is the allocated type.Thistypeshallbeacompleteobjecttype,butnotan abstractclasstypeorarray thereof(1.8, 
3.9, 10.4).[Note: because references are not objects, references cannot be created by new-expressions. — end note ] 
[Note: the type-id may be a cv-qualified type, in which case the object created by the new-expression has a cv-qualified 
type. — end note ] 

new-expression:
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt ( type-id ) new-initializeropt


new-placement:
( expression-list )
new-type-id:
type-specifier-seq new-declaratoropt


new-declarator:
ptr-operator new-declaratoropt
direct-new-declarator


direct-new-declarator:
[ expression ]
direct-new-declarator [ constant-expression ]


new-initializer:
( expression-listopt )


Entities created by a new-expression have dynamic storage duration(3.7.3).[Note: the lifetime of such an entity is 
not necessarily restricted to the scope in which it is created. — end note ]If the entity is a non-array object, thenewexpression returns a pointer to the object created. If it is an array, the new-expression returns a pointer to the initial 
element of the array. 

2 The new-type-id in a new-expression is the longest possible sequence of new-declarators.[ Note: this prevents ambiguities between declarator operators &, *, [], and their expression counterparts. — end note ][Example: 

new int *i; // syntax error: parsed as (new int*) i
// not as (new int)*i


75) The actual size of a base class subobject may be less than the result of applying sizeof to the subobject,due to virtual base classes and less 
strict padding requirements on base class subobjects. 

Draft 


91 Expressions 5.3 Unary expressions 

The * is the pointer declarator and not the multiplication operator. — end example ]
3[Note: parentheses in a new-type-id of a new-expression canhave surprisingeffects.[ Example:
new int (*[10])(); // error


is ill-formed because the binding is 

(new int ) (*[10])(); // error 

Instead,theexplicitly parenthesizedversionofthe new operator can be used to create objects of compound types(3.9.2): 

new (int (*[10])()); 

allocates an array of 10 pointers to functions (taking no argument and returning int. — end example ] — end note ] 

4 The type-specifier-seq shall not contain class declarations, or enumeration declarations. 

5 When the allocated object is an array (that is, the direct-new-declarator syntax is used or the new-type-id or type-id 
denotes an array type), the new-expression yieldsa pointertothe initial element(ifany)ofthe array.[ Note: both new 
int and new int[10] have type int* and the type of new int[i][10] is int (*)[10] — end note ] 

6 Every constant-expression in a direct-new-declarator shallbeanintegral constantexpression(5.19)andevaluatetoa 
strictly positive value. The expression in a direct-new-declarator shall have integral or enumeration type(3.9.1)with 
a non-negative value.be of integral type, enumeration type, or a class type for which a single conversion function to 
integralor enumerationtypeexists(12.3).Iftheexpressionisof classtype,theexpressionis converted bycallingthat 
conversion function, and the result of the conversion is used in place of the original expression. If the value of the 
expression is negative, the behavior is undefined.[Example: if n is a variable of type int, then new float[n][5] is 
well-formed (because n is the expression of a direct-new-declarator),but new float[5][n] is ill-formed (because n 
is nota constant-expression). If n is negative, the effect of new float[n][5] is undefined. — end example ] 

7 When the value of the expression in a direct-new-declarator is zero, the allocation functionis calledto allocate an array 
with no elements. 

8Anew-expression obtains storage for the object by calling an allocation function (3.7.3.1). Ifthe new-expression terminatesbythrowinganexception,itmayrelease storageby callinga deallocation function(3.7.3.2).Ifthe allocatedtype 
is a non-array type, the allocation function’s name is operator new and the deallocation function’s name is operator 
delete. If the allocated type is an array type, the allocation function’s name is operator new[] and the deallocation 
function’s name is operator delete[].[Note: an implementation shall provide default definitions for the global 
allocation functions(3.7.3, 18.4.1.1, 18.4.1.2). AC++ program can provide alternative definitions of these functions 
(17.4.3.4)and/or class-specific versions(12.5). — end note ] 

9 If the new-expression begins with a unary :: operator, the allocation function’s name is looked up in the global scope. 
Otherwise,ifthe allocatedtypeisa classtype T or array thereof, the allocation function’s name is looked up in the scope 
of T Ifthislookupfailstofindthename,orifthe allocatedtypeisnotaclasstype,the allocation function’s nameis 
looked up in the global scope. 

10 Anew-expression passes the amount of space requestedto the allocation function as the first argument of type std:: 
size_t. That argument shall be no less thanthe size of the object being created; it may be greater than the size of the 
objectbeing createdonlyifthe objectisan array.For arraysof char and unsigned char, the difference between the 
result of the new-expression and the address returnedby the allocationfunction shallbe an integral multipleof the most 
stringent alignment requirement(3.9)of anyobject type whose size is no greater than the size of the array being created. 

Draft 


5.3 Unary expressions Expressions 92 
[Note: Because allocation functions are assumed to return pointers to storage that is appropriately aligned for objects 
of anytype, this constraint on array allocation overhead permits the common idiom of allocating character arrays into 
which objects of other types will later be placed. — end note ] 

11 The new-placement syntax is used to supplyadditional arguments to an allocation function. If used, overload resolution 
is performed on a function call created by assembling an argument list consisting of the amount of space requested 
(the first argument) and the expressions in the new-placement part of the new-expression (the second and succeeding 
arguments). The first ofthese arguments has type std::size_t and the remaining arguments have the corresponding 
types of the expressions in the new-placement. 

12 [Example: 

— new T results in a call of operator new(sizeof(T)), 
— new(2,f) T results in a call of operator new(sizeof(T),2,f), 
— new T[5] results in a call of operator new[](sizeof(T)*5+x), and 
— new(2,f) T[5] results in a call of operator new[](sizeof(T)*5+y,2,f). 
Here, x and y are non-negative unspecified values representing array allocation overhead; the result of the new-expression will be offset by this amount from the value returned by operator new[]. This overhead may be applied in all 
array new-expressions, including those referencing the library function operator new[](std::size_t, void*) and 
other placement allocation functions. The amount of overhead may vary from one invocation of new to another. — end 
example] 

13 [Note: unless an allocation function is declared with an empty exception-specification (15.4), throw(), it indicates 
failureto allocate storagebythrowingabad_alloc exception(clause15,18.4.2.1);it returnsanon-null pointer otherwise. 
If the allocation function is declared with an empty exception-specification, throw(), it returns null to indicatefailure 
to allocate storage and a non-null pointer otherwise. — end note ]If the allocation function returns null, initialization 
shall not be done, the deallocation function shall not be called, and the value of the new-expression shall be null. 

14 [Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage in which 
space for the object has been reserved. The block of storage is assumed to be appropriately aligned and of the requested 
size. The address of the created object will not necessarily be the same as that of the block if the object is an array. 

— end note ] 
15 Anew-expression that creates an object of type T initializes that object as follows: 
— If the new-initializer is omitted: 
— If T isa (possibly cv-qualified) non-POD classtype(or array thereof),the objectisdefault-initialized(8.5). 
If T is a const-qualified type, the underlying class type shall have a user-declared default constructor. 
— Otherwise, the object created has indeterminate value. If T is a const-qualified type, or a (possibly cvqualified) POD class type (or array thereof) containing (directly or indirectly) a member of const-qualified 
type, the program is ill-formed; 
— If the new-initializer is of the form (), the item is value-initialized(8.5); 
— If the new-initializer is of the form(expression-list)andT is a class type, the appropriate constructor is called, 
using expression-list as the arguments(8.5); 
Draft 


93 Expressions 5.3 Unary expressions 

— If the new-initializer is of the form(expression-list)andT is an arithmetic, enumeration, pointer, or pointer-tomember type and expression-list comprises exactly one expression, then the object is initialized to the (possibly 
converted)valueof theexpression(8.5); 
— Otherwise the new-expression is ill-formed. 
16 If the new-expression createsan objectoran arrayof objectsof class type,accessand ambiguity control are doneforthe 
allocation function, the deallocation function(12.5), and the constructor(12.1). If the newexpression creates anarray 
of objectsof class type, access and ambiguity control are done for the destructor(12.4). 

17 Ifanypartoftheobject initialization describedabove76) terminatesbythrowinganexceptionanda suitable deallocation 
function can be found, the deallocation function is called to free the memory in which the object was being constructed, 
after which the exception continues to propagate in the context of the new-expression. If no unambiguous matching 
deallocation functioncanbefound,propagatingtheexceptiondoesnotcausetheobject’smemorytobefreed.[ Note: 
This is appropriate when the called allocation function does not allocate memory; otherwise, it is likely to result in a 
memory leak. — end note ] 

18 If the new-expression begins witha unary :: operator, the deallocation function’s name is looked up in the global scope. 
Otherwise, if the allocated type is a class type T or an array thereof, the deallocation function’s name is looked up in 
the scope of T.Ifthislookupfailstofindthename,oriftheallocatedtypeisnotaclasstypeorarray thereof,the 
deallocation function’s name is looked up in the global scope. 

19 Adeclaration of a placement deallocation function matches the declaration of a placement allocation function if it has 
the same numberof parameters and, after parameter transformations(8.3.5), all parameter typesexcept the first are 
identical. Anynon-placement deallocation function matches a non-placementallocation function. If the lookup finds a 
single matching deallocation function, that function will be called; otherwise, no deallocation function will be called. 
Ifthelookupfindsthetwo-parameterformofausual deallocation function(3.7.3.2)andthat function, consideredas 
a placement deallocation function, would have been selected as a match for the allocation function, the program is 
ill-formed.[ Example: 

struct S { 

// Placement allocation function: 

static void * operator new ( std :: size _t , std :: size_t ); 

// Usual (non-placement) deallocation function: 

static void operator delete ( void * , std :: size_t );
};


S* p=new (0) S; // ill-formed: non-placement deallocation function matches
// placement allocation function


— end example ] 
20 Ifa new-expression callsa deallocation function,it passesthevalue returned fromthe allocation function callasthe first 
argument of type void*. If a placement deallocation function is called, it is passed the same additional arguments as 
were passed to the placement allocation function,that is, the same arguments as those specified with the new-placement 
syntax. If the implementation is allowedto make a copyof anyargument as part of the call to the allocation function, it 
isallowedtomakeacopy(ofthesameoriginalvalue)aspartofthecalltothe deallocationfunctionorto reusethecopy 
madeaspartofthecalltothe allocation function.Ifthecopyiselidedinoneplace,itneednotbeelidedintheother. 

76) This may include evaluating a new-initializer and/or calling a constructor. 

Draft 


5.3 Unary expressions Expressions 94 
21 Whether the allocation function is called before evaluating the constructor arguments or after evaluating the constructor 
argumentsbut before enteringthe constructoris unspecified.Itisalso unspecified whethertheargumentstoaconstructor 
are evaluated if the allocation function returns the null pointer or exits using an exception. 

5.3.5 Delete [expr.delete] 
1 The delete-expression operator destroysa most derived object(1.8)or array createdbya new-expression. 

delete-expression:
::opt delete cast-expression
::opt delete [ ] cast-expression


The first alternativeis for non-array objects, and the secondis for arrays. The operandshallhavea pointer type, ora 
classtypehavingasingleconversion function(12.3.2)toapointertype.Theresulthastypevoid. 

2 If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion 
function, and the converted operand is used in place ofthe original operand for the remainder of this section. In either 
alternative, if the value of the operand of delete is the null pointer the operation has no effect.may be a null pointer 
value. InIfitisnotanull pointervalue, inthe first alternative(delete object), the value of the operand of delete shall 
beapointertoa non-arrayobjectorapointertoa subobject(1.8)representingabaseclassofsuchanobject(clause 
10).Ifnot,thebehavioris undefined.Inthe second alternative(delete array), the value of the operand of delete shall 
be the pointer value which resulted from a previous array new-expression.77) If not, the behavior is undefined.[ Note: 
this means that the syntax of the delete-expression must match the type of the object allocated by new, not the syntax 
of the new-expression. — end note ][Note: a pointer to a const type can be the operand of a delete-expression; it 
isnot necessarytocastawaythe constness(5.2.11)ofthepointerexpression beforeitisusedastheoperandofthe 
delete-expression. — end note ] 

3 In the first alternative(delete object ), if the static type of the operand is different from its dynamic type, the static type 
shall be a base class of the operand’s dynamic type and the static type shall have a virtual destructor or the behavior is 
undefined. In the second alternative(delete array )if the dynamic type of the object to be deleted differs from its static 
type, the behavior is undefined.78) 

4 The cast-expression in a delete-expression shall be evaluated exactly once. If the delete-expression calls the implementation deallocation function(3.7.3.2), andif the operandof the deleteexpressionis not the null pointer constant, the 
deallocation function will deallocate the storage referenced by the pointer thus rendering the pointer invalid. [Note: the 
value of a pointer that refers to deallocated storage is indeterminate. – end note] 

5 If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial 
destructor or a deallocation function, the behavior is undefined. 

6 TheIf the value of the operand of the delete-expression is not a null pointer value, the delete-expression will invoke the 
destructor (if any) for the object or the elements of the array being deleted. In the case of an array, the elements will be 
destroyedinorderof decreasing address(thatis,inreverseorderofthe completionoftheir constructor;see 12.6.2). 

7 TheIf the value of the operand of the delete-expression is not a null pointer value, the delete-expression will call a 
deallocation function (3.7.3.2). Otherwise, it is unspecified whether the deallocation function will be called.[Note: The 

77) For non-zero-length arrays, this is the same as a pointer to the first element of the array created by thatnew-expression. Zero-length arrays do 

not have a first element.
78) This implies that an object cannot be deleted using a pointer of type void* because there are no objects of type void.


Draft 


95 Expressions 5.4 Explicit type conversion (cast notation) 

deallocation function is called regardless of whether the destructor for the object or some element of the array throws an 
exception. — end note ] 

8[Note: An implementation provides default definitions of the global deallocation functions operator delete() for 
non-arrays(18.4.1.1)andoperator delete[]() for arrays(18.4.1.2).AC++ program can provide alternative definitionsof these functions(17.4.3.4), and/or class-specificversions(12.5). — end note ]When thekeyworddelete in a 
delete-expression is precededbythe unary :: operator,the global deallocation function is used to deallocate the storage. 

9 Access and ambiguity control are done for both the deallocation function and the destructor(12.4, 12.5). 

5.4 Explicit type conversion (cast notation) [expr.cast] 
1 The result of the expression (T) cast-expression is of type T. The result is an lvalue if T is a reference type, otherwise 
the resultis an rvalue.[ Note: if T isa non-classtype thatis cv-qualified, the cv-qualifiers are ignored when determining 
the type of the resulting rvalue; see 3.10. — end note ] 

2 Anexplicit type conversion canbeexpressed using functionalnotation(5.2.3),a type conversion operator(dynamic_
cast, static_cast, reinterpret_cast, const_cast ), or the cast notation. 

cast-expression:
unary-expression
( type-id ) cast-expression


3 Types shall not be defined in casts.
4 Anytype conversion not mentioned below and not explicitly defined by the user(12.3)is ill-formed.
5 The conversions performed by


— a const_cast (5.2.11), 
— a static_cast (5.2.9), 
— a static_cast followedby a const_cast, 
— a reinterpret_cast (5.2.10), or 
— a reinterpret_cast followed by a const_cast, 
can be performed using the cast notation of explicit type conversion. The same semantic restrictions and behaviors 
apply, with the exception that in performing a static_cast in the following situations the conversion is valid even if 
the base class is inaccessible: 

— a pointer to an object of derived class type or an lvalue of derived class type may be explicitly converted to a 
pointer or reference to an unambiguous base class type, respectively; 
— a pointer to member of derived class type may be explicitly converted to a pointer to member of an unambiguous 
non-virtual base class type; 
— a pointer to an object of an unambiguous non-virtual base class type, an lvalue of an unambiguous non-virtual 
baseclasstype,orapointertomemberofan unambiguous non-virtualbaseclasstypemaybeexplicitlyconverted 
to a pointer, a reference, or a pointer to member of a derived class type, respectively. 
If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the 
listis used,evenifa cast resulting from that interpretationis ill-formed.Ifa conversion canbe interpretedin more than 
oneway asa static_cast followed by a const_cast, the conversionis ill-formed.[Example: 

Draft 


5.5 Pointer-to-member operators Expressions 96 
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};
A*foo( D*p ){


return (A*)( p ); // ill-formed static_cast interpretation
}


— end example ] 
6 Theoperandofacastusingthecast notationcanbeanrvalueoftype“pointerto incompleteclasstype”.The destination 
type of a cast using the cast notation can be “pointer to incomplete class type”. In such cases, even if there is a 
inheritance relationship between the source and destination classes, whether the static_cast or reinterpret_cast 
interpretation is used is unspecified. 

5.5 Pointer-to-member operators [expr.mptr.oper] 
1 The pointer-to-member operators ->* and .* group left-to-right. 

pm-expression:
cast-expression
pm-expression .* cast-expression
pm-expression ->* cast-expression


2 The binary operator .* binds its second operand, which shall be of type “pointer to member of T” (where T is a 
completely-defined class type) to its first operand, which shall be of class T or of a class of which T is an unambiguous 
and accessible base class. The result is an object or a function of the type specified by the second operand. 

3 The binary operator ->* binds its second operand, which shall be of type “pointer to member of T” (where T is a 
completely-defined class type) to its first operand, which shall be of type “pointer to T” or “pointer to a class of which T 
isan unambiguousand accessiblebase class.” The resultisanobjectora functionofthetype specifiedbythe second 
operand. 

4 If the dynamic type of the object does not contain the member to which the pointer refers, the behavior is undefined. 

5 The restrictions on cv-qualification, and the manner in which the cv-qualifiers of the operands are combined to produce 
the cv-qualifiers of the result, are the same as the rules for E1.E2 givenin 5.2.5.[ Note: itisnot possibletouseapointer 
to member that refers to a mutable member to modify a const class object.Forexample, 

struct S { 

S() : i(0) { } 

mutable int i;
};


void f()
{


const S cs;
int S::* pm = &S::i; // pm refers to mutable member S::i
cs.*pm = 88; // ill-formed: cs is a const object


} 

— end note ] 
Draft 


97 Expressions 5.6 Multiplicative operators 

6 If the result of .* or ->* is a function, then that result can be used only as the operand for the function call operator (). 
[Example: 

(ptr _to _obj ->*ptr_to_mfct)(10); 

calls the member function denoted by ptr_to_mfct for the object pointed to by ptr_to_obj. — end example ]The 
result of a .* expression is an lvalue only if its first operand is an lvalue and its second operand is a pointer to data 
member. The result of an ->* expression is an lvalue only if its second operand is a pointer to data member. If the 
second operand is the null pointer to member value(4.11), the behavior is undefined. 

5.6 Multiplicative operators [expr.mul] 
1 The multiplicative operators *, /, and % group left-to-right. 

multiplicative-expression:
pm-expression
multiplicative-expression * pm-expression
multiplicative-expression / pm-expression
multiplicative-expression % pm-expression


2 The operands of * and / shall have arithmetic or enumeration type; the operands of % shall have integral or enumeration 
type. The usual arithmetic conversions are performed on the operands and determine the type of the result. 

3 The binary * operator indicates multiplication. 

4 The binary / operator yields the quotient, andthe binary % operator yields the remainder from the division of the first 
expression by the second. If the second operand of / or % is zero the behavior is undefined; otherwise (a/b)*b + a%b 
is equal to a. If both operands are nonnegative then the remainder is nonnegative; if not, the sign of the remainder is 
implementation-defined79). 

5.7 Additive operators [expr.add] 
1 The additive operators + and -group left-to-right. The usual arithmetic conversions are performed for operands of 
arithmetic or enumerationtype. 

additive-expression:
multiplicative-expression
additive-expression + multiplicative-expression
additive-expression -multiplicative-expression


For addition,eitherbothoperandsshallhave arithmetic or enumerationtype,oroneoperandshallbeapointertoa 
completely defined object type and the other shall have integral or enumeration type. 

2 For subtraction, one of the following shall hold: 

— both operands have arithmetic or enumeration type; or 
— both operands are pointers to cv-qualified or cv-unqualified versions of the same completely defined object type; 
or 
79) According to work underway toward the revision of ISO C, the preferred algorithm for integer division follows the rules defined in the ISO 
Fortran standard, ISO/IEC 1539:1991, in which the quotient is always rounded toward zero. 

Draft 


5.8 Shift operators Expressions 98 
— the left operandisa pointertoa completely defined objecttype and the right operand has integral or enumeration 
type. 
3 The result of the binary + operator is the sum of the operands. The result of the binary -operator is the difference 
resulting from the subtraction of the second operand from the first. 

4 For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of 
an array of length one with the type of the object as its element type. 

5 When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer 
operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to 
an element offset from the original element such that the difference of the subscripts of the resulting and original array 
elements equals the integral expression. In other words, if the expression P points to the i-th element of an array object, 
the expressions (P)+N (equivalently, N+(P))and(P)-N (where N has the value n)point to, respectively, thei+ n-th and 
i- n-th elements of the arrayobject, providedthey exist. Moreover, if the expression P points to the last element of an 
array object, theexpression (P)+1 pointsonepastthelast elementofthearrayobject,andiftheexpression Q points one 
past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the 
pointer operand and the result point to elements of the same array object, or one past the last element of the array object, 
the evaluation shall not produce an overflow; otherwise, the behavior is undefined. 

6 When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of 
the two array elements. The type of the result is an implementation-defined signed integral type; this type shall be the 
same type that is defined as std::ptrdiff_t in the <cstddef> header(18.1).Aswithanyother arithmeticoverflow, 
ifthe resultdoesnotfitinthespaceprovided,thebehavioris undefined.Inotherwords,iftheexpressions P and Q point 
to, respectively, the i-th and j-th elements of an array object, the expression (P)-(Q) has the value i- jprovided the 
value fits in an object of type std::ptrdiff_t. Moreover, if the expression P points either to an element of an array 
object or one past the last element of an array object, and the expression Q points to the last element of the same array 
object, the expression ((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value 
zero if the expression P points one past the last element of the array object, even though the expression (Q)+1 does not 
point to an element of the array object. Unless both pointers point to elements of the same array object, or one past the 
last element of the array object, the behavior is undefined.80) 

7 Ifthevalue0isaddedtoor subtractedfromapointervalue,theresult comparesequaltothe originalpointervalue. 
If two pointers point to the same object or both point one past the end of the same array or both are null, and the two 
pointersare subtracted,theresult comparesequaltothevalue0convertedtothetype std::ptrdiff_t. 

5.8 Shift operators [expr.shift] 
1 The shift operators << and >> group left-to-right. 

80) Another way to approach pointer arithmetic is first to convert the pointer(s) to character pointer(s): In this scheme the integral value of the 
expressionaddedtoor subtractedfromtheconvertedpointerisfirst multipliedbythesizeoftheobject originallypointedto,andthe resultingpointer 
is converted back to the original type. For pointer subtraction, the result of the difference between the character pointers is similarly divided by the 
size of the object originally pointed to. 

When viewed in this way, an implementation need only provide one extra byte (which might overlap another object in the program) just after the 
end of the object in order to satisfy the “one past the last element” requirements. 

Draft 


99 Expressions 5.9 Relational operators 

shift-expression:
additive-expression
shift-expression << additive-expression
shift-expression >> additive-expression


The operands shall be of integral or enumeration type and integral promotions are performed. The type of the result is 
that of the promoted left operand. The behavior is undefined if the right operand is negative, or greater than or equal to 
the length in bits of the promoted left operand. 

2 The value of E1 << E2 is E1 (interpreted as a bit pattern) left-shifted E2 bit positions; vacated bits are zero-filled. If E1 
has an unsigned type, the value of the result is E1 multipliedbythe quantity2raisedtothepower E2, reduced modulo 
ULLONG_MAX+1 if E1 has type unsigned long long int, ULONG_MAX+1 if E1 has type unsigned long int, UINT_
MAX+1 otherwise.[ Note: the constants ULLONG_MAX, ULONG_MAX, and UINT_MAX are defined in the header <climits>. 

— end note ] 
3 The value of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a 
nonnegative value, the value of the result is the integral part of the quotient of E1 dividedby the quantity2raised to the 
power E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined. 

5.9 Relational operators [expr.rel] 
1 The relational operators group left-to-right.[ Example: a<b<c means (a<b)<c and not (a<b)&&(b<c). — end example ] 

relational-expression:
shift-expression
relational-expression < shift-expression
relational-expression > shift-expression
relational-expression <= shift-expression
relational-expression >= shift-expression


The operands shall have arithmetic, enumeration or pointer type. The operators < (lessthan), > (greaterthan), <= (less 
than or equal to), and >= (greater than or equal to) all yield false or true. The type of the result is bool. 

2 The usual arithmetic conversions are performed on operands of arithmetic or enumeration type. Pointer conversions 
(4.10)and qualification conversions(4.4)are performed on pointer operands (or on a pointer operand and a null pointer 
constant) to bring them to their composite pointer type. If one operand is a null pointer constant, the composite pointer 
type is the type of the other operand. Otherwise, if one of the operands has type “pointer to cv1 void,” then the other 
has type “pointer to cv2T” and the composite pointer typeis “pointer to cv12 void,” where cv12 is the union of cv1 
and cv2.Otherwise,thecompositepointertypeisapointertype similar(4.4)tothetypeofoneofthe operands,with 
a cv-qualification signature(4.4)thatis the unionof the cv-qualification signaturesof the operand types.[Note: this 
implies that anypointer can be compared to a null pointer constant and that anyobject pointer can be compared to a 
pointer to (possibly cv-qualified) void. — end note ][Example: 

void *p;
const int *q;
int **pi;
const int * const * pci ;
void ct ()
{


p <= q; // Both converted to const void* before comparison 

Draft 


5.10 Equality operators Expressions 100 
pi <= pci; // Both converted to const int *const * before comparison
}


— end example ]Pointers to objects or functions of the same type (after pointer conversions) can be compared, with a 
result defined as follows: 
— If two pointers p and q ofthe sametypepointtothe sameobjector function,orbothpointonepasttheendofthe 
same array, or are both null, then p<=q and p>=q both yield true and p<q and p>q both yield false. 
— If two pointers p and q of the same type point to different objects that are not members of the same object or 
elements of the same array or to different functions, or if only one of them is null, the results of p<q, p>q, p<=q, 
and p>=q are unspecified. 
— If two pointers point to non-static data members of the same object, or to subobjects or array elements of such 
members, recursively, the pointer to thelater declared member compares greater provided the two members are 
not separated by an access-specifier label(11.1)and provided their classis nota union. 
— If two pointers point to non-static data members of the same object separated by an access-specifier label(11.1) 
the result is unspecified. 
— If two pointers point to data members of the same union object, theycompare equal (after conversion to void*, if 
necessary). If two pointers point to elements of the same array or one beyond the end of the array, the pointer to 
the object with the higher subscript compares higher. 
— Other pointer comparisons are unspecified. 
5.10 Equality operators [expr.eq] 
equality-expression:
relational-expression
equality-expression == relational-expression
equality-expression != relational-expression


1 The == (equal to) and the != (not equal to) operators have the same semantic restrictions, conversions, and result type as 
the relational operatorsexcept for theirlower precedence and truth-value result.[ Note: a<b == c<d is true whenever 
a<b and c<d have the same truth-value. — end note ]Pointers to objects or functions of the same type (after pointer 
conversions) can be compared for equality. Two pointers of the same type compare equal if and only if they are both 
null, both point to the samefunction, or both represent the same address(3.9.2). 

2 Inaddition,pointerstomemberscanbecompared,orapointertomemberandanullpointer constant. Pointertomember 
conversions(4.11)and qualificationconversions(4.4)are performedtobringthemtoa commontype.Ifoneoperandis 
a null pointer constant, the common type is the type of the other operand. Otherwise, the common type is a pointer to 
membertype similar(4.4)tothetypeofoneofthe operands,witha cv-qualification signature(4.4)thatistheunionof 
the cv-qualification signaturesof the operand types.[ Note: this implies that anypointer to member can be compared to 
a null pointer constant. — end note ]If both operands are null, theycompare equal. Otherwise if only one is null, they 
compare unequal. Otherwise if either is a pointer to a virtual member function, the result is unspecified. Otherwise they 
compareequalifandonlyifthey would refertothe same memberofthe same mostderivedobject(1.8)orthe same 
subobjectif they were dereferenced withahypothetical objectof the associated class type.[ Example: 

struct B { 

Draft 


101 Expressions 5.11 Bitwise AND operator 

int f ();
};
struct L : B {};
struct R : B {};
struct D :L, R {};


int (B::*pb)() = &B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr); // false


— end example ] 
5.11 Bitwise AND operator [expr.bit.and] 
and-expression:
equality-expression
and-expression & equality-expression


1 The usual arithmetic conversions are performed; theresultis the bitwise AND functionof the operands. The operator 
applies only to integral or enumeration operands. 

5.12 Bitwise exclusive OR operator [expr.xor] 
exclusive-or-expression:
and-expression
exclusive-or-expression ^ and-expression


1 The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the operands. The 
operator applies only to integral or enumeration operands. 

5.13 Bitwise inclusive OR operator [expr.or] 
inclusive-or-expression:
exclusive-or-expression
inclusive-or-expression | exclusive-or-expression


1 The usual arithmetic conversions are performed; the result is the bitwise inclusive OR function of its operands. The 
operator applies only to integral or enumeration operands. 

5.14 Logical AND operator [expr.log.and] 
logical-and-expression:
inclusive-or-expression
logical-and-expression && inclusive-or-expression


1 The && operator groups left-to-right. The operands are both implicitly converted to type bool (clause4). The result 

is true if both operands are true and false otherwise. Unlike &, && guarantees left-to-right evaluation: the second 

operand is not evaluated if the first operand is false. 

2 The result is a bool. All sideeffectsofthe firstexpressionexceptfor destructionof temporaries(12.2)happen before 

Draft 


5.15 Logical OR operator Expressions 102 
the second expression is evaluated. 

5.15 Logical OR operator [expr.log.or] 
logical-or-expression:
logical-and-expression
logical-or-expression || logical-and-expression


1 The || operator groups left-to-right. The operands are both implicitly converted to bool (clause4). It returns true if 
either of its operands is true,andfalse otherwise. Unlike |,|| guarantees left-to-rightevaluation; moreover,the second 
operand is not evaluated if the first operand evaluates to true. 

2 The result is a bool. All sideeffectsofthe firstexpressionexceptfor destructionof temporaries(12.2)happen before 
the second expression is evaluated. 

5.16 Conditional operator [expr.cond] 
conditional-expression:
logical-or-expression
logical-or-expression ? expression : assignment-expression


1 Conditionalexpressions group right-to-left. The firstexpressionis implicitlyconvertedto bool (clause4). Itisevaluated 
and if it is true,theresultofthe conditionalexpressionisthevalueofthesecondexpression, otherwisethatofthethird 
expression. All side effects of the first expression except for destruction of temporaries(12.2)happen before the second 
or third expression is evaluated. Only one of the second and third expressions is evaluated. 

2 If either the second or thethird operand has type (possibly cv-qualified) void, then thelvalue-to-rvalue(4.1), array-topointer(4.2), and function-to-pointer(4.3)standard conversions are performed on the second and third operands, and 
one of the following shall hold: 

— The second or the third operand (but not both) is a throw-expression (15.1); the result is of the type of the other 
and is an rvalue. 
— Both the second and the third operands have type void the result is of type void and is an rvalue. [ Note: this 
includes the case where both operands are throw-expressions. — end note ] 
3 Otherwise, if the second and third operand have different types, and either has (possibly cv-qualified) class type, an 
attempt is made to convert each of those operands to the type of the other. The process for determining whether an 
operand expression E1 of type T1 can be converted to match an operand expression E2 of type T2 is defined as follows: 

— If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (clause 4)to the type 
“reference to T2”, subject to the constraintthat in the conversion the reference must bind directly(8.5.3)toE1. 
— If E2 is an rvalue, or if the conversion above cannot be done: 
— if E1 and E2 haveclasstype,andthe underlyingclasstypesarethesameoroneisabaseclassoftheother: E1 
can be converted to match E2 ifthe classof T2 isthe sametypeas,orabaseclassof,theclassof T1, and the 
cv-qualification of T2 is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification 
of T1. If the conversion is applied, E1 is changed to an rvalue of type T2 that still refers to the original 
source class object (or the appropriate subobject thereof).[Note: that is, no copy is made. — end note ]by 
copy-initializing a temporary of type T2 from E1 and using that temporary as the converted operand. 
— Otherwise (i.e., if E1 or E2 hasa nonclass type,oriftheybothhaveclass typesbutthe underlying classes are 
not either the same or one a base class of the other): E1 can be converted to match E2 if E1 can be implicitly 
Draft 


103 Expressions 5.17 Assignment and compound assignment operators 

converted to the type that expression E2 would have if E2 were converted to an rvalue (or the type it has, if 
E2 is an rvalue). 

Using this process, it is determined whether the second operand can be converted to match the third operand, and 
whether the third operand can be converted to match the second operand. If both can be converted, or one can be 
convertedbut the conversion is ambiguous, the program is ill-formed. If neither can be converted, the operands 
are left unchanged and further checking is performed as described below. If exactly one conversion is possible, 
thatconversionisappliedtothe chosenoperandandtheconvertedoperandisusedinplaceoftheoriginaloperand 
for the remainder of this section. 

4 If the second and third operands arelvalues andhave the same type, the resultisofthattypeandis anlvalue anditisa 
bit-field if the second or the third operand is a bit-field, or if both are bit-fields. 

5 Otherwise, the result is an rvalue. If the second and third operands do not have the same type, and either has (possibly 
cv-qualified) classtype,overload resolutionis usedto determinethe conversions(ifany)tobe appliedtothe operands 
(13.3.1.2, 13.6). If theoverload resolutionfails, the programis ill-formed. Otherwise, the conversions thus determined 
are applied, and the converted operands are used in place of the original operands for the remainder of this section. 

6 Lvalue-to-rvalue(4.1), array-to-pointer(4.2), and function-to-pointer(4.3)standard conversions are performed on the 
second and third operands. After those conversions, one of the following shall hold: 

— The second and third operands have the same type; the result is of that type. If the operands have class type, the 
result is an rvalue temporary of the result type, which is copy-initialized from either the second operand or the 
third operand depending on the value of the first operand. 
— The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions are performed to bring them to a common type, and the result is of that type. 
— The second and third operands have pointer type, or one has pointer type andthe other is a nullpointer constant; 
pointer conversions(4.10)and qualification conversions(4.4)are performed to bring them to their composite 
pointer type(5.9). The resultisof the composite pointer type. 
— The secondandthird operandshave pointerto membertype,or onehaspointerto membertypeandthe otherisa 
null pointer constant; pointer to member conversions(4.11)and qualification conversions(4.4)are performed to 
bring them to a common type, whose cv-qualification shall match the cv-qualification of either the second or the 
third operand. The result is of the common type. 
5.17 Assignment and compound assignment operators [expr.ass] 
1 The assignment operator(=)and the compound assignment operators all group right-to-left. All require a modifiable 
lvalueastheirleftoperandand returnanlvaluewiththetypeandvalueoftheleftoperandafterthe assignmenthastaken 
place. The result in all cases is a bit-field if the left operand is a bit-field. 

assignment-expression:
conditional-expression
logical-or-expression assignment-operator assignment-expression
throw-expression


assignment-operator: one of 

= *= /= %= += -= >>= <<= &= ^= |= 

2 In simple assignment(=), the value of the expression replaces that of the object referred to by the left operand. 

Draft 


5.18 Comma operator Expressions 104 
3 Iftheleftoperandisnotofclasstype,theexpressionis implicitlyconverted(clause 4)tothe cv-unqualifiedtypeofthe 
left operand. 

4 Ifthe left operandisof class type,the class shallbe complete. Assignmentto objectsofa classis definedbythecopy 
assignment operator(12.8, 13.5.3). 

5 [Note: For class objects, assignmentis notin general the same as initialization(8.5, 12.1, 12.6, 12.8). — end note ] 

6 When the left operand of an assignment operator denotes a reference to T, the operation assigns to the object of type T 
denoted by the reference. 

7 The behavior of an expression of the form E1 op= E2 is equivalent to E1 = E1 op E2 except that E1 is evaluated only 
once. In += and -=, E1 shall either have arithmetic type or be a pointer to a possibly cv-qualified completely defined 
object type. In all other cases, E1 shall have arithmetic type. 

8 If the value being stored in an object is accessed from another object that overlaps in any way the storage of the first 
object,thentheoverlapshallbeexactandthetwoobjectsshallhavethe sametype, otherwisethebehavioris undefined. 

5.18 Comma operator [expr.comma] 
1 The comma operator groups left-to-right. 

expression:
assignment-expression
expression , assignment-expression


Apairofexpressionsseparatedbya commaisevaluated left-to-rightandthevalueofthe leftexpressionis discarded. 
The lvalue-to-rvalue(4.1), array-to-pointer(4.2), and function-to-pointer(4.3)standard conversions are not applied to 
the leftexpression. All sideeffects(1.9)of the leftexpression,except for the destructionof temporaries(12.2), are 
performed beforetheevaluationoftherightexpression.Thetypeandvalueofthe resultarethetypeandvalueofthe 
right operand; the result is an lvalue if its right operand is an lvalue, and is a bit-field if its right operand is an lvalue and 
a bit-field. 

2 In contexts where comma isgivena special meaning,[ Example: in lists of arguments to functions(5.2.2)and lists 
of initializers(8.5) — end example ]the comma operator as described in clause 5 can appear only in parentheses. 
[Example: 

f(a, (t= 3, t+2), c); 

has three arguments, the second of which has the value 5. — end example ] 

5.19 Constant expressions [expr.const] 
1 In severalplaces,C++ requiresexpressionsthatevaluatetoanintegralor enumeration constant: as array bounds(8.3.4, 
5.3.4),ascase expressions(6.4.2),as bit-field lengths(9.6),as enumerator initializers(7.2),as static member initializers 
(9.4.2), and as integral or enumeration non-type template arguments(14.3). 

constant-expression: 

conditional-expression 
An integral constant-expression can involve only literals of arithmetic types(2.13, 3.9.1), enumerators, non-volatile 
const variables or static data members of integral or enumeration types initialized with constant expressions(8.5), 
non-type template parameters of integral or enumeration types, and sizeof expressions. Floating literals(2.13.3)can 
appear only if theyare cast to integral or enumeration types. Only type conversions to integral or enumeration types can 

Draft 


105 Expressions 5.19 Constant expressions 

be used. In particular, except in sizeof expressions, functions, class objects, pointers, or references shall not be used, 
and assignment, increment, decrement, function-call, or comma operators shall notbe used. 

2 Other expressions are considered constant-expressions only for the purpose of non-local static object initialization 
(3.6.2). Such constant expressions shall evaluate to one of the following: 

— a null pointervalue(4.10), 
— a null member pointer value(4.11), 
— an arithmetic constant expression, 
— an address constant expression, 
— a reference constant expression, 
— an address constant expression for a complete object type, plus or minus an integral constant expression, or 
— a pointer to member constant expression. 
3 An arithmetic constant expression shall satisfy the requirements for an integral constant expression, except that 
— floating literals need notbe cast to integral or enumeration type, and 
— conversions to floating point types are permitted. 
4 An address constant expression is a pointer to an lvalue designating an object of static storage duration, a string literal 
(2.13.4), or a function. The pointer shall be created explicitly, using the unary & operator, or implicitly using a nontypetemplateparameterofpointertype,orusinganexpressionofarray(4.2)or function(4.3)type.The subscripting 
operator [] and the class member access . and -> operators, the & and * unary operators, and pointer casts (except 
dynamic_casts,5.2.7)canbeusedinthe creationofan address constantexpression,butthevalueofanobjectshall 
notbe accessedbytheuseofthese operators.Ifthe subscriptingoperatorisused,oneofitsoperandsshallbeanintegral 
constantexpression. Anexpression that designates the addressofa subobjectofa non-POD class object (clause 9)is 
not an address constant expression(12.7). Function calls shall not be used in an address constant expression, even if the 
function is inline and has a reference return type. 

5Areference constant expression isanlvalue designatingan objectofstatic storage duration,a non-type template parameter of reference type, or a function. The subscripting operator [], the class member access . and -> operators, the & 
and * unary operators,and reference casts(except thoseinvoking user-defined conversion functions(12.3.2)andexcept 
dynamic_casts(5.2.7)) canbe usedin the creationofa reference constantexpression,but thevalueof an object shall 
notbe accessedbytheuseofthese operators.Ifthe subscriptingoperatorisused,oneofitsoperandsshallbeanintegral 
constantexpression. Anlvalueexpression that designatesa member or base classofa non-POD class object (clause 9) 
is nota reference constantexpression(12.7). Function calls shall notbe usedina reference constantexpression,evenif 
the function is inline and has a reference return type. 

6 Apointer to member constant expression shall be created using the unary & operator applied to a qualified-id operand 
(5.3.1), optionally precededbyapointerto member cast(5.2.9). 

Draft 


5.19 Constant expressions Expressions 106 
Draft 


Chapter6 Statements [stmt.stmt]


1 Except as indicated, statements are executed in sequence. 

statement:
labeled-statement
expression-statement
compound-statement
selection-statement
iteration-statement
jump-statement
declaration-statement
try-block


6.1 Labeled statement [stmt.label] 
1 Astatement can be labeled. 

labeled-statement:
identifier : statement
case constant-expression : statement
default : statement


An identifier label declares the identifier. The only use of an identifier label is as the target of a goto. The scope of a 
labelis the functionin whichit appears. Labels shall notbe redeclared withinafunction.Alabel canbe usedina goto 
statement before its definition. Labels have their own name space and do not interfere with other identifiers. 

2 Case labels and default labels shall occur only in switch statements. 

6.2 Expression statement [stmt.expr] 
1 Expression statementshavethe form 

expression-statement:
expressionopt ;


Theexpressionisevaluatedanditsvalueis discarded. Thelvalue-to-rvalue(4.1), array-to-pointer(4.2),and function-
to-pointer(4.3)standardconversionsarenotappliedtotheexpression.Allsideeffectsfromanexpression statementare 
completed before the next statement is executed. An expression statement with the expression missing is called a null 
statement.[ Note: Most statements areexpression statements — usually assignments or function calls.Anull statement 
is useful to carry a label just before the } ofa compound statementandto supplya nullbodytoaniterationstatement 
such as a while statement(6.5.1). — end note ] 

6.3 Compound statement or block [stmt.block] 
1 So that several statements can be used where one is expected, the compound statement (also, and equivalently, called 


6.4 Selection statements Statements 108 
“block”) is provided. 

compound-statement:
{ statement-seqopt }


statement-seq:
statement
statement-seq statement


Acompound statement definesa local scope(3.3).[Note: a declaration is a statement (6.7). — end note ] 

6.4 Selection statements [stmt.select] 
1 Selection statements choose one of several flows of control. 

selection-statement:
if ( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement


condition:
expression
type-specifier-seq declarator = assignment-expression


In clause 6, the term substatement refers to the contained statement or statements that appear in the syntax notation. 
The substatement in a selection-statement (each substatement, in the else form of the if statement) implicitly defines 
alocalscope(3.3).Ifthe substatementina selection-statementisasingle statementandnota compound-statement, it 
isasifitwasrewrittentobea compound-statement containingthe original substatement.[ Example: 

if (x)
int i;


can be equivalently rewritten as 

if (x) {
int i;
}


Thus after the if statement, i is no longer in scope. — end example ] 

2 The rules for conditions apply both to selection-statement s and to the for and while statements(6.5). The declarator 
shall not specify a function or an array. The type-specifier-seq shall not contain typedef and shall not declare a new 
class or enumeration. 

3 Aname introduced by a declaration in a condition (either introduced by the type-specifier-seq or the declarator of the 
condition) is in scope from its point of declaration until the end of the substatements controlled by the condition. If the 
nameis re-declaredinthe outermost blockofa substatement controlledbythe condition,the declaration that re-declares 
the nameis ill-formed.[ Example: 

if (int x = f()) { 

int x; // ill-formed, redeclaration of x
}
else {


int x; // ill-formed, redeclaration of x
}


Draft 


109 Statements 6.4 Selection statements 

— end example ] 
4 The value of a condition that is an initialized declaration in a statement other than a switch statement is the value of 
the declared variable implicitly converted to type bool. If that conversion is ill-formed, the program is ill-formed. The 
value of a condition that is an initialized declaration in a switch statement is the value of the declared variable if it 
has integral or enumeration type, or of that variable implicitly converted to integral or enumeration type otherwise. The 
valueofa condition thatisanexpressionisthevalueoftheexpression, implicitly convertedto bool for statements other 
than switch if that conversionisill-formed, the programis ill-formed. Thevalueof the condition willbe referredto as 
simply “the condition” where the usage is unambiguous. 

5 Ifa condition can be syntactically resolved as either an expression or the declaration ofa local name, it is interpreted as 
a declaration. 

6.4.1 The if statement [stmt.if] 
1 If the condition(6.4)yieldstrue the first substatementisexecuted.Ifthe else part of the selection statement is present 
and the condition yields false, the second substatement is executed. In the second form of if statement (the one 
including else), if the first substatement is also an if statement then that inner if statement shall contain an else 
part.81) 

6.4.2 The switch statement [stmt.switch] 
1 The switch statement causes controltobe transferredtooneofseveral statements dependingonthevalueofacondition. 

2 The condition shall be of integral type, enumeration type, or of a class type for which a single conversion function to 
integralor enumerationtypeexists(12.3).Ifthe conditionisof classtype,the conditionisconvertedby callingthat 
conversion function, and the result of the conversion is used in place of the original condition for the remainder of this 
section. Integral promotions are performed. Any statement within the switch statement can be labeled with one or 
more case labels as follows: 

case constant-expression : 

where the constant-expression shall be an integral constant-expression. The integral constant-expression(5.19)is implicitly converted to the promoted type of the switch condition. No two of the case constants in the same switch shall 
have the same value after conversion to the promoted type of the switch condition. 

3 There shall be at most one label of the form 

default : 

within a switch statement. 

4 Switch statements can be nested; a case or default label is associated with the smallest switch enclosing it. 

5 When the switch statementisexecuted,its conditionisevaluatedand comparedwitheachcase constant.Ifoneofthe 
case constants is equal to the value of the condition, control is passed to the statement following the matched case label. 
If no case constant matches the condition, and if there is a default label, control passes to the statement labeledby the 
default label. If no case matches and if there is no default then none of the statements in the switch is executed. 

6 case and default labels in themselves do not alter the flow of control, which continues unimpeded across such labels. 
Toexit froma switch, seebreak, 6.6.1.[ Note: usually,the substatementthatisthe subjectofa switchis compoundand 

81) In other words, the else is associated with the nearest un-elsed if. 

Draft 


6.5 Iteration statements Statements 110 
case and default labels appearonthetop-level statements contained withinthe (compound) substatement,butthisis 
not required. Declarations can appear in the substatement of a switch-statement. — end note ] 

6.5 Iteration statements [stmt.iter] 
1 Iteration statements specify looping. 

iteration-statement:
while ( condition ) statement
do statement while ( expression );
for ( for-init-statement conditionopt ; expressionopt ) statement


for-init-statement:
expression-statement
simple-declaration


[Note: a for-init-statement ends with a semicolon. — end note ] 

2 The substatement in an iteration-statement implicitly definesa local scope(3.3)whichis enteredandexited each time 
through the loop. 

Ifthe substatementinan iteration-statementisasingle statementandnota compound-statement, itis asifitwas rewritten 
tobea compound-statement containing the original statement.[ Example: 

while (--x >= 0)
int i;


can be equivalently rewritten as 

while (--x >= 0) {
int i;
}


3 Thus after the while statement, i is no longer in scope. — end example ]
4[Note: The requirements on conditions in iteration statements are described in 6.4. — end note ]


6.5.1 The while statement [stmt.while] 
1 In the while statementthe substatementisexecuted repeatedly untilthevalueofthe condition(6.4)becomesfalse. 
The test takes place before each execution of the substatement. 

2 Whenthe conditionofawhile statementisadeclaration,thescopeofthevariablethatis declaredextendsfromitspoint 
of declaration(3.3.1)totheendofthe whilestatement.Awhile statement of the form 

while (T t = x) statement 

is equivalent to 

label : 

{ // start of condition scope
T t = x;
if (t) {


statement 

goto label ; 

Draft 


111 Statements 6.5 Iteration statements 

}
} // end of condition scope


The object createdina conditionis destroyed and created with each iterationof theloop.[ Example: 

struct A {
int val ;
A(int i) : val(i) { }
~A() { }


operator bool () { return val != 0; }
};
int i =1;
while (A a = i) {
// ... 

i =0;
}


In the while-loop, the constructor and destructor are each called twice, once for the condition that succeeds and once for 
the condition thatfails. — end example ] 

6.5.2 The do statement [stmt.do] 
1 The expression is implicitly converted to bool;if that is not possible, the program is ill-formed. 

2 In the do statement the substatement is executed repeatedly until the value of the expression becomes false. The test 
takes place after each execution of the statement. 

6.5.3 The for statement [stmt.for] 
1 The for statement 

for ( for-init-statement conditionopt ; expressionopt ) statement 

is equivalent to 

{ 

for-init-statement 

while ( condition ){
statement
expression ;


}
}


except that names declared in the for-init-statement are in the same declarative-region as those declared in the condition, 
and except that a continue in statement (not enclosed in another iteration statement) will execute expression before 
re-evaluating condition.[ Note: Thus the firststatement specifies initialization for the loop; the condition(6.4)specifies 
a test, made before each iteration, such that the loop is exited when the condition becomes false;the expression often 
specifies incrementing that is done after each iteration. — end note ] 

2 Either or bothof the condition and theexpression canbe omitted.Amissing condition makes the implied while clause 
equivalent to while(true). 

Draft 


6.6 Jump statements Statements 112 
3 If the for-init-statement is a declaration, the scope of the name(s) declared extends to the end of the for-statement. 
[Example: 

int i =42;
int a [10];


for (int i =0; i <10; i++)
a[i] = i;


int j= i; // j = 42 

— end example ] 
6.6 Jump statements [stmt.jump] 
1 Jump statements unconditionally transfer control. 

jump-statement: 

break ;
continue ;
return expressionopt ;
goto identifier ;


2 Onexit froma scope(however accomplished), destructors(12.4)are called for all constructedobjectswith automatic 
storage duration(3.7.2)(named objects or temporaries) that are declared in that scope, in the reverse order of their 
declaration. Transfer out of a loop, out of a block, or back past an initialized variable with automatic storage duration 
involvesthe destructionofvariableswith automaticstorage durationthatareinscopeatthepoint transferredfrombut 
not at the point transferred to. (See 6.7 for transfers into blocks).[ Note: However, the program can be terminated (by 
calling std::exit() or std::abort() (18.3), for example) without destroying class objects with automatic storage 
duration. — end note ] 

6.6.1 The break statement [stmt.break] 
1 The break statement shall occur only in an iteration-statement or a switch statement and causes termination of the 
smallest enclosing iteration-statement or switch statement; control passes to the statement followingthe terminated 
statement, if any. 

6.6.2 The continue statement [stmt.cont] 
1 The continue statement shall occur only in an iteration-statement and causes control to pass to the loop-continuation 
portion of the smallest enclosing iteration-statement, that is, to the end of the loop. More precisely, in each of the 
statements 

while (foo) { do { for (;;) {
{{{


// ... // ... // ... 

}}}
contin : ; contin : ; contin : ;
} } while (foo); }


Draft 


113 Statements 6.7 Declaration statement 

a continue not containedinan enclosediteration statementisequivalentto goto contin. 

6.6.3 The return statement [stmt.return] 
1 Afunction returns to its caller by thereturn statement. 

2Areturn statement withoutanexpressioncanbeusedonlyin functionsthatdonot returnavalue,thatis,a functionwith 
the return type void,a constructor(12.1),ora destructor(12.4).Areturn statementwithanexpressionof non-voidtype 
can be used only in functions returning a value; the value of the expression is returned to the caller of the function. The 
expression is implicitly converted to the return type of the function in which it appears. Areturn statement can involve 
the constructionandcopyofa temporaryobject(12.2).Flowingofftheendofa functionisequivalenttoa return with 
no value; this results in undefined behavior in a value-returning function. 

3 Areturn statement withan expression of type “cv void” can be used only in functions with a return type of cv void; the 
expression is evaluated just before the function returns to its caller. 

6.6.4 The goto statement [stmt.goto] 
1 The goto statement unconditionally transfers control to the statement labeled by the identifier. The identifier shallbe a 
label(6.1)locatedin the current function. 

6.7 Declaration statement [stmt.dcl] 
1 Adeclaration statement introduces one or more new identifiers intoa block;it hasthe form 

declaration-statement:
block-declaration


Ifan identifier introducedbya declarationwaspreviously declaredinan outerblock,the outer declarationishiddenfor 
the remainder of the block, after which it resumes its force. 

2 Variables with automatic storage duration(3.7.2)are initialized each time theirdeclaration-statement is executed.Variables with automatic storage duration declaredin the block are destroyed onexit from the block(6.6). 

3 Itis possibleto transfer intoa block,but notinaway that bypasses declarations with initialization. A program that 
jumps82) from a point where a local variable with automatic storage duration is not in scope to a point where it is in 
scopeis ill-formed unlessthevariable has POD type(3.9)andis declared without aninitializer (8.5). 

[Example: 

void f()
{


// ...
goto lx ; // ill-formed: jump into scope of a
// ...


ly:
X a =1;


// ... 

lx: 
goto ly ; // OK, jump implies destructor
// call for a followedby construction
// again immediately following label ly


} 

82) The transfer from the condition of a switch statement to a case label is considered a jump in this respect. 

Draft 


6.8 Ambiguity resolution Statements 114 
— end example ] 
4 The zero-initialization(8.5)of all local objects with static storage duration(3.7.1)is performed before anyother initialization takes place.Alocal objectof POD type(3.9)with static storage duration initializedwithconstant-expressions is 
initialized beforeits blockis first entered.An implementationis permittedto performearly initializationof other local 
objects with static storage duration under the same conditions that an implementation is permitted to statically initialize 
an object with static storage duration in namespace scope(3.6.2). Otherwise such an object is initialized the first time 
control passes through its declaration; such an object is considered initialized upon the completion of its initialization. 
If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next 
time control enters the declaration. If control re-enters the declaration (recursively) while the object is being initialized, 
the behavioris undefined.[ Example: 

int foo(int i) 

{
static int s = foo (2* i ); // recursive call -undefined
return i +1;


} 

— end example ] 
5 The destructorforalocalobjectwithstaticstorage durationwillbeexecutedifandonlyifthevariablewas constructed. 
[Note: 3.6.3 describes the order in which local objects with static storage duration are destroyed. — end note ] 

6.8 Ambiguity resolution [stmt.ambig] 
1 There is an ambiguity in the grammar involving expression-statements and declarations: An expression-statement with 
afunction-styleexplicittypeconversion(5.2.3)asits leftmostsubexpressioncanbe indistinguishablefromadeclaration 
where the first declarator starts witha (. In those cases the statement isa declaration.[ Note: Todisambiguate, the whole 
statement might have to be examined to determine if it is an expression-statement or a declaration. This disambiguates 
many examples.[Example: assuming T is a simple-type-specifier (7.1.5), 

T(a)->m = 7; // expression-statement
T(a )++; // expression-statement
T(a ,5) < <c; // expression-statement


T(*d)( int ); // declaration
T(e )[5]; // declaration
T(f) = { 1, 2 }; // declaration
T(*g)(double (3)); // declaration


In the last example above, g, which is a pointer to T, is initialized to double(3). This is of course ill-formed for 
semantic reasons,but thatdoes notaffect the syntactic analysis. — end example ] 

2 The remaining cases are declarations.[ Example: 

class T { 

// ... 

public :
T ();
T( int );
T(int , int);


Draft 


115 Statements 6.8 Ambiguityresolution 

};
T(a ); // declaration
T(*b )(); // declaration
T(c )=7; // declaration
T(d),e,f =3; // declaration
extern int h;
T(g)(h ,2); // declaration


— end example ] — end note ] 
The disambiguationispurely syntactic;thatis,themeaningofthe names occurringinsucha statement,beyond whether 
they are type-names or not, is not generally used in or changed by the disambiguation. Class templates are instantiated 
as necessary to determine if a qualified name is a type-name. Disambiguation precedes parsing, and a statement disambiguated as a declaration may be an ill-formed declaration. If, during parsing, a name in a template parameter is bound 
differently thanitwouldbebound duringa trial parse,the programis ill-formed.No diagnosticis required.[ Note: This 
can occur only when the name is declared earlier in the declaration. — end note ][Example: 

struct T1 {
T1 operator()(int x) { return T1(x); }
int operator =( int x ) { return x ; }
T1(int) { }


};
struct T2 { T2(int){ } };
int a, (*(*b)(T2))(int), c, d;


void f() { 

// disambiguation requires this to be parsed
// as a declaration


T1(a) = 3,
T2 (4) , // T2 will be declared as
(*(* b)( T2(c )))( int (d )); // a variable of type T1


// but this will not allow 
// the last part of the 
// declaration to parse 
// properly since it depends 
// on T2 being a type-name 

} 

— end example ] 
Draft 


6.8 Ambiguity resolution Statements 116 
Draft 


Chapter7 Declarations [dcl.dcl]


1 Declarations specify how names are to be interpreted. Declarations have the form 

declaration-seq:
declaration
declaration-seq declaration


declaration:
block-declaration
function-definition
template-declaration
explicit-instantiation
explicit-specialization
linkage-specification
namespace-definition


block-declaration:
simple-declaration
asm-definition
namespace-alias-definition
using-declaration
using-directive
static_assert-declaration


simple-declaration:
decl-specifier-seqopt init-declarator-listopt ;


static_assert-declaration:
static_assert ( constant-expression , string-literal );


[Note: asm-definitions are described in 7.4, and linkage-specifications are described in 7.5. Function-definitions are described in 8.4 and template-declarationsare described in clause 14. Namespace-definitions are described in 7.3.1,usingdeclarations are described in 7.3.3 and using-directives are described in 7.3.4. — end note ]Thesimple-declaration 

decl-specifier-seqopt init-declarator-listopt ; 

is divided into two parts: decl-specifiers, the components of a decl-specifier-seq, are described in 7.1 and declarators, 
the components of an init-declarator-list, are describedin clause 8. 

2Adeclaration occursinascope(3.3);thescoperulesare summarizedin 3.4.Adeclarationthat declaresa functionor 
defines a class, namespace, template, or function also has one or more scopes nested within it. These nested scopes, in 
turn, canhave declarations nested within them. Unless otherwise stated, utterancesin clause 7about componentsin,of, 
or contained by a declaration or subcomponent thereof refer only to those components of the declaration that are not 
nested within scopes nested within the declaration. 


7.1 Specifiers Declarations 118 
3 Ina simple-declaration, the optional init-declarator-list canbe omittedonly when declaringa class (clause 9)or enumeration(7.2), that is, when the decl-specifier-seq contains either a class-specifier, an elaborated-type-specifier with a 
class-key (9.1), or an enum-specifier. In these cases and whenever a class-specifier or enum-specifier is present in the 
decl-specifier-seq, the identifiers in these specifiers are among the names being declared by the declaration (as class-
names, enum-names, or enumerators, depending on the syntax). In such cases, and except for the declaration of an 
unnamed bit-field(9.6), the decl-specifier-seq shall introduce one or more names into the program, or shall redeclare a 
name introducedbya previous declaration.[ Example: 

enum { }; // ill-formed
typedef class { }; // ill-formed


— end example ] 
4 Ina static_assert-declaration the constant-expression shallbeanintegral constantexpression(5.19).Ifthevalueofthe 
expression when converted to bool is true, the declaration has no effect. Otherwise, the program is ill-formed, and 
the resulting diagnostic message(1.4)shall include the text of thestring-literal, except that characters not in the basic 
source characterset(2.2)arenot requiredto appearinthe diagnostic message.[ Example: 

static_assert(sizeof(long) >= 8, "64-bit code generation not supported."); 

— end example ] 
5 Each init-declarator in the init-declarator-list contains exactly one declarator-id, which is the name declared by that 
init-declarator and hence one of the names declared by the declaration. The type-specifiers (7.1.5)in thedecl-specifierseq and the recursive declarator structure of the init-declarator describea type(8.3), whichis then associated with the 
name being declared by the init-declarator. 

6 If the decl-specifier-seq contains the typedef specifier, the declaration is called a typedef declaration and the name of 
each init-declarator is declared to be a typedef-name, synonymous with its associated type(7.1.3). If the decl-specifierseq contains no typedef specifier, the declaration is called a function declaration if the type associated with the name 
isa function type(8.3.5)and anobject declaration otherwise. 

7 Syntactic components beyond those found in the general form of declaration are added to a function declaration to 
make a function-definition. An object declaration, however, is also a definition unless it contains the extern specifier 
andhasno initializer(3.1).Adefinition causesthe appropriate amountof storagetobe reservedandanyappropriate 
initialization(8.5)tobe done. 

8 Only in function declarations for constructors, destructors, andtype conversions can the decl-specifier-seq be omitted.83) 

7.1 Specifiers [dcl.spec] 
1 The specifiers that can be used in a declaration are 

decl-specifier:
storage-class-specifier
type-specifier
function-specifier


friend
typedef


83) The “implicit int” ruleofCis no longer supported. 

Draft 


119 Declarations 7.1 Specifiers 

decl-specifier-seq:
decl-specifier-seqopt decl-specifier


2 The longest sequence of decl-specifiers that could possibly be a type name is taken as the decl-specifier-seq of a declaration. The sequence shallbe self-consistent as described below.[ Example: 

typedef char* Pc;
static Pc ; // error: name missing


Here, the declaration static Pc is ill-formed because no name was specified for the static variable of type Pc.To get a 
variable called Pc,a type-specifier (other than const or volatile)has to be present to indicate that thetypedef-name 
Pc is the name being (re)declared, rather than being part of the decl-specifier sequence.For anotherexample, 

void f( const Pc ); // void f(char* const) (not const char*)
void g( const int Pc ); // void g(const int)


— end example ] 
3 [Note: since signed, unsigned, long, and short by default imply int,a type-name appearing after one of those 

specifiersis treated as the name being (re)declared.[ Example:
void h( unsigned Pc ); // void h(unsigned int)
void k( unsigned int Pc ); // void k(unsigned int)


— end example ] — end note ] 
7.1.1 Storage class specifiers [dcl.stc] 
1 The storage class specifiers are 

storage-class-specifier: 

auto
register
static
extern
mutable


At most one storage-class-specifier shall appear in a given decl-specifier-seq. Ifa storage-class-specifier appears in 
a decl-specifier-seq, there can be no typedef specifier in the same decl-specifier-seq and the init-declarator-list of 
the declaration shall not be empty (except for global anonymous unions, which shall be declared static (9.5)). The 
storage-class-specifier applies to the name declared by each init-declarator in the list and not to any names declared 
by other specifiers. Astorage-class-specifier shall notbe specifiedin anexplicit specialization(14.7.3)or anexplicit 
instantiation(14.7.2)directive. 

2 The auto or register specifiers can be applied only to names of objects declared in a block(6.3)or to function 
parameters(8.4).Theyspecifythatthe namedobjecthas automatic storage duration(3.7.2).Anobject declared without 
a storage-class-specifier at block scope or declared as a function parameter has automatic storage duration by default. 
[Note: hence, the auto specifier is always redundant and not often used; one use of auto isto distinguisha declaration-
statement from an expression-statement explicitly rather than relying on the disambiguation rules(6.8), which mayaid 
readers. — end note ] 

3Aregister specifier has the same semantics as an auto specifier togetherwithahinttotheimplementationthatthe 
objectso declaredwillbeheavilyused.[ Note: the hint canbeignored andin most implementationsit willbe ignoredif 
the addressof the objectistaken. — end note ] 

Draft 


7.1 Specifiers Declarations 120 
4 The static specifier canbe appliedonlyto namesof objectsand functionsandto anonymous unions(9.5). There can 
be no static function declarations within a block, nor any static function parameters. Astatic specifier used in 
the declarationofan object declaresthe objecttohave static storage duration(3.7.1).A static specifier can be used in 
declarationsof class members; 9.4 describes itseffect.For the linkageof a name declared witha static specifier, see 

3.5. 
5 The extern specifier can be applied only to the names of objects and functions. The extern specifier cannot be used in 
the declaration of class members or function parameters. For the linkage of a name declared with an extern specifier, 
see 3.5. 

6 A name declared in a namespace scope without a storage-class-specifier has external linkage unless it has internal 
linkage because of a previous declaration and provided it is not declared const. Objects declared const and not 
explicitly declared extern have internal linkage. 

7 The linkages implied by successive declarations for a given entity shall agree. That is, within a given scope, each 
declaration declaring the same object name or the same overloading of a function name shall imply the same linkage. 
Each functioninagiven setofoverloaded functions canhavea different linkage,however.[ Example: 

static char * f (); // f() has internal linkage
char* f() // f() still has internal linkage
{ /* ... * / }


char* g(); // g() has external linkage
static char * g () // error: inconsistent linkage
{ /* ... * / }


void h();
inline void h (); // external linkage


inline void l ();
void l (); // external linkage


inline void m ();
extern void m (); // external linkage


static void n ();
inline void n (); // internal linkage


static int a; // a has internal linkage
int a; // error: two definitions


static int b; // b has internal linkage
extern int b; // b still has internal linkage


int c; // c has external linkage
static int c; // error: inconsistent linkage


extern int d; // d has external linkage
static int d; // error: inconsistent linkage


Draft 


121 Declarations 7.1 Specifiers 

— end example ] 
8 The nameofa declaredbut undefined class canbe usedin an extern declaration. Such a declaration can only be used 
inways thatdo not requireacomplete class type.[Example: 

struct S;
extern S a;
extern S f ();
extern void g(S);


void h() 

{
g(a ); // error: S is incomplete
f (); // error: S is incomplete


} 

— endexample ]Themutable specifier can be applied only to names of class data members(9.2)and cannot be applied 
to names declared const or static,and cannotbe appliedtoreference members.[Example: 
class X {
mutable const int* p; // OK
mutable int* const q; // ill-formed


}; 

— end example ] 
9 The mutable specifier on a class data member nullifies a const specifier applied to the containing class object and 
permits modification of the mutable class member even though the rest of the object is const (7.1.5.1). 

7.1.2 Function specifiers [dcl.fct.spec] 
1 Function-specifiers can be used only in function declarations. 
function-specifier: 

inline
virtual
explicit


2 A function declaration(8.3.5, 9.3, 11.4)with an inline specifier declares an inline function. The inline specifier 
indicates to the implementation that inline substitution of the function body at the point of call is to be preferred to the 
usual function call mechanism. An implementation is not required to perform this inline substitution at the point of 
call;however, evenif this inline substitutionis omitted, the other rules for inline functions definedby 7.1.2 shall stillbe 
respected. 

3 Afunction defined withina class definitionisan inline function. Theinline specifier shall not appear ona block scope 
function declaration.84) If the inline specifier is used in a friend declaration, that declaration shall be a definition or 
the function shall have previously been declared inline. 

4 An inline functionshallbe definedinevery translationunitinwhichitisusedandshallhaveexactlythe same definition 
inevery case(3.2).[Note: a call to the inline function may be encountered before its definition appears in the translation 
unit. — end note ]If the definition of a function appears in a translation unit before its first declaration as inline, the 

84) The inlinekeyword has noeffect on the linkageofa function. 

Draft 


7.1 Specifiers Declarations 122 
program is ill-formed. If a function with external linkage is declared inline in one translation unit, it shall be declared 
inline in all translation units in which it appears; no diagnostic is required. An inline function with externallinkage 
shall have the same address in all translation units. A static local variable in an extern inline function always 
referstothe sameobject.Astring literalinan extern inline function is the same objectin different translation units. 

5 The virtual specifier shall only be used in declarations of non-static class member functions that appear within a 
member-specification of a class definition; see 10.3. 

6 The explicit specifier shallbe used onlyindeclarationsof constructors withina class definition;see 12.3.1. 

7.1.3 The typedef specifier [dcl.typedef] 
1 Declarations containing the decl-specifier typedef declare identifiers that can be used later for naming fundamental 
(3.9.1)or compound(3.9.2)types. Thetypedef specifier shall notbe usedina function-definition (8.4), and it shall not 
be combined in a decl-specifier-seq with anyother kind of specifier except a type-specifier. 

typedef-name: 

identifier 
Aname declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a typedefname is syntacticallyequivalenttoakeywordand namesthetype associated withtheidentifierintheway describedin 
clause8.A typedef-name is thusa synonym for another type.A typedef-name does not introduce a new type the way a 
class declaration(9.1)or enum declaration does.[ Example: after 

typedef int MILES , * KLICKSP ; 

the constructions 

MILES distance ;
extern KLICKSP metricp ;


are all correct declarations;the type of distance is int that of metricp is “pointer to int.” — end example ] 

2 In a given non-class scope, a typedef specifier can be used to redefine the name of anytype declared in that scope to 
refertothetypeto whichitalready refers.[ Example: 

typedef struct s { /* ... * / } s;
typedef int I;
typedef int I;
typedef I I;


— end example ] 
3 In a give class scope, a typedef specifier can be used to redefine any class-name declared in that scope that is not also 
a typedef-name to refer to the type to whichitalready refers. 
[Example: 

struct S {
typedef struct A {} A; // OK
typedef struct B B; // OK
typedef A A; // error


Draft 


123 Declarations 7.1 Specifiers 

— end example ] 
4 In a given scope, a typedef specifier shall not be used to redefine the name of anytype declared in that scope to refer 
toa different type.[ Example: 

class complex { /* ... * / };
typedef int complex ; // error: redefinition


— end example ] 
5 Similarly, in a given scope, a class or enumeration shall not be declared with the same name as a typedef-name that is 
declaredinthatscopeandreferstoatypeotherthantheclassor enumeration itself.[ Example: 

typedef int complex ;
class complex { /* ... * / }; // error: redefinition


— end example ] 
6[Note: Atypedef-name that namesa class type,ora cv-qualifiedversion thereof,is alsoa class-name (9.1). Ifa typedefname is used to identify the subject of an elaborated-type-specifier (7.1.5.3),a class definition(clause 9),a constructor 
declaration(12.1), ora destructor declaration(12.4), the programis ill-formed. — end note ] 

[Example: 

struct S {
S();
~S();


}; 

typedef struct S T; 

S a = T(); // OK
struct T * p; // error


— end example ] 
7 If the typedef declaration defines an unnamed class (or enum), the first typedef-name declared by the declaration to be 
thatclasstype(orenumtype)isusedtodenotetheclasstype(orenumtype)forlinkage purposesonly(3.5).[Example: 
typedef struct { } *ps, S; // S is the class name for linkage purposes 

— end example ] 
8 [Note: if the typedef-name is used where a class-name (or enum-name)is required, the program is ill-formed. For 
example, 

typedef struct {
S (); // error: requires a return type because S is
// an ordinary member function, not a constructor


} S; 

— end note ] 
Draft 


7.1 Specifiers Declarations 124 
9 If a typedef TD names a type “reference to cv1 S”, an attempt to create the type “reference to cv2 TD” creates the type 
“reference to cv12 S”, where cv12 is the union of the cv-qualifiers cv1 and cv2. Redundant qualifiers are ignored. 
[Example: 

int i;
typedef int& RI;
RI& r1 = i; // r1 has the type int&
const RI& r2 = i; // r2 has the type const int&


— end example ] 
7.1.4 The friend specifier [dcl.friend] 
The friend specifier is used to specify access to class members; see 11.4. 

7.1.5 Type specifiers [dcl.type] 
1 The type-specifiers are 

type-specifier:
simple-type-specifier
class-specifier
enum-specifier
elaborated-type-specifier
typename-specifier
cv-qualifier


2 As a general rule, at most one type-specifier is allowed in the complete decl-specifier-seq of a declaration. The only 
exceptions to this rule are the following: 

— const or volatile can be combined with anyother type-specifier. However, redundant cv-qualifiers are prohibitedexceptwhen introduced through the useof typedefs(7.1.3)or template type arguments(14.3),in which case 
the redundant cv-qualifiers are ignored. 
— signed or unsigned can be combined with char, long, short, or int. 
— short or long can be combined with int. 
— long can be combined with double. 
— long can be combined with long. 
3 At least one type-specifier thatis nota cv-qualifier is requiredina declaration unlessit declaresa constructor, destructor 
or conversion function.85) 

4 [Note: class-specifiersandenum-specifiersarediscussedin clause9and7.2,respectively.The remainingtype-specifiers 
are discussedin the restofthis section. — end note ] 

85) There is no special provision for a decl-specifier-seq that lacks a type-specifier or that has a type-specifier that only specifies cv-qualifiers. The 
“implicit int” ruleofCis no longer supported. 

Draft 


125 Declarations 7.1 Specifiers 

7.1.5.1 The cv-qualifiers [dcl.type.cv] 
1 There are two cv-qualifiers, const and volatile. Ifa cv-qualifier appears in a decl-specifier-seq, the init-declaratorlist of the declaration shall not be empty. [Note: 3.9.3 describes how cv-qualifiers affect object and function types. 

— end note ] 
2 An object declared in namespace scope with a const-qualified type has internal linkage unless it is explicitly declared 
extern or unlessitwaspreviously declaredtohaveexternal linkage.Avariableof non-volatile const-qualifiedintegral 
or enumeration typeinitializedby an integral constantexpression canbe usedin integral constantexpressions(5.19). 
[Note: as described in 8.5, the definition of an object or subobject of const-qualified type must specify an initializer or 
be subject to default-initialization. — end note ] 

3Apointeror referencetoa cv-qualifiedtypeneednotactuallypointorrefertoa cv-qualifiedobject,butitis treatedas 
if it does; a const-qualified access path cannot be used to modify an object even if the object referenced is a non-const 
object and can be modified through some other access path.[ Note: cv-qualifiers are supported by the type system so 
that theycannot be subverted without casting(5.2.11). — end note ] 

4 Except that anyclass member declared mutable (7.1.1)can be modified, anyattempt to modify a const object during 
its lifetime(3.8)results in undefined behavior. 

[Example: 

const int ci = 3; // cv-qualified (initialized as required)
ci =4; // ill-formed: attempt to modify const


int i =2; // not cv-qualified
const int * cip ; // pointer toconst int
cip = &i; // OK: cv-qualified access path to unqualified


*cip = 4; // ill-formed: attempt to modify through ptr to const 
int* ip;
ip = const_ cast <int*>(cip); // cast needed to convert const int* to int*


*ip =4; // defined: *ip points to i, a non-const object 
const int * ciq = new const int (3); // initialized as required
int* iq = const_cast <int*>(ciq); // cast required


*iq =4; // undefined: modifies a const object 
5 For another example 

class X { 

public :
mutable int i;
int j;


};
class Y {


public :
X x;
Y ();


}; 

Draft 


7.1 Specifiers Declarations 126 
const Y y; 

y.x.i ++; // well-formed: mutable member can be modified 
y.x.j ++; // ill-formed: const-qualified member modified
Y* p = const_ cast <Y*>(&y); // cast away const-ness of y
p->x.i = 99; // well-formed: mutable member can be modified
p->x.j = 99; // undefined: modifies a const member
— end example ] 
6 Ifan attemptismadetorefertoanobject definedwithavolatile-qualifiedtypethroughtheuseofanlvaluewitha 
non-volatile-qualified type,the program behaviouris undefined. 

7 [Note: volatile isahinttothe implementationtoavoid aggressive optimizationinvolvingtheobject becausethevalue 
oftheobjectmightbechangedby means undetectablebyan implementation.See 1.9for detailed semantics.Ingeneral, 
the semantics of volatile are intendedtobethe sameinC++ as theyare in C. — end note ] 

7.1.5.2 Simple type specifiers [dcl.type.simple] 
1 The simple type specifiers are 

simple-type-specifier: 

::opt nested-name-specifieropt type-name 

::opt nested-name-specifier template template-id 

char 

wchar_t 

bool 

short 

int 

long 

signed 

unsigned 

float 

double 

void 

type-name:
class-name
enum-name
typedef-name


2 The simple-type-specifier sspecifyeitherapreviously-declareduser-definedtypeoroneofthe fundamentaltypes(3.9.1). 
Table8summarizes thevalid combinationsof simple-type-specifier s and the types theyspecify. 

Table 8:simple-type-specifier s and the types theyspecify 

Specifier(s) Type 

type-name the type named
char “char”
unsigned char “unsigned char”
signed char “signedchar”
bool “bool”
unsigned “unsigned int”


Draft 


127 Declarations 7.1 Specifiers 


Specifier(s) Type 

type-name the type named
unsigned int “unsigned int”
signed “int”
signed int “int”
int “int”
unsigned short int “unsigned short int”
unsigned short “unsigned short int”
unsigned long int “unsigned long int”
unsigned long “unsigned long int”
unsigned long long int “unsigned long long int”
unsigned long long “unsigned long long int”
signed long int “longint”
signed long “longint”
signed long long int “longlong int”
signed long long “longlong int”
long long int “longlong int”
long long “longlong int”
long int “long int”
long “long int”
signed short int “short int”
signed short “short int”
short int “short int”
short “short int”
wchar_t “wchar_t”
float “float”
double “double”
long double “longdouble”
void “void”



3 When multiple simple-type-specifiers are allowed, they can be freely intermixed with other decl-specifiers in anyorder. 
It is implementation-defined whether bit-fields and objects of char type are represented as signed or unsigned quantities. 
The signed specifier forces char objects and bit-fields to be signed; it is redundant with other integral types. 

7.1.5.3 Elaborated type specifiers [dcl.type.elab] 
elaborated-type-specifier:
class-key ::opt nested-name-specifieropt identifier
class-key ::opt nested-name-specifieropt templateopt template-id
enum ::opt nested-name-specifieropt identifier


1 If an elaborated-type-specifier isthe sole constituentofa declaration,the declarationis ill-formed unlessitisanexplicit 
specialization(14.7.3), anexplicit instantiation(14.7.2)orit has oneof the followingforms: 

Draft 


7.2 Enumeration declarations Declarations 128 
class-keyidentifier ;
friend class-key ::opt identifier ;
friend class-key ::opt template-id ;
friend class-key ::opt nested-name-specifier identifier ;
friend class-key ::opt nested-name-specifier templateopt template-id ;


2 3.4.4 describes how name lookup proceeds for the identifier in an elaborated-type-specifier. If the identifier resolves 
to a class-name or enum-name, the elaborated-type-specifier introduces it into the declaration the same way a simple-
type-specifier introduces its type-name. If the identifier resolves to a typedef-name, the elaborated-type-specifier is 
ill-formed.[ Note: this implies that, within a class template with a template type-parameter T, the declaration 
friend class T; 

is ill-formed. — end note ] 

3 The class-key or enum keyword present in theelaborated-type-specifier shall agree in kind with the declaration to which 
the name in the elaborated-type-specifier refers. This rule also applies to the form of elaborated-type-specifier that 
declares a class-name or friend class since it can be construed as referring to the definition of the class. Thus, in any 
elaborated-type-specifier, the enum keyword shall be usedto refer to an enumeration(7.2), the union class-key shall be 
usedto refertoa union (clause 9),and eitherthe class or struct class-key shallbe usedto refertoa class (clause 9) 
declared using the class or struct class-key. 

7.2 Enumeration declarations [dcl.enum] 
1 An enumerationisa distinct type(3.9.1)with named constants. Its name becomes anenum-name, within its scope. 
enum-name: 
identifier 
enum-specifier: 
enum identifieropt{ enumerator-listopt} 
enumerator-list: 
enumerator-definition 
enumerator-list , enumerator-definition 
enumerator-definition: 
enumerator 
enumerator = constant-expression 
enumerator: 
identifier 

2 The identifiers in an enumerator-list are declared as constants, and can appear wherever constants are required. An 
enumerator-definition with = gives the associated enumerator the value indicated by the constant-expression. The 
constant-expression shall be of integral or enumeration type. If the first enumerator has no initializer, the value of 
the corresponding constant is zero. An enumerator-definition without an initializer gives the enumerator the value 
obtained by increasing the value of the previous enumerator by one. 

[Example: 

enum {a, b, c=0 };
enum { d, e, f=e+2 };


defines a, c, and d to be zero, b and e to be 1, and f to be 3. — end example ] 
3 The point of declaration for an enumerator is immediately after its enumerator-definition.[ Example: 

Draft 


129 Declarations 7.2 Enumeration declarations 

const int x = 12;
{ enum { x = x }; }


4 Here, the enumerator x is initialized with the value ofthe constant x, namely 12. — end example ] 

5 Each enumeration definesa type thatis different from all other types.Following the closing braceof an enum-specifier, 
each enumerator has the type of its enumeration. Prior to the closing brace, the type of each enumerator is the type 
of its initializing value. If an initializer is specified for an enumerator, the initializing value has the same type as the 
expression. If no initializer is specified for the first enumerator, the type is an unspecified integral type. Otherwise the 
type is the same as the type of the initializing value of the preceding enumerator unless the incremented value is not 
representablein that type, in which case the type is an unspecified integral type sufficient to contain the incremented 
value. 

6 The underlying type ofan enumerationisanintegraltypethatcan representallthe enumeratorvaluesdefinedintheenumeration.Ifnointegraltypecan representallthe enumeratorvalues,the enumerationis ill-formed.Itis implementation-
defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not 
be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list 
is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of sizeof() 
applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of sizeof() applied to 
the underlying type. 

7 For an enumeration whereemin is the smallest enumerator and emax is the largest, the values of the enumeration are the 
values of the underlying type in the range bmin to bmax , where bmin and bmax are, respectively, the smallest and largest 
values of the smallest bit-field that can store emin and emax .86) It is possible to define an enumeration that has values not 
defined by anyof its enumerators. 

8 Two enumeration types are layout-compatible if theyhave the sameunderlying type. 

9 Thevalueofan enumeratororanobjectofanenumerationtypeisconvertedtoanintegerbyintegral promotion(4.5). 
[Example: 

enum color { red , yellow , green =20 , blue };
color col = red ;
color* cp = &col;
if (*cp == blue) // ...


makes color a type describing various colors, and then declares col as an object of that type, and cp as a pointer to an 
object of that type. The possible values of an object of type color are red, yellow, green, blue thesevalues canbe 
converted to the integral values 0, 1, 20, and 21. Since enumerations are distinct types, objects of type color can be 
assigned only values of type color. 

color c =1; // error: type mismatch,
// no conversion from int to color


int i = yellow ; // OK: yellow converted to integral value 1
// integral promotion


— end example ] 
86) On a two’s-complement machine, bmax is the smallest value greater than or equal to max(|emin|-1,|emax|) of the form2M-1;bmin is zero if emin 
is non-negative and -(bmax + 1) otherwise. 

Draft 


7.3 Namespaces Declarations 130 
10 An expression of arithmetic or enumeration type can be converted to an enumeration type explicitly. The value is 
unchangedifitisinthe rangeof enumerationvaluesofthe enumeration type; otherwisethe resulting enumerationvalue 
is unspecified. 

11 The enum-name and each enumerator declared by an enum-specifier is declared in the scope that immediately contains 
the enum-specifier. Thesenames obeythe scope rules defined for all names in(3.3)and(3.4). An enumerator declared in 
class scope can be referred to using the class member access operators(::,. (dot) and -> (arrow)), see 5.2.5.[ Example: 

class X { 

public :
enum direction { left=’l’, right=’r’ };
int f(int i)


{ return i==left ? 0 : i= =right ? 1 : 2; }
};


void g(X* p) 

{
direction d; // error: direction not in scope
int i;
i = p->f(left); // error: left not in scope
i = p->f(X::right); // OK
i = p->f(p->left); // OK


// ... 

} 

— end example ] 
7.3 Namespaces [basic.namespace] 
1 A namespace is an optionally-named declarative region. The name of a namespace can be used to access entities 
declared in that namespace; that is, the members of the namespace. Unlike other declarative regions, the definition of a 
namespace can be split over several parts of one or more translation units. 

2 The outermost declarative region of a translation unit is a namespace; see 3.3.5. 

7.3.1 Namespace definition [namespace.def] 
1 The grammar for a namespace-definition is 

Draft 


131 Declarations 7.3 Namespaces 

namespace-name:
original-namespace-name
namespace-alias


original-namespace-name:
identifier


namespace-definition:
named-namespace-definition
unnamed-namespace-definition


named-namespace-definition:
original-namespace-definition
extension-namespace-definition


original-namespace-definition:
namespace identifier { namespace-body }
extension-namespace-definition:
namespace original-namespace-name { namespace-body }
unnamed-namespace-definition:
namespace { namespace-body }
namespace-body:
declaration-seqopt


2 The identifier in an original-namespace-definition shall not have been previously defined in the declarative region in 
which the original-namespace-definition appears. The identifier in an original-namespace-definition is the name of the 
namespace. Subsequently in that declarative region, it is treated as an original-namespace-name. 

3 The original-namespace-name in an extension-namespace-definition shall have previously been defined in an originalnamespace-definition in the same declarative region. 

4 Every namespace-definition shall appearin the global scope orina namespace scope(3.3.5). 

5 Because a namespace-definition contains declarations in its namespace-body and a namespace-definition is itself a 
declaration, it follows that namespace-definitions canbe nested.[ Example: 

namespace Outer {
int i;
namespace Inner {


void f() { i++; } // Outer::i 
int i; 
void g() { i++; } // Inner::i 

}
}


— end example ] 
6 The enclosing namespaces of a declaration are those namespaces in which the declaration lexically appears, except for 
a redeclaration of a namespace member outside its original namespace (e.g., a definition as specified in 7.3.1.2). Such a 
redeclaration has the same enclosing namespaces as the original declaration.[Example: 

namespace Q {
namespace V {
void f(); // enclosing namespaces are the global namespace, Q, and Q::V


class C { void m(); }; 

} 

Draft 


7.3 Namespaces Declarations 132 
void V::f() { // enclosing namespaces are the global namespace, Q, and Q::V 

extern void h(); // ... so this declares Q::V::h 

} 
void V::C::m() { // enclosing namespaces are the global namespace, Q, and Q::V 

}
}


— end example ] 
7.3.1.1 Unnamed namespaces [namespace.unnamed] 
1 An unnamed-namespace-definition behaves as if it were replacedby 

namespace unique { /* empty body */ }
using namespace unique ;
namespace unique { namespace-body }


where all occurrences of uniqueina translation unit are replacedby the sameidentifier and this identifier differs from 
all other identifiersin theentire program.87)[Example: 

namespace { int i ; } // unique::i
void f() { i++; } // unique::i++


namespace A { 

namespace {
int i; // A:: unique ::i
int j; // A:: unique ::j


}
void g() { i++; } // A:: unique ::i++
}


using namespace A;
void h() {
i ++; // error: unique ::i or A:: unique ::i


A:: i ++; // A:: unique ::i 
j ++; // A:: unique ::j
}


— end example ] 
2 The use of the static keywordis deprecatedwhen declaringobjectsinanamespacescope(seeannexD);theunnamednamespace provides a superior alternative. 

7.3.1.2 Namespace member definitions [namespace.memdef] 
1 Members (includingexplicit specializationsof templates(14.7.3))ofa namespace canbe defined within that namespace. 
[Example: 

namespace X {
void f() { /* ... * / }
}


87) Although entitiesin an unnamed namespace mighthaveexternal linkage, theyareeffectively qualifiedbya name uniqueto their translation unit 
and therefore can never be seen from anyother translation unit. 

Draft 


133 Declarations 7.3 Namespaces 

— end example ] 
2 Members (includingexplicit specializationsof templates(14.7.3))ofa named namespace can alsobe defined outside 
that namespacebyexplicit qualification(3.4.3.2)of the name being defined, provided that the entity being definedwas 
already declared in the namespace and the definition appears after the point of declaration in a namespace that encloses 
the declaration’s namespace.[ Example: 

namespace Q {
namespace V {


void f (); 
} 
void V::f() { /* ... * / } // OK 
void V::g() { /* ... * / } // error: g() is not yet a member of V 
namespace V { 

void g ();
}
}


namespace R {
void Q::V::g() { /* ... * / } // error: R doesn’tenclose Q
}


— end example ] 
3 Every name first declaredina namespaceisa memberofthat namespace.Ifa friend declaration in a non-local class 
first declares a class or function88) the friend class or function is a member of the innermost enclosing namespace. The 
nameofthefriendisnotfoundbysimplenamelookupuntilamatching declarationisprovidedinthat namespacescope 
(either before or after the class definition granting friendship). If a friend function is called, its name may be found 
by the name lookup that considers functions from namespaces and classes associated with the types of the function 
arguments(3.4.2). When looking fora prior declarationofa class ora functiondeclared asa friend, and when the 
name of the friend class or function is neither a qualified name nor a template-id, scopes outside the innermost enclosing namespace scope are not considered.If the name in a friend declaration is neither qualified nor a template-id 
and the declaration is a function or an elaborated-type-specifier, the lookup to determine whether the entity has been 
previously declared shall not consider any scopes outside the innermost enclosing namespace.[Note: the other forms 
of friend declarations cannot declare a new member of the innermost enclosing namespace and thus follow the usual 
lookup rules. — end note ][Example: 

// Assume f and g have not yet been defined.
void h( int );
template <class T> void f2(T);
namespace A {


class X {
friend void f(X); // A::f(X) is a friend
class Y {


friend void g (); // A::g is a friend 
friend void h(int); // A::h is a friend 
// ::h not considered 
friend void f2 < >( int ); // ::f2<>(int) is a friend 

88) this implies that the name of the class or function is unqualified. 

Draft 


7.3 Namespaces Declarations 134 
};
};


// A::f, A::g and A::h are not visible here
X x;
void g() { f(x); } // definition of A::g
void f(X) { /* ... * /} // definition of A::f
void h(int) { /* ... * / } // definition of A::h
// A::f, A::g and A::h are visible here and known to be friends


} 

using A::x; 

void h()
{


A:: f(x); 
A:: X::f(x ); // error: f is not a member of A::X 
A:: X::Y::g (); // error: g is not a member of A::X::Y
}
— end example ] 
7.3.2 Namespace alias [namespace.alias] 
1Anamespace-alias-definition declares an alternate name for a namespace according to the following grammar: 
namespace-alias: 
identifier 
namespace-alias-definition: 
namespace identifier = qualified-namespace-specifier ; 
qualified-namespace-specifier: 
::opt nested-name-specifieropt namespace-name 

2 The identifier in a namespace-alias-definition is a synonym for the name of the namespace denoted by the qualifiednamespace-specifier and becomes a namespace-alias.[Note: when looking up a namespace-name in a namespacealias-definition, only namespace names are considered, see 3.4.6. — end note ] 

3 In a declarative region, a namespace-alias-definition can be used to redefine a namespace-alias declared in that declarativeregiontoreferonlytothe namespaceto whichit already refers. [Example: the following declarations are well-
formed: 

namespace Company_with_very_long_name { /* ... * / }
namespace CWVLN = Company_with_very_long_name;
namespace CWVLN = Company_with_very_long_name ; // OK: duplicate
namespace CWVLN = CWVLN ;


— end example ] 
4 A namespace-name or namespace-alias shall not be declared as the name of anyother entity in the same declarative 
region. A namespace-name defined at global scope shall not be declared as the name of anyother entity in anyglobal 

Draft 


135 Declarations 7.3 Namespaces 

scope of the program. No diagnostic is required for a violation of this rule by declarations in different translation units. 

7.3.3 The using declaration [namespace.udecl] 
1Ausing-declaration introduces a name into the declarative region in which the using-declaration appears. That name is 
a synonym for the name of some entity declared elsewhere. 

using-declaration:
using typenameopt ::opt nested-name-specifier unqualified-id ;
using :: unqualified-id ;


The member name specified in a using-declaration is declared in the declarative region in which the using-declaration 
appears.[ Note: onlythe specified nameisso declared; specifyingan enumeration nameina using-declaration does not 
declare its enumeratorsinthe using-declaration’s declarative region. — end note ] 

2 Every using-declaration is a declaration and a member-declaration and so canbe usedina class definition.[ Example: 

struct B {
void f(char);
void g(char);
enum E{e};
union { int x; };


}; 

struct D : B{
using B::f;
void f(int) { f(’c’); } // calls B::f(char)
void g(int) { g(’c’); } // recursively calls D::g(int)


}; 

— end example ] 
3 Ina using-declaration used as a member-declaration, the nested-name-specifier shall name a base class of the class 
being defined. Sucha using-declaration introducesthesetof declarationsfoundbymembernamelookup(10.2,3.4.3.1). 
[Example: 

class C {
int g ();
};


class D2 : public B {
using B::f; // OK: B isa baseof D2
using B::e; // OK: e is an enumerator of base B
using B::x; // OK: x is a union member of base B
using C::g; // error: C isn’t a base of D2


}; 

— end example ] 
4 [Note: since constructors and destructors do not have names, a using-declaration cannot refer to a constructor or a 
destructor for a base class. Since specializations of member templates for conversion functions are not found by name 
lookup, they are not considered when a using-declaration specifies a conversion function(14.5.2). — end note ]If 
an assignment operator brought from a base class into a derived class scope has the signature of a copy-assignment 

Draft 


7.3 Namespaces Declarations 136 
operator for the derived class(12.8), the using-declaration does not by itself suppress the implicit declaration of the 
derived class copy-assignment operator; the copy-assignment operator from the base class is hidden or overridden by 
the implicitly-declared copy-assignment operator of the derived class, as described below. 

5 Ausing-declaration shall not name a template-id.[ Example: 

class A { 

public :
template <class T> void f(T);
template < class T > struct X { };


};
class B : public A {
public :


using A::f<double >; // ill-formed
using A::X<int >; // ill-formed
};


— end example ] 
6Ausing-declaration shall not name a namespace. 
7Ausing-declaration for a class member shall be a member-declaration.[ Example: 
struct X {
int i;
static int s;


}; 

void f()
{
using X::i; // error: X::i is a class member
// and this is not a member declaration.
using X::s; // error: X::s is a class member
// and this is not a member declaration.


} 

— end example ] 
8 Members declared by a using-declaration can be referred to by explicit qualification just like other member names 
(3.4.3.2). In a using-declaration, a prefix :: refers to the global namespace.[ Example: 

void f(); 

namespace A {
void g ();
}


namespace X {
using ::f; // globalf
using A::g; // A’s g


} 

Draft 


137 Declarations 7.3 Namespaces 

v o i d h ( ) 
{ 
X : : f ( ) ; // calls ::f 
X : : g ( ) ; // calls A::g 
} 

— end example ] 
9 Ausing-declaration is a declaration and can therefore be used repeatedly where (and only where) multiple declarations 
are allowed.[ Example: 

namespace A { 
int i; 
} 

namespace A1 { 

using A::i; 

using A::i; // OK: double declaration 
} 

void f() 

{ 

using A::i; 

using A::i; // error: double declaration 
} 

class B { 
public : 
int i; 
}; 

class X : public B { 

using B::i; 

using B::i; // error: double member declaration 
}; 

— end example ] 
10 The entity declared by a using-declaration shall be known in the context using it according to its definition at the point 
of the using-declaration. Definitions added to the namespace after the using-declaration are not considered when a use 
of the nameis made.[ Example: 

namespace A { 
void f(int); 
} 

using A::f; // f is a synonym for A::f; 
// that is, for A::f(int). 
namespace A { 
void f(char); 
} 

Draft 


7.3 Namespaces Declarations 138 
void foo ()
{
f(’a’); // calls f(int),
} // even though f(char) exists.


void bar ()
{
using A::f; // f is a synonym for A::f;
// that is, for A::f(int) and A::f(char).
f(’a’); // calls f(char)
}


— end example ] 
11 [Note: partial specializations of class templates are found by looking up the primary class template and then considering all partial specializations of that template. If a using-declaration names a class template, partial specializations 
introduced after the using-declaration are effectively visible because the primary template is visible(14.5.4). — end 
note ] 

12 Since a using-declaration is a declaration, the restrictions on declarations of the same name in the same declarative 
region(3.3)also apply tousing-declarations.[ Example: 

namespace A {
int x;
}


namespace B {
int i;
struct g { };
struct x { };
void f(int);
void f(double);
void g(char); // OK: hides struct g


} 

void func () 

{
int i;
using B::i; // error: i declared twice
void f(char);
using B::f; // OK: each f is a function
f (3.5); // calls B::f(double)
using B::g;
g(’a’); // calls B::g(char)
struct g g1 ; // g1 has class type B::g
using B::x;
using A::x; // OK: hides struct B::x
x = 99; // assigns toA::x
struct x x1 ; // x1 has class type B::x


} 

Draft 


139 Declarations 7.3 Namespaces 

— end example ] 
13 If a function declaration in namespace scope or block scope has the same name and the same parameter types as a 
function introducedby a using-declaration, and the declarations do not declare the same function, the program is ill-
formed. [Note: two using-declarations may introduce functions with the same name and the same parameter types. 
If, for a call to an unqualified function name, function overload resolution selects the functions introduced by such 
using-declarations, the function call is ill-formed. 

[Example: 

namespace B {
void f(int);
void f(double);


} 

namespace C {
void f(int);
void f(double);
void f(char);


} 

void h() 

{
using B::f; // B::f(int) and B::f(double)
using C::f; // C::f(int), C::f(double), and C::f(char)
f(’h’); // calls C::f(char)
f (1); // error: ambiguous: B::f(int) or C::f(int)?
void f(int); // error:


// f(int) conflicts with C::f(int) and B::f(int)
}


— end example ] — end note ] 
14 When a using-declaration brings names from a base class into a derived class scope, member functions and member 
function templates in the derived class override and/or hide member functions and member function templates with the 
same name, parameter-type-list(8.3.5), and cv-qualification in a base class (rather than conflicting). 

[Example: 

struct B {
virtual void f(int);
virtual void f(char);
void g(int);
void h(int);


}; 

struct D : B{
using B::f;
void f(int); // OK: D::f(int) overrides B::f(int);


using B::g;
void g(char); // OK


Draft 


7.3 Namespaces Declarations 140 
using B::h;
void h(int); // OK: D::h(int) hides B::h(int)
};


void k(D* p) 

{
p ->f (1); // calls D::f(int)
p ->f(’a’); // calls B::f(char)
p ->g (1); // calls B::g(int)
p ->g(’a’); // calls D::g(char)


} 

— end example ] 
15 [Note: two using-declarationsmay introduce functionswiththesamenameandthesame parametertypes.If,foracallto 
an unqualified function name, function overload resolution selects the functions introduced by such using-declarations, 
the function call is ill-formed. — end note ] 

16 For the purpose of overload resolution, the functions which are introducedby ausing-declaration into a derived class 
will be treated as though they were members of the derived class. In particular, the implicit this parameter shall be 
treated as if it were a pointer to the derived class rather than to the base class. This has no effect on the type of the 
function, and in all other respects the function remains a member of the base class. 

17 All instances of the name mentioned in a using-declaration shall be accessible. In particular, if a derived class uses 
a using-declaration to access a member of a base class, the member name shall be accessible. If the name is that 
of an overloaded member function, then all functions named shall be accessible. The base class members mentioned 
by a using-declaration shall be visible in the scope of at least one of the direct base classes of the class where the 
using-declaration is specified.[ Note: because a using-declaration designates a base class member (and not a member 
subobject or a member function of a base class subobject), a using-declaration cannot be used to resolve inherited 
member ambiguities.Forexample, 

struct A { int x (); };
struct B : A {};
struct C : A{


using A::x;
int x(int);
};


struct D :B, C{
using C::x;
int x(double);


};
int f(D* d) {
return d->x(); // ambiguous:B::x or C::x
}


— end note ] 
18 The alias created by the using-declaration has the usual accessibility for a member-declaration.[ Example: 
class A { 

Draft 


141 Declarations 7.3 Namespaces 

private :
void f(char);
public :
void f(int);
protected :
void g ();
};


class B : public A {
using A::f; // error: A::f(char) is inaccessible
public :
using A::g; // B::g is a public synonym for A::g
};


— end example ] 
19 [Note: use of access-declarations (11.3)is deprecated; memberusing-declarations provide a better alternative. — end 
note ] 

20 Ifa using-declaration uses thekeyword typename and specifiesa dependent name(14.6.2), the name introducedby the 
using-declaration is treated as a typedef-name (7.1.3). 

7.3.4 Using directive [namespace.udir] 
using-directive:
using namespace ::opt nested-name-specifieropt namespace-name ;


1Ausing-directive shall not appear in class scope,but may appear in namespace scope or in block scope.[ Note: when 
looking up a namespace-name in a using-directive, only namespace names are considered, see 3.4.6. — end note ] 

2A using-directive specifies that the names in the nominated namespace can be used in the scope in which the using-
directive appears after the using-directive. During unqualified name lookup(3.4.1), the names appear as if they were 
declared in the nearest enclosing namespace which contains both the using-directive and the nominated namespace. 
[Note: in this context, “contains” means “contains directly or indirectly”. — end note ] 

3Ausing-directive doesnotaddanymemberstothe declarativeregionin whichit appears.[ Example: 

namespace A {
int i;
namespace B {


namespace C { 

int i;
}
using namespace A::B::C;
void f1() {


i =5; // OK, C::i visible in B and hides A::i 

}
}
namespace D {


using namespace B;
using namespace C;
void f2() {


Draft 


7.3 Namespaces Declarations 142 
i = 5 ; // ambiguous,B::C::i or A::i? 
} 
} 
v o i d f 3 ( ) { 
i = 5 ; // uses A::i 
} 
} 
v o i d f 4 ( ) { 
i = 5 ; // ill-formed; neither i is visible 
} 
— end example ] 

The using-directive is transitive: if a scope contains a using-directive that nominates a second namespace that itself 
contains using-directives, the effect is as if the using-directives from the second namespace also appeared in the first. 
[Example: 

namespace M { 
int i; 
} 

namespace N { 

int i; 

using namespace M; 
} 

void f() 

{ 

using namespace N; 

i =7; // error: both M::i and N::i are visible 
} 

For another example, 

namespace A { 

int i; 
} 
namespace B { 

int i; 
int j; 
namespace C { 
namespace D { 

using namespace A; 

int j; 

int k; 

int a = i; // B::i hides A::i 
} 
using namespace D; 
int k =89; // no problem yet 
int l = k; // ambiguous:C::k or D::k 
int m = i; // B::i hides A::i 

Draft 


143 Declarations 7.3 Namespaces 

int n = j; // D::j hides B::j
}
}


— end example ] 
5 Ifa namespaceisextendedby an extension-namespace-definition aftera using-directive for that namespaceisgiven, the 
additional members of the extended namespace and the members of namespaces nominated by using-directives in the 
extension-namespace-definition can be used after the extension-namespace-definition. 

If namelookupfindsa declarationfora nameintwodifferent namespaces,andthedeclarationsdonot declarethe same 
entityanddonot declare functions,the useofthe nameis ill-formed.[ Note: in particular,the name of an object, function 
or enumerator does not hidethe nameofa class or enumeration declaredina different namespace.Forexample, 

namespace A {
class X{};
extern "C" int g();
extern "C++" int h();


} 

namespace B {
void X(int);
extern "C" int g();
extern "C++" int h();


}
using namespace A;
using namespace B;


void f() {
X (1); // error: name X found in two namespaces
g (); // okay: nameg refers to the same entity
h (); // error: name h found in two namespaces


} 

— end note ] 
6 During overload resolution, all functions from the transitive search are considered for argument matching. The set of 
declarations found by the transitive search is unordered. [Note: in particular, the order in which namespaces were 
considered and the relationships among the namespaces implied by the using-directives do not cause preference to be 
given to any of the declarations found by the search. — end note ]An ambiguity exists if the best match finds two 
functions with the same signature, even if one is in a namespace reachable through using-directives in the namespace of 
the other.89) 

[Example: 

namespace D {
int d1;
void f(char);


} 

89) During name lookup in a class hierarchy, some ambiguities may be resolved by considering whether one member hides the other along some 
paths(10.2). Thereis no such disambiguation when considering the setof names found asa resultof following using-directives. 

Draft 


7.4 The asm declaration Declarations 144 
using namespace D; 

int d1; // OK: no conflict with D::d1 

namespace E {
int e;
void f(int);


} 

namespace D { // namespace extension
int d2;
using namespace E;
void f(int);


} 

void f() 

{
d1 ++; // error: ambiguous ::d1 or D::d1?
:: d1 ++; // OK


D:: d1 ++; // OK 
d2 ++; // OK: D::d2 
e ++; // OK: E::e 
f (1); // error: ambiguous: D::f(int) or E::f(int)? 
f(’a’); // OK: D::f(char) 
} 

— end example ] 
7.4 The asm declaration [dcl.asm] 
1 An asm declaration has the form 

asm-definition: 

asm ( string-literal ); 
The asm declaration is conditionally-supported; its meaning is implementation-defined.[ Note: Typically it is used to 
pass information through the implementation to an assembler. — end note ] 

7.5 Linkage specifications [dcl.link] 
1 All function types, function names with external linkage, and variable names with external linkage have a language 
linkage.[ Note: Some of the properties associated with an entity with language linkage are specific to each implementation and are not described here.Forexample,a particular language linkage maybe associated witha particular formof 
representing names of objects andfunctions with external linkage, or with a particular calling convention, etc. — end 
note ]Thedefault language linkageofall function types, function names,andvariable namesisC++ languagelinkage. 
Two function types with different language linkages are distinct types even if theyare otherwise identical. 

2 Linkage(3.5)betweenC++ and non-C++ code fragments can be achieved using a linkage-specification: 
linkage-specification: 
extern string-literal { declaration-seqopt } 
extern string-literal declaration 

Draft 


145 Declarations 7.5 Linkage specifications 

The string-literal indicates the required language linkage. This International Standard specifies the semantics for 
the string-literals "C" and "C++". Use of a string-literal other than "C" or "C++" is conditionally-supported, with 
implementation-defined semantics.[ Note: Therefore,a linkage-specification witha string-literal that is unknown to the 
implementation requires a diagnostic. — end note ][Note: It is recommended that the spelling of the string-literal be 
taken from the document defining that language. For example, Ada (not ADA)andFortran or FORTRAN, depending on 
the vintage. — end note ] 

3 Every implementation shallprovide for linkage to functions written in theCprogramming language, "C", and linkage 
toC++ functions, "C++".[ Example: 

complex sqrt ( complex ); // C++linkageby default
extern "C" {
double sqrt ( double ); // Clinkage
}


— end example ] 
4 Linkage specifications nest. When linkage specifications nest, the innermost one determines the language linkage. A 
linkage specification does not establish a scope. A linkage-specification shall occur only in namespace scope(3.3). In 
a linkage-specification, the specified language linkage applies to the function types of all function declarators, function names with external linkage, and variable names with external linkage declared within the linkage-specification. 
[Example: 

extern "C" void f1(void(*pf)(int));
// the name f1 and its function type haveClanguage
// linkage; pf isa pointertoaCfunction


extern "C" typedef void FUNC();
FUNC f2 ; // the name f2 hasC++language linkage and the
// function’s type hasClanguage linkage
extern "C" FUNC f3; // the name of function f3 and the function’s type
// haveClanguage linkage


void (* pf2 )( FUNC *); // the name of the variable pf2 hasC++linkage and
// the type of pf2 is pointer toC++function that
// takes oneparameteroftype pointertoCfunction


extern "C" { 

static void f4 (); // the name of the function f4 has
// internal linkage (notClanguage
// linkage) and the function’s type
// hasClanguage linkage.


} 

extern "C" void f5() { 

extern void f4 (); // OK: Name linkage (internal)
// and function type linkage (C
// language linkage) gotten from
// previous declaration.


} 

extern void f4 (); // OK: Name linkage (internal)
// and function type linkage (C


Draft 


7.5 Linkage specifications Declarations 146 
// language linkage) gotten from 
// previous declaration. 

} 

void f6() { 

extern void f4 (); // OK: Name linkage (internal)
// and function type linkage (C
// language linkage) gotten from
// previous declaration.


} 

— end example ]AC language linkage is ignored for the names of class members and the member function type of 
class member functions.[ Example: 
extern "C" typedef void FUNC _c();
class C {


void mf1 ( FUNC_c *); // the name of the function mf1 and the member 
// function’s type haveC++language linkage; the 
// parameter has type pointer toCfunction 

FUNC_c mf2 ; // the name of the function mf2 and the member
// function’s type haveC++language linkage


static FUNC_c* q; // the name of the data member q hasC++language 
// linkage and the data member’s type is pointer to 
// Cfunction 

}; 

extern "C" {
class X {
void mf (); // the name of the function mf and the member
// function’s type haveC++language linkage


void mf2 ( void (*)()); // the name of the function mf2 hasC++language 
// linkage; the parameter has type pointer to 
// Cfunction 

};
}


— end example ] 
5 If two declarations of the same function or object specify different linkage-specifications (that is, the linkage-specifications of these declarations specify different string-literals), the program is ill-formed if the declarations appear in the 
same translation unit, and the one definition rule(3.2)applies if the declarations appear in different translation units. 
Except for functions withC++ linkage, a function declaration without a linkage specification shall not precede the first 
linkagespecificationforthat function.Afunctioncanbe declared withoutalinkage specificationafteranexplicitlinkage 
specification has been seen; the linkage explicitly specified in the earlier declaration is not affected by such a function 
declaration. 

6 At most one function with a particular name can have C language linkage. Two declarations for a function with C 
language linkage with the same function name (ignoring the namespace names that qualify it) that appear in different 
namespace scopes refer to the same function. Two declarations for an object withClanguage linkage with the same 
name (ignoringthe namespace namesthatqualifyit)that appearindifferent namespace scopesrefertothe sameobject. 

Draft 


147 Declarations 7.5 Linkage specifications 

[Note: becauseofthe one definition rule(3.2),only one definitionfora functionor object withClinkagemay appear 
inthe program;thatis,sucha functionorobjectmustnotbe definedin morethanonenamespace scope.Forexample, 

namespace A {
extern "C" int f();
extern "C" int g() { return 1; }
extern "C" int h();


} 

namespace B {
extern "C" int f(); // A::f and B::f refer
// to the same function


extern "C" int g() { return 1; } // ill-formed, the function g
// withClanguage linkage
// has two definitions


} 

int A::f() { return 98; } //definition for the functionf
// withClanguage linkage


extern "C" int h() { return 97; }
// definition for the function h
// withClanguage linkage
// A::h and ::h refer to the same function


— end note ] 
7 Adeclaration directly containedinalinkage-specification is treated as if it contains the extern specifier(7.1.1)for the 
purposeof determining the linkageof thedeclared name and whetheritisa definition. Sucha declaration shall not 
specifya storage class.[ Example: 

extern "C" double f();
static double f (); // error
extern "C" int i; // declaration
extern "C" {


int i; // definition
}
extern "C" static void g(); // error


— end example ] 
8[Note: becausethe languagelinkageispartofa functiontype,whenapointertoCfunction(forexample)is dereferenced,the functionto whichitrefersis consideredaCfunction. — end note ] 

9 Linkage fromC++ to objects defined in otherlanguages and to objects defined inC++ from other languages is implementation-defined and language-dependent. Only where the object layout strategies of two language implementations 
are similar enough can suchlinkagebe achieved. 

Draft 


7.5 Linkage specifications Declarations 148 
Draft 


Chapter8 Declarators [dcl.decl]


1 A declarator declares a single object, function, or type, within a declaration. The init-declarator-list appearing in a 
declarationisa comma-separated sequenceof declarators, eachof which canhave aninitializer. 

init-declarator-list:
init-declarator
init-declarator-list , init-declarator


init-declarator:
declarator initializeropt


2 Thetwo componentsofa declaration are the specifiers(decl-specifier-seq;7.1)and the declarators(init-declarator-list). 
The specifiers indicate the type, storage class or other properties of the objects, functions or typedefs being declared. The 
declarators specify the names of these objects, functions or typedefs, and (optionally)modify the type of the specifiers 
with operators such as * (pointer to) and () (function returning). Initial values can also be specified in a declarator; 
initializers are discussed in 8.5 and 12.6. 

3 Each init-declarator in a declaration is analyzed separately as if it was in a declaration by itself.90) 

4 Declarators have the syntax 

declarator:
direct-declarator
ptr-operator declarator


direct-declarator:
declarator-id
direct-declarator ( parameter-declaration-clause ) cv-qualifier-seqopt exception-specificationopt
direct-declarator [ constant-expressionopt ]
( declarator )


90)Adeclarationwithseveral declaratorsisusuallyequivalenttothe corresponding sequenceof declarationseachwithasingle declarator.Thatis 

T D1, D2, ... Dn; 

is usually equvalent to 

T D1; T D2; ... T Dn; 
where T is a decl-specifier-seq and each Di is an init-declarator. Theexception occurs whena name introducedbyoneofthe declarators hidesa type 
name used by the dcl-specifiers, so that when the same dcl-specifiers are used in a subsequent declaration, theydo not have the same meaning, as in 

struct S { ... };
S S, T; // declare two instances of struct S
which is not equivalent to


struct S { ... };
S S;
S T; // error



8.1 Type names Declarators 150 
ptr-operator: 

* cv-qualifier-seqopt
&
::opt nested-name-specifier * cv-qualifier-seqopt
cv-qualifier-seq:
cv-qualifier cv-qualifier-seqopt


cv-qualifier: 

const
volatile


declarator-id:
id-expression
::opt nested-name-specifieropt class-name


Aclass-name has special meaning in a declaration of the class of that name and when qualified by that name using the 
scope resolution operator :: (5.1, 12.1, 12.4). 

8.1 Type names [dcl.name] 
1 To specify type conversions explicitly, and as an argument of sizeof, new, or typeid, the name of a type shall be 
specified. This can be done with a type-id, which is syntactically a declaration for an object or function ofthat type that 
omits the name of the object or function. 

type-id:
type-specifier-seq abstract-declaratoropt


type-specifier-seq:
type-specifier type-specifier-seqopt


abstract-declarator:
ptr-operator abstract-declaratoropt
direct-abstract-declarator


direct-abstract-declarator:
direct-abstract-declaratoropt
( parameter-declaration-clause ) cv-qualifier-seqopt exception-specificationopt
direct-abstract-declaratoropt[ constant-expressionopt ]
( abstract-declarator )


It is possible to identify uniquely the location in the abstract-declarator where the identifier would appear if the construction werea declaratorina declaration.The namedtypeisthenthe sameasthetypeofthehypothetical identifier. 
[Example: 

int // int i
int * // int *pi
int *[3] // int *p[3]
int (*)[3] // int (*p3i)[3]
int *() // int *f()
int (*)( double ) // int (*pf)(double)


name respectively the types “int,” “pointer to int,” “arrayof3pointersto int,” “pointerto arrayof3 int,” “function 
of (no parameters) returning pointer to int,” and “pointer to a function of(double)returningint.” — end example ] 

Draft 


151 Declarators 8.2 Ambiguityresolution 

2 Atype can also be named (often more easily) by using atypedef (7.1.3). 

8.2 Ambiguity resolution [dcl.ambig.res] 
1 The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6.8 can also 
occur in the context of a declaration. In that context, the choice is between a function declaration with a redundant set 
of parentheses around a parameter name and an object declaration with a function-style cast as the initializer. Just as 
for the ambiguities mentioned in 6.8, the resolution is to consider any construct that could possibly be a declaration 
a declaration. [Note: a declaration can be explicitly disambiguated by a nonfunction-style cast, by an = to indicate 
initialization orby removing the redundant parentheses around the parameter name. — end note ][Example: 

struct S {
S(int );
};


void foo(double a) 

{
S w(int(a)); // function declaration
S x( int ()); // function declaration
S y((int)a); // object declaration
S z = int(a); // object declaration


} 

— end example ] 
2 The ambiguity arising from the similarity between a function-style cast and a type-id can occur in different contexts. 
The ambiguity appears as a choice between a function-style cast expression and a declaration of a type. The resolution 
is that anyconstruct that could possibly be a type-id in its syntactic context shall be considered a type-id. 

3 [Example: 

# include < cstddef >
char *p;
void * operator new ( std :: size _t , int );
void foo () {


const int x = 63;
new (int(*p)) int; // new-placement expression
new ( int (*[ x ])); // new type-id


} 

4 For another example, 

template <class T>
struct S {


T *p;
};
S<int()> x; //type-id
S<int(1)> y; // expression (ill-formed)


5 For another example, 

Draft 


8.3 Meaning of declarators Declarators 152 
void foo () 

{
sizeof ( int (1)); // expression
sizeof ( int ()); // type-id (ill-formed)


} 

6 For another example, 

void foo () 

{
( int (1)); // expression
( int ())1; // type-id (ill-formed)


} 

— end example ] 
7 Another ambiguity arises in a parameter-declaration-clause of a function declaration, or in a type-id that is the operand 
of a sizeof or typeid operator, when a type-name is nestedin parentheses. In this case, the choice is between the 
declarationofa parameteroftypepointerto functionandthe declarationofa parameterwith redundant parentheses 
around the declarator-id. The resolution is to consider the type-name asa simple-type-specifier rather thana declarator-
id.[ Example: 

class C {};
void f(int(C)) { } // void f(int(*fp)(C c)) { }
// not: void f(int C);


int g(C); 

void foo () {
f (1); // error: cannot convert 1 to function pointer
f(g ); // OK


} 

For another example, 

class C {};
void h( int *( C [10])); // void h(int *(*_fp)(C _parm[10]));
// not: void h(int *C[10]);


— end example ] 
8.3 Meaning of declarators [dcl.meaning] 
1 A list of declarators appears after an optional (clause 7)decl-specifier-seq (7.1). Each declarator contains exactly 
one declarator-id; it names the identifier that is declared. An unqualified-id occurring in a declarator-id shall be 
a simple identifier except for the declaration of some special functions(12.3, 12.4, 13.5)and for the declaration of 
template specializations or partial specializations(14.7).A declarator-id shall not be qualified except for the definition 
ofa member function(9.3)or static data member(9.4)outsideof its class, the definition orexplicit instantiationofa 
function or variable member of a namespace outside of its namespace, or the definition of a previously declared explicit 
specialization outside of its namespace, or the declaration of a friend function that is a member of another class or 
namespace(11.4). When the declarator-id is qualified, the declaration shall refer to a previously declared member 

Draft 


153 Declarators 8.3 Meaning of declarators 

of the class or namespace to which the qualifier refers, and the member shall nothave been introducedbya using-
declaration in the scope of the class or namespace nominated by the nested-name-specifier of the declarator-id.[ Note: 
if the qualifier is the global :: scope resolution operator, the declarator-id refers to a name declared in the global 
namespace scope. — end note ] 

2 An auto, static, extern, register, mutable, friend, inline, virtual, or typedef specifier applies directly to 
each declarator-id in an init-declarator-list;the type specified for eachdeclarator-id depends onboth the decl-specifierseq and its declarator. 

3 Thus, a declaration of a particular identifier has the form 

T D 

where T isa decl-specifier-seq and D isadeclarator.Followingisarecursiveprocedurefor determiningthetype specified 
for the contained declarator-id by such a declaration. 

4 First, the decl-specifier-seq determines a type. In a declaration 

T D 

the decl-specifier-seq T determines the type T.[ Example: in the declaration 

int unsigned i; 

the type specifiers int unsigned determine the type “unsigned int”(7.1.5.2). — end example ] 

5 In a declaration TD where D is an unadorned identifier the type of this identifier is “T.” 

6 In a declaration TD where D has the form 
(D1) 
the type of the contained declarator-id is the same as that of the contained declarator-id in the declaration 

T D1 

Parenthesesdo not alter thetypeof the embeddeddeclarator-id,but theycan alter the binding of complex declarators. 

8.3.1 Pointers [dcl.ptr] 
1 In a declaration TD where D has the form 

* cv-qualifier-seqopt D1 
and the type of the identifier in the declaration T D1 is “derived-declarator-type-list T,” then the type of theidentifier of 
D is “derived-declarator-type-list cv-qualifier-seq pointer to T.”The cv-qualifiers apply to the pointer and not to the object 
pointed to. 

2 [Example: the declarations 

const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
int i, *p, *const cp = &i;


Draft 


8.3 Meaning of declarators Declarators 154 
declare ci, a constant integer; pc, a pointer to a constant integer; cpc, a constant pointer to a constant integer; ppc,a 
pointer to a pointer to a constant integer; i, an integer; p, a pointer to integer; and cp, a constant pointer to integer. The 
value of ci, cpc, and cp cannot be changed after initialization. The value of pc can be changed, and so can the object 
pointed to by cp. Examples of some correct operations are 

i = ci; 

*cp = ci;
pc ++;
pc = cpc;
pc =p;
ppc = &pc;
Examples of ill-formed operations are 

ci =1; // error
ci ++; // error


*pc =2; // error
cp = &ci; // error
cpc ++; // error
p = pc; // error
ppc = &p; // error
Each is unacceptable because it would either change the value of an object declared const or allow it to be changed 
through a cv-unqualified pointer later, for example: 

*ppc = &ci; // OK,but would make p point to ci ...
// ... because of previous error
*p =5; // clobber ci 
— end example ] 
3 See also 5.17 and 8.5. 
4[Note: there areno pointersto references; see 8.3.2. Sincethe addressofa bit-field(9.6)cannotbetaken,a pointer can 
never point to a bit-field. — end note ] 

8.3.2 References [dcl.ref] 
1 In a declaration TD where D has the form 

& D1 

and the type of the identifier in the declaration T D1 is “derived-declarator-type-list T,” then the type of theidentifier of 
D is “derived-declarator-type-list reference to T.” Cv-qualified references are ill-formed except when the cv-qualifiers are 
introduced through the useofa typedef(7.1.3)orofa template type argument(14.3),in which case the cv-qualifiers are 
ignored.[ Example: in 

typedef int& A;
const A aref = 3; // ill-formed;
// non-const reference initialized with rvalue


Draft 


155 Declarators 8.3 Meaning of declarators 

the type of aref is “reference to int”, not “const reference to int”. — end example ][Note: a reference can be 
thoughtof asa nameof an object. — end note ]Adeclarator that specifies the type “reference tocv void” is ill-formed. 

2 [Example: 

void f(double& a) { a += 3.14; } 

// ... 

double d = 0;
f(d);


declares a to be a reference parameter of f so the call f(d) will add 3.14 to d. 

int v [20]; 

// ... 

int& g(int i) { return v[i]; } 

// ... 

g (3) = 7; 

declares the function g() to return a reference to an integer so g(3)=7 will assign 7 to the fourth element of the array 

v.For another example, 
struct link {
link * next ;
};


link * first ; 

void h(link*& p) // p is a reference to pointer 

{
p-> next = first ;
first = p;
p =0;


} 

void k() 

{
link* q = new link;
h(q);


} 

declares p to be a reference to a pointer to link so h(q) will leave q with the value zero. See also 8.5.3. — end 
example] 

3 It is unspecified whether or not a reference requires storage(3.7). 

4 There shall be no references to references, no arrays of references, and no pointers to references. The declaration of a 
reference shall contain an initializer (8.5.3)exceptwhenthe declaration containsanexplicitextern specifier(7.1.1), is 
a class member(9.2)declaration withinaclass definition,oristhe declarationofa parameterora returntype(8.3.5); 
see3.1.Areference shallbe initializedto refertoavalid objector function.[ Note: in particular,a null reference cannot 
exist in a well-defined program, because the only way to create such a reference would be to bind it to the “object” 

Draft 


8.3 Meaning of declarators Declarators 156 
obtained by dereferencing a null pointer, which causes undefined behavior. As described in 9.6, a reference cannot be 
bound directly to a bit-field. — end note ] 

8.3.3 Pointers to members [dcl.mptr] 
1 In a declaration TD where D has the form 

::opt nested-name-specifier * cv-qualifier-seqopt D1 

and the nested-name-specifier names a class, and the type of the identifier in the declaration T D1 is “derived-declaratortype-list T,” then the type of the identifier of D is “derived-declarator-type-list cv-qualifier-seq pointer to member of class 
nested-name-specifier of type T.” 

2 [Example: 

class X { 

public :
void f(int);
int a;


};
class Y;


int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;
double X ::* pmd ;
char Y ::* pmc ;


declares pmi, pmf, pmd and pmc to be a pointer to a member of X of type int, a pointer to a member of X of type 
void(int), a pointer to a member of X of type double and a pointer to a member of Y of type char respectively. The 
declaration of pmd is well-formed even though X has no members of type double. Similarly, the declaration of pmc is 
well-formed even though Y is an incomplete type. pmi and pmf can be used like this: 

X obj; 

// ... 

obj.*pmi = 7; // assign7 to an integer
// member of obj
(obj .* pmf )(7); // call a function member of obj
// with the argument 7


— end example ] 
3 Apointerto membershallnotpointtoa static memberofaclass(9.4),a memberwith referencetype,or“cv void.” 
[Note: see also 5.3 and 5.5. The type “pointer to member” is distinct from the type “pointer”, that is, a pointer to 
member is declared only by the pointer to member declarator syntax, and never by the pointer declarator syntax. There 
is no “reference-to-member” typeinC++. — end note ] 

8.3.4 Arrays [dcl.array] 
1 In a declaration TD where D has the form 

D1 [ constant-expressionopt ] 

Draft 


157 Declarators 8.3 Meaning of declarators 

and the type of the identifier in the declaration T D1 is “derived-declarator-type-list T,” then the type of the identifier of 
D is an array type. T is called the array element type;this type shall not be a reference type, the (possiblycv-qualified) 
type void, a function type or an abstract class type. If the constant-expression (5.19)is present, it shall be an integral 
constant expression and its value shall be greater than zero. The constant expression specifies the bound of (number of 
elements in) the array. If the value of the constant expression is N, the array has N elements numbered 0 to N-1, and 
the type of the identifier of D is “derived-declarator-type-list array of NT.” An object of array type contains a contiguously 
allocated non-empty set of N subobjects of type T. If the constant expression is omitted, the type of the identifier of D is 
“derived-declarator-type-list array of unknown bound of T,” an incomplete object type. The type “derived-declarator-typelist array of NT” is a different type from the type “derived-declarator-type-list array of unknown bound of T,” see 3.9. Any 
type of the form “cv-qualifier-seq array of NT” is adjusted to “array of N cv-qualifier-seq T,” and similarly for “array of 
unknown bound of T.”[ Example: 

typedef int A[5], AA[2][3];
typedef const A CA ; // typeis “arrayof5const int”
typedef const AA CAA ; // typeis “arrayof2 arrayof3const int”


— end example ][Note: an “array of N cv-qualifier-seq T” has cv-qualified type; see 3.9.3. — end note ] 
2 Anarraycanbe constructedfromoneofthe fundamentaltypes(except void),froma pointer, froma pointer to member, 
from a class, from an enumeration type, or from another array. 

3 Whenseveral“arrayof” specificationsare adjacent,a multidimensionalarrayis created;the constantexpressionsthat 
specifythe bounds of the arrays can be omitted only for the first member ofthe sequence.[ Note: this elision is useful 
for function parameters of array types, and when the array is external and the definition, which allocates storage, is 
given elsewhere. — end note ]The firstconstant-expression canalsobe omittedwhenthedeclaratorisfollowedbyan 
initializer (8.5). In this case the bound is calculated from the number of initial elements (say, N)supplied(8.5.1), and 
the type of the identifier of D is “array of NT.” 

4 [Example: 

float fa [17] , * afp [17]; 

declares an array of float numbers and an array of pointers to float numbers.For anotherexample, 

static int x3d [3][5][7]; 

declaresa static three-dimensional arrayof integers, with rank3 × 5× 7. In complete detail, x3d is an array of three 
items; each item is an array of five arrays; each ofthe latter arrays is an array of seven integers. Anyof the expressions 
x3d, x3d[i], x3d[i][j], x3d[i][j][k] can reasonably appear in an expression. — end example ] 

5 [Note: conversions affecting lvalues of array type are described in 4.2. Objects of array types cannot be modified, see 

3.10. — end note ] 
6 Except whereithas been declaredfora class(13.5.5),the subscript operator [] is interpretedin suchaway that E1[E2] 
is identical to *((E1)+(E2)). Because of the conversion rules that apply to +, if E1 is an array and E2 an integer, then 
E1[E2] refers to the E2-th member of E1. Therefore, despite its asymmetric appearance, subscripting is a commutative 
operation. 

7 Aconsistent rule is followed for multidimensional arrays. If E is an n-dimensional array of rank i× j× ... × k, then 
E appearing in an expression is converted to a pointer to an (n- 1)-dimensional array with rank j× ... × k. If the * 

Draft 


8.3 Meaning of declarators Declarators 158 
operator, either explicitly or implicitly as a result of subscripting, is applied to this pointer, the result is the pointed-to 
(n- 1)-dimensional array, whichitselfis immediately converted intoa pointer. 

8 [Example: consider 

int x [3][5]; 

Here x is a3× 5array of integers. Whenx appears in an expression, it is converted to a pointer to (the first of three) 
five-membered arraysofintegers.Intheexpression x[i] which is equivalent to *(x+i), x is first converted to a pointer 
as described; then x+i is converted to the type of x, which involves multiplying i by the length of the object to which 
the pointer points, namely five integer objects. The results are added and indirection applied to yield an array (of five 
integers),whichinturnisconvertedtoapointertothefirstoftheintegers.Ifthereis anothersubscriptthesameargument 
applies again; this time the result is an integer. — end example ] 

9[Note: it follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that the first 
subscript in the declaration helps determine the amount of storage consumed by an array but plays no other part in 
subscript calculations. — end note ] 

8.3.5 Functions [dcl.fct] 
1 In a declaration TD where D has the form 

D1 ( parameter-declaration-clause ) cv-qualifier-seqopt exception-specificationopt and the 
type of the contained declarator-id in the declaration T D1 is “derived-declarator-type-list T,”the typeofthe declarator-
id in D is “derived-declarator-type-list function of(parameter-declaration-clause )cv-qualifier-seqopt returning T”;a typeof 
this form is a function type91). 

parameter-declaration-clause:
parameter-declaration-listopt ...opt
parameter-declaration-list , ...


parameter-declaration-list:
parameter-declaration
parameter-declaration-list , parameter-declaration


parameter-declaration:
decl-specifier-seq declarator
decl-specifier-seq declarator = assignment-expression
decl-specifier-seq abstract-declaratoropt
decl-specifier-seq abstract-declaratoropt = assignment-expression


2 The parameter-declaration-clause determines the arguments that can be specified, and their processing, when the function is called.[ Note: the parameter-declaration-clause is used to convert the arguments specified on the function call; 
see 5.2.2. — end note ]If theparameter-declaration-clause is empty, the function takes no arguments. The parameter 
list (void) is equivalent to the empty parameter list. Except for this special case, void shall not be a parameter type 
(though typesderived from void, such as void*, can). If the parameter-declaration-clause terminates with an ellipsis, 
the number of arguments shall be equal to or greater than the number of parameters that do not have a default argument. 
Where syntactically correct, “, ...” is synonymous with “...”.[ Example: the declaration 

int printf ( const char * , ...); 

declares a function that can be called with varying numbers and types of arguments. 

91) As indicated by the syntax, cv-qualifiers are a significant component in function return types. 

Draft 


159 Declarators 8.3 Meaning of declarators 

printf("hello world");
printf("a= %d b= %d", a, b);


However, the first argument must be of a type that can be converted to a const char* — end example ][Note: the 
standard header <cstdarg> contains a mechanism for accessing arguments passed using the ellipsis (see 5.2.2 and 
18.7). — end note ] 

3 Asingle name can be used for several different functions in a single scope; this is function overloading (clause13). All 
declarations for a function shall agree exactly in both the return type and the parameter-type-list. The type of a function 
is determined using the following rules. The type of each parameter is determined from its own decl-specifier-seq and 
declarator. After determining the type of each parameter, anyparameter of type “array of T” or “function returning T” 
is adjusted to be “pointer to T” or “pointer to function returning T,” respectively. After producing the list of parameter 
types, several transformations take place upon these types to determine the function type. Any cv-qualifier modifying 
a parameter type is deleted. [Example: the type void(*)(const int) becomes void(*)(int) — end example ] 
Such cv-qualifiers affect only the definition of the parameter within the body of the function; they do not affect the 
function type. If a storage-class-specifier modifies a parameter type, the specifier is deleted. [Example: register 
char* becomes char* — end example ]Suchstorage-class-specifiers affect only the definition of the parameter within 
the bodyof the function;theydo notaffect the function type. The resulting listof transformed parameter types and the 
presence or absence of the ellipsis is the function’s parameter-type-list. 

4Acv-qualifier-seq shall only be part of the function type for a non-static member function, the function type to which a 
pointer to member refers, or the top-level function type of a function typedef declaration. The effect of a cv-qualifierseq in a function declarator is not the same as adding cv-qualification on top of the function type. In the latter case, the 
cv-qualifiers are ignored.[ Example: 

typedef void F (); 

struct S {
const F f; // OK: equivalent to: void f();


}; 

— endexample ]The return type, the parameter-type-list and thecv-qualifier-seq,but not the default arguments(8.3.6)or 
theexception specification(15.4),arepartofthe functiontype.[Note: function types are checked during theassignments 
and initializations of pointer-to-functions, reference-to-functions, and pointer-to-member-functions. — end note ] 
5 [Example: the declaration 

int fseek(FILE*, long , int); 

declares a function taking three arguments of the specified types, and returning int (7.1.5). — end example ] 

6 If the type of a parameter includes a type of the form “pointer to array of unknown bound of T” or “reference to array 
of unknown bound of T,”the programis ill-formed.92) Functions shallnothavea returntypeoftype array or function, 
although theymay have a return type of type pointer or reference to such things. There shallbe no arrays of functions, 
although there can be arrays of pointers to functions. Types shall not be defined in return or parameter types. The type 
of a parameter or the return type for a function definition shall not be an incomplete class type (possibly cv-qualified) 

92) This excludes parameters of type “ptr-arr-seq T2” where T2 is “pointer to array of unknown bound of T” and where ptr-arr-seq means any 

sequenceof “pointerto”and “arrayof” derived declarator types. Thisexclusion appliestothe parametersofthe function,andifa parameterisa 

pointer to function or pointer to member function then to its parameters also, etc. 

Draft 


8.3 Meaning of declarators Declarators 160 
unless the function definition is nested within the member-specification for that class (including definitions in nested 
classes defined within the class). 

7 Atypedefoffunctiontypemaybeusedto declarea functionbutshallnotbeusedtodefinea function(8.4).[Example: 

typedef void F (); 

F fv; // OK: equivalent to void fv(); 

F fv {} // ill-formed 

void fv() { } // OK: definition of fv 

— end example ]Atypedef of a function type whose declarator includes acv-qualifier-seq shall be used only to declare 
the function type for a non-static member function, to declare the function type to which a pointer to member refers, or 
to declare the top-level function typeof another function typedef declaration.[ Example: 
typedef int FIC ( int ) const ;
FIC f; // ill-formed: does not declare a member function
struct S {


FIC f; // OK
};
FIC S::*pm = &S::f; // OK


— end example ] 
8 An identifier can optionally be provided as a parameter name; if present in a function definition(8.4), it names a 
parameter (sometimes called “formal argument”).[ Note: in particular, parameter names are also optional in function 
definitions and names used for a parameter in different declarations and the definition of a function need not be the 
same. If a parameter name is present in a function declaration that is not a definition, it cannot be used outside of the 
parameter-declaration-clause sinceitgoesoutof scopeattheendofthe function declarator(3.3). — end note ] 

9 [Example: the declaration 

int i, 

*pi ,
f() ,
*fpi ( int ),
(*pif)(const char*, const char*),
(* fpif ( int ))( int );
declares an integer i,a pointerpi to an integer,afunction f taking no argumentsand returning an integer,a function fpi 
taking an integer argument and returning a pointer to an integer, a pointer pif to a function which takes two pointers 
to constant characters and returns an integer, a function fpif taking an integer argument and returning a pointer to 
a function that takes an integer argument and returns an integer. It is especially useful to compare fpi and pif. The 
binding of *fpi(int) is *(fpi(int)),sothe declaration suggests,andthe same constructioninanexpression requires, 
the calling of a function fpi, and then using indirection through the (pointer) result to yield an integer. In the declarator 
(*pif)(const char*, const char*), the extra parentheses are necessary to indicate that indirection through a 
pointertoa functionyieldsa function,whichisthen called. — endexample ][Note: typedefs are sometimes convenient 
when the return typeofa functionis complex.Forexample, the function fpif above could have been declared 

typedef int IFUNC ( int );
IFUNC * fpif ( int );


Draft 


161 Declarators 8.3 Meaning of declarators 

— end note ] 
8.3.6 Default arguments [dcl.fct.default] 
1 If an expression is specified in a parameter declaration this expression is used as a default argument. Default arguments 
willbe usedin calls wheretrailing arguments are missing. 

2 [Example: the declaration 

void point(int = 3, int = 4); 

declaresa functionthatcanbecalledwithzero,one,ortwoargumentsoftype int.It canbe calledinanyof theseways: 

point (1 ,2); point (1); point (); 

The last two calls are equivalent to point(1,4) and point(3,4), respectively. — end example ] 

3 Adefault argument expression shall be specified only in theparameter-declaration-clause of a function declaration or 
ina template-parameter (14.1).Ifitis specifiedinaparameter-declaration-clause,it shall not occur withina declarator 
or abstract-declarator of a parameter-declaration.93) 

4 For non-template functions, default arguments can be added in later declarations of a function in the same scope. Declarations in different scopes have completely distinct sets of default arguments. That is, declarations in inner scopes 
do not acquire default arguments from declarations in outer scopes, and vice versa. In a given function declaration, all 
parameters subsequent to a parameter with a default argumentshall have default arguments supplied in this or previous 
declarations.Adefaultargument shallnotbe redefinedbya later declaration(noteventothe samevalue).[ Example: 

void g( int = 0 , ...); // OK, ellipsis is not a parameter so it can follow
// a parameter with a default argument


void f(int , int);
void f(int , int = 7);
void h()
{


f (3); // OK, calls f(3, 7)
void f(int = 1, int); // error: does not use default
// from surrounding scope


} 

void m() 

{
void f(int , int); // has no defaults
f (4); // error: wrong number of arguments
void f(int , int = 5); // OK
f (4); // OK, calls f(4, 5);
void f(int , int = 5); // error: cannot redefine, even to


// same value 

}
void n()
{


93) This means that default arguments cannot appear, for example, in declarations of pointers to functions, references to functions, or typedef 
declarations. 

Draft 


8.3 Meaning of declarators Declarators 162 
f (6); // OK, calls f(6, 7)
}


— end example ]For a given inline function defined in different translation units, the accumulated sets of default 
arguments at the end of the translation units shall be the same; see 3.2. If a friend declaration specifies a default 
argument expression, that declaration must be a definition and shall be the only declaration of the function or function 
template in the translation unit. 
5 Adefaultargumentexpressionis implicitly converted (clause4)tothe parameter type. Thedefaultargumentexpression 
has the same semantic constraints as the initializer expression in a declaration of a variable of the parameter type, 
usingthecopy-initialization semantics(8.5). The namesintheexpression are bound,andthe semantic constraints are 
checked,atthepointwherethedefaultargumentexpression appears.Namelookupandcheckingof semantic constraints 
for default arguments in function templates and in member functions of class templates are performed as described in 

14.7.1.[ Example: in the following code, g will be called with the value f(2): 
int a =1;
int f(int);
int g(int x = f(a)); // default argument: f(::a)


void h() {
a =2;
{


int a =3;
g (); // g(f(::a))
}
}


— end example ][Note: in member function declarations, names in default argument expressions are looked up as 
described in 3.4.1. Access checking applies to names in default argument expressions as described in clause 11. — end 
note ] 
6 Except for member functions of class templates, the default arguments in a member function definition that appears 
outside of the class definition are added to the set of default arguments provided by the member function declaration 
in the class definition. Default arguments for a member function of a class template shall be specified on the initial 
declarationof the memberfunction within the class template.[ Example: 

class C {
void f(int i = 3);
void g(int i, int j = 99);


}; 

void C::f(int i = 3) // error: default argument already
{} // specified in class scope
void C::g(int i = 88, int j) // in this translation unit,
{} // C::g can be called with no argument


— end example ] 
7 Localvariables shall notbe usedin default argumentexpressions.[ Example: 
Draft 


163 Declarators 8.3 Meaning of declarators 

void f() 

{
int i;
extern void g(int x = i); //error
// ...


} 

— end example ] 
8 Thekeyword this shall notbe usedina default argumentofa member function.[ Example: 
class A {
void f(A* p = this) { } // error
};


— end example ] 
9 Default arguments are evaluated each time the function is called. The order of evaluation of function arguments is 
unspecified. Consequently, parameters of a function shall notbe usedin default argumentexpressions, evenif they 
are not evaluated. Parameters of a function declared before a default argument expression are in scope and can hide 
namespace and class member names.[ Example: 

int a;
int f(int a, int b = a); // error: parameter a
// used as default argument


typedef int I;
int g(float I, int b = I(2)); // error: parameter I found
int h(int a, int b = sizeof(a)); // error, parameter a used


// in default argument 

— end example ]Similarly, a non-static member shall not be used in a default argument expression,even if it is not 
evaluated, unlessit appearsastheid-expressionofa class member accessexpression(5.2.5)or unlessitisusedtoform 
a pointer to member(5.3.1).[Example: the declaration of X::mem1() in the following example is ill-formed because 
no object is supplied for the non-static member X::a used as an initializer. 
int b; 

class X {
int a;
int mem1(int i = a); // error: non-static member a


// used as default argument
int mem2(int i = b); // OK; use X::b
static int b;


}; 

The declaration of X::mem2() is meaningful, however, since no object is needed to access the static member X::b. 
Classes, objects, and members are describedin clause 9. — end example ]Adefault argument is not part of the type of 
a function.[Example: 

int f(int = 0); 

void h() 

Draft 


8.4 Function definitions Declarators 164 
{
int j = f(1);
int k = f(); // OK, means f(0)


} 

int (*p1)(int) = &f;
int (*p2)() = &f; // error: type mismatch


— end example ]When a declaration of a function is introduced by way of ausing-declaration (7.3.3), any default 
argument information associated with the declaration is made known as well. If the function is redeclared thereafter in 
the namespace with additional default arguments, the additional arguments are also known at anypoint following the 
redeclaration where the using-declaration is in scope. 
10 Avirtual functioncall(10.3)usesthedefaultargumentsinthe declarationofthe virtual function determinedbythe static 
type of the pointer or reference denoting the object. An overriding function in a derived class does not acquire default 
arguments from the functionit overrides.[Example: 

struct A { 

virtual void f(int a = 7);
};
struct B : public A {


void f(int a);
};
void m()
{


B* pb = new B;
A* pa = pb;
pa ->f (); // OK, calls pa->B::f(7)
pb ->f (); // error: wrong number of arguments for B::f()


} 

— end example ] 
8.4 Function definitions [dcl.fct.def] 
1 Function definitionshave theform 

function-definition:
decl-specifier-seqopt declarator ctor-initializeropt function-body
decl-specifier-seqopt declarator function-try-block


function-body:
compound-statement


2 The declarator in a function-definition shall have the form 

D1 ( parameter-declaration-clause ) cv-qualifier-seqopt exception-specificationopt 

as describedin 8.3.5.Afunction shallbe defined onlyin namespace or class scope.
3[Example: a simple example of a complete function definition is


int max(int a, int b, int c)
{


Draft 


165 Declarators 8.5 Initializers 

int m =(a >b) ? a : b;
return (m >c) ? m : c;
}


Here int is the decl-specifier-seq;max(int a, int b, int c) is the declarator;{/* ... */} is the function-body. 

— end example ] 
4Actor-initializer is used only in a constructor; see 12.1 and 12.6. 
5A cv-qualifier-seq can be part of a non-static member function declaration, non-static member function definition, or 
pointer to member function only; see 9.3.2. It is part of the function type. 
6[Note: unused parameters need notbenamed.Forexample, 

void print(int a, int)
{
std::printf("a = %d\n",a);
}


— end note ] 
8.5 Initializers [dcl.init] 
1 Adeclarator can specify an initialvalue for the identifier being declared. The identifier designates an object or reference 
beinginitialized. The process of initialization described in the remainder of 8.5 applies also toinitializations specified 
by other syntactic contexts, such as the initializationoffunction parameters with argumentexpressions(5.2.2)or the 
initializationof returnvalues(6.6.3). 

initializer:
= initializer-clause
( expression-list )


initializer-clause:
assignment-expression
{ initializer-list ,opt }
{}


initializer-list:
initializer-clause
initializer-list , initializer-clause


2 Automatic, register, static, andexternalvariablesof namespace scope canbeinitializedby arbitraryexpressionsinvolving literals and previouslydeclaredvariables and functions.[ Example: 

int f(int);
int a =2;
int b = f(a);
int c(b);


— end example ] 
3 [Note: default argument expressions are more restricted; see 8.3.6. 
The order of initialization of static objects is described in 3.6 and 6.7. — end note ] 

Draft 


8.5 Initializers Declarators 166 
4 Tozero-initialize an object of type T means: 

— if T isa scalar type(3.9), the objectis setto thevalue 0 (zero), taken as an integral constant expression, converted 
to T;94) 
— if T isa non-union class type, each non-static data member and each base-class subobjectis zero-initialized; 
— if T is a union type, the object’s firstnamed data member95) is zero-initialized; 
— if T is an array type, each element is zero-initialized; 
— if T is a reference type, no initialization is performed. 
5 Todefault-initialize an object of type T means: 
— if T isa non-POD classtype (clause 9),thedefault constructorfor T is called (and the initialization is ill-formed 
if T has no accessible default constructor); 
— if T is an array type, each element is default-initialized; 
— otherwise, the object is zero-initialized.
Tovalue-initialize an object of type T means:


— if T isa class type (clause 9)witha user-declared constructor(12.1), then the default constructor for T is called 
(and the initialization is ill-formed if T has no accessible default constructor); 
— if T is a non-union class type without a user-declared constructor, then every non-static data member and base-
class component of T is value-initialized;96) 
— if T is an array type, then each element is value-initialized; 
— otherwise, the object is zero-initialized 
6 Aprogram that calls for default-initialization or value-initialization of an entity of reference type is ill-formed. IfT is a 
cv-qualified type,the cv-unqualifiedversionof T is used for these definitions of zero-initialization, default-initialization, 
and value-initialization. 
7 Every object of static storage duration shall be zero-initialized at program startup before anyother initialization takes 
place.[ Note: in some cases, additional initialization is done later. — end note ] 
8 An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized. 
[Note: since () is not permittedby the syntaxfor initializer, 

X a(); 

is not the declaration of an object of class X,but the declaration of a function taking no argument and returning an X. 
The form () is permittedin certain other initialization contexts(5.3.4, 5.2.3, 12.6.2). — end note ] 

9 If no initializer is specified for an object, and the object is of (possibly cv-qualified) non-POD class type (or array 
thereof), the object shall be default-initialized; if the object is of const-qualified type, the underlying class type shall 
have a user-declared default constructor. Otherwise, if no initializer is specified for a non-static object, the object and 

94)As specified in 4.10, converting an integral constant expression whose value is 0 to a pointer type results in a null pointer value.
95) This member must not be static,by virtue of the requirements in 9.5.
96)Value-initialization for such a class object may be implementedby zero-initializing the object and then calling the default constructor.


Draft 


167 Declarators 8.5 Initializers 

its subobjects, if any, have an indeterminate initial value97);if the object or anyof its subobjects are of const-qualified 
type, the program is ill-formed. 

10 An initializer fora staticmemberisin the scopeof the member’s class.[Example: 

int a; 

struct X {
static int a;
static int b;


}; 

int X::a = 1;
int X::b = a; // X::b = X::a


— end example ] 
11 The form of initialization (using parentheses or =)is generally insignificant, but does matter when the entity being 
initialized hasa class type; see below.Aparenthesized initializercanbea listofexpressions only when the entity being 
initialized has a class type. 

12 The initialization that occursin argument passing, function return, throwing anexception(15.1), handling anexception 
(15.3), and brace-enclosed initializer lists(8.5.1)is calledcopy-initialization and is equivalent to the form 

Tx= a; 

13 The initialization that occurs in new expressions(5.3.4), static_cast expressions(5.2.9), functional notation type 
conversions(5.2.3), and base and member initializers(12.6.2)is calleddirect-initialization and is equivalent to the form 

T x(a); 

14 If T is a scalar type, then a declaration of the form 

Tx ={ a }; 

is equivalent to 

Tx= a; 

15 The semantics of initializers are as follows. The destination type is the type of the object or reference being initialized 
and the source type is the type of the initializer expression. The source type is not defined when the initializer is 
brace-enclosed or when it is a parenthesized list of expressions. 

— If the destination type is a reference type, see 8.5.3. 
— If the destination type is an array of characters or an array of wchar_t, and the initializer is a string literal, see 
8.5.2. 
— Otherwise, if the destination type is an array, see 8.5.1. 
— If the destination type is a (possibly cv-qualified) class type: 
97) This does not apply to aggregate objects with automatic storage duration initialized with an incomplete brace-enclosed initializer-list;see 8.5.1. 

Draft 


8.5 Initializers Declarators 168 
— If the classis an aggregate(8.5.1), and the initializerisa brace-enclosed list, see 8.5.1. 
— If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of 
the source type is the same class as, or a derived class of, the class of the destination, constructors are 
considered. The applicable constructors are enumerated(13.3.1.3), and the best one is chosen through 
overload resolution(13.3). The constructor so selected is called to initialize the object, with the initializer 
expression(s) as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the 
initialization is ill-formed. 
— Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can 
convert from the source type to the destination type or (when a conversion function is used) to a derived 
class thereof are enumeratedas describedin 13.3.1.4,andthe best oneis chosen throughoverload resolution 
(13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed. The function 
selectedis called with the initializer expression as its argument; if the function is a constructor, the call 
initializesa temporaryof the cv-unqualified versionof the destinationtype. The temporaryis an rvalue. 
The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, 
according to the rules above, the object that is the destination of the copy-initialization. In certain cases, an 
implementationis permittedto eliminatethecopying inherentin this direct-initializationby constructingthe 
intermediate result directlyinto the object being initialized; see 12.2, 12.8. 
— Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered. The 
applicable conversion functions are enumerated(13.3.1.5),andthe best oneis chosen throughoverload resolution 
(13.3). The user-defined conversion so selected is called to convert the initializer expression into the object being 
initialized.Iftheconversion cannotbedoneoris ambiguous,the initializationisill-formed. 
— Otherwise, theinitialvalueof the object beinginitializedis the (possibly converted)valueof the initializer expression. Standardconversions(clause 4)willbeused,if necessary,toconvertthe initializerexpressiontothe 
cv-unqualified version of the destination type; no user-defined conversions are considered. If the conversion cannot be done, the initialization is ill-formed.[ Note: an expression of type “cv1 T” can initialize an object of type 
“cv2 T” independently of the cv-qualifiers cv1 and cv2. 
int a;
const int b = a;
int c = b;


— end note ] 
8.5.1 Aggregates [dcl.init.aggr] 
1 An aggregateisanarrayoraclass(clause 9)withnouser-declaredconstructors(12.1),noprivateor protectednon-static 
data members (clause 11), no base classes (clause 10), and no virtual functions(10.3). 

2 When an aggregate is initialized the initializer can contain an initializer-clause consisting of a brace-enclosed, comma-
separated list of initializer-clauses for the members of the aggregate, written in increasing subscript or member order. If 
the aggregate contains subaggregates,thisrule applies recursivelytothe membersofthe subaggregate.[ Example: 

struct A {
int x;
struct B {


Draft 


169 Declarators 8.5 Initializers 

int i;
int j;
} b;
}a ={1, {2, 3}};


initializes a.x with 1, a.b.i with 2, a.b.j with 3. — end example ] 
3 An aggregate that is a class can also be initialized with a single expression not enclosed in braces, as described in 8.5. 
4 An arrayof unknown size initialized with abrace-enclosed initializer-list containing n initializers, where n shall be 

greater than zero, is defined as having n elements(8.3.4).[Example: 

int x[] ={1, 3, 5}; 

declares and initializes x as a one-dimensional array that has three elements since no size was specified and there are 
three initializers. — endexample ]An empty initializer list{} shall not be used as the initializer for an array of unknown 
bound.98) 

5 Static data members are not considered membersof the class for purposesof aggregate initialization.[ Example: 

struct A {
int i;
static int s;
int j;


} a ={1, 2}; 

Here, the second initializer2initializes a.j and not the static data member A::s — end example ] 
6 An initializer-list is ill-formed if the number of initializers exceeds the number of members or elements to initialize. 
[Example: 
char cv[4] = { ’a’, ’s’, ’d’, ’f’, 0 }; // error 

is ill-formed. — end example ] 

7 If there are fewer initializers in the list than there are members in the aggregate, then each member not explicitly 
initialized shallbevalue-initialized(8.5).[Example: 

struct S { int a; char* b; int c; };
S ss = { 1, "asdf" };


initializes ss.a with 1, ss.b with "asdf", and ss.c with the value of an expression of the form int(), that is, 0. 

— end example ] 
8 An initializer for an aggregate member that is an empty class shall have the form of an empty initializer-list {}. 
[Example: 

struct S { }; 

struct A {
S s;
int i;


} a={{} ,3}; 

98) The syntax provides for empty initializer-list s,but nonethelessC++does not have zero length arrays. 

Draft 


8.5 Initializers Declarators 170 
— end example ]An empty initializer-list can be used to initialize anyaggregate. If the aggregate is not an empty class, 
then each member of the aggregate shall be initialized with a value of the form T() (5.2.3), where T represents the type 
of the uninitialized member. 
9 If an incomplete or empty initializer-list leaves a member of reference type uninitialized, the program is ill-formed. 

10 When initializing a multi-dimensional array, the initializers initialize the elements with the last (rightmost) index of the 
arrayvarying thefastest(8.3.4).[Example: 

int x[2][2] ={3, 1, 4, 2}; 

initializes x[0][0] to 3, x[0][1] to 1, x[1][0] to 4, and x[1][1] to 2. On the other hand, 

float y [4][3] = { 

{1}, { 2 }, { 3 }, {4}
};
initializes the first column of y (regarded as a two-dimensional array) and leaves the rest zero. — end example ] 

11 Braces can be elided in an initializer-list as follows. If the initializer-list begins with a left brace, then the succeeding 
comma-separated list of initializers initializes the members of a subaggregate; it is erroneous for there to be more 
initializers than members. If, however, the initializer-list for a subaggregate does not begin with a left brace, then only 
enough initializers from the list are taken to initialize the members of the subaggregate; anyremaining initializers are 
leftto initializethenextmemberofthe aggregateof whichthe current subaggregateisa member.[ Example: 

float y [4][3] = {
{ 1, 3, 5 },
{ 2, 4, 6 },
{ 3, 5, 7 },


}; 

isa completely-braced initialization:1,3,and5initializethefirstrowofthe array y[0], namely y[0][0], y[0][1], 
and y[0][2]. Likewise the next two lines initialize y[1] and y[2]. The initializer ends early and therefore y[3]s 
elements are initialized as if explicitly initialized with an expression of the form float(), that is, are initialized with 

0.0. In the following example, braces in the initializer-list are elided; however the initializer-list has the same effect as 
the completely-braced initializer-list of the above example, 
float y [4][3] = {
1, 3, 5, 2, 4, 6, 3, 5, 7


}; 

The initializer for y begins witha left brace,but the one for y[0] does not, therefore three elements from the list are 
used. Likewise the next three are taken successively for y[1] and y[2]. — end example ] 

12 Allimplicit type conversions (clause 4)are consideredwhen initializing the aggregate member with an initializer from 
an initializer-list. If the initializer can initialize a member, the member is initialized. Otherwise, if the member is itself 
a non-empty subaggregate, brace elision is assumed and the initializer is considered for the initialization of the first 
member of the subaggregate. 

[Example: 

Draft 


171 Declarators 8.5 Initializers 

struct A {
int i;


operator int ();
};
struct B {
A a1 , a2; 

int z;
};
A a;
Bb ={4, a, a };


Braces are elided around the initializer for b.a1.i. b.a1.i is initialized with 4, b.a2 is initialized with a, b.z is 
initialized with whatever a.operator int() returns. — end example ] 

13 [Note: An aggregate array or an aggregate class may contain members of a class type with a user-declared constructor 
(12.1). Initialization of these aggregate objects is described in 12.6.1. — end note ] 

14 When an aggregate with static storage duration is initialized with a brace-enclosed initializer-list, if all the member 
initializer expressions are constant expressions, and the aggregate is a POD type, the initialization shall be done during 
the static phaseof initialization(3.6.2); otherwise,itis unspecified whether the initializationof members with constant 
expressions takes place duringthe static phase or during the dynamic phase of initialization. 

15 When a union is initialized with a brace-enclosed initializer, the braces shall only contain an initializer for the first 
memberof the union.[ Example: 

union u { int a; char* b; }; 

ua ={1};
ub= a;
uc =1; // error
ud ={0, "asdf" }; // error
u e = { "asdf" }; // error


— end example ] 
16 [Note: as described above, the braces around the initializer for a union member can be omitted if the union is a member 
of another aggregate. — end note ] 

8.5.2 Character arrays [dcl.init.string] 
1A char array (whether plain char, signed char, or unsigned char)can be initialized by a string-literal (optionally enclosed in braces); a wchar_t array can be initialized by a wide string-literal (optionally enclosed in braces); 
successive characters of the string-literal initialize the membersofthe array.[ Example: 

char msg[] = "Syntax error on line %s\n"; 

showsa character array whose members are initialized witha string-literal. Note that because ’\n’ isa single character 
and because a trailing ’\0’ is appended, sizeof(msg) is 25. — end example ] 
2 There shall notbe more initializers than there are array elements.[ Example: 
char cv[4] = "asdf"; // error 

Draft 


8.5 Initializers Declarators 172 
is ill-formed since there is no space for the implied trailing ’\0’. — end example ] 

8.5.3 References [dcl.init.ref] 
1 Avariable declared to be a T&, that is “reference to type T (8.3.2), shall be initialized by an object, or function, of type 
T or by an object that can be converted into a T.[ Example: 

int g(int);
void f()
{


int i;
int& r = i; // r refers to i
r =1; // the value of i becomes 1
int* p =&r; // p points to i
int& rr = r; // rr refers to what r refers to, that is, to i
int (&rg)(int) = g; // rg refers to the function g
rg(i ); // calls function g
int a [3];
int (&ra)[3] = a; // ra refers to the array a
ra[1] = i; // modifies a[1]


} 

— end example ] 
2 A reference cannot be changed to refer to another object after initialization. Note that initialization of a reference is 
treatedverydifferentlyfromassignmenttoit.Argumentpassing(5.2.2)and functionvalue return(6.6.3)are initializations. 

3 The initializer canbe omitted fora reference onlyina parameterdeclaration(8.3.5),in the declarationofa function 
return type,inthe declarationofa class member withinits class definition(9.2),andwherethe extern specifier is 
explicitly used.[Example: 

int& r1; // error: initializer missing
extern int & r2 ; // OK


— end example ] 
4 Given types “cv1 T1” and “cv2 T2,” “cv1 T1” is reference-related to “cv2 T2” if T1 is the same type as T2, or T1 is a 
base class of T2.“cv1 T1” is reference-compatible with “cv2 T2” if T1 is reference-related to T2 and cv1 is the same 
cv-qualification as, or greater cv-qualification than, cv2. For purposes of overload resolution, cases for which cv1 is 
greater cv-qualification than cv2 are identified as reference-compatible with added qualification (see 13.3.3.2). In all 
cases where the reference-related or reference-compatible relationship of two types is used to establish the validity of 
a reference binding, and T1 is a base class of T2, a program that necessitates such a binding is ill-formed if T1 is an 
inaccessible (clause 11)or ambiguous(10.2)base class ofT2. 

5 Areference to type “cv1 T1” is initialized by an expression of type “cv2 T2” as follows: 

— If the initializer expression 
— is an lvalue (but is not a bit-field), and “cv1 T1” is reference-compatible with “cv2 T2,” or 
Draft 


173 Declarators 8.5 Initializers 

— has a class type (i.e., T2 is a class type) and can be implicitly converted to an lvalue of type “cv3 T3,” where 
“cv1 T1” is reference-compatible with “cv3 T3”99) (this conversionis selectedby enumerating the applicable 
conversion functions(13.3.1.6)and choosing the best one through overload resolution(13.3)), 
then the reference is bound directly to the initializer expression lvalue in the first case, and the reference is bound 
to the lvalue result of the conversion in the second case. In these cases the reference is said to bind directly to the 
initializer expression.[ Note: the usuallvalue-to-rvalue(4.1), array-to-pointer(4.2), and function-to-pointer(4.3) 
standard conversions are not needed, and therefore are suppressed, when such direct bindings to lvalues are done. 

— end note ] 
[Example: 
d o u b l e d = 2 . 0 ; 
d o u b l e & r d = d ; 
c o n s t d o u b l e & r c d = d ; 
// 
// 
rd refers to d 
rcd refers to d 

struct A { };
struct B : public A {} b;
A& ra = b; // ra refers to A subobject in b
const A& rca = b; // rca refers to A subobject in b


— end example ] 
— Otherwise, the reference shall be to a non-volatile const type (i.e., cv1 shall be const).[Example: 
double & rd2 = 2.0; // error: not an lvalue and reference not const 
int i =2; 
double& rd3 = i; // error: type mismatchand reference not const 

— end example ] 
— If the initializer expression is an rvalue, with T2 a class type, and “cv1 T1” is reference-compatible with “cv2 
T2,”the referenceis bound in oneofthefollowingways (the choiceisimplementation-defined):totheobject 
represented by the rvalue (see 3.10)or to a sub-object within that object. 
— The reference is bound to the object represented by the rvalue (see 3.10)or to a subobject within that 
object. 
— Atemporaryoftype“cv1T2”[sic]iscreated,andaconstructoris calledtocopy theentirervalue object 
into the temporary. The reference is bound to the temporary or to a subobject within the temporary.100) 
The constructor that would be used to make the copy shall be callable whether or not the copy is actually 
done.[Example: 

struct A { };
struct B : public A {} b;
extern B f ();
const A& rca = f(); // Either boundBound to the A subobject of the B rvalue,.


// or the entire B object is copied and the reference 
// is bound to the A subobject of the copy 

99) This requiresa conversion function(12.3.2)returninga reference type. 
100) Clearly, if the reference initialization being processed is one for the first argument of a copy constructor call, an implementation must eventually 
choose the first alternative (binding without copying) to avoid infinite recursion. 

Draft 


8.5 Initializers Declarators 174 
— end example ] 
— If the initializer expression is an rvalue, with T2 an array type, and “cv1 T1” is reference-compatible with 
“cv2 T2,” the reference is bound to the object represented by the rvalue (see 3.10). 
— Otherwise, a temporary of type “cv1 T1” is created and initialized from the initializer expression using the 
rules fora non-reference copy initialization(8.5). The referenceis then boundtothe temporary. If T1 
is reference-related to T2, cv1 must be the same cv-qualification as, or greater cv-qualification than, cv2; 
otherwise, the programis ill-formed.[ Example: 
const double & rcd2 = 2; // rcd2 refers to temporary with value 2.0 
const volatile int cvi = 1; 
const int& r = cvi; // error: type qualifiers dropped 

— end example ]
[Note: 12.2 describes the lifetime of temporaries bound to references. — end note ]
Draft 


Chapter9 Classes [class]


1 Aclassisa type. Its namebecomesaclass-name (9.1)within its scope. 
class-name: 
identifier 
template-id 
Class-specifiers and elaborated-type-specifiers(7.1.5.3)are used to make class-names. An object of a class consists of 
a (possibly empty) sequence of members and base class objects. 

class-specifier:
class-head { member-specificationopt }


class-head:
class-keyidentifieropt base-clauseopt
class-keynested-name-specifier identifier base-clauseopt
class-keynested-name-specifieropt template-id base-clauseopt


class-key: 

class
struct
union


Aclass-specifier where the class-head omits the optional identifier defines an unnamed class. 

2A class-name is inserted into the scope in which it is declared immediately after the class-name is seen. The class-
name is also insertedinto the scopeof the class itself; thisis known as the injected-class-name.For purposes of access 
checking, the injected-class-nameis treated asifit werea publicmember name.A class-specifier is commonly referred 
to asa class definition. Aclassis considereddefined after the closing braceof its class-specifier has been seen even 
though its member functions are in general not yet defined. 

3 Complete objectsand member subobjectsof classtype shallhave nonzero size.101)[Note: class objects can be assigned, 
passed as arguments to functions, and returned by functions (except objects of classes for which copying has been 
restricted; see 12.8). Other plausible operators, such as equality comparison, can be defined by the user; see 13.5. 

— end note ] 
4 Astructure is a class defined with the class-key struct;itsmembers andbase classes(clause10)are publicby default 
(clause 11).A union is a class defined with the class-key union;its members are publicby default andit holds only one 
data memberata time(9.5).[Note: aggregates of class type are described in 8.5.1. — end note ]APOD-struct is an 
aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or 
reference, and has no user-declared copyassignment operator and no user-declared destructor. Similarly, a POD-union 

101) Base class subobjects are not so constrained. 


9.1 Class names Classes 176 
is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such 
types) or reference, and has no user-declared copyassignment operator and no user-declared destructor.A POD class is 
a class that is either a POD-struct or a POD-union. 

5 Ifa class-head contains a nested-name-specifier, the class-specifier shall refer to a class that was previously declared 
directly in the class or namespace to which the nested-name-specifier refers (i.e., neither inherited nor introduced by a 
using-declaration), and the class-specifier shall appear in a namespace enclosing the previous declaration. 

9.1 Class names [class.name] 
1 Aclass definition introducesa new type.[Example: 

struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;


declares threevariablesofthree different types. This implies that 

a1 = a2; // error: Y assigned to X
a1 = a3; // error: int assigned to X


are type mismatches, and that 

int f(X);
int f(Y);


declare an overloaded (clause 13)functionf() and not simply a single function f() twice.For the same reason, 

struct S { int a; };
struct S { int a; }; // error, double definition


is ill-formed because it defines S twice. — end example ] 

2 Aclass declaration introduces the class name into the scope where it is declared and hides anyclass, object, function, 
or other declarationof that namein an enclosing scope(3.3). Ifa class nameis declaredina scope where an object, 
function, or enumerator of the same name is also declared, then when bothdeclarations are in scope, the class can be 
referred to only using an elaborated-type-specifier (3.4.4).[Example: 

struct stat { 

// ... 

}; 

stat gstat ; // use plain stat to
// define variable


int stat ( struct stat *); // redeclare stat as function 

void f()
{
struct stat * ps ; // struct prefix needed


Draft 


177 Classes 9.1 Class names 

// to name struct stat
// ...
stat (ps ); // call stat()
// ...


} 

— end example ]Adeclaration consisting solely of class-key identifier; is either a redeclaration of the name in the 
current scope or a forward declaration of the identifier as a class name. It introduces the class name into the current 
scope.[ Example: 
struct s { int a; }; 

void g()
{
struct s; // hide global struct s


// with a local declaration
s* p; // refer to local struct s
struct s { char* p; }; // define local struct s
struct s; // redeclaration, has no effect


} 

— end example ][Note: Such declarations allow definitionof classes that referto each other.[ Example: 
class Vector ; 

class Matrix { 

// ... 

friend Vector operator *( Matrix & , Vector &);
};


class Vector { 

// ... 

friend Vector operator *( Matrix & , Vector &);
};


Declaration of friends is described in 11.4, operator functions in 13.5. — end example ] — end note ] 

[Note: An elaborated-type-specifier (7.1.5.3)can alsobe used asatype-specifier as part of a declaration. It differs from 
a class declaration in that if a class of the elaborated name is in scope the elaborated name will refer to it. — end note ] 
[Example: 

struct s { int a; }; 

void g(int s) 

{
struct s* p = new struct s; // globals
p->a = s; // local s


} 

— end example ] 
Draft 


9.2 Class members Classes 178 
4[Note: The declaration of a class name takes effect immediately after the identifier is seen in the class definition or 
elaborated-type-specifier.For example, 

class A * A; 

first specifies A to be the name of a class and then redefines it as the name of a pointer to an object of that class. This 
means that the elaborated form class A must be used to refer to the class. Such artistry with names can be confusing 
and is best avoided. — end note ] 

5Atypedef-name (7.1.3)that names a class type, or a cv-qualified version thereof, is also aclass-name,but shall not be 
used as the identifier in a class-head. 

9.2 Class members [class.mem] 
member-specification:
member-declaration member-specificationopt
access-specifier : member-specificationopt


member-declaration:
decl-specifier-seqopt member-declarator-listopt ;
function-definition ;opt
::opt nested-name-specifier templateopt unqualified-id ;
using-declaration
static_assert-declaration
template-declaration


member-declarator-list:
member-declarator
member-declarator-list , member-declarator


member-declarator:
declarator pure-specifieropt
declarator constant-initializeropt
identifieropt : constant-expression


pure-specifier: 

=0 

constant-initializer:
= constant-expression


1 The member-specification in a class definition declares the full set of members of the class; no member can be added 
elsewhere. Membersofaclassaredatamembers,memberfunctions(9.3),nestedtypes,and enumerators.Datamembers 
and member functions are static or non-static; see 9.4. Nested types are classes(9.1, 9.7)and enumerations(7.2)defined 
in the class,and arbitrary types declared as membersby useofa typedef declaration(7.1.3). The enumerators of an 
enumeration(7.2)defined in the class are members of the class. Except when used to declare friends(11.4)or to 
introduce the nameofa memberofabase class intoa derived class(7.3.3,11.3), member-declarationsdeclare members 
of the class, and each such member-declaration shall declare at least one member name of the class. Amember shall 
not be declared twice in the member-specification, exceptthat a nested class or member class template can be declared 
and then later defined. 

2Aclassis considereda completely-definedobjecttype(3.9)(or completetype)attheclosing} of the class-specifier. 
Within the class member-specification, the class is regarded as complete within function bodies, default arguments, 

Draft 


179 Classes 9.2 Class members 

exception-specifications, and constructor ctor-initializers (including such things in nested classes). Otherwise it is regarded as incomplete within its own classmember-specification. 

3 [Note: a single name can denote several function members provided their types are sufficiently different (clause 13). 

— end note ] 
4Amember-declarator can contain a constant-initializer only if it declares a static member(9.4)ofconst integral or 
const enumeration type, see 9.4.2. 

5 Amember canbe initialized usinga constructor; see 12.1.[ Note: see clause 12 for a description of constructors and 
other special member functions. — end note ] 

6 Amember shall not beauto, extern, or register. 

7 The decl-specifier-seq is omitted in constructor, destructor, and conversion function declarations only. The member-
declarator-list can be omitted only after a class-specifier, or an enum-specifier, ora decl-specifier-seq of the form 
friend elaborated-type-specifier. orina friend declaration(11.4).Apure-specifier shall be used only in the declaration of a virtual function(10.3). 

8 Non-static (9.4)data membersshallnothaveincompletetypes.Inparticular,aclassC shall not contain a non-static 
member of class C,but it can contain a pointer or reference to an object of class C. 

9 Each occurrenceinanexpressionofthe nameofa non-static datamemberor non-static memberfunctionofa class shall 
beexpressedasa class memberaccess(5.2.5),except whenit appearsinthe formationofa pointerto member(5.3.1), 
whenit appearsinthebodyofa non-static member functionofits classorofa classderivedfromits class(9.3.1),or 
when it appears in a mem-initializer for a constructor for its class or for a class derived from its class(12.6.2). 

10 [Note: the type of a non-static member function is an ordinary function type, and the type of a non-static data member 
is an ordinary object type. There are no special member function types or data member types. — end note ] 

11 [Example: Asimpleexampleofa classdefinitionis 

struct tnode {
char tword [20];
int count ;
tnode * left ;
tnode * right ;


}; 

which contains an array of twenty characters, an integer, and two pointers to similar structures. Once this definition has 
been given, the declaration 

tnode s, *sp; 

declares s to bea tnode and sp to be a pointer to a tnode. With these declarations, sp->count refers to the count 
member of the structure to which sp points; s.left refers to the left subtree pointer of the structure s;ands.right>tword[0] refers to the initial character of the tword member of the right subtree of s. — end example ] 

12 Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated so that 
later members have higher addresses within a class object. The order of allocation of non-static data members separated 
byan access-specifier is unspecified(11.1). Implementation alignment requirements might cause two adjacent members 

Draft 


9.3 Member functions Classes 180 
nottobe allocated immediately aftereach other;somight requirementsfor spacefor managing virtual functions(10.3) 
and virtual base classes(10.1). 

13 If T is the name of a class, then each of the following shall have a name different from T: 

— every static data member of class T; 
— every member function of class T [Note: this restriction does not apply to constructors, which do not have names 
(12.1) — end note ]; 
— every member of class T that is itself a type; 
— every enumerator of every member of class T that is an enumerated type; and 
— every member of every anonymous union that is a member of class T. 
14 In addition, if class T hasa user-declared constructor(12.1),every non-static data memberof class T shall have a name 
different from T. 

15 Two POD-struct (clause9)types are layout-compatible if theyhave the same number of non-static data members, and 
corresponding non-static data members(in order)have layout-compatible types(3.9). 

16Two POD-union(clause9)typesare layout-compatibleiftheyhavethe same numberof non-staticdatamembers,and 
corresponding non-staticdata members(inanyorder)have layout-compatibletypes(3.9). 

17 If a POD-union contains two or more POD-structs that share a common initial sequence, and if the POD-union object 
currently containsoneofthese POD-structs,itis permittedtoinspectthe common initialpartofanyofthem.TwoPODstructssharea commoninitial sequenceif corresponding membershave layout-compatibletypes(and,for bit-fields,the 
same widths) for a sequence of one or more initial members. 

18 Apointertoa POD-structobject, suitablyconvertedusingareinterpret_cast, points to its initial member (or if that 
member is a bit-field, then to the unit in which it resides) and vice versa. [Note: There might therefore be unnamed 
padding withina POD-struct object,butnotatitsbeginning,as necessaryto achieve appropriate alignment. — end 
note ] 

9.3 Member functions [class.mfct] 
1 Functions declared in the definition of a class, excluding those declared with a friend specifier(11.4), are called 
member functions of that class. A member function may be declared static in which case it is a static member 
functionof its class(9.4); otherwiseitisa non-static member function of its class(9.3.1, 9.3.2). 

2 Amember function maybe defined(8.4)in its class definition,in which caseitis aninline member function(7.1.2), or 
itmaybe defined outsideofitsclass definitionifithasalreadybeendeclaredbutnot definedinitsclass definition. A 
member function definition that appears outsideof the class definition shall appearina namespace scope enclosing the 
class definition. Except for member function definitions that appear outside of a class definition, and except for explicit 
specializations of member functions of class templates and member function templates(14.7)appearing outside of the 
class definition,a memberfunction shall notbe redeclared. 

3 An inline member function (whether static or non-static) may also be defined outside of its class definition provided 
either its declaration in the class definition or its definition outside of the class definition declares the function as inline. 
[Note: member functionsofa classin namespace scopehaveexternal linkage. Member functionsofa local class(9.8) 
have no linkage. See 3.5. — end note ] 

Draft 


181 Classes 9.3 Member functions 

4 There shall be at most one definition of a non-inline member function in a program; no diagnostic is required. There 
may be more than one inline member function definition in a program. See 3.2 and 7.1.2. 

5 Ifthe definitionofamemberfunctionislexicallyoutsideitsclassdefinition,thememberfunctionnameshallbequalified 
by its class name using the :: operator.[ Note: a name used in a member function definition (that is, in the parameter-
declaration-clause includingthedefaultarguments(8.3.6),orinthe member functionbody,or,foraconstructor function 
(12.1), in a mem-initializer expression(12.6.2))is lookedup as describedin 3.4. — end note ][Example: 

struct X {
typedef int T;
static T count ;
void f(T);


};
void X::f(T t = count) { }


The member function f of class X is defined in global scope; the notation X::f specifies that the function f is a member 
of class X and in the scope of class X. In the function definition, the parameter type T refers to the typedef member T 
declared in class X and the default argument count refers to the static data member count declared in class X. — end 
example] 

6Astatic local variable in a member function always refers to the same object, whether or not the member function is 
inline. 

7 Member functions may be mentioned in friend declarations after their class has been defined. 

8 Member functionsofalocalclassshallbe definedinlineintheirclass definition,ifthey are definedatall. 

9[Note: a member function can be declared(but not defined) using a typedef for a function type. The resulting member 
function has exactly the same type as it would have if the function declarator were provided explicitly, see 8.3.5. For 
example, 

typedef void fv(void);
typedef void fvc ( void ) const ;
struct S {


fv memfunc1 ; // equivalent to:void memfunc1(void);
void memfunc2 ();
fvc memfunc3 ; // equivalent to:void memfunc3(void) const;


};
fv S::* pmfv1 = &S::memfunc1;
fv S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;


Also see 14.3. — end note ] 

9.3.1 Nonstatic member functions [class.mfct.non-static] 
1Anon-static member functionmaybe calledforanobjectofitsclasstype,orforanobjectofaclassderived(clause 10) 
fromits class type, usingthe class memberaccess syntax(5.2.5, 13.3.1.1).Anon-static member functionmay alsobe 
called directly using the function call syntax(5.2.2, 13.3.1.1) 

— from within the body of a member function of its class or of a class derived from its class, or 
— from a mem-initializer (12.6.2)for a constructor for its class or for a class derived from its class. 
Draft 


9.3 Member functions Classes 182 
2 If a non-static member function of a class X is called for an object that is not of type X, or of a type derivedfrom X, the 
behavior is undefined. 

3 When an id-expression (5.1)thatisnotpartofa class member accesssyntax(5.2.5)andnotusedtoforma pointer 
to member(5.3.1)is usedin the bodyofa non-static member functionof classX or used in the mem-initializer for a 
constructor of class X, if name lookup(3.4.1)resolves the namein theid-expression to a non-static non-type member 
of class X or of a base class of X,the id-expression is transformed intoa class member accessexpression(5.2.5)using 
(*this) (9.3.2)as the postfix-expression to the left of the . operator. The member name then refers to the member 
of the object for which the function is called. Similarly during name lookup, when an unqualified-id (5.1)used in the 
definition of a member function for class X resolves to a static member, an enumerator or a nested type of class X or 
of a base class of X, the unqualified-id is transformed into a qualified-id (5.1)in which thenested-name-specifier names 
the classof the member function.[ Example: 

struct tnode {
char tword [20];
int count ;
tnode * left ;
tnode * right ;
void set(char*, tnode* l, tnode* r);


}; 

void tnode::set(char* w, tnode* l, tnode* r) 

{
count = strlen(w)+1;
if (sizeof(tword)<=count)


perror("tnode string too long");
strcpy(tword ,w);
left = l;
right = r;


} 

void f(tnode n1, tnode n2) 

{
n1.set("abc",&n2 ,0);
n2.set("def" ,0,0);


} 

In the bodyofthe member function tnode::set,the member namestword,count, left, and right refer to members 
of the object for which the function is called. Thus, in the call n1.set("abc",&n2,0), tword refers to n1.tword, and 
in the call n2.set("def",0,0), it refers to n2.tword. The functions strlen, perror, and strcpy are not members 
of the class tnode and should be declared elsewhere.102) — end example ] 

4 Anon-static member function may be declaredconst, volatile, or const volatile. These cv-qualifiers affect the 
type of the this pointer(9.3.2).Theyalsoaffectthe functiontype(8.3.5)ofthe member function;a member function 
declared const is a const member function, a member function declared volatile is a volatile member function and a 
member function declared const volatile is a const volatile member function.[ Example: 

struct X { 

102) See, for example, <cstring> (21.4). 

Draft 


183 Classes 9.3 Member functions 

void g () const ;
void h () const volatile ;
};


X::g is a const member function and X::h is a const volatile member function. — end example ] 
5 Anon-static member function may be declaredvirtual (10.3)or pure virtual (10.4). 

9.3.2 The this pointer [class.this] 
1 In the bodyofa non-static(9.3)member function, thekeywordthis is a non-lvalue expression whose value is the 
address of the object for which the function is called. The type of this in a member function of a class X is X*. If 
the member function is declared const, the type of this is const X*, if the member function is declared volatile, 
the type of this is volatile X*, and if the member function is declared const volatile, the type of this is const 
volatile X*. 

2 Ina const member function, the object for which the function is called is accessed through a const access path; 
therefore, a const member function shall notmodify the object and its non-static data members.[ Example: 

struct s {
int a;
int f () const ;
int g() { return a++; }
int h () const { return a ++; } // error


}; 

int s::f() const { return a; } 

The a++ in the body of s::h is ill-formed because it tries to modify (a part of) the object for which s::h() is called. 
This is not allowed in a const member function because this is a pointer to const;that is,*this has const type. 

— end example ] 
3 Similarly, volatile semantics(7.1.5.1)apply involatile member functions when accessing the object and its non-
static data members. 

4 A cv-qualified member function can be called on an object-expression(5.2.5)only if the object-expression is as cvqualified or less-cv-qualifiedthan the member function.[ Example: 

void k(s& x, const s& y)
{


x.f (); 
x.g (); 
y.f (); 
y.g (); // error
}
The call y.g() is ill-formed because y is const and s::g() is a non-const member function, that is, s::g() is 
less-qualified than the object-expressiony. — end example ] 

Draft 


9.4 Static members Classes 184 
5 Constructors(12.1)and destructors(12.4)shall not be declaredconst, volatile or const volatile.[ Note: However,these functionscanbeinvokedto createanddestroyobjectswith cv-qualifiedtypes,see(12.1)and(12.4). — end 
note ] 

9.4 Static members [class.static] 
1 Adata or function member of a class may be declaredstatic in a class definition, in which case it is a static member 
of the class. 

2Astatic member s of class X maybe referredto using the qualified-id expression X::s;it is not necessary to use the 
class member accesssyntax(5.2.5)to refertoastatic member.A static member may be referred to using the class 
member access syntax, in which case the object-expression is evaluated.[Example: 

class process {
public :


static void reschedule ();
};
process & g ();


void f() 

{
process::reschedule (); // OK: no object necessary
g (). reschedule (); // g() is called


} 

— end example ] 
3 Astatic membermaybe referredto directlyinthe scopeofits classorinthe scopeofa class derived (clause 10)from 
its class; in this case, the static member is referred to as if a qualified-id expression was used, with the nested-namespecifier of the qualified-id naming the class scope from which the static memberis referenced.[ Example: 

int g();
struct X {


static int g ();
};
struct Y : X{


static int i;
};
int Y::i = g(); // equivalent toY::g();


— end example ] 
4 If an unqualified-id (5.1)is used in the definition of astatic member following the member’s declarator-id, and name 
lookup(3.4.1)finds that theunqualified-id refers to a static member, enumerator, or nested type of the member’s 
class (or of a base class of the member’s class), the unqualified-id is transformed into a qualified-id expression in which 
the nested-name-specifier names the class scope from which the member is referenced. The definition of a static 
membershallnotusedirectlythe namesofthe non-static membersofitsclassorofabaseclassofitsclass(includingas 
operands of the sizeof operator). The definitionofa static member may only refer to thesemembersto form pointer 
to members(5.3.1)or with the class member access syntax(5.2.5). 

Draft 


185 Classes 9.4 Static members 

5 Static members obeythe usual class member access rules (clause 11). When used in the declaration of a class member, 
the static specifier shall only be used in the member declarations that appear within the member-specification of the 
class definition.[ Note: it cannot be specified in member declarations that appear in namespace scope. — end note ] 

9.4.1 Static member functions [class.static.mfct] 
1 [Note: the rules described in 9.3 apply to static member functions. — end note ] 

2[Note: a static member function does not have a this pointer(9.3.2). — end note ]Astatic member function 
shall not be virtual. There shall not be a static and a non-static member function with the same name and the same 
parameter types(13.1).A static member function shall notbe declared const, volatile, or const volatile. 

9.4.2 Static data members [class.static.data] 
1Astatic data memberisnotpartofthe subobjectsofa class.Thereisonly onecopyofa static data member shared 
by all the objects of the class. 

The declaration of a static data member in its class definition is not a definition and may be of an incomplete type 
other than cv-qualified void. The definition fora static data member shall appearina namespace scope enclosing the 
member’s class definition. In the definition at namespace scope, the name of the static data member shall be qualified 
by its class name using the :: operator. The initializer expression in the definition of a static data member is in the 
scopeof its class(3.3.6).[Example: 

class process {
static process * run_chain ;
static process * running ;


}; 

process * process :: running = get_main ();
process * process :: run_chain = running ;


The static data member run_chain of class process is defined in global scope; the notation process::run_chain 
specifies that the member run_chain is a member of class process and in the scope of class process. In the static 
data member definition, the initializer expression refers to the static data member running of class process. — end 
example] 

[Note: once the static data member has been defined, it exists even if no objects of its class have been created. 
[Example: in the example above, run_chain and running exist even if no objects of class process are createdbythe 
program. — end example ] — end note ] 

2 Ifa static data member is of const integral or const enumeration type, its declaration in the class definition can 
specify a constant-initializer whichshallbeanintegral constantexpression(5.19).Inthatcase,themembercanappear 
in integral constant expressions. The member shall still be defined in a namespace scope if it is used in the program and 
the namespace scope definition shall not contain an initializer. 

3 There shall be exactly one definition of a static data member that is used in a program; no diagnostic is required; see 

3.2. Unnamed classes and classes contained directly or indirectly within unnamedclasses shall not contain static data 
members. 
4 Static data membersofa classin namespace scopehaveexternal linkage(3.5).Alocalclass shall nothave static 
data members. 

Draft 


9.5 Unions Classes 186 
5 Static data members are initializedand destroyed exactly like non-local objects(3.6.2, 3.6.3). 
6Astatic data member shall not be mutable (7.1.1). 

9.5 Unions [class.union] 
1 In a union, at most one of the data members can be active at any time, that is, the value of at most one of the data 
members can be stored in a union at anytime. [Note: one special guarantee is made in order to simplify the use of 
unions:Ifa POD-union containsseveralPOD-structs that sharea common initial sequence(9.2),andif an objectof 
this POD-union type contains one of the POD-structs, it is permitted to inspect the common initial sequence of anyof 
POD-struct members; see 9.2. — end note ]The size of a union is sufficient to contain the largest of its data members. 
Each data memberisallocated asifit were the sole memberofa struct.Aunion canhave member functions (including 
constructors and destructors),but not virtual(10.3)functions. Aunion shall nothave base classes. Aunion shall not 
beusedasabase class.Anobjectofa classwitha non-trivialdefault constructor(12.1),a non-trivialcopyconstructor 
(12.8),a non-trivial destructor(12.4), ora non-trivial copyassignment operator(13.5.3, 12.8)cannotbea memberofa 
union, nor can an array of such objects. If a union contains a static data member, or a member of reference type, the 
program is ill-formed. 

2 Aunion of the form 

union {member-specification}; 

is called an anonymous union; it defines an unnamed object of unnamed type. The member-specification of an anonymous union shall onlydefine non-static data members.[ Note: nested types and functions cannot be declared within an 
anonymous union. — end note ]The names of the members of an anonymous union shall be distinct from the names 
of anyother entity in the scope in which the anonymous union is declared. For the purpose of name lookup, after the 
anonymous union definition,the membersofthe anonymous union are consideredtohavebeen definedinthe scopein 
which the anonymous unionis declared.[ Example: 

void f() 

{
union { int a; char* p; };
a =1;


// ... 

p = "Jennifer"; 

// ... 

} 

3 Here a and p are used like ordinary (nonmember) variables, but since they are union members they have the same 
address. — end example ] 

Anonymous unions declared in a named namespace or in the global namespace shall be declared static. Anonymous 
unions declared at block scope shall be declared with anystorage class allowed for a block-scope variable, or with no 
storage class. Astorage class is not allowed in a declaration of an anonymous union in a class scope. An anonymous 
union shall not have private or protected members (clause 11). An anonymous union shall not have function 
members. 

4 Aunion for which objects orpointers are declaredis not an anonymous union.[Example: 

union { int aa; char* p; } obj , *ptr = &obj;
aa =1; // error
ptr ->aa = 1; // OK


Draft 


187 Classes 9.6 Bit-fields 

The assignment to plain aa is ill-formed since the member name is not visible outside the union, and even if it were 
visible, it is not associated with anyparticular object. — end example ][Note: Initialization of unions with no user-
declared constructorsis describedin(8.5.1). — end note ] 

9.6 Bit-fields [class.bit] 
1 Amember-declarator of the form 

identifieropt : constant-expression 

specifies a bit-field; its length is set off from the bit-field name by a colon. The bit-field attribute is not part of the 
type of the class member. The constant-expression shall be an integral constant-expression with a value greater than or 
equal to zero. The constant-expression may be larger than the number of bits in the object representation(3.9)of the 
bit-field’s type; in such cases the extra bits are used as padding bits and do not participate in the value representation 
(3.9)of the bit-field. Allocation ofbit-fields within a class object is implementation-defined. Alignment of bit-fields is 
implementation-defined. Bit-fields are packed into some addressable allocation unit.[ Note: bit-fieldsstraddle allocation 
units on some machines and not on others. Bit-fields are assigned right-to-left on some machines, left-to-right on others. 

— end note ] 
2 Adeclaration for a bit-field that omits theidentifier declares an unnamed bit-field. Unnamed bit-fields are not members 
and cannot be initialized.[ Note: an unnamed bit-field is useful for padding to conform to externally-imposed layouts. 

— end note ]As a special case, an unnamedbit-field with a width ofzero specifies alignment of the next bit-field at an 
allocation unit boundary. Only when declaring an unnamed bit-field may the constant-expression be a value equal to 
zero. 
3 Abit-fieldshallnotbeastaticmember.Abit-fieldshallhaveintegralor enumerationtype(3.9.1).Itis implementationdefinedwhetheraplain (neitherexplicitly signed norunsigned) char,short,int or long bit-fieldissigned or unsigned. 
Abool value cansuccessfullybe storedina bit-fieldofanynonzero size. The address-of operator & shall not be applied 
to a bit-field, so there are no pointers to bit-fields. A non-const reference shall not be bound to a bit-field(8.5.3). 
[Note: ifthe initializerfora referenceoftype const T& is an lvalue that refers to a bit-field, the reference is bound to 
a temporary initialized to hold the value of the bit-field; the reference is not bound to the bit-field directly. See 8.5.3. 

— end note ] 
4 If the value true or false is stored into a bit-field of type bool of anysize (including a one bit bit-field), the original 
bool valueandthevalueofthebit-fieldshallcompareequal.Ifthevalueofan enumeratorisstoredintoa bit-fieldofthe 
same enumeration type and the number of bits in the bit-field is large enough to hold all the values of that enumeration 
type, the original enumeratorvalue and thevalueof the bit-field shall compare equal.[ Example: 

enum BOOL { FALSE = 0 , TRUE =1 };
struct A {


BOOL b :1;
};
A a;
void f() {


a.b = TRUE;
if (a.b == TRUE) // shall yield true
{ /* ... * / }
} 

Draft 


9.7 Nested class declarations Classes 188 
— end example ] 
9.7 Nested class declarations [class.nest] 
1 Aclass can be declared within another class. Aclass declared within another is called anested class. The name of a 
nested class is local to its enclosing class. The nested class is in the scope of its enclosing class.[ Note: In accordance 
with9.2,exceptbyusingexplicitpointers, references,andobjectnames,declarationsinanestedclassshallnotusenonstatic data members or non-static member functions from the enclosing class. This restriction applies in all constructs 
including the operands of the sizeof operator. — end note ] 

[Example: 

int x;
int y;


class enclose { 

public :
int x;
static int s;


class inner { 

void f(int i) 

{ 
int a = sizeof(x); // error: direct use of enclose::x even in sizeof 
x = i; // error: assign to enclose::x 
s = i; // OK: assign to enclose::s 
::x = i; // OK: assign to global x 
y = i; // OK: assign to global y 

} 

void g(enclose* p, int i)
{
p->x = i; // OK: assign to enclose::x
}


};
};


inner* p = 0; // error: inner not in scope 

— end example ] 
2 Memberfunctionsandstaticdatamembersofanestedclasscanbedefinedinanamespacescopeenclosingthe definition 
of their class.[ Example: 

class enclose {
public :


class inner {
static int x;
void f(int i);


Draft 


189 Classes 9.8 Local class declarations 

};
};


int enclose::inner::x = 1; 

void enclose::inner::f(int i) { /* ... * / } 

— end example ] 
3 If class X is defined in a namespace scope, a nested class Y may be declared in class X and later definedin thedefinition 
of class X or be later defined in a namespace scope enclosing the definition of class X.[ Example: 

class E {
class I1 ; // forwarddeclaration of nested class
class I2;
class I1 {}; // definition of nested class


};
class E::I2 {}; // definition of nested class


— end example ] 
4 Likea member function, a friend function(11.4)defined withina nested classisinthelexical scopeof that class;it 
obeys the same rules for name binding as a static member function of that class(9.4)and has no special access rights to 
members of an enclosing class. 

9.8 Local class declarations [class.local] 
1 Aclass canbe declared withina function definition; sucha classis calledalocal class. The nameofa local classis local 
to its enclosing scope. The local class is in the scope of the enclosing scope, and has the same access to names outside 
the function as does the enclosing function. Declarations in a local class can use only type names, static variables, 
extern variables and functions, and enumerators from the enclosing scope.[Example: 

int x;
void f()
{


static int s ;
int x;
extern int g ();


struct local {
int g() { return x; } // error: x is auto
int h() { return s; } // OK
int k() { return ::x; } // OK
int l() { return g(); } // OK


}; 

// ... 

} 

local* p = 0; // error: local not in scope 

— end example ] 
Draft 


9.9 Nested type names Classes 190 
2 An enclosing function has no special access to members of the local class; it obeys the usual access rules (clause 11). 
Member functionsofa local class shallbe defined within their class definition,iftheyare definedat all. 

3 If class X is a local class a nested class Y may be declared in class X and later defined in the definition of class X or be 
later defined in the same scope as the definition of class X.Aclass nested within a localclass is a local class. 

4 Alocal class shall not have static data members. 

9.9 Nested type names [class.nested.type] 
1 Type names obeyexactly the same scope rules as other names. In particular, type names defined withina class definition 
cannotbe used outside theirclass without qualification.[ Example: 

class X { 

public :
typedef int I;
class Y { /* ... * / };
I a;


}; 

I b; // error
Y c; // error


X::Y d; // OK 
X::I e; // OK 
— end example ] 
Draft 


Chapter 10 Derived classes [class.derived]


1 Alist of base classes can be specified in a class definition using the notation: 

base-clause:
: base-specifier-list


base-specifier-list:
base-specifier
base-specifier-list , base-specifier


base-specifier:
::opt nested-name-specifieropt class-name
virtual access-specifieropt ::opt nested-name-specifieropt class-name
access-specifier virtualopt ::opt nested-name-specifieropt class-name


access-specifier: 

private
protected
public


2 The class-name in a base-specifier shallnotbean incompletely definedclass(clause 9);thisclassiscalleda direct base 
class for the class being defined. During the lookup fora base class name, non-type names are ignored(3.3.7). If the 
name found is not a class-name, the program is ill-formed. Aclass B is a base class of a class D if it is a direct base 
class of D or a direct base class of one of D’s base classes.Aclassis an indirect base classof anotherifitisa base class 
butnota directbase class.Aclassissaidtobe (directlyor indirectly)derived from its (direct or indirect) base classes. 
[Note: See clause 11 for the meaning of access-specifier. — end note ]Unless redeclared in the derived class, members 
of a base class are also considered to be members of the derived class. The base class members are said to be inherited 
by the derived class. Inherited members can be referred to in expressions in the same manner as other members of the 
derived class, unless their names are hidden or ambiguous(10.2).[Note: the scope resolution operator :: (5.1)can be 
usedtorefertoadirector indirectbasememberexplicitly.Thisallows accesstoanamethathasbeen redeclaredinthe 
derived class. Aderived class can itself serve as a base class subject to access control; see 11.2. Apointer to a derived 
class canbe implicitly convertedtoapointertoan accessible unambiguousbase class(4.10).Anlvalueofaderived 
classtypecanbeboundtoareferencetoan accessible unambiguousbaseclass(8.5.3). — end note ] 

3 The base-specifier-list specifies the type of the base class subobjects contained in an object of the derived class type. 
[Example: 

class Base {
public :
int a, b, c;
};



10.1 Multiple base classes Derived classes 192 
class Derived : public Base {
public :
int b;
};


class Derived2 : public Derived {
public :
int c;
};


Here, an object of class Derived2 will have a subobject of class Derived which in turn will have a subobject of class 
Base. — end example ] 

4 The orderin which the base class subobjects are allocatedin the most derived object(1.8)is unspecified. [Note: a 
derived class and its base class subobjects canbe representedbya directed acyclic graph(DAG) where an arrow means 
“directlyderived from.”ADAGof subobjectsis often referredtoasa “subobject lattice.” 

Base 

Derived1 

Derived2 

5 The arrows need not have a physical representation in memory. — end note ] 

6 [Note: initialization of objects representing base classes can be specified in constructors; see 12.6.2. — end note ] 

7[Note: Abaseclass subobjectmighthavealayout(3.7)differentfromthelayoutofamostderivedobjectofthe same 
type.Abase class subobject mighthavea polymorphic behavior(12.7)different from the polymorphic behaviorofa 
mostderivedobjectofthesametype.Abaseclasssubobjectmaybeof zerosize(clause 9);however,twosubobjects 
that have the same class type and that belong to the same most derived object must not be allocated at the same address 
(5.10). — end note ] 

10.1 Multiple base classes [class.mi] 
1Aclasscanbederivedfromanynumberofbase classes.[Note: the use of more than one direct base class is often called 
multiple inheritance. — end note ][Example: 

class A { /* ... * / };
class B { /* ... * / };
class C { /* ... * / };
class D : public A , public B , public C { /* ... * / };


— end example ] 
2 [Note: the order of derivation is not significant except as specified by the semantics of initialization by constructor 
(12.6.2), cleanup(12.4), and storage layout(9.2, 11.1). — end note ] 

Draft 


193 Derived classes 10.1 Multiple base classes 

3Aclass shallnotbe specifiedasa directbase classofaderived class morethan once. [Note: a class can be an indirect 
base class more than once and can be a direct and an indirect base class. There are limited things that can be done with 
such a class. The non-static data members and member functions of the direct base class cannot be referred to in the 
scope of the derived class. However, the static members, enumerations and types can be unambiguously referred to. 

— end note ][Example: 
class X { /* ... * / };
class Y : public X , public X { /* ... * / }; // ill-formed


class L { public : int next ; /* ... * / };
class A : public L { /* ... * / };
class B : public L { /* ... * / };
class C : public A , public B { void f (); /* ... * / }; // well-formed
class D : public A , public L { void f (); /* ... * / }; // well-formed


— end example ] 
4 A base class specifier that does not contain the keyword virtual, specifies a non-virtual base class. A base class 
specifier that contains thekeyword virtual, specifiesa virtual base class.For each distinct occurrenceofa non-virtual 
base class in the class lattice of the most derived class, the most derived object(1.8)shall contain a corresponding 
distinct base class subobject of that type. For each distinct base class that is specified virtual, the most derived object 
shall containa single base class subobjectof that type.[ Example: for an object of class type C, each distinct occurrence 
ofa (non-virtual) base class L in the class lattice of C corresponds one-to-one withadistinct L subobject within the object 
of type C. Given the class C defined above, an object of class C will have two subobjects of class L as shown below. 

L L 

A B 

C 

5 In such lattices,explicitqualification canbe usedto specifywhich subobjectis meant. Thebodyof function C::f could 
refer to the member next of each L subobject: 

void C::f() { A::next = B::next; } // well-formed 

Without theA:: or B:: qualifiers, the definition of C::f abovewouldbe ill-formed becauseof ambiguity(10.2). 

6 For another example, 

class V { /* ... * / };
class A : virtual public V { /* ... * / };
class B : virtual public V { /* ... * / };
class C : public A , public B { /* ... * / };


for an object c of class type C, a single subobject of type V is shared by every base subobject of c that has a virtual 
base class of type V. Given the class C defined above, an object of class C will have one subobject of class V, as shown 
below. 

Draft 


10.2 Member name lookup Derived classes 194 
. V.Q

A B 

C 

7 Aclass can have both virtual and non-virtual base classes of a given type. 

class B { /* ... * / };
class X : virtual public B { /* ... * / };
class Y : virtual public B { /* ... * / };
class Z : public B { /* ... * / };
class AA : public X , public Y , public Z { /* ... * / };


For an object of class AA, all virtual occurrences of base class B in the class lattice of AA correspond to a single B 
subobject within the object of type AA, and every other occurrence of a (non-virtual) base class B in the class lattice of 
AA corresponds one-to-one with a distinct B subobject within the object of type AA. Given the class AA defined above, 
class AA has two subobjects of class B:Z’s B and the virtual B sharedby X and Y, as shown below. 

. B .Q
B 

X YZ 

AA 

— end example ] 
10.2 Member name lookup [class.member.lookup] 
1 Member name lookup determines the meaningofa name(id-expression)ina class scope(3.3.6). Name lookup can 
result in an ambiguity, in which case the program is ill-formed. For anid-expression, name lookup begins in the class 
scope of this; for aqualified-id, name lookup begins in the scope of the nested-name-specifier. Name lookup takes 
place before access control(3.4, clause 11). 

2 The following steps define the result of name lookup for a member name f in a class scope C. 

3 The lookup set for f in C, called S( f,C),consistsoftwo componentsets: the declaration set,a set of members named f; 
and the subobject set, a set of subobjects where declarations of these members (possibly including using-declarations) 
were found. In the declaration set, using-declarations are replacedbythe members theydesignate, andtype declarations 
(including injected-class-names) are replaced by the types theydesignate. S( f,C) is calculated as follows: 

4 If C containsadeclarationofthe name f,the declaration set containsevery declarationoff declared in C that satisfies the 
requirements of the language construct in which the lookup occurs. [Note: Looking up a name in an elaborated-typespecifier (3.4.4)orbase-specifier (clause10),for instance, ignoresall non-type declarations, while lookingupa namein 

Draft 


195 Derived classes 10.2 Member name lookup 

a nested-name-specifier (3.4.3)ignores function, object, and enumerator declarations. As another example, looking up 
a name in a using-declaration (7.3.3)includes the declaration of a class or enumeration that would ordinarily be hidden 
by another declaration of that name in the same scope. — end note ]If the resulting declaration set is not empty, the 
subobject set contains C itself, and calculation is complete. 

5 Otherwise(i.e., C does not contain a declaration of f or the resulting declaration set is empty), S( f,C) is initially empty. 
If C has base classes, calculate the lookup set for f in each direct base class subobject Bi, and merge each such lookup 
set S( f,Bi) in turn into S( f,C). 

6 The following steps define the result of merging lookup set S( f,Bi) into the intermediate S( f,C): 

— If each of the subobject members of S( f,Bi) is a base class subobject of at least one of the subobject members 
of S( f,C), or if S( f,Bi) is empty, S( f,C) is unchanged and the merge is complete. Conversely, if each of the 
subobject members of S( f,C) is a base class subobject of at least one of the subobject members of S( f,Bi), or if 
S( f,C) is empty, the new S( f,C) isa copyof S( f,Bi). 
— Otherwise, if the declaration sets of S( f,Bi) and S( f,C) differ, the merge is ambiguous: the new S( f,C) is a 
lookup set with an invalid declaration set and the union of the subobject sets. In subsequent merges, an invalid 
declaration set is considered different from anyother. 
— Otherwise, the new S( f,C) is a lookup set with the shared set of declarations and the union of the subobject sets. 
7 The result of name lookup for f in C is thedeclaration set of S( f,C). If it is aninvalid set, the program is ill-formed. 
[Example: 

struct A { int x; }; // S(x,A)={{A::x },{ A }}
struct B { float x ; }; // S(x,B)={{B::x },{ B }}
struct C: public A, public B { }; // S(x,C)={invalid,{A in C, B in C }}
struct D: public virtual C { }; // S(x,D)= S(x,C)
struct E: public virtual C { char x; }; // S(x,E)={{E::x },{ E }}
struct F: public D, public E { }; // S(x,F)= S(x,E)
int main () {


F f; 

f.x =0; // OK, lookup finds E::x
}
S(x,F) is unambiguous because the A and B base subobjects of D are also base subobjects of E, so S(x,D) is discarded 
in the first merge step. — end example ] 

8 If the nameof anoverloaded functionis unambiguously found,overloading resolution(13.3)also takes place before 
access control. Ambiguities can oftenbe resolvedby qualifyinga name with its class name.[ Example: 

class A {
public :
int f ();
};


class B {
public :
int f ();
};


Draft 


10.2 Member name lookup Derived classes 196 
class C : public A , public B {
int f() { return A::f() + B::f(); }
};


— end example ] 
9 [Note: A static member, a nested type or an enumerator defined in a base class T can unambiguously be found even 
if an object has more than one base class subobject of type T.Two base class subobjects share the non-static member 
subobjects of their common virtual base classes. — end note ][Example: 

class V { public: int v; };
class A {
public :


int a;
static int s;
enum {e};


};
class B : public A , public virtual V {};
class C : public A , public virtual V {};


class D : public B , public C { }; 

void f(D* pd) 

{
pd ->v ++; // OK: only one v (virtual)
pd ->s ++; // OK: only one s (static)
int i = pd->e; // OK: only one e (enumerator)
pd ->a ++; // error, ambiguous: two as in D


} 

— end example ] 
10 [Note: When virtual base classes are used, a hidden declaration can be reached along a path through the subobject 
lattice that does not pass through thehiding declaration. This is not an ambiguity. The identical use with non-virtual 
base classes is an ambiguity; in that case there is no unique instance of the name that hides all the others. — end 
note ][Example: 

class V { public: int f(); int x; };
class W { public: int g(); int y; };
class B : public virtual V , public W
{
public :


int f(); int x; 

int g(); int y;
};
class C : public virtual V , public W { };


class D : public B , public C { void glorp (); }; 

— end example ] 
Draft 


197 Derived classes 10.2 Member name lookup 

WV W

.Q..Q. 

B C 

D 

11 [Note: The names declared in V and the left-hand instance of W are hidden by those in B,but the names declared in the 
right-hand instance of W are not hidden at all. — end note ] 

void D::glorp() 

{
x ++; // OK: B::x hides V::x
f (); // OK: B::f() hides V::f()
y ++; // error: B::y and C’s W::y
g (); // error: B::g() and C’s W::g()


} 

— end example ] 
12 An explicit or implicit conversion from a pointer to or an lvalue of a derived class to a pointer or reference to one of its 
base classesshallunambiguouslyrefertoauniqueobject representingthebaseclass.[ Example: 

class V {};
class A {};
class B : public A , public virtual V { };
class C : public A , public virtual V { };
class D : public B , public C { };


void g() 

{
D d;
B* pb =&d;
A* pa =&d; // error, ambiguous: C’s A or B’s A?
V* pv =&d; // OK: only one V subobject


} 

— end example ] 
13 [Note: Even if the result of name lookup is unambiguous, use of a name found in multiple subobjects might still be 
ambiguous(4.11, 5.2.5, 11.2). — end note ][Example: 

struct B1 {
void f ();
static void f(int);
int i;


};
struct B2 {
void f(double);


Draft 


10.3 Virtual functions Derived classes 198 
};
struct I1: B1 { };
struct I2: B1 { };


struct D: I1, I2, B2 {
using B1::f;
using B2::f;
void g() {


f (); // Ambiguous conversion ofthis 
f (0); // Unambiguous (static) 
f (0.0); // Unambiguous (only oneB2) 
int B1::* mpB1 = &D::i; // Unambiguous 
int D::* mpD = &D::i; // Ambiguous conversion 

}
};


— end example ] 
10.3 Virtual functions [class.virtual] 
1 Virtual functions support dynamic binding and object-oriented programming. Aclass that declares or inherits a virtual 
function is called a polymorphic class. 

2 If a virtual member function vf is declared in a class Base and in a class Derived, derived directly or indirectly 
from Base, a member function vf with the same name, parameter-type-list(8.3.5), and cv-qualification as Base::vf 
is declared, then Derived::vf is also virtual (whether or not itis so declared) and it overrides103) Base::vf. For 
convenience we say that anyvirtual function overrides itself. Then in any well-formed class, for each virtual function 
declared in that class or any of its direct or indirect base classes there is a unique final overrider that overrides that 
functionandeveryotheroverriderofthatfunction.Therulesformemberlookup(10.2)areusedto determinethefinal 
overrider fora virtual functionin the scopeofa derived classbut ignoring names introducedby using-declarations. 
[Example: 

struct A { 

virtual void f ();
};
struct B : virtual A {


virtual void f ();
};


struct C:B,virtual A{ 

using A::f;
};
void foo () {


C c; 

c.f (); // calls B::f, the final overrider 
c.C::f (); // calls A::f because of the using-declaration 
103)Afunctionwiththe same namebutadifferent parameterlist (clause13)asa virtual functionisnot necessarily virtualanddoesnotoverride.The 
use of the virtual specifierinthe declarationofanoverriding functionislegalbut redundant(has empty semantics). Access control (clause 11)is 
not considered in determining overriding. 

Draft 


199 Derived classes 10.3 Virtual functions 

} 

— end example ] 
3[Note: a virtual member function does not have to be visible to be overridden, for example, 
struct B { 

virtual void f ();
};
struct D : B{


void f(int);
};
struct D2 :D{


void f ();
};


the function f(int) in class D hides the virtual function f() in its base class B;D::f(int) is not a virtual function. 
However, f() declared in class D2 has the same name and the same parameter list as B::f(), and therefore is a virtual 
function that overrides the function B::f() even though B::f() is not visible in class D2. — end note ] 

4 Even though destructors are not inherited, a destructor in a derived class overrides a base class destructor declared 
virtual; see 12.4 and 12.5. 

5 The return type of an overriding function shall be either identical to the return type of the overridden function or 
covariant with the classes of the functions. If a function D::f overrides a function B::f, the return types of the 
functions are covariant if theysatisfy the following criteria: 

— both are pointers to classes or references to classes104) 
— the class in the return type of B::f is the same class as the class in the return type of D::f, or is an unambiguous 
and accessible direct or indirect base class of the class in the return type of D::f 
— both pointers or references have the same cv-qualification and the class type in the return type of D::f has the 
same cv-qualification as or less cv-qualification than the class type in the return type of B::f. 
6 If the return type of D::f differs from the return type of B::f, the class type in the return type ofD::f shall be complete 
at the point of declaration of D::f or shall be the class type D. When the overriding function is called as the final 
overrider of the overridden function, its result is converted to the type returned by the (statically chosen) overridden 
function(5.2.2).[Example: 

class B {};
class D : private B { friend class Derived ; };
struct Base {


virtual void vf1 ();
virtual void vf2 ();
virtual void vf3 ();
virtual B* vf4();
virtual B* vf5();
void f ();


}; 

104) Multi-level pointers to classes or references to multi-level pointers to classes are not allowed. 

Draft 


10.3 Virtual functions Derived classes 200 
struct No_good : public Base {
D* vf4 (); // error: B (base class of D)inaccessible
};


class A; 

struct Derived : public Base {
void vf1 (); // virtual and overrides Base::vf1()
void vf2 ( int ); // not virtual, hides Base::vf2()
char vf3 (); // error: invalid difference in return type only
D* vf4 (); // OK: returns pointer to derived class
A* vf5 (); // error: returns pointer to incomplete class
void f ();


}; 

void g() 

{ 

Derived d; 

Base* bp = &d; // standard conversion: 

// Derived* to Base* 

bp -> vf1 (); // calls Derived::vf1() 

bp -> vf2 (); // calls Base::vf2() 

bp ->f (); // calls Base::f() (not virtual) 

B* p = bp->vf4(); // calls Derived::pf() and converts the 

// result to B* 

Derived* dp = &d; 

D* q = dp->vf4(); // calls Derived::pf() and does not 

// convert the result to B*
dp -> vf2 (); // ill-formed: argument mismatch
}


— end example ] 
7 [Note: the interpretation of the call of a virtual function depends on the type of the object for which it is called (the 

dynamic type), whereas the interpretation of a call of a non-virtual member function depends only on the type of the 

pointer or reference denoting that object (the static type)(5.2.2). — end note ] 

8 [Note: the virtual specifier implies membership,soa virtualfunction cannotbea nonmember(7.1.2)function. Nor 

cana virtualfunctionbea static member, sincea virtualfunction call reliesona specific objectfor determining which 

functiontoinvoke.Avirtualfunction declaredin one class canbe declareda friend in another class. — end note ] 

9 Avirtual function declaredina class shallbe defined, or declared pure(10.4)in that class, or both;but no diagnosticis 
required(3.2). 

10 [Example: here are some uses of virtual functions with multiple base classes: 

struct A { 

virtual void f (); 

}; 

struct B1 :A{ // note non-virtual derivation
void f ();
};


Draft 


201 Derived classes 10.3 Virtual functions 

struct B2 :A{
void f ();
};


struct D : B1, B2 { // D has two separate A subobjects
};


void foo ()
{
D d;


// A* ap =&d; // would be ill-formed: ambiguous
B1* b1p = &d;
A* ap =b1p;
D* dp =&d;
ap ->f (); // calls D::B1::f
dp ->f (); // ill-formed: ambiguous


} 

In class D above there are two occurrences of class A and hence two occurrences of the virtualmember function A::f. 
The final overrider of B1::A::f is B1::f and the final overrider of B2::A::f is B2::f. 

11 The following example shows a function that does not have a unique final overrider: 

struct A {
virtual void f ();
};


struct VB1 : virtual A { // note virtual derivation
void f ();
};


struct VB2 : virtual A {
void f ();
};


struct Error : VB1 , VB2 { // ill-formed
};


struct Okay : VB1 , VB2 {
void f ();
};


Both VB1::f and VB2::f override A::f but there is no overrider of both of them in class Error. This example is 
therefore ill-formed. Class Okay is well formed, however, because Okay::f is a final overrider. 

12 The following example uses the well-formed classes from above. 

struct VB1a : virtual A { // does not declare f
};


Draft 


10.4 Abstract classes Derived classes 202 
struct Da : VB1a , VB2 {
};


void foe () 

{
VB1a* vb1ap = new Da;
vb1ap ->f(); // calls VB2::f


} 

— end example ] 
13 Explicit qualification with the scope operator(5.1)suppresses the virtual callmechanism.[Example: 
class B { public : virtual void f (); };
class D : public B { public : void f (); };


void D::f() { /* ... * / B::f(); } 

Here, the function call in D::f really does call B::f and not D::f. — end example ] 

10.4 Abstract classes [class.abstract] 
1 The abstract class mechanism supports the notion of a general concept, such as a shape, of which only more concrete 
variants, such as circle and square, can actually be used. An abstract class can also be used to define an interface for 
which derived classes provide a variety of implementations. 

2 An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract class can 
be created except as subobjects of a class derived from it. Aclass is abstract if it has at least one pure virtual function. 
[Note: such a function might be inherited: see below. — end note ]A virtual function is specifiedpure by using a 
pure-specifier (9.2)in the function declaration in the class definition. Apure virtual function need be defined only if 
called with, or asif with(12.4), the qualified-id syntax(5.1).[Example: 

class point { /* ... * / };
class shape { // abstract class
point center ;


// ... 

public :
point where () { return center ; }
void move(point p) { center=p; draw(); }
virtual void rotate ( int ) = 0; // pure virtual
virtual void draw () = 0; // pure virtual
// ...


}; 

— end example ][Note: a function declaration cannot provide both a pure-specifier and a definition — end note ] 
[Example: 
struct C {
virtual void f() = 0 { }; // ill-formed
};


Draft 


203 Derived classes 10.4 Abstract classes 

— end example ] 
3 An abstractclassshallnotbeusedasa parametertype,asa function returntype,orasthetypeofanexplicitconversion. 
Pointersand referencestoan abstract class canbe declared.[ Example: 

shape x; // error: object of abstract class
shape* p; // OK
shape f (); // error
void g( shape ); // error
shape& h(shape&); // OK


— end example ] 
4 Aclass is abstractif it contains or inherits at leastone pure virtual function for which the final overrider is pure virtual. 
[Example: 

class ab_circle : public shape {
int radius ;


public :
void rotate ( int ) {}
// ab_circle::draw() is a pure virtual


}; 

Since shape::draw() is a pure virtual function ab_circle::draw() is a pure virtual by default. The alternative 
declaration, 

class circle : public shape {
int radius ;


public :
void rotate ( int ) {}
void draw (); // a definition is required somewhere


}; 

would make class circle nonabstract and a definition of circle::draw() must be provided. — end example ] 

5[Note: an abstractclasscanbederivedfromaclassthatisnot abstract,andapure virtual functionmayoverridea virtual 
function which is not pure. — end note ] 

6 Member functions canbe called froma constructor(or destructor)ofan abstract class;theeffectof makinga virtual call 
(10.3)to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor 
(or destructor) is undefined. 

Draft 


10.4 Abstract classes Derived classes 204 
Draft 


Chapter 11 Member access control [class.access]


1 Amember of a class can be 

— private;thatis,itsnamecanbeusedonlyby membersand friendsoftheclassinwhichitis declared. 
— protected;thatis,its namecanbeusedonlyby membersand friendsoftheclassinwhichitis declared,andby 
members and friends of classes derived from this class (see 11.5). 
— public;that is, its name can be usedanywhere without access restriction. 
2 A member of a class can also access all the names declared in the class of which it is a member. A local class of a 
member function may access the same names that the member function itself may access.105) 

3 Membersofa class defined with thekeyword class are private by default. Members of a class defined with the 
keywordsstruct or union are public by default.[Example: 

class X {
int a; // X::a is privateby default
};


struct S {
int a; // S::a is publicby default
};


— end example ] 
4 Access control is applied uniformly to all names, whether the names are referred to from declarations or expressions. 
[Note: access control appliesto names nominatedby friend declarations(11.4)andusing-declarations(7.3.3). — end 
note ]Inthe caseofoverloadedfunction names, access controlisappliedtothe function selectedbyoverload resolution. 
[Note: because access control applies to names, if access control is applied to a typedef name, only the accessibility of 
the typedef name itself is considered. The accessibility of the entity referred to by the typedef is not considered. For 
example, 

class A
{
class B{};
public :
typedef B BB;
};


105)Access permissions are thus transitive and cumulative to nested and local classes. 


Member access control 206 

void f()
{


A::BB x; // OK, typedef name A::BB is public 
A::B y; // access error, A::B is private
}
— end note ] 
5 It should be notedthat it is access to members and base classes that is controlled, not their visibility. Names of members 
are still visible, and implicit conversions to base classes are still considered, when those members and base classes are 
inaccessible. The interpretation of a given construct is established without regard to access control. If the interpretation 
established makes use of inaccessible member names or base classes, the constructis ill-formed. 

6 All access controls in clause 11 affect the ability to access a class member name from a particular scope. The access 
control for names used in the definition of a class member that appears outside of the member’s class definition is done 
as if the entire member definition appeared in the scope of the member’s class. In particular, access controls apply 
as usual to member names accessed as part of a function return type, even though it is not possible to determine the 
access privileges of that use without first parsing the rest of the function declarator. Similarly, access control for implicit 
calls to the constructors, the conversion functions, or the destructor called to create and destroy a static data member is 
performed asif these calls appearedin the scopeof the member’s class.[ Example: 

class A {
typedef int I; // private member
I f ();
friend I g(I);
static I x;


}; 

A::I A::f() { return 0; } 
A::I g(A::I p = A::x); 
A::I g(A::I p) { return 0; } 
A::I A::x = 0; 
7 Here, all the uses of A::I are well-formed because A::f and A::x are members of class A and g is a friend of class A. 
This implies, for example, that access checking on the first use of A::I must be deferred until it is determined that this 
use of A::I is as the return type of a member of class A. — end example ] 

8 The namesinadefaultargumentexpression(8.3.6)areboundatthepointofdeclaration,and accessischeckedatthat 
point rather than at any points of use of the default argument expression. Access checking for default arguments in 
function templates and in member functions of class templates is performed as described in 14.7.1. 

9 The names in a defaulttemplate-argument (14.1)have their access checked in the context in which they appear rather 
than at any points of use of the defaulttemplate-argument.[Example: 

class B ;
template <class T> class C {
protected:


typedef T TT;
};


template <class U, class V = typename U::TT> 

Draft 


207 Member access control 11.1 Access specifiers 

class D : public U ; 

D <C<B> >* d; // access error, C::TT is protected 

— end example ] 
11.1 Access specifiers [class.access.spec] 
1 Member declarationscanbelabeledbyan access-specifier (clause 10): access-specifier : member-specificationopt 
An access-specifier specifies the access rules for members following it until the end of the class or until another access-
specifier is encountered.[ Example: 

class X {
int a; // X::a is privateby default: class used


public :
int b; // X::b is public
int c; // X::c is public


}; 

— end example ] 
2 Anynumberof access specifiersis allowed and no particular orderis required.[ Example: 
struct S {
int a; // S::a is publicby default: struct used
protected :
int b; // S::b is protected
private :
int c; // S::c is private
public :
int d; // S::d is public
};


— end example ] 
3 The order of allocation of data members with separate access-specifier labelsis unspecified(9.2). 
4 When a member is redeclared within its class definition, the access specified at its redeclaration shall be the same as at 
its initial declaration.[ Example: 

struct S {
class A;
private :
class A {}; // error: cannot change access
};


— end example ] 
5 [Note: In a derived class, the lookup of a base class name will find the injected-class-name instead of the name of the 
base class in the scope in which it was declared. The injected-class-name might be less accessible than the name of the 
base class in the scope in which it was declared. — end note ] 

Draft 


11.2 Accessibility of base classes and base class members Member access control 208 
[Example: 

class A {};
class B : private A { };
class C : public B {


A *p; // error: injected-class-name A is inaccessible
::A *q; // OK
};


— end example ] 
11.2 Accessibility of base classes and base class members [class.access.base] 
1 If a class is declared to be a base class (clause 10)for another class using thepublic access specifier, the public 
members of the base class are accessible as public members of the derived class and protected members of the base 
class are accessible as protected members of the derived class. If a class is declared to be a base class for another 
class using the protected access specifier, the public and protected members of the base class are accessible as 
protected membersofthederivedclass.Ifaclassis declaredtobeabaseclassfor anotherclassusingthe private 
access specifier, the public and protected members of the base class are accessible as private members of the 
derived class106). 

2 In the absence of an access-specifier fora base class, public is assumed when the derived class is declared struct and 
private is assumed when the class is declared class.[ Example: 

class B { /* ... * / };
class D1 : private B { /* ... * / };
class D2 : public B { /* ... * / };
class D3 :B{ /* ... * / }; // B privateby default
struct D4 : public B { /* ... * / };
struct D5 : private B { /* ... * / };
struct D6 :B{ /* ... * / }; // B publicby default
class D7 : protected B { /* ... * / };
struct D8 : protected B { /* ... * / };


Here B is a public base of D2, D4, and D6, a private base of D1, D3, and D5,andaprotected baseof D7 and D8. — end 
example] 

3[Note: Amemberofaprivate base class mightbe inaccessible as an inherited member name,but accessible directly. 
Becauseoftherulesonpointer conversions(4.10)andexplicit casts(5.4),a conversionfroma pointertoaderived class 
toa pointertoan inaccessible base classmightbeill-formedifan implicit conversionis used,but well-formedifan 
explicit castis used.Forexample, 

class B { 

public :
int mi; // non-static member
static int si ; // static member


};
class D : private B {
};


106) As specified previously in clause 11, private members of a base class remain inaccessible even to derived classes unless friend declarations 
within the base class definition are used to grant access explicitly. 

Draft 


209 Member access control 11.2 Accessibility of base classes and base class members 

class DD : public D {
void f ();
};


void DD::f() {
mi =3; // error: mi is private in D
si =3; // error: si is private in D
::B b;


b.mi = 3; // OK(b.mi is different from this->mi) 
b.si = 3; // OK(b.si is different from this->si) 
::B::si = 3; // OK 
::B* bp1 = this; // error: B is a private base class 
::B* bp2 = (::B*)this; // OK with cast 
bp2 ->mi = 3; // OK: access through a pointer to B. 
} 

— end note ]
Abase classB of N is accessible at R, if
— an invented public member of B would be a public member of N, or 
— Roccurs in a member or friend of class N, and an invented public member of B would be a private or protected 
member of N, or 
— Roccursina memberor friendofa class P derived from N, and an invented public member of B would bea private 
or protected member of P, or 
— there exists a class S such that B is a base class of S accessible at Rand S is a base class of N accessible at R. 
[Example: 
class B {
public :
int m;
};


class S: private B {
friend class N;
};


class N: private S {
void f() {


B* p = this; // OK because class S satisfies the fourth condition 
// above: B is a base class of N accessible in f() because 
// B is an accessible base class of S and S is an accessible 
// base class of N. 

}
};


— end example ] 
Draft 


11.3 Access declarations Member access control 210 
5 Ifa base classis accessible, one can implicitly converta pointertoa derived classtoa pointerto that base class(4.10, 
4.11). [Note: it follows that members and friends of a class X can implicitly convert an X* to a pointer to a private 
or protected immediate base class of X. — end note ]The accessto a member is affected by the class in which the 
memberisnamed.Thisnamingclassistheclassinwhichthemembernamewaslookedupand found.[ Note: this class 
can be explicit, e.g., when a qualified-id is used,or implicit, e.g., whena class memberaccess operator(5.2.5)is used 
(including cases where an implicit “this->” is added). If both a class member access operator and a qualified-id are 
used to name the member (as in p->T::m),theclass namingthe memberisthe class namedbythenested-name-specifier 
of the qualified-id (that is, T). — end note ]Amemberm is accessible at the point Rwhen named in class N if 

— m as a member of N is public, or 
— m as a member of Nis private, and Roccurs in a member or friend of class N, or 
— m as a member of N is protected, and Roccurs in a member or friend of class N, or in a member or friend of a class 
P derived from N, where m as a member of P is public, private, or protected, or 
— there exists a base class B of N that is accessible at R, and m is accessible at Rwhen named in class B.[ Example: 
class B; 

class A { 

private : 

int i; 

friend void f(B*);
};
class B : public A { };
void f(B* p) {


p->i = 1; // OK: B* can be implicitly cast to A*,
// and f has access to i in A
}


— end example ] 
6 If a class member access operator, including an implicit “this->,” is used to access a non-static data member or non-
static member function, the reference is ill-formed if the left operand (considered as a pointer in the “.” operator case) 
cannotbe implicitlyconvertedtoapointertothenamingclassoftherightoperand.[ Note: this requirement is in addition 
to the requirement that the member be accessible as named. — end note ] 

11.3 Access declarations [class.access.dcl] 
1 The accessofa memberofa base class canbechangedin the derived classby mentioning its qualified-id in the derived 
class definition. Such mention is called an access declaration. The effect of an access declaration qualified-id ; is 
defined to be equivalent to the declaration using qualified-id ;.107) 

[Example: 

class A { 

public :
int z;


107) Access declarations are deprecated; member using-declarations(7.3.3)providea better meansofdoingthe same things.In earlierversionsofthe 

C++language, access declarations were more limited; they were generalized and made equivalent to using-declarations in the interest of simplicity. 

Programmers are encouraged to use using-declarations, rather than the new capabilities of access declarations, in new code. 

Draft 


211 Member access control 11.4 Friends 

int z1;
};


class B : public A {
int a;


public :
int b, c;
int bf ();


protected :
int x;
int y;


}; 

class D : private B {
int d;
public :


B::c; // adjust access toB::c 
B::z; // adjust access toA::z 
A:: z1 ; // adjust access toA::z1
int e;
int df ();
protected : 

B::x; // adjust access toB::x 
int g;
};


class X : public D {
int xf ();


}; 

int ef(D&);
int ff(X&);


The external function ef can use only the names c, z, z1, e, and df. Being a member of D, the function df can use 
the names b, c, z, z1, bf, x, y, d, e, df, and g,but not a. Being a member of B, the function bf can use the members 
a, b, c, z, z1, bf, x, and y. The function xf can use the public and protected names from D, that is, c, z, z1, e, and 
df (public), and x, and g (protected). Thus the external function ff has access onlyto c, z, z1, e, and df. If D were 
a protected or private base class of X, xf wouldhavethe sameprivilegesas before,but ff would have no access at all. 

— end example ] 
11.4 Friends [class.friend] 
1 Afriend of a class is a function or class that is given permission to use the private and protected member names from 
the class.Aclass specifies itsfriends,if any,bywayof friend declarations. Such declarationsgive special access rights 
to the friends,but theydo not make the nominated friends members of the befriending class.[ Example: the following 
example illustrates the differences between members and friends: 

class X {
int a;
friend void friend_set(X*, int);


Draft 


11.4 Friends Member access control 212 
public :
void member_set(int);
};


void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }


void f() 

{
X obj ;
friend_set(&obj ,10);


obj.member_set (10);
}
— end example ] 
Declaringa classtobea friendimpliesthatthenamesofprivateandprotected membersfromthe class granting friendship can be accessed in declarations of members of the befriended class.[ Note: this means that access toprivate and 
protected names is also granted to member functions of the friend class (as if the functions were each friends) and to 
the static data member definitions of the friend class. This also means that private and protected type names from the 
class granting friendship canbe usedin the base-clause of a nested class of the friend class. However, the declarations 
of members of classes nested within the friend class cannot access the names of private and protected members from the 
class granting friendship. Also, because the base-clause of the friend class is not part of its member declarations, the 
base-clause of the friend class cannot access the names of the private and protected members from the class granting 
friendship.For example, 

class A {
class B{};
friend class X;


};
class X : A::B { // ill-formed: A::B cannot be accessed
// in the base-clause for X


A::B mx; // OK: A::B used to declare member of X 
class Y : A::B { // OK: A::B used to declare member of X 
A::B my; // ill-formed: A::B cannot be accessed 
// to declare members of nested class of X 
};
};


— end note ]An elaborated-type-specifier shall be used in a friend declaration for a class. 108) A class shall not be 
definedina friend declaration.[ Example: 
class X {
enum { a =100 };
friend class Y;


}; 

class Y { 

108) The class-key of the elaborated-type-specifier is required. 

Draft 


213 Member access control 11.4 Friends 

int v[X::a]; // OK, Y is a friend of X
};


class Z {
int v[X::a]; // error: X::a is private
};


— end example ] 
Afriend declaration that does not declare a function shall have one of the following forms: 

friend elaborated-type-specifier ;
friend simple-type-specifier ;
friend typename-specifier ;


[Note: a friend declaration may be the declaration in a template-declaration (clause 14, 14.5.3). — end note ]If the 
type specifier in a friend declaration designates a (possibly cv-qualified) class type, that class is declared as a friend; 
otherwise, the friend declaration is ignored.[Example: 

class C;
typedef C Ct;


class X1 {
friend C; // OK: class C is a friend
};


class X2 {
friend Ct; // OK: class C is a friend
friend D; // error: no type-name D in scope
friend class D; // OK: elaborated-type-specifier declares new class


}; 

template <typename T> class R {
friend T;
};


R<C> rc; // class C is a friend of R<C>
R<int> Ri; // OK: "friend int;" is ignored


— end example ] 
4Afunction first declaredina friend declarationhasexternal linkage(3.5). Otherwise,the function retainsitsprevious 
linkage(7.1.1). 

5 Whena friend declaration referstoanoverloadednameor operator,onlythefunction specifiedbythe parameter types 
becomesa friend.Amember functionofa class X can be a friend of a class Y.[ Example: 

class Y {
friend char* X::foo(int);
friend X::X(char); // constructors can be friends
friend X ::~ X (); // destructors can be friends
// ...


Draft 


11.4 Friends Member access control 214 
}; 

— end example ] 
6 Afunction canbe definedina friend declarationofa classif and onlyif the classisa non-local class(9.8), the function 
nameis unqualified, and thefunction has namespace scope.[ Example: 

class M {
friend void f () { } // definition of global f, a friend of M,
// not the definition of a member function


}; 

— end example ] 
7 Sucha functionis implicitly inline.A friend function definedina classisinthe(lexical) scopeofthe classin which 
itis defined.Afriend function defined outside the classis not(3.4.1). 
8 No storage-class-specifier shall appear in the decl-specifier-seq of a friend declaration. 
9 Aname nominatedbya friend declaration shallbe accessiblein the scopeof the class containing the friend declaration. 

The meaning of the friend declaration is the same whether the friend declaration appears in the private, protected 
or public (9.2)portion of the classmember-specification. 
10 Friendshipis neither inherited nor transitive.[ Example: 

class A {
friend class B;
int a;


}; 

class B {
friend class C;
};


class C {
void f(A* p)
{


p ->a ++; // error: C is not a friend of A
// despite being a friend of a friend


}
};


class D : public B {
void f(A* p)
{


p ->a ++; // error: D is not a friend of A
// despite being derived from a friend


}
};


— end example ] 
Draft 


215 Member access control 11.5 Protected member access 

11 Ifa friend declaration appearsina local class(9.8)andthe name specifiedisan unqualified name,aprior declaration 
is lookedup without considering scopes that are outside the innermost enclosing non-class scope.Fora friend function 
declaration, if there is no prior declaration, the program is ill-formed. For a friend class declaration, if there is no 
prior declaration,the classthatis specified belongstothe innermost enclosing non-class scope,butifitis subsequently 
referenced, its name is not found by name lookup until a matching declaration is provided in the innermost enclosing 
nonclass scope.[ Example: 

class X;
void a();
void f() {


class Y;
extern void b ();
class A {


friend class X; // OK,but X is a local class, not ::X
friend class Y; // OK
friend class Z; // OK, introduces local class Z
friend void a (); // error, ::a is not considered
friend void b (); // OK
friend void c (); // error


};
X *px; // OK,but ::X is found
Z *pz; // error, no Z is found


} 

— end example ] 
11.5 Protected member access [class.protected] 
1 An additional accesscheckbeyondthose described earlierinclause 11isappliedwhena non-staticdatamemberornonstatic member functionisa protected memberofits naming class(11.2)109)As described earlier, accesstoa protected 
memberisgranted becausethereference occursinafriendormemberofsomeclass C.Ifthe accessistoformapointerto 
member(5.3.1), the nested-name-specifier shall name C ora class derived from C. All other accessesinvolvea (possibly 
implicit) objectexpression(5.2.5).In this case,the classofthe objectexpression shallbe C or a class derived from C. 
[Example: 

class B { 

protected :
int i;
static int j;


}; 

class D1 : public B {
};


class D2 : public B {
friend void fr(B*,D1*,D2*);
void mem(B*,D1*);


}; 

109) This additional check does not apply to other members, e.g. static data members or enumerator member constants. 

Draft 


11.6 Access to virtual functions Member access control 216 
void fr(B* pb, D1* p1, D2* p2) 

{ 

pb->i = 1; // ill-formed 

p1->i = 2; // ill-formed 

p2->i = 3; // OK (access through a D2) 

p2->B::i = 4; // OK (access through a D2, even though 

// naming class isB)
int B::* pmi _B = &B::i; // ill-formed
int B::* pmi _B2 = &D2::i; // OK (type of &D2::i is int B::*)


B::j = 5; // OK (because refers to static member) 
D2::j =6; // OK (because refers to static member)
}


void D2::mem(B* pb, D1* p1) 

{ 

pb->i = 1; // ill-formed 

p1->i = 2; // ill-formed 

i =3; // OK (access through this) 

B::i = 4; // OK (access through this, qualification ignored)
int B::* pmi _B = &B::i; // ill-formed
int B::* pmi _B2 = &D2::i; // OK
j =5; // OK (because j refers to static member)
B::j = 6; // OK (because B::j refers to static member)
}
void g(B* pb, D1* p1, D2* p2) 

{ 

pb->i = 1; // ill-formed 

p1->i = 2; // ill-formed 

p2->i = 3; // ill-formed 

} 

— end example ] 
11.6 Access to virtual functions [class.access.virt] 
1 The access rules (clause 11)fora virtual function are determinedby its declaration and are notaffectedbythe rules for 
a function that lateroverrides it.[Example: 

class B {
public :
virtual int f ();
};


class D : public B {
private :
int f ();
};


void f()
{


Draft 


217 Member access control 11.7 Multiple access 

D d;
B* pb =&d;
D* pd =&d;


pb ->f (); // OK: B::f() is public,
// D::f() is invoked
pd ->f (); // error: D::f() is private
}


— end example ] 
2 Access is checked at the call point using the type of the expression used to denote the object for which the member 
functionis called(B* in theexample above). The accessof the member functionin the classin whichitwas defined(D 
in the example above) is in general not known. 

11.7 Multiple access [class.paths] 
1 Ifa name canbe reachedbyseveralpaths througha multiple inheritance graph,the accessis thatofthepaththatgives 
most access.[ Example: 

class W { public : void f (); };
class A : private virtual W { };
class B : public virtual W { };
class C : public A , public B {


void f() { W::f(); } // OK
};


2 Since W::f() is available to C::f() along the public path through B, access is allowed. — end example ] 

11.8 Nested classes [class.access.nest] 
1 Anested class is a member and as such has the same access rights as anyother member. The members of an enclosing 
classhaveno special accessto membersofa nested class;theusual access rules (clause 11)shallbeobeyed.[Example: 

class E {
int x;
class B {};


}; 

class I {
B b; // OK: E::I can access E::B
int y;
void f(E* p, int i)
{


p->x = i; // OK: E::I can access E::x
}
};


int g(I* p)
{


Draft 


11.8 Nested classes Member access control 218 
return p->y; // error: I::y is private 

} 

}; 

— end example ] 
Draft 


Chapter 12 Special member functions [special]


1 The default constructor(12.1), copyconstructor and copyassignment operator(12.8), and destructor(12.4)are special 
member functions. The implementation will implicitly declare these member functions foraclass type when the program 
doesnotexplicitlydeclarethem,exceptasnotedin 12.1.The implementationwill implicitlydefinethemiftheyareused, 
as specifiedin 12.1, 12.4 and 12.8. Programs shall not define implicitly-declared special member functions. Programs 
mayexplicitly referto implicitly declared special member functions.[ Example: a program may explicitly call, take the 
addressoforformapointertomembertoan implicitly declaredspecialmemberfunction. 

struct A { }; // implicitly-declaredA::operator=
struct B : A{


B& operator =( const B &);
};
B& B::operator= (const B& s) {


this ->A::operator= (s); // well-formed
return * this ;


} 

— end example ] 
2[Note: the special member functions affect the way objects of class type are created, copied, and destroyed, and how 
values can be converted to values of other types. Often such special member functions are called implicitly. — end 
note ] 

3 Special member functions obey the usual access rules (clause 11). [Example: declaring a constructor protected 
ensures that only derived classes and friends can create objects using it. — end example ] 

12.1 Constructors [class.ctor] 
1 Constructors do not have names. Aspecial declarator syntax using an optional sequence offunction-specifier s(7.1.2) 
followed by the constructor’s class name followed by a parameter list is used to declare or define the constructor. In 
sucha declaration, optionalparentheses around the constructor class name are ignored.[ Example: 

class C {
public :
C (); // declares the constructor
};


C::C() { } // defines the constructor 
— end example ] 

12.1 Constructors Special member functions 220 
2 Aconstructor is used to initialize objects of its class type. Because constructors do not have names, theyare never found 
during namelookup;howeveranexplicittypeconversionusingthe functional notation(5.2.3)will causea constructor 
tobe calledto initializean object.[ Note: for initialization of objects of class type see 12.6. — end note ] 

3 Atypedef-name shall not be used as the class-name in the declarator-id for a constructor declaration. 

4 Aconstructor shall not bevirtual (10.3)or static (9.4). Aconstructor can be invoked for a const, volatile or 
const volatile object. A constructor shall not be declared const, volatile, or const volatile (9.3.2). const 
and volatile semantics(7.1.5.1)are not applied on an object under construction. They come into effect when the 
constructor for the most derived object(1.8)ends. 

5Adefault constructor for a class X is a constructor of class X that can be called without an argument. If there is no user-
declared constructor for class X, a default constructor is implicitly declared. An implicitly-declared default constructor 
is an inline public memberof its class.Adefault constructoris trivial if it is implicitly-declared and if: 

— its class has no virtual functions(10.3)and no virtual base classes(10.1), and 
— all the direct base classes of its class have trivial default constructors, and 
— forallthe non-staticdata membersofitsclassthatareofclasstype(orarray thereof),eachsuchclasshasatrivial 
default constructor. 
6 Otherwise, the default constructor is non-trivial. 

7 An implicitly-declared default constructor for a class is implicitly defined when it is used(3.2)to create an object of 
itsclasstype(1.8).The implicitly-defineddefault constructorperformsthesetof initializationsoftheclassthatwould 
be performed by a user-written default constructor for that class with an empty mem-initializer-list (12.6.2)and an 
empty function body. If that user-written default constructor would be ill-formed, the program is ill-formed. Before the 
implicitly-declared default constructor for a class is implicitly defined, all the implicitly-declared default constructors 
for its base classes and its non-static data members shall have been implicitly defined. [Note: an implicitly-declared 
default constructor has an exception-specification (15.4). — end note ] 

8 Default constructors are called implicitly to create class objects of static or automatic storage duration(3.7.1, 3.7.2) 
defined withoutaninitializer(8.5), are calledto create class objectsof dynamic storage duration(3.7.3)createdbya 
new-expression in which the new-initializer is omitted(5.3.4), or are calledwhen theexplicit type conversion syntax 
(5.2.3)is used. Aprogram is ill-formed if the default constructor for an object is implicitly used and the constructor is 
not accessible (clause 11). 

9[Note: 12.6.2 describes the order in which constructors for base classes and non-static data members are called and 
describes how arguments can be specified for the calls to these constructors. — end note ] 

10 Acopyconstructor(12.8)is used to copyobjects of class type. 

11 Aunion member shall not be of a class type (or array thereof) that has a non-trivial constructor. 

12 No return type (not even void)shall be specified for a constructor. Areturn statement in the body of a constructor 
shall not specify a return value. The address of a constructor shall not be taken. 

13 Afunctional notationtypeconversion(5.2.3)canbeusedto createnewobjectsofitstype.[Note: The syntax looks like 
an explicit call of the constructor. — end note ][Example: 

complex zz = complex (1 ,2.3);
cprint ( complex (7.8 ,1.2) );


Draft 


221 Special member functions 12.2 Temporary objects 

— end example ] 
14 An object createdin thiswayis unnamed.[ Note: 12.2 describes the lifetime of temporary objects. — end note ][Note: 
explicit constructor calls do not yield lvalues, see 3.10. — end note ] 

15 [Note: some language constructs have special semantics when used during construction; see 12.6.2 and 12.7. — end 
note ] 

16 Duringthe constructionofa const object,ifthevalueofthe objectoranyofits subobjectsis accessed throughanlvalue 
thatis not obtained, directly or indirectly,from the constructor’s this pointer, thevalueof the object or subobjectthus 
obtainedis unspecified.[ Example: 

struct C;
void no_opt(C*);


struct C { 

int c; 

C() : c(0) { no_ opt(this); } 

}; 

const C cobj ; 

void no_opt(C* cptr) { 

int i = 

cptr ->c 

cout << 

<< 
} 

— end example ] 
cobj.c * 100; // value of cobj.c is unspecified
= 1;
cobj.c * 100 // value of cobj.c is unspecified
’\n’;


12.2 Temporary objects [class.temporary] 
Temporariesof classtype are createdinvarious contexts: bindinganrvaluetoa reference(8.5.3),returninganrvalue 
(6.6.3),a conversion that creates an rvalue(4.1, 5.2.9, 5.2.11, 5.4), throwing anexception(15.1), enteringa handler 
(15.3), andin some initializations(8.5).[Note: the lifetimeofexception objectsis describedin 15.1. — end note ]Even 
when thecreationof the temporary objectisavoided(12.8), all the semantic restrictions mustbe respected asif the 
temporary objectwas created.[ Example: even if the copyconstructor is not called, all the semantic restrictions, such as 
accessibility (clause 11), shall be satisfied. — end example ] 

[Example: 

class X { 

// ... 

public : 

// ... 

X(int );
X( const X &);
~X();


}; 

Draft 


12.2 Temporary objects Special member functions 222 
X f(X); 

void g() 

{
X a (1);
X b = f(X(2));
a = f(a);


} 

2 Here, an implementation might use a temporary in which to construct X(2) before passing it to f() using X’s copy-
constructor; alternatively, X(2) might be constructed in the space used to holdthe argument. Also, a temporary might 
be used to hold the result of f(X(2)) before copying it to b using X’s copy-constructor; alternatively, f()’s result might 
be constructed in b. On the other hand, theexpression a=f(a) requiresa temporaryforthe resultof f(a), which is then 
assigned to a. — end example ] 

3 When an implementation introducesa temporary objectofa class thathasa non-trivial constructor(12.1, 12.8),it shall 
ensure that a constructor is called for the temporary object. Similarly, the destructor shall be called for a temporary 
withanon-trivial destructor(12.4).Temporary objects are destroyed as the last stepinevaluating the full-expression 
(1.9)that(lexically) containsthepointwheretheywere created.Thisistrueevenifthatevaluationendsinthrowingan 
exception. 

4 There aretwo contextsin which temporaries are destroyedatadifferent pointthantheendofthe full-expression. The 
firstcontextiswhenadefault constructoriscalledto initializeanelementofanarray.Ifthe constructorhasoneormore 
default arguments, anytemporaries created in the default argument expressions are destroyed immediately after return 
from the constructor. 

5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or 
the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the 
referenceexceptas specifiedbelow.Atemporaryboundtoa referencememberina constructor’sctor-initializer(12.6.2) 
persists untilthe constructorexits.Atemporary boundtoa reference parameterina function call(5.2.2)persists until 
the completion of the full expression containing the call. Atemporary bound to the returned value in a function return 
statement(6.6.3)persists untilthe functionexits.Inall these cases,the temporaries created duringtheevaluationofthe 
expression initializingthe reference,exceptthe temporaryto whichthe referenceis bound, are destroyedattheendofthe 
full-expression in which they are created and in the reverse order ofthe completion of their construction. If the lifetime 
of two or more temporaries to which references are bound ends at the same point, these temporaries are destroyed at that 
point in the reverse order of the completion of their construction. In addition, the destruction of temporaries bound to 
references shall take into account the orderingof destructionof objects with static or automatic storage duration(3.7.1, 
3.7.2); that is, if obj1 is an object with static or automatic storage duration created before the temporary is created, the 
temporary shall be destroyed before obj1 is destroyed; if obj2 is an object with static or automatic storage duration 
created after the temporary is created, the temporary shall be destroyed after obj2 is destroyed.[ Example: 

class C { 

// ... 

public :
C ();
C( int );
friend C operator+(const C&, const C&);
~C ();


}; 

Draft 


223 Special member functions 12.3 Conversions 

C obj1 ; 

const C& cr = C(16)+C(23); 

C obj2 ; 

the expression C(16)+C(23) creates three temporaries.Afirst temporary T1 to holdthe resultoftheexpression C(16), 
a second temporary T2 to hold the result of the expression C(23), and a third temporary T3 to hold the result of the 
addition of these two expressions. The temporary T3 is then bound to the reference cr. It is unspecified whether T1 or 
T2 is created first. On an implementation where T1 is created before T2, it is guaranteed that T2 is destroyed before T1. 
The temporaries T1 and T2 are bound to the reference parameters of operator+;these temporaries are destroyed atthe 
end of the full expression containing the call to operator+. The temporary T3 bound to the reference cr is destroyed 
at the end of cr’s lifetime, that is, at the end of the program. In addition, the order in which T3 is destroyed takes into 
account the destruction order of other objects with static storage duration. That is, because obj1 is constructed before 
T3, and T3 is constructed before obj2, it is guaranteed that obj2 is destroyed before T3, and that T3 isdestroyed before 
obj1. — end example ] 

12.3 Conversions [class.conv] 
1 Type conversions of class objects can be specified by constructors and by conversion functions. These conversions are 
called user-defined conversions and are used for implicit type conversions (clause 4), for initialization(8.5), and for 
explicit type conversions(5.4, 5.2.9). 

2 User-defined conversionsare applied only where they are unambiguous(10.2, 12.3.2). Conversions obey the access 
control rules (clause 11). Access control is applied after ambiguity resolution(3.4). 

3 [Note: See 13.3 for a discussion of the use of conversions in function calls as well as examples below. — end note ] 

4 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value. 
[Example: 

class X { 

// ... 

public : 

operator int ();
};
class Y { 

// ... 

public : 

operator X ();
};
Y a;
int b= a; // error
// a.operator X().operator int() not tried
int c = X(a); // OK: a.operator X().operator int()


— end example ] 
5 User-defined conversions are used implicitly only if they are unambiguous. A conversion function in a derived class 
doesnothideaconversion functioninabaseclass unlessthetwo functionsconverttothesametype. Functionoverload 

Draft 


12.3 Conversions Special member functions 224 
resolution(13.3.3)selects the best conversion function to perform the conversion.[Example: 

class X {
public :


// ... 

operator int ();
};
class Y : public X {
public :


// ... 

operator char ();
};
void f(Y& a)
{
if (a) { // ill-formed:
// X::operator int() or Y::operator char() // ...
}
}


— end example ] 
12.3.1 Conversionby constructor [class.conv.ctor] 
1 A constructor declared without the function-specifier explicit that can be called with a single parameter specifies 
a conversion from the type of its first parameter to the type of its class. Such a constructor is called a converting 
constructor.[ Example: 

class X { 

// ... 

public :
X(int );
X(const char*, int =0);


}; 

void f(X arg ) 

{
X a =1; // a = X(1)
X b = "Jessie"; // b = X("Jessie",0)
a =2; // a = X(2)
f (3); // f(X(3))


} 

— end example ] 
2 Anexplicit constructor constructs objects just like non-explicitconstructors,but does so only where the direct-initialization syntax(8.5)or where casts(5.2.9, 5.4)areexplicitly used.Adefault constructor maybe anexplicit constructor; 
sucha constructorwillbeusedto performdefault-initializationorvalue-initialization(8.5).[Example: 

class Z { 

Draft 


225 Special member functions 12.3 Conversions 

public :
explicit Z ();
explicit Z(int);


// ... 

}; 

Z a; // OK: default-initialization performed
Za1 =1; // error: no implicit conversion
Z a3 = Z(1); // OK: direct initialization syntax used
Z a2 (1); // OK: direct initialization syntax used
Z* p = new Z(1); // OK: direct initialization syntax used
Z a4 = (Z)1; // OK: explicit cast used
Z a5 = static _cast <Z >(1); // OK: explicit cast used


— end example ] 
3 A non-explicit copy-constructor(12.8)isa converting constructor. An implicitly-declared copy constructoris not an 
explicit constructor; it may be called for implicit type conversions. 

12.3.2 Conversion functions [class.conv.fct] 
1 Amember function of a classX with a name of the form 

conversion-function-id:
operator conversion-type-id
conversion-type-id:
type-specifier-seq conversion-declaratoropt
conversion-declarator:
ptr-operator conversion-declaratoropt


specifies a conversion from X to the type specified by the conversion-type-id. Such member functions are called conversion functions. Classes, enumerations, and typedef-names shall not be declared in the type-specifier-seq. Neither 
parameter types nor returntype canbespecified. Thetypeofa conversion function(8.3.5)is “function takingnoparameter returning conversion-type-id.”Aconversion functionisneverusedtoconverta (possibly cv-qualified)objectto 
the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or 
a reference to it), or to (possibly cv-qualified) void.110) 

[Example: 

class X { 

// ... 

public : 

operator int ();
};
void f(X a) 

{
int i = int(a);
i = (int)a;


110) Even though never directly called to perform a conversion, such conversion functions can be declared and can potentially be reached through a 
call to a virtual conversion function in a base class 

Draft 


12.4 Destructors Special member functions 226 
i = a;
}


In all three cases thevalueassigned willbe convertedby X::operator int(). — end example ] 
2 User-defined conversions arenotrestrictedto usein assignmentsand initializations.[ Example: 

void g(X a, X b) 

{
int i =(a) ?1+a :0;
int j =(a&&b) ? a+b : i;
if (a) { // ...
}


} 

— end example ] 
3 The conversion-type-id shall not represent a function type nor an array type. The conversion-type-id in a conversion-
function-id is the longest possible sequence of conversion-declarators. [Note: this prevents ambiguities between the 
declarator operator* and itsexpression counterparts.[ Example: 

&ac.operator int*i; // syntax error:
// parsed as: &(ac.operator int *)i
// not as: &(ac.operator int)*i


The * is the pointer declarator and not the multiplication operator. — end example ] — end note ] 
4 Conversion functions are inherited. 
5 Conversion functions can be virtual. 
6 Conversion functions cannot be declared static. 

12.4 Destructors [class.dtor] 
1 Aspecial declarator syntax using an optionalfunction-specifier (7.1.2)followed by~ followed by the destructor’s class 
name followed by an empty parameter list is used to declare the destructor in a class definition. In such a declaration, 
the ~ followedby the destructor’s class name canbe enclosedin optional parentheses;such parentheses are ignored.A 
typedef-name shall not be used as the class-name following the ~ in the declarator for a destructor declaration. 

2 A destructor is used to destroyobjects of its class type. A destructor takes no parameters, and no return type can be 
specified for it (not even void). The address of a destructor shall not be taken. Adestructor shall not bestatic.A 
destructor canbeinvokedfora const, volatile or const volatile object.Adestructor shall notbe declared const, 
volatile or const volatile (9.3.2). const and volatile semantics(7.1.5.1)are not applied on an object under 
destruction. Theystop beingineffect when the destructor for the most derived object(1.8)starts. 

3 If a class has no user-declared destructor, a destructor is declared implicitly. An implicitly-declared destructor is an 
inline public memberof its class.Adestructoris trivial if it is implicitly-declared and if: 

— all of the direct base classes of its class have trivial destructors and 
— for all of the non-static data members of its class that are of class type (or array thereof), each such class has a 
trivial destructor. 
Draft 


227 Special member functions 12.4 Destructors 

4 Otherwise, the destructor is non-trivial. 

5 An implicitly-declared destructor is implicitly defined when it is used to destroy an object of its class type(3.7). A 
program is ill-formed if the class for which a destructor is implicitly defined has: 

— a non-static data member of class type (or array thereof) with an inaccessible destructor, or 
— a base class with an inaccessible destructor. 
Before the implicitly-declared destructor for a class is implicitly defined, all the implicitly-declared destructors for its 
base classesandits non-static data members shallhave been implicitly defined.[ Note: an implicitly-declared destructor 
has an exception-specification (15.4). — end note ] 

6 After executing the body of the destructor and destroying anyautomatic objects allocated within the body, a destructor 
for class X calls the destructors for X’s direct members, thedestructors for X’s direct base classes and, if X is the type 
of the most derived class(12.6.2), its destructor calls the destructors for X’s virtual base classes. All destructors are 
called as if they were referenced with a qualified name, that is, ignoring anypossible virtual overriding destructors in 
more derived classes. Bases and members are destroyed in the reverse order of the completion of their constructor (see 
12.6.2).A return statement(6.6.3)ina destructormightnot directly returntothe caller; before transferring controlto 
thecaller,the destructorsforthe membersand bases are called. Destructorsfor elementsofan array are calledinreverse 
order of their construction (see 12.6). 

7 Adestructor can be declaredvirtual (10.3)orpurevirtual (10.4); if anyobjects of that class or anyderived class are 
created in the program, the destructor shall be defined. If a class has a base class with a virtual destructor, its destructor 
(whether user-or implicitly-declared) is virtual. 

8 [Note: some language constructs have special semantics when used during destruction; see 12.7. — end note ] 

9 Aunion member shall not be of a class type (or array thereof) that has a non-trivial destructor. 

10 Destructors are invoked implicitly (1) fora constructed object with static storage duration(3.7.1)at program termination 
(3.6.3), (2) for a constructed object with automatic storage duration(3.7.2)when the block in which the object is 
createdexits(6.7),(3)fora constructed temporary object whenthelifetimeofthe temporary object ends(12.2),(4) 
for a constructed object allocated by a new-expression (5.3.4), through use of a delete-expression (5.3.5), (5) in several 
situationsduetothehandlingofexceptions(15.3).Aprogramisill-formedifanobjectofclasstypeorarray thereofis 
declared and the destructor for the class is not accessible at the point of the declaration. Destructors can also be invoked 
explicitly. 

11 At the point of definition of a virtual destructor (including an implicit definition(12.8)), the non-array deallocation 
functionis lookedupin the scopeof the destructor’sclass(10.2), and,if no declarationis found, the functionis looked 
up in the global scope. If the result of this lookup is ambiguous or inaccessible, or if the lookup selects a placement 
deallocation function, the program is ill-formed. [Note: this assures that a deallocation function corresponding to the 
dynamic type of an object is available for the delete-expression (12.5). — end note ] 

12 In an explicit destructor call, the destructor name appears as a ~ followed by a type-name that names the destructor’s 
classtype.Theinvocationofa destructorissubjecttotheusualrulesformember functions(9.3),thatis,iftheobjectis 
notofthe destructor’sclasstypeandnotof aclassderivedfromthe destructor’sclasstype,the programhas undefined 
behavior (except that invoking delete ona null pointer has noeffect).[ Example: 

struct B {
virtual ~B() { }


}; 

Draft 


12.4 Destructors Special member functions 228 
struct D : B{
~D() { }
};


D D_object ;
typedef B B_alias ;
B* B_ ptr = & D_object ;


void f() {
D_object .B ::~ B (); // calls B’s destructor
B_ptr -> ~B(); // calls D’s destructor
B_ptr -> ~B_alias(); // calls D’s destructor
B_ptr ->B_alias::~B(); // calls B’s destructor
B_ptr ->B_alias::~B_alias(); // calls B’s destructor


} 

— end example ][Note: anexplicit destructor call mustalwaysbe written usinga member access operator(5.2.5)ora 
qualified-id(5.1); in particular, theunary-expression ~X() ina member functionisnotanexplicit destructorcall(5.3.1). 
— end note ] 
13 [Note: explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific addresses 
using a new-expression with the placement option. Such use of explicit placement and destruction of objects can be 
necessarytocopewith dedicated hardware resourcesandfor writing memory managementfacilities.Forexample, 

void * operator new ( std :: size _t , void * p ) { return p ; }
struct X {


// ... 

X(int ); 

~X();
};
void f(X* p);


void g() // rare, specialized use: 

{
char* buf = new char[sizeof(X)];
X* p = new(buf) X(222); // use buf[] and initialize
f(p);
p->X ::~ X (); // cleanup


} 

— end note ] 
14 Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the destructor is 
invoked for an object whose lifetime has ended(3.8).[Example: if the destructor for an automatic object is explicitly 
invoked, and the block is subsequently left in a manner that would ordinarily invoke implicit destruction of the object, 
the behavior is undefined. — end example ] 

15 [Note: the notation forexplicit callofa destructor canbe used for anyscalar type name(5.2.4). Allowing this makesit 
possibletowritecodewithouthavingtoknowifa destructorexistsforagiventype.Forexample, 

typedef int I; 

Draft 


229 Special member functions 12.5 Free store 

I* p; 

// ... 

p->I::~ I(); 

— end note ] 
12.5 Free store [class.free] 
1 Anyallocation function for a class T isa static member(evenif notexplicitly declared static). 
2[Example: 

class Arena ;
struct B {


void * operator new ( std :: size _t , Arena *);
};
struct D1 :B{
};


Arena* ap;
void foo(int i)
{


new (ap) D1; // calls B::operator new(std::size_t, Arena*) 
new D1[i]; // calls ::operator new[](std::size_t) 
new D1; // ill-formed: ::operator new(std::size_t) hidden 

} 

— end example ] 
3 When an object is deleted with a delete-expression (5.3.5), a deallocation function (operator delete() for non-
array objects or operator delete[]() for arrays) is (implicitly) called to reclaim the storage occupied by the object 
(3.7.3.2). 

4 Ifa delete-expression begins with a unary :: operator, the deallocation function’s name is looked up in global scope. 
Otherwise, if the delete-expression is used to deallocate a class object whose static type has a virtual destructor, the 
deallocation function is the one selected at the point of definition of the dynamic type’s virtual destructor(12.4).111) 
Otherwise, if the delete-expression is used to deallocate an object of class T or array thereof, the static and dynamic 
typesofthe object shallbe identicalandthe deallocation function’s nameis lookedupinthe scopeof T. If this lookup 
fails to find the name, the name is looked up in the global scope. If the result of the lookup is ambiguous or inaccessible, 
or if the lookup selects a placement deallocation function, the program is ill-formed. 

5 When a delete-expression is executed, the selected deallocation function shall be called with the address of the block of 
storagetobe reclaimedasits firstargumentand(ifthetwo-parameterstyleisused)thesizeofthe blockasits second 
argument.112) 

6 Anydeallocation function for a class X is a static member (even if not explicitly declared static).[Example: 

111) Asimilar provision is not needed for the array version ofoperator delete because 5.3.5 requires that in this situation, the static type of the 
delete-expression’s operand be the same as its dynamic type. 
112) If the static type in the delete-expression is different from the dynamic type and the destructoris not virtual the size mightbe incorrect,but that 
case is already undefined; see 5.3.5. 

Draft 


12.5 Free store Special member functions 230 
class X { 

// ... 

void operator delete ( void *);
void operator delete []( void * , std :: size_t );
};


class Y { 

// ... 

void operator delete ( void * , std :: size_t );
void operator delete []( void *);
};


— end example ] 
Since member allocation and deallocation functions are static theycannotbe virtual.[ Note: however, when the cast-
expression of a delete-expression refers to an object of class type, because thedeallocation function actually called is 
looked up in the scope of the class that is the dynamic type of the object, if the destructor is virtual, the effect is the 
same.For example, 

struct B {
virtual ~B();
void operator delete ( void * , std :: size_t );


}; 

struct D : B{
void operator delete ( void *);
};


void f() 

{
B* bp = new D;
delete bp ; // 1: uses D::operator delete(void*)


} 

Here, storage for the non-array object of class D is deallocated by D::operator delete(), due to the virtual destructor. — end note ][Note: virtual destructors have no effect on the deallocation function actually called when the 
cast-expression of a delete-expression referstoan arrayofobjectsofclasstype.Forexample, 

struct B {
virtual ~B();
void operator delete []( void * , std :: size_t );


}; 

struct D : B{
void operator delete []( void * , std :: size_t );
};


void f(int i)
{
D* dp = new D[i];


Draft 


231 Special member functions 12.6 Initialization 

delete [] dp ; // uses D::operator delete[](void*, std::size_t)
B* bp = new D[i];
delete [] bp ; // undefined behavior


} 

— end note ] 
8 Accesstothe deallocationfunctionischeckedstatically.Hence,eventhoughadifferentonemightactuallybeexecuted, 
the statically visible deallocation function is required to be accessible. [Example: for the call on line //1 above, if 
B::operator delete() had been private, the delete expression would have been ill-formed. — end example ] 

12.6 Initialization [class.init] 
1 When no initializer is specified for an object of (possibly cv-qualified) class type (or array thereof), or the initializer 
has the form (), the object is initialized as specified in 8.5. The object is default-initialized if there is no initializer, or 
value-initialized if the initializer is (). 

2 An object of class type (or array thereof) can be explicitly initialized; see 12.6.1 and 12.6.2. 

3 When an array of class objects is initialized (either explicitly or implicitly), the constructor shall be called for each 
element of the array, following the subscript order; see 8.3.4. [Note: destructors for the array elements are called in 
reverse order of their construction. — end note ] 

12.6.1 Explicit initialization [class.expl.init] 
1 An object of class type can be initialized with a parenthesized expression-list, where the expression-list is construed as 
an argument list for a constructor that is called to initialize the object. Alternatively, a single assignment-expression can 
be specifiedas an initializer using the = form of initialization. Either direct-initialization semantics or copy-initialization 
semantics apply; see 8.5.[ Example: 

class complex { 

// ... 

public :
complex ();
complex ( double );
complex ( double , double );


// ... 

}; 

complex sqrt ( complex , complex ); 

complex a (1); // initialize by a call of 

// complex(double) 
complex b = a; // initialize by a copy of a 
complex c = complex (1 ,2); // construct complex(1,2) 

// usingcomplex(double,double) 
// copy it into c 
complex d = sqrt(b,c); // call sqrt(complex,complex) 
// and copy the result into d 
complex e; // initialize by a call of 
// complex() 
complex f = 3; // construct complex(3) using 

Draft 


12.6 Initialization Special member functions 232 
// complex(double) 
// copy it into f 
complex g={1, 2}; // error: constructor is required 

— end example ][Note: overloadingof the assignmentoperator(13.5.3)has noeffect on initialization. — end note ] 
2 When an aggregate (whether class or array) contains members of class type and is initialized by a brace-enclosed 
initializer-list (8.5.1), each such member is copy-initialized (see 8.5)by the correspondingassignment-expression. If 
there are fewer initializers in the initializer-list than members of the aggregate, each member not explicitly initialized 
shall bevalue-initialized(8.5).[Note: 8.5.1 describes how assignment-expressions in an initializer-list are paired with 
the aggregate members theyinitialize. — end note ][Example: 

complex v [6] = { 1 , complex (1 ,2) , complex () , 2 }; 

Here, complex::complex(double) is called for the initialization of v[0] and v[3], complex::complex(double, 
double) is called for the initialization of v[1], complex::complex() is called for the initialization v[2], v[4], and 
v[5].For another example, 

class X { 

public :
int i;
float f;
complex c;


} x = { 99, 88.8, 77.7 }; 

Here, x.i is initialized with 99, x.f is initialized with 88.8, and complex::complex(double) is called for the initialization of x.c. — end example ][Note: braces can be elided in the initializer-list for any aggregate, even if the 
aggregate has members of a class type with user-defined type conversions; see 8.5.1. — end note ] 

3[Note: if T isaclasstypewithnodefaultconstructor,anydeclarationofanobjectoftype T (orarray thereof)is ill-formed 
if no initializer is explicitly specified (see 12.6 and 8.5). — end note ] 

4 [Note: the order in which objects with static storage duration are initialized is described in 3.6.2 and 6.7. — end note ] 

12.6.2 Initializing bases and members [class.base.init] 
1 Inthe definitionofaconstructorforaclass, initializersfordirectand virtualbasesubobjectsand non-staticdata members 
can be specified by a ctor-initializer, which has the form 

ctor-initializer:
: mem-initializer-list


mem-initializer-list:
mem-initializer
mem-initializer , mem-initializer-list


mem-initializer:
mem-initializer-id ( expression-listopt )


mem-initializer-id:
::opt nested-name-specifieropt class-name
identifier


Draft 


233 Special member functions 12.6 Initialization 

2 Names in a mem-initializer-id are looked up in the scope of the constructor’s class and, if not found in that scope, 
are looked up in the scope containing the constructor’s definition. [Note: if the constructor’s class contains a member 
with the same name as a direct or virtual base class of the class, a mem-initializer-id naming the member or base class 
and composed of a single identifier refers to the class member. A mem-initializer-id for the hidden base class may be 
specified using a qualified name. — end note ]Unless themem-initializer-id names a non-static data member of the 
constructor’s class or a direct or virtual base of that class, the mem-initializer is ill-formed. Amem-initializer-list can 
initializea base class using anyname that denotes that base class type.[ Example: 

struct A { A(); };
typedef A global_A ;
struct B { };
struct C: public A, public B { C(); };


C::C(): global_A() { } // mem-initializer for base A 
— end example ]Ifamem-initializer-id is ambiguous because it designates both a direct non-virtual base class and an 
inherited virtual base class, the mem-initializer is ill-formed.[ Example: 
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };


C::C(): A() { } // ill-formed: which A? 
— end example ]Actor-initializer may initialize the member of an anonymous union that is a member of the constructor’s class. If a ctor-initializer specifies more than one mem-initializer for the same member, for the same base class or 
for multiple members of the same union (including members of anonymous unions), the ctor-initializer is ill-formed. 
3 The expression-list in a mem-initializer is used to initialize the base class or non-static data member subobject denoted 
by the mem-initializer-id. The semantics of a mem-initializer are as follows: 

— if the expression-list of the mem-initializer isomitted,thebaseclassor membersubobjectisvalue-initialized(see 
8.5); 
— otherwise, the subobject indicatedby mem-initializer-id is direct-initialized using expression-list as the initializer 
(see 8.5). 

[Example: 

struct B1 { B1(int); /* ... * / };
struct B2 { B2(int); /* ... * / };
struct D : B1, B2 {


D(int );
B1 b;
const int c;


}; 

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)
{ /* ... * / }
D d (10);
— end example ]There is a sequence point(1.9)after the initialization of each base and member. Theexpression-list of 
a mem-initializer is evaluated as part of the initialization of the corresponding base or member. 
Draft 


12.6 Initialization Special member functions 234 
4 If a given non-static data member or base class is not named by a mem-initializer-id (including the case where there is 
no mem-initializer-list because the constructor has no ctor-initializer), then 

— Iftheentityisa non-staticdatamemberof(possibly cv-qualified)classtype(orarraythereof)orabaseclass,and 
theentityclassisa non-PODclass,theentityisdefault-initialized(8.5).Iftheentityisa non-staticdatamember 
of a const-qualified type, the entity class shall have a user-declared default constructor. 
— Otherwise, the entity is not initialized. If the entity is of const-qualifiedtype or reference type, or of a (possibly 
cv-qualified) POD class type (or array thereof) containing (directly or indirectly) a member of a const-qualified 
type, the program is ill-formed. 
After the call to a constructor for class X has completed, if a member of X is neither specified in the constructor’s 
mem-initializers, nor default-initialized, nor value-initialized, nor given a value during execution of the body of the 
constructor, the member hasindeterminatevalue. 

5 Initialization shall proceed in the following order: 

— First, and only for the constructor of the most derived class as described below, virtual base classes shall be 
initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base 
classes, where “left-to-right” is the order of appearance of the base class names in the derived class base-specifierlist. 
— Then, direct base classes shall be initialized in declaration order as theyappear in the base-specifier-list (regardless 
of the order of the mem-initializers). 
— Then, non-static data members shall be initialized in the order they were declared in the class definition (again 
regardless of the order of the mem-initializers). 
— Finally, the body of the constructor is executed. 
[Note: the declaration order is mandated to ensure that base and member subobjects are destroyed in the reverse order 
of initialization. — end note ] 

6 All subobjects representing virtual base classes are initializedby the constructor of the most derived class(1.8). If 
the constructor of the most derived class does not specify a mem-initializer for a virtual base class V, then V’s default 
constructor is called to initialize the virtual base class subobject. If V does not have an accessible default constructor, 
the initialization is ill-formed. Amem-initializer naming a virtual base class shall be ignored during execution of the 
constructorof anyclass thatis not the most derived class.[ Example: 

class V { 

public :
V();
V(int );


// ... 

}; 

class A : public virtual V { 

public :
A();
A(int );


// ... 

}; 

Draft 


235 Special member functions 12.6 Initialization 

class B : public virtual V { 

public :
B();
B(int );


// ... 

}; 

class C : public A , public B , private virtual V { 

public :
C();
C(int );


// ... 

}; 

A::A(int i) : V(i) { /* ... * / } 
B::B(int i) { /* ... * / } 
C::C(int i) { /* ... * / } 
V v (1); // use V(int)
A a (2); // use V(int)
B b (3); // use V()
C c (4); // use V()


— end example ] 
7 Names in the expression-list of a mem-initializer are evaluated in the scope of the constructor for which the meminitializer is specified.[ Example: 

class X {
int a;
int b;
int i;
int j;


public :
const int& r;
X(int i): r(a), b(i), i(i), j(this->i) {}


}; 

initializes X::r to refer to X::a, initializes X::b with the value of the constructor parameter i, initializes X::i with the 
value of the constructor parameter i, and initializes X::j with the value of X::i;this takes place each time an object of 
class X is created. — end example ][Note: because the mem-initializer areevaluatedin the scopeofthe constructor, the 
this pointer can be used in the expression-list of a mem-initializer to refer to the object being initialized. — end note ] 

8 Member functions (including virtual member functions, 10.3)can be called for an object under construction. Similarly, 
an object under construction can be the operand of the typeid operator(5.2.8)orofadynamic_cast (5.2.7). However, 
if these operations are performedina ctor-initializer (orina function called directlyor indirectlyfroma ctor-initializer) 
before all the mem-initializer s for base classeshave completed, the resultof the operationis undefined.[Example: 

class A {
public :


Draft 


12.7 Construction and destruction Special member functions 236 
A( int );
};


class B : public A {
int j;


public :
int f ();
B() : A(f()), // undefined: calls member function


// but baseA not yet initialized
j(f()) { } // well-defined: bases are all initialized
};


class C {
public :
C( int );
};


class D : public B, C {
int i;
public :
D() : C(f()), // undefined: calls member function
// but baseC not yet initialized
i(f()) {} // well-defined: bases are all initialized
};


— end example ] 
9 [Note: 12.7 describes the result of virtual function calls, typeid and dynamic_casts during construction for the well-
defined cases; that is, describes the polymorphic behavior of an object under construction. — end note ] 

12.7 Construction and destruction [class.cdtor] 
1 For anobjectof non-POD class type (clause9), before the constructorbeginsexecution and after the destructor finishes 
execution,referringtoany non-staticmemberorbaseclassoftheobject resultsinundefinedbehavior.[ Example: 

struct X { int i; };
struct Y : X {};
struct A { int a; };
struct B:public A{int j; Yy; };


extern B bobj ;
B* pb = &bobj; // OK
int* p1 = &bobj.a; // undefined, refers to base class member
int* p2 = &bobj.y.i; // undefined, refers to member’s member


A* pa = &bobj; // undefined, upcast to a base class type
B bobj ; // definition of bobj


extern X xobj ;
int* p3 = &xobj.i; //OK,X is a POD class


Draft 


237 Special member functions 12.7 Construction and destruction 

X xobj ; 

2 For another example, 

struct W { int j; };
struct X : public virtual W { };
struct Y {


int *p;
X x;
Y() : p(&x.j) // undefined, x is not yet constructed
{}


}; 

— end example ] 
3 Toexplicitlyor implicitlyconvertapointer(anlvalue) referringtoanobjectofclassX toa pointer (reference) toa direct 
or indirect base class B of X, the construction of X and the construction of all of its direct or indirect bases that directly 
or indirectly derive from B shall have started and the destruction of these classes shall not have completed, otherwise 
the conversion results in undefined behavior. To form a pointer to (or access the value of) a direct non-static member 
of an object obj, the construction of obj shall have started and its destruction shall not have completed, otherwise the 
computationof the pointervalue(or accessing the membervalue) resultsin undefined behavior.[ Example: 

struct A { };
struct B : virtual A { };
struct C : B {};
struct D : virtual A { D(A*); };
struct X { X(A*); };


struct E :C, D, X{
E() : D(this), // undefined: upcast from E* to A*
// might use pathE* D* A*


!!

// butD is not constructed 
// D((C*)this), // defined: 
// E* C* defined because E() has started 

!

// and C* A* defined because 

!

// C fully constructed
X( this ) // defined: upon construction of X,
// C/B/D/A sublattice is fully constructed
{}
};


— end example ] 
4 Member functions, including virtual functions(10.3), canbe calledduring construction or destruction(12.6.2). Whena 
virtual functionis called directlyor indirectlyfroma constructor (includingfromthe mem-initializer fora data member) 
or from a destructor, and the object to which the call applies is the object under construction or destruction, the function 
calledisthe one definedin the constructor or destructor’sown class orin oneof its bases,but not a functionoverriding 
itina class derived fromthe constructoror destructor’s class,oroverridingitin oneofthe other base classesofthe most 
derived object(1.8). If the virtualfunction call uses anexplicit class member access(5.2.5)and the object-expression 

Draft 


12.7 Construction and destruction Special member functions 238 
referstotheobject under constructionor destructionbutitstypeisneitherthe constructoror destructor’sown classor 
oneof its bases, the resultof the callis undefined.[ Example: 

class V { 

public :
virtual void f ();
virtual void g ();


}; 

class A : public virtual V {
public :
virtual void f ();
};


class B : public virtual V { 

public :
virtual void g ();
B(V*, A*);


}; 

class D : public A, B { 

public :
virtual void f ();
virtual void g ();
D() : B((A*)this, this) { }


}; 

B::B(V* v, A* a) {
f (); // calls V::f, not A::f
g (); // calls B::g, not D::g
v ->g (); // v is base of B, the call is well-defined, calls B::g
a ->f (); // undefined behavior, a’s type not a base of B
} 

— end example ] 
5 The typeid operator(5.2.8)can be used during construction or destruction(12.6.2). When typeid is used in a constructor (including from the mem-initializer foradatamember)orina destructor,orusedina function called (directlyor 
indirectly) from a constructor or destructor, if the operand of typeid refers to the object under construction or destruction, typeid yields the std::type_info object representing the constructor or destructor’s class. If the operand of 
typeid refers to the object under construction or destruction and the static type of the operand is neither the constructor 
or destructor’s class nor one ofits bases, the result of typeid is undefined. 

6 Dynamic_casts(5.2.7)can be used during construction or destruction(12.6.2). Whena dynamic_cast is used in 
a constructor (including from the mem-initializer for a data member) or in a destructor, or used in a function called 
(directly or indirectly) from a constructor or destructor, if the operand of the dynamic_cast refers to the object under 
construction or destruction, this object is considered to be a most derived object that has the type of the constructor or 
destructor’s class. If the operand of the dynamic_cast refers to the object under construction or destruction and the 
static type of the operand is not a pointer to or object of the constructor or destructor’s own class or one of its bases, the 
dynamic_cast results in undefined behavior. 

Draft 


239 Special member functions 12.8 Copying class objects 

[Example: 

class V {
public :
virtual void f ();
};


class A : public virtual V { }; 

class B : public virtual V {
public :
B(V*, A*);
};


class D : public A, B {
public :
D() : B((A*)this, this) { }
};


B::B(V* v, A* a) {
typeid (* this ); // type_info forB
typeid (*v ); // well-defined: *v has type V, a base of B
// yields type_info forB 
typeid (*a ); // undefined behavior: type A not a base of B 
dynamic_cast <B*>(v); // well-defined: v of type V*, V base of B 

// results in B*
dynamic_cast <B*>(a); // undefined behavior,
// a has type A*, A not a base of B
}


— end example ] 
12.8 Copying class objects [class.copy] 
1Aclass object canbecopiedintwoways,by initialization(12.1,8.5), includingfor functionargument passing(5.2.2) 
andfor functionvalue return(6.6.3),andby assignment(5.17). Conceptually, thesetwo operations are implementedby 
a copyconstructor(12.1)and copyassignment operator(13.5.3). 

2 Anon-template constructor for classX isa copy constructor if its first parameter is of type X&, const X&,volatile X& 
or const volatile X&, and either there are no other parameters or else all other parameters have default arguments 
(8.3.6).113)[Example: X::X(const X&) and X::X(X&,int=1) are copyconstructors. 

class X { 

// ... 

public :
X(int );
X(const X&, int = 1);


}; 

113) Because a template constructor is never a copyconstructor, the presence ofsuch a template does not suppress the implicit declaration of a copy 
constructor.Template constructors participateinoverload resolution with other constructors, including copyconstructors, anda template constructor 
may be used to copy an object if it provides a better match than other constructors. 

Draft 


12.8 Copying class objects Special member functions 240 
X a (1); // calls X(int);
X b(a , 0); // calls X(const X&, int);
Xc= b; // calls X(const X&, int);


— end example ][Note: all formsof copyconstructor maybe declared fora class.[ Example: 
class X { 

// ... 

public : 

X( const X &); 

X(X &); // OK 

}; 

— end example ] — end note ][Note: if a class X only has a copyconstructor with a parameter of type X&, an initializer 
of type const X or volatile X cannot initialize an object oftype (possibly cv-qualified) X.[ Example: 
struct X {
X (); // default constructor
X(X &); // copy constructor with a nonconst parameter


};
const X cx;
Xx= cx; // error — X::X(X&) cannot copy cx into x


— end example ] — end note ] 
3 Adeclaration of a constructor for a classX is ill-formed if its first parameter is of type (optionally cv-qualified) X and 
either there are no other parameters or else all other parametershave default arguments.Amember function templateis 
never instantiatedto performthecopyofa class objecttoan objectofits class type.[ Example: 

struct S {
template <typename T> S(T);
};


S f(); 

void g() {
S a( f() ); // does not instantiate member template
}


— end example ] 
4 If the class definition does not explicitly declare a copy constructor, one is declared implicitly. Thus, for the class 
definition 

struct X {
X(const X&, int);
};


acopyconstructoris implicitly-declared.Ifthe user-declared constructoris laterdefinedas 

X::X(const X& x, int i =0) { /* ... * / } 
Draft 


241 Special member functions 12.8 Copying class objects 

then any use of X’s copyconstructor is ill-formed because of the ambiguity; no diagnostic is required. 
5 The implicitly-declared copyconstructor for a class X will have the form 

X::X(const X&) 
if 

— each direct or virtual base class B of X has a copyconstructor whose first parameter is of type const B& or const 
volatile B&, and 
— for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a 
copyconstructor whose first parameter is of type const M& or const volatile M&.114) 
Otherwise, the implicitlydeclared copyconstructor willhave the form 

X::X(X&) 
An implicitly-declared copyconstructor is an inline public member of its class. 
6 Acopyconstructor for classX is trivial if it is implicitly declaredand if 

— class X has no virtual functions(10.3)and no virtual base classes(10.1), and 
— each direct base class of X has a trivial copyconstructor, and 
— for all the non-static data members of X that are of class type (or array thereof), each such class type has a trivial 
copyconstructor; 
otherwise the copyconstructor is non-trivial. 

7 An implicitly-declared copy constructor is implicitly defined if it is used to initialize an object of its class type from 
a copyof an object of its class type or of a class type derived from its class type115). [Note: the copy constructor is 
implicitly definedevenif theimplementation elided its use(12.2). — end note ]Aprogram is ill-formed if the class for 
whichacopyconstructorisimplicitly defined has: 

— a non-static data member of class type (or array thereof) with an inaccessible or ambiguous copyconstructor, or 
— a base class with an inaccessible or ambiguous copyconstructor. 
Before the implicitly-declaredcopyconstructor fora class is implicitly defined, all implicitly-declared copyconstructors 
for its direct and virtual base classes and its non-static data members shall have been implicitly defined. [Note: an 
implicitly-declared copy constructor has an exception-specification (15.4). — end note ] 

8 The implicitly-defined copyconstructor for class X performsa memberwisecopyofits subobjects. The orderofcopying 
isthe sameasthe orderof initializationof basesand membersina user-defined constructor(see 12.6.2). Each subobject 
is copied in the manner appropriate to its type: 

— if the subobject is of class type, the copyconstructor for the class is used; 
— if the subobject is an array, each element is copied, in the manner appropriate to the element type; 
— if the subobjectisof scalar type, thebuilt-in assignment operatoris used. 
114) This implies that the reference parameter of the implicitly-declared copyconstructor cannot bind to a volatile lvalue; see C.1.8.
115) See 8.5 for more details on direct and copyinitialization.


Draft 


12.8 Copying class objects Special member functions 242 
Virtual base class subobjects shallbe copied only onceby the implicitly-defined copyconstructor (see12.6.2). 

9 A user-declared copy assignment operator X::operator= is a non-static non-template member function of class X 
withexactly oneparameterof type X, X&, const X&, volatile X& or const volatile X&.116)[Note: an overloaded 
assignment operator must be declared to have only one parameter; see 13.5.3. — end note ][Note: more than one form 
of copy assignment operator may be declared for a class. — end note ][Note: if a class X only has a copyassignment 
operator witha parameterof type X&, anexpressionof type const X cannot be assigned to an object of type X.[ Example: 

struct X {
X ();
X& operator=(X&);


}; 

const X cx; 

X x; 

void f() { 

x = cx; // error:
// X::operator=(X&) cannot assign cx into x
}


— end example ] — end note ] 
10 If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. The implicitly-
declared copyassignment operator for a class X will have the form 

X& X::operator= (const X&) 

if 

— each direct base class B of X has a copy assignment operator whose parameter is of type const B&, const 
volatile B& or B, and 
— for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a 
copyassignment operator whose parameter is of type const M&, const volatile M& or M.117) 
Otherwise, the implicitlydeclared copyassignment operator willhave the form 

X& X::operator= (X&) 

The implicitly-declared copyassignment operator for class X has the return type X&;it returns the object for whichthe 
assignment operator is invoked, that is, the object assigned to. An implicitly-declared copyassignment operator is an 
inline public memberofits class. Becauseacopyassignment operatoris implicitly declaredforaclassifnot declared 
bythe user,abase classcopyassignment operatorisalwayshiddenbythecopyassignment operatorofaderived class 
(13.5.3). A using-declaration (7.3.3)that brings in from a base class an assignment operator with a parameter type 
that could be that of a copy-assignment operator for the derived class is not considered an explicit declaration of a 
copy-assignment operator and does not suppress the implicit declaration of the derived class copy-assignment operator; 

116) Because a template assignment operator is never a copyassignment operator, the presence of such a template does not suppress the implicit 
declarationofacopyassignment operator.Template assignment operators participateinoverload resolutionwithother assignment operators, including 
copyassignment operators, and a template assignment operator may be used to assign an object if it provides a better match than other assignment 
operators. 

117) This implies that the reference parameter of the implicitly-declared copyassignment operator cannot bind to a volatile lvalue; see C.1.8. 

Draft 


243 Special member functions 12.8 Copying class objects 

the operator introduced by the using-declaration is hidden by the implicitly-declared copy-assignment operator in the 
derived class. 

11 Acopyassignment operatorfor classX is trivial if it is implicitly declared and if 

— class X has no virtual functions(10.3)and no virtual base classes(10.1), and 
— each direct base class of X has a trivial copyassignmentoperator, and 
— for all the non-static data members of X that are of class type (or array thereof), each such class type has a trivial 
copyassignment operator; 
otherwise the copyassignment operator is non-trivial. 

12 An implicitly-declared copyassignment operator is implicitly defined whenanobjectofits classtypeis assignedavalue 
of its class type or a value of a class type derived from its class type. Aprogram is ill-formed if the class for which a 
copyassignment operator is implicitly defined has: 

— a non-static data member of const type, or 
— a non-static data member of reference type, or 
— a non-static data member of class type (or array thereof) with an inaccessible copyassignment operator, or 
— a base class with an inaccessible copyassignment operator. 
Before the implicitly-declared copyassignment operator for a class is implicitly defined, all implicitly-declared copy 
assignment operatorsforitsdirectbaseclassesandits non-staticdatamembersshallhavebeen implicitly defined.[ Note: 
an implicitly-declared copyassignment operator has an exception-specification (15.4). — end note ] 

13 The implicitly-defined copyassignment operator for class X performs memberwise assignment of its subobjects. The 
direct base classes of X are assigned first, in the order of their declaration in the base-specifier-list,and then theimmediate 
non-static data members of X are assigned, in the order in which theywere declared in the class definition. Each subobject 
is assigned in the manner appropriate to its type: 

— ifthe subobjectisof classtype,thecopy assignment operatorforthe classisused(asifbyexplicit qualification; 
that is, ignoring anypossible virtual overriding functions in more derived classes); 
— if the subobject is an array, each element is assigned, in the manner appropriate to the element type; 
— if the subobjectisof scalar type, thebuilt-in assignment operatoris used. 
It is unspecified whether subobjects representing virtual base classes are assigned more than onceby the implicitly-
defined copyassignment operator.[ Example: 

struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C :B, A {};


it is unspecified whether the virtual base class subobject V is assigned twice by the implicitly-defined copyassignment 
operator for C. — end example ] 

Draft 


12.8 Copying class objects Special member functions 244 
14 Aprogramis ill-formedifthe copyconstructor or the copyassignment operator for an objectis implicitly used and the 
special member functionis not accessible (clause 11).[Note: Copying one objectinto another using the copyconstructor 
or the copyassignment operator does not change the layout or size of either object. — end note ] 

15 When certain criteria are met, an implementation is allowed to omit the copy construction of a class object, even if 
the copy constructor and/or destructorfor the object have side effects. In such cases, the implementation treats the 
source and target of the omitted copyoperation as simply two different ways of referring to the same object, and the 
destruction of that object occurs at the later of the times when the two objects would have been destroyed without the 
optimization.118) This elision of copyoperations is permitted in the following circumstances (which may be combined 
to eliminate multiple copies): 

— ina return statement in a function with a class return type, when the expression is the name of a non-volatile 
automatic object with the same cv-unqualified type as the function return type, the copyoperation can be omitted 
by constructing the automatic object directly into the function’s return value 
— whena temporaryclassobjectthathasnotbeenboundtoa reference(12.2)wouldbecopiedtoaclassobjectwith 
thesame cv-unqualifiedtype,thecopyoperationcanbe omittedbyconstructingthe temporaryobject directlyinto 
the target of the omitted copy 
[Example: 

class Thing { 

public :
Thing ();
~ Thing ();
Thing ( const Thing &);


}; 

Thing f() {
Thing t;
return t;


} 

Thing t2 = f (); 

Here the criteria for elision can be combined to eliminate two calls to the copyconstructor of class Thing: the copying 
of the local automatic object t into the temporary object for the return value of function f() and the copying of that 
temporary object into object t2. Effectively, the construction of the local object t can be viewed as directly initializing 
the global object t2, and that object’s destruction will occur at program exit. — end example ] 

118) Because only one object is destroyed instead of two, and one copyconstructor is not executed, there is still one object destroyed for each one 
constructed. 

Draft 


Chapter 13 Overloading [over]


1 When two or more different declarations are specified for a single name in the same scope, that name is said to be 
overloaded.By extension,two declarationsinthesamescopethat declarethesamenamebutwithdifferenttypesare 
called overloaded declarations. Only function declarations can be overloaded; object and type declarations cannot be 
overloaded. 

2 When an overloaded function name is used in a call, which overloaded function declaration is being referenced is 
determinedbycomparingthetypesoftheargumentsatthepointofusewiththetypesofthe parametersintheoverloaded 
declarationsthatare visibleatthepointof use. This function selection processiscalled overloadresolutionand is defined 
in 13.3.[ Example: 

double abs ( double );
int abs(int);


abs (1); // call abs(int);
abs (1.0); // call abs(double);


— end example ] 
13.1 Overloadable declarations [over.load] 
1 Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. Aprogram is illformedifit containstwo such non-overloadabledeclarationsinthe same scope.[ Note: this restriction applies toexplicit 
declarations in a scope, and between such declarations and declarations made through a using-declaration (7.3.3). It 
doesnotapplytosetsof functionsfabricatedasa resultof namelookup(e.g., becauseof using-directives) or overload 
resolution (e.g., for operator functions). — end note ] 

2 Certain function declarations cannot be overloaded: 

— Function declarations that differ only in the return type cannot be overloaded. 
— Member function declarations with the same name and the same parameter-type-list cannot be overloaded if any 
of themisa static member function declaration(9.4). Likewise, member function template declarations with 
the same name,the same parameter-type-list,andthe same template parameter lists cannotbeoverloadedifanyof 
them is a static memberfunction template declaration. The typesof the implicit object parameters constructed 
for the member functions for the purpose of overload resolution(13.3.1)are not considered when comparing 
parameter-type-lists for enforcement of this rule. In contrast, if there is no static member function declaration 
amonga setof member function declarations with the same name and the sameparameter-type-list, then these 
member function declarations can be overloaded if they differ in the type of their implicit object parameter. 
[Example: the following illustratesthis distinction: 

13.1 Overloadable declarations Overloading 246 
class X {
static void f();
void f (); // ill-formed
void f () const ; // ill-formed
void f () const volatile ; // ill-formed
void g ();
void g () const ; // OK: no static g
void g () const volatile ; // OK: no static g


}; 

— end example ] 
[Note: as specified in 8.3.5, function declarations that have equivalent parameter declarations declare the same function 
and therefore cannot be overloaded: 

— Parameter declarations that differ only in the use of equivalent typedef “types” are equivalent. Atypedef is not 
a separate type,but onlyasynonym for another type(7.1.3).[Example: 
typedef int Int; 

void f(int i);
void f(Int i); // OK: redeclaration of f(int)
void f(int i) { /* ... * / }
void f(Int i) { /* ... * / } // error: redefinition of f(int)


— end example ] 
Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded function declarations.[ Example: 

enum E { a }; 

void f(int i) { /* ... * / }
void f(E i) { /* ... * / }


— end example ] 
— Parameter declarations that differ only in a pointer* versus an array [] are equivalent. That is, the array declarationis adjustedto becomea pointer declaration(8.3.5). Onlythe secondand subsequent array dimensions are 
significantin parametertypes(8.3.4).[Example: 
int f(char*);
int f(char[]); // same as f(char*);
int f(char[7]); // same as f(char*);
int f(char[9]); // same as f(char*);


int g(char(*)[10]);
int g(char[5][10]); // same as g(char(*)[10]);
int g(char[7][10]); // same as g(char(*)[10]);
int g(char(*)[20]); // different from g(char(*)[10]);


— end example ] 
Draft 


247 Overloading 13.1 Overloadable declarations 

— Parameter declarations that differ only in that one is a function type and the other is a pointer to the same function 
type areequivalent. Thatis,the functiontypeis adjustedto becomeapointerto functiontype(8.3.5).[Example: 
void h(int());
void h(int (*)()); // redeclaration of h(int())
void h(int x()) { } // definition of h(int())
void h(int (*x)()) { } // ill-formed: redefinition of h(int())


— end example ] 
— Parameter declarations that differ only in the presence or absence ofconst and/or volatile are equivalent. That 
is, the const and volatile type-specifiers for each parameter type are ignored when determining which function 
is being declared, defined,or called.[ Example: 
typedef const int cInt ;


int f (int);
int f ( const int ); // redeclaration of f(int)
int f(int) {... } // definition of f(int)
int f (cInt) { ... } // error: redefinition of f(int)


— end example ] 
Only the const and volatile type-specifiers at the outermost level of the parameter type specification are 
ignored in this fashion; const and volatile type-specifiersburied within a parameter type specification are 
significant and can be used to distinguish overloaded function declarations.119) In particular, for any type T, 
“pointer to T,” “pointer to const T,” and “pointer to volatile T” are considered distinct parameter types, as are 
“reference to T,” “reference to const T,” and “reference to volatile T.” 

— Two parameter declarations that differ only in their default arguments are equivalent. [Example: consider the 
following: 
void f (int i, int j);
void f (int i, int j = 99); // OK: redeclaration of f(int, int)
void f (int i = 88, int j); // OK: redeclaration of f(int, int)
void f (); // OK: overloaded declaration of f


v o i d p r o g ( ) 
{ 
f ( 1 , 2 ) ; // OK: call f(int, int) 
f ( 1 ) ; // OK: call f(int, int) 
f ( ) ; // Error: f(int, int) or f()? 
} 

— end example ] — end note ] 
119) When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the const and volatile 
type-specifiersatthe outermostlevelofthe parametertype specificationsfortheinner functiontypearealso ignored. 

Draft 


13.2 Declaration matching Overloading 248 
13.2 Declaration matching [over.dcl] 
1Two function declarationsofthesamenamerefertothesame functioniftheyareinthesamescopeandhaveequivalent 
parameter declarations(13.1).Afunction memberofa derived classis not in the same scope as a function member of 
the same nameina base class.[ Example: 

class B {
public :
int f(int);
};


class D : public B {
public :
int f(char*);
};


Here D::f(char*) hides B::f(int) rather than overloading it. 

void h(D* pd)
{
pd ->f (1); // error:


// D::f(char*) hides B::f(int)
pd ->B::f (1); // OK
pd ->f(" Ben " ); // OK, calls D::f


} 

— end example ] 
2 Alocally declared functionis notin the same scope asa functionina containing scope.[Example: 
int f( char *);
void g()
{


extern f(int);
f(" asdf " ); // error: f(int) hides f(char*)
// so there is no f(char*) in this scope
}


void caller () 

{
extern void callee(int, int);
{


extern void callee ( int ); // hides callee(int, int)
callee (88 , 99); // error: only callee(int) in scope
}
}


— end example ] 
3 Differentversionsof anoverloaded member function canbegiven different access rules.[ Example: 
Draft 


249 Overloading 13.3 Overloadresolution 

class buffer { 

private :
char* p;
int size ;


protected :
buffer(int s, char* store) { size = s; p = store; }


// ... 

public :
buffer(int s) { p = new char[size = s]; }


// ... 

}; 

— end example ] 
13.3 Overloadresolution [over.match] 
1 Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are to be the 
arguments of the call and a set of candidate functions that can be called based on the context of the call. The selection 
criteria for the best function are the number of arguments, how well the arguments match the parameter-type-list of the 
candidate function, how well (for non-static member functions) the object matches the implied object parameter, and 
certain other propertiesof the candidate function.[ Note: the function selected by overload resolution is not guaranteed 
to be appropriate for the context. Other restrictions, such as the accessibility of the function, can make its use in the 
calling context ill-formed. — end note ] 

2 Overload resolution selects the function to call in seven distinct contexts within the language: 

— invocationofa function namedin the function call syntax(13.3.1.1.1); 
— invocationofafunction call operator,apointer-to-function conversion function,areference-to-pointer-to-function 
conversion function, or a reference-to-function conversion function on a class object named in the function call 
syntax(13.3.1.1.2); 
— invocation of the operator referenced in an expression(13.3.1.2); 
— invocationofa constructorfor direct-initialization(8.5)ofa class object(13.3.1.3); 
— invocationofa user-definedconversion for copy-initialization(8.5)ofa class object(13.3.1.4); 
— invocation of a conversion function for initialization of an object of a nonclass type from an expression of class 
type(13.3.1.5); and 
— invocation of a conversion function for conversion to an lvalue to which a reference(8.5.3)will be directly bound 
(13.3.1.6). 
Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way. But, once 
the candidate functions and argument lists have been identified, the selection of the best function is the same in all cases: 

— First, a subset of the candidate functions (those that have the proper number of arguments and meet certain other 
conditions)is selectedtoformasetof viable functions(13.3.2). 
Draft 


13.3 Overloadresolution Overloading 250 
— Thenthebest viable functionisselected basedontheimplicit conversion sequences(13.3.3.1)neededto match 
each argument to the corresponding parameter of each viable function. 
3 If a best viable function exists and is unique, overload resolution succeeds and produces it as the result. Otherwise 
overload resolution fails and the invocation is ill-formed. When overload resolution succeeds, and the best viable 
functionis not accessible(clause 11)in the contextin whichitis used, the programis ill-formed. 

13.3.1 Candidate functions and argument lists [over.match.funcs] 
1 The subclausesof 13.3.1 describethesetof candidate functionsandtheargumentlist submittedtooverload resolution 
ineachofthesevencontextsinwhichoverload resolutionisused.The source transformationsand constructions defined 
in these subclauses are only for the purpose of describing the overload resolution process. An implementation is not 
required to use such transformations and constructions. 

2 The set of candidate functions can contain both member and non-member functions tobe resolved against the same 
argument list. So that argument and parameter lists are comparable within this heterogeneous set, a member function is 
considered to have an extra parameter, called the implicit object parameter, which represents the object for which the 
member function has been called.For the purposesofoverload resolution, both static and non-staticmember functions 
have an implicit object parameter,but constructorsdo not. 

3 Similarly, when appropriate, the context can construct an argument list that contains an implied object argument to 
denote the object to be operated on. Since arguments and parameters are associated by position within their respective 
lists, the convention is that the implicit object parameter, if present, is always the first parameter and the implied object 
argument, if present, is always the first argument. 

4 For non-static member functions, the type of the implicit object parameter is “reference to cv X” where X is the class 
of which the function is a member and cv is the cv-qualification on the member function declaration. [Example: 
for a const member function of class X, the extra parameter is assumed to have type “reference to const X”. — end 
example]Forconversion functions,the functionis consideredtobeamemberoftheclassoftheimplicitobjectargument 
forthe purposeof definingthetypeofthe implicitobject parameter.For non-conversion functions introducedbya usingdeclaration intoaderivedclass,the functionis consideredtobeamemberofthederivedclassforthepurposeofdefining 
the type ofthe implicit object parameter. For static member functions, the implicit object parameter is considered to 
match anyobject (since if the function is selected, the object is discarded).[ Note: no actual type is established for the 
implicit object parameter of a static member function, and no attempt will be made to determine a conversion sequence 
for that parameter(13.3.3). — end note ] 

5 During overload resolution, the implied object argument is indistinguishable from other arguments. The implicit object 
parameter, however, retainsits identity since conversions on the corresponding argument shall obey these additional 
rules: 

— no temporary object can be introduced to hold the argument for the implicit object parameter; 
— no user-defined conversions can be applied to achieve a type match with it; and 
— even if the implicit object parameter is not const-qualified, an rvalue temporary can be bound to the parameter 
as long as in all other respects the temporary can be converted to the type of the implicit object parameter. 
6 Because only one user-defined conversion is allowed in an implicit conversion sequence, special rules apply when 
selecting the best user-defined conversion(13.3.3, 13.3.3.1).[Example: 

Draft 


251 Overloading 13.3 Overloadresolution 

class T {
public :
T();


// ... 

}; 

class C : T{
public :
C(int );


// ... 

};
Ta =1; // ill-formed: T(C(1)) not tried


— end example ] 
7 In each case where a candidate is a function template, candidate function template specializations are generated using 
template argument deduction(14.8.3, 14.8.2). Those candidates are then handled as candidate functions in the usual 
way.120) A given name can refer to one or more function templates and also to a set of overloaded non-template 
functions.Insuchacase,the candidate functionsgeneratedfromeachfunctiontemplateare combinedwiththesetof 
non-template candidate functions. 

13.3.1.1 Function call syntax [over.match.call] 
1 Recall from 5.2.2, thatafunction call isa postfix-expression,possibly nested arbitrarilydeepin parentheses, followedby 

an optional expression-listenclosed in parentheses: ( ... (opt postfix-expression ) ... )opt ( expression-listopt ) 
Overload resolution is required if the postfix-expression isthe nameofa function,a function template(14.5.5),anobject 
of class type, or a set of pointers-to-function. 

2 13.3.1.1.1 describes how overload resolution is used in the first two of the above cases to determine the function to call. 
13.3.1.1.2 describes how overload resolution is used in the third of the above cases to determine the function to call. 
3 Thefourth case arises froma postfix-expression of the form &F, where F names a set of overloaded functions. In the 
context of a function call, &F is treated the same as the name F by itself. Thus, (&F)( expression-listopt ) is simply 
(F)( expression-listopt ), which is discussed in 13.3.1.1.1. If the function selected by overload resolution according 
to 13.3.1.1.1 is a non-static member function, the program is ill-formed.121) (The resolution of &F in other contexts is 
described in 13.4.) 

13.3.1.1.1 Call to named function [over.call.func] 
1 Of interest in 13.3.1.1.1 are only those function calls in which the postfix-expression ultimately contains a name that 
denotes one or more functions that might be called. Such a postfix-expression, perhaps nested arbitrarily deep in parentheses, has one of the following forms: 

120) The process of argument deduction fully determines the parameter types of the function template specializations, i.e., the parameters of function 
template specializations contain no template parameter types. Therefore the function template specializations can be treated as normal (non-template) 
functions for the remainder of overload resolution. 

121)When F is a non-static member function, a reference of the form &A::f is a pointer-to-member, which cannot be used with the function-call 
syntax, and a reference of the form &F is an invalid use of the “&” operator on a non-static member function. 

Draft 


13.3 Overloadresolution Overloading 252 
postfix-expression: 
postfix-expression . id-expression 
postfix-expression -> id-expression 
primary-expression 
These represent two syntactic subcategories of function calls: qualified function calls and unqualified function calls. 
2 In qualified function calls, the name to be resolved is an id-expression and is preceded by an -> or . operator. Since 
the construct A->B is generallyequivalent to (*A).B, the rest of clause 13 assumes, without loss of generality, that all 
member function calls have been normalized to the form that uses an object and the . operator. Furthermore, clause 
13 assumes that the postfix-expression that is the left operand of the . operator has type “cv T” where T denotes a 
class122). Under this assumption, the id-expression in the call is looked up as a member function of T following the rules 
for looking up names in classes (10.2). The function declarations found by that lookup constitute the set of candidate 
functions. The argument list is the expression-list in the call augmented by the addition of the left operand of the . 
operator in the normalized member function call as the implied object argument (13.3.1). 
3 In unqualified function calls, the name is not qualified by an -> or . operator and has the more general form of a 
primary-expression. The name is looked up in the context of the function call following the normal rules for name 
lookup in function calls (3.4). The function declarations found by that lookup constitute the set of candidate functions. 
Because of the rules for name lookup, the set of candidate functions consists (1) entirely of non-member functions or (2) 
entirely of member functions of some class T. In case (1), the argument list is the same as the expression-list in the call. 
In case (2), the argument list is the expression-list in the call augmented by the addition of an implied object argument 
as in a qualified function call. If the keyword this (9.3.2)is in scope and refers to classT, or a derived class of T, then 
the implied object argument is (*this). If the keyword this is not in scope or refers to another class, then a contrived 
object of type T becomes the implied object argument123). If the argument list is augmented by a contrived object and 
overload resolution selects one of the non-static member functions of T, the call is ill-formed. 
13.3.1.1.2 Call to object of class type [over.call.object] 
1 If the primary-expression E in the function call syntax evaluates to a class object of type “cv T”, then the set of candidate 
functions includes at least the function call operators of T. The function call operators of T are obtained by ordinary 
lookup of the name operator() in the context of (E).operator(). 
2 In addition, for each conversion function declared in T of the form 
operator conversion-type-id ( ) cv-qualifier ; 
where cv-qualifier is the same cv-qualification as, or agreater cv-qualification than, cv,and whereconversion-type-id denotes the type “pointer to function of (P1,...,Pn) returning R”, or the type “reference to pointer to function of (P1,...,Pn) 
returning R”, or the type “reference to function of (P1,...,Pn) returning R”, a surrogate call function with the unique name 
call-function and having the form R call-function ( conversion-type-id F, P1 a1, ... ,Pn an) { return F (a1,... 
is also considered as a candidate function. Similarly, surrogate call functions are added to the set of candidate functions 
for each conversion function declared in a base class of T provided the function is not hidden within T by another 
intervening declaration124). 
,an); } 
122) Note that cv-qualifiers on the type of objects are significant in overload resolution for both lvalue and class rvalue objects. 
123) An implied object argument must be contrived to correspond to the implicit object parameter attributed to member functions during overload 
resolution. It is not used in the call to the selected function. Since the member functions all have the same implicit object parameter, the contrived 
object will not be the cause to select or reject a function. 
124) Note that this construction can yield candidate call functions that cannot be differentiated one from the other by overload resolution because they 
have identical declarations or differ only in their return type. The call will be ambiguous if overload resolution cannot select a match to the call that is 
uniquely better than such undifferentiable functions. 
Draft 


253 Overloading 13.3 Overloadresolution 

3 If such a surrogate call function is selected by overload resolution, the corresponding conversion function will be called 
to convert E to the appropriatefunction pointer or reference, and the function will thenbe invoked with the arguments 
of the call. If the conversionfunction cannot be called (e.g., because of an ambiguity), the program is ill-formed. 

4 The argument list submitted to overload resolution consists of the argument expressions present in the function call 
syntaxprecededbythe impliedobjectargument (E).[ Note: when comparing the call against the function call operators, 
the implied object argument is compared against the implicit object parameter of the function call operator. When 
comparing the call against a surrogate call function, the implied object argument is compared against the first parameter 
of the surrogate call function. The conversion function from which the surrogate call function was derived will be used 
in the conversion sequence for that parameter since it converts the implied object argument to the appropriate function 
pointer or reference required by that first parameter. — end note ][Example: 

int f1(int); 

int f2(float); 

typedef int (* fp1 )( int ); 

typedef int (* fp2 )( float ); 

struct A { 

operator fp1 () { return f1 ; } 
operator fp2 () { return f2 ; }
} a;
int i = a(1); // Calls f1 via pointer returned from
// conversion function 

— end example ] 
13.3.1.2 Operators in expressions [over.match.oper] 
1 If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to 
beabuilt-in operatorand interpreted accordingto clause 5.[ Note: because ., .*, and :: cannot be overloaded, these 
operators arealwaysbuilt-in operators interpreted accordingto clause 5. ?: cannotbeoverloaded,butthe rulesin this 
subclause are used to determine the conversions to be applied to the second and third operands when theyhave class or 
enumeration type(5.16). — end note ][Example: 

class String { 

public :
String ( const String &);
String ( char *);


operator char * ();
};
String operator + ( const String & , const String &);
void f( void )
{
char* p= "one" + "two"; // ill-formed because neither
// operand has user-defined type


int I =1+1; // Always evaluates to2 even if
// user-defined types exist which
// would perform the operation.


} 

— end example ] 
Draft 


13.3 Overloadresolution Overloading 254 
If either operand has a type that is a class or an enumeration, a user-defined operator function might be declared that 
implementsthisoperatororauser-definedconversioncanbe necessarytoconverttheoperandtoatypethatis appropriate 
forabuilt-in operator.Inthiscase,overload resolutionisusedto determinewhichoperator functionorbuilt-in operatoris 
to be invoked to implement the operator. Therefore, the operator notation is first transformed to the equivalent function-
call notation as summarizedinTable 9(where @ denotes one of the operators covered in the specified subclause). 

Table 9: relationship between operator and function call notation 

Subclause Expression As member function As non-member function 
13.5.1 
13.5.2 
13.5.3 
13.5.5 
13.5.6 
13.5.7 
@a 
a@b 
a=b 
a[b] 
a-> 
a@ 
(a).operator@ ( ) 
(a).operator@ (b) 
(a).operator= (b) 
(a).operator[](b) 
(a).operator-> ( ) 
(a).operator@ (0) 
operator@ (a) 
operator@ (a, b) 
operator@ (a, 0) 

3 For a unary operator@ with an operand of a type whose cv-unqualified version is T1, and for a binary operator @ with a 
left operand of a type whose cv-unqualified version is T1 and a right operand of a type whose cv-unqualified version is 
T2, three sets of candidate functions, designated member candidates, non-member candidates and built-in candidates, 
are constructed as follows: 

— If T1 isacompleteclasstype,thesetofmember candidatesistheresultofthequalifiedlookupof T1::operator@ 
(13.3.1.1.1); otherwise, the set of member candidates is empty. 
— The set of non-member candidates is the result of the unqualified lookup of operator@ in the context of the 
expression accordingtotheusualrulesfornamelookupinunqualified functioncalls(3.4.2)exceptthatallmember 
functions are ignored. However, if no operand has a class type, only those non-member functions in the lookup 
set thathavea first parameterof type T1 or “reference to (possibly cv-qualified) T1”, when T1 is an enumeration 
type, or (if there is a right operand) a second parameter of type T2 or “reference to (possibly cv-qualified) T2”, 
when T2 is an enumeration type, are candidate functions. 
— For the operator ,, the unary operator &, or the operator ->, thebuilt-in candidates set is empty. For all other 
operators,thebuilt-in candidatesincludeallofthe candidate operator functions definedin 13.6that, comparedto 
the given operator, 
— have the same operator name, and 
— accept the same number of operands, and 
— accept operand typesto whichthegiven operandor operands canbe converted accordingto 13.3.3.1,and 
— do not have the same parameter-type-list as anynon-template non-member candidate. 
4 For thebuilt-in assignmentoperators, conversionsof the left operand are restricted as follows: 
— no temporaries are introduced to hold the left operand, and 
— no user-defined conversions are applied to the left operand to achieve a type match with the left-most parameter 
ofabuilt-in candidate. 
5 For all other operators, no suchrestrictions apply. 

Draft 


255 Overloading 13.3 Overloadresolution 

6 The set of candidate functions for overload resolution is the union of the member candidates, the non-member candidates, and thebuilt-in candidates. The argument list contains allof the operandsof the operator. The bestfunction from 
thesetof candidate functionsis selected accordingto 13.3.2and 13.3.3.125)[Example: 

struct A { 

operator int ();
};
A operator+(const A&, const A&);
void m() {
A a, b;
a + b; // operator+(a,b) chosen over int(a) + int(b)
}


— end example ] 
7 Ifabuilt-in candidateis selectedbyoverload resolution,theoperands are convertedtothe typesofthe corresponding 
parameters of the selected operation function. Then the operator is treated as the correspondingbuilt-in operator and 
interpreted according to clause 5. 

8 The second operand of operator -> is ignored in selecting an operator-> function, and is not an argument when the 
operator-> function is called. When operator-> returns, the operator -> is applied to the value returned, with the 
original second operand.126) 

9 If the operatoris the operator ,, the unary operator &, or the operator ->, and there are no viable functions, then the 
operatoris assumedtobethebuilt-in operatorand interpreted accordingto clause 5. 

10 [Note: the lookup rules for operators in expressions are different than the lookup rules for operator function names in a 
function call, as shown in the following example: 

struct A { };
void operator + (A, A);


struct B {
void operator + (B);
void f ();


}; 

A a; 

void B::f() { 

operator+ (a,a); // ERROR — global operator hiddenby member 
a+ a; // OK — calls global operator+
}


— end note ] 
125) If the set of candidate functions is empty, overload resolution is unsuccessful. 
126) If the value returned by the operator-> function has class type, this may result in selecting and calling another operator-> function. The 
process repeats until an operator-> function returns a value of non-class type. 

Draft 


13.3 Overloadresolution Overloading 256 
13.3.1.3 Initializationby constructor [over.match.ctor] 
1 Whenobjectsofclasstypeare direct-initialized(8.5),orcopy-initializedfromanexpressionofthesameoraderived 
class type(8.5), overload resolution selects the constructor. For direct-initialization, the candidate functions are all 
the constructors of the class of the object being initialized. For copy-initialization, the candidate functions are all the 
converting constructors (12.3.1)of that class. The argument list is the expression-list within the parentheses of the 
initializer. 

13.3.1.4 Copy-initializationof classby user-defined conversion [over.match.copy] 
1 Undertheconditionsspecifiedin 8.5,aspartofacopy-initializationofanobjectofclasstype,auser-definedconversion 
canbeinvokedtoconvertan initializerexpressiontothetypeoftheobjectbeing initialized.Overload resolutionisused 
to select the user-defined conversion to beinvoked. Assuming that “cv1 T”is the type of the object being initialized, 
with T a class type, the candidate functions are selected as follows: 

— The converting constructors(12.3.1)ofT are candidate functions. 
— Whenthetypeoftheinitializerexpressionisa classtype“cv S”, the conversion functions of S and its base classes 
are considered. Those that are not hidden within S and yielda type whose cv-unqualifiedversionisthe same type 
as T or is a derived class thereof are candidate functions. Conversion functions that return “reference to X” return 
lvalues of type X and are therefore consideredto yield X for this process of selecting candidate functions. 
2 In both cases, the argument list has one argument, which is the initializer expression. [Note: this argument will be 
compared against the first parameter of the constructors and against the implicit object parameter of the conversion 
functions. — end note ] 

13.3.1.5 Initializationby conversion function [over.match.conv] 
1 Under the conditions specified in 8.5, as part of an initialization of an object of nonclass type, a conversion function 
can be invoked to convert an initializer expression of class type to the type of the object being initialized. Overload 
resolution is used to select the conversion function to be invoked. Assuming that “cv1 T” is the type of the object being 
initialized, and “cv S”isthe typeof the initializerexpression, with S a class type, the candidate functions are selected as 
follows: 

— The conversion functions of S and its base classes are considered. Those that are not hidden within S and yield 
type T or a type that can be converted to type T viaa standard conversion sequence(13.3.3.1.1)are candidate 
functions. Conversion functions that return a cv-qualified type are considered to yield the cv-unqualified version 
of that type for this process of selecting candidate functions. Conversion functions that return “reference to cv2 
X” return lvalues of type cv2 X” and are therefore considered to yield X for this process of selecting candidate 
functions. 
2 The argument list has one argument, whichis the initializerexpression.[ Note: this argument will be compared against 
the implicit object parameter of the conversion functions. — end note ] 

13.3.1.6 Initializationby conversion functionfor directreference binding [over.match.ref] 
1 Under the conditions specified in 8.5.3, a reference can be bound directly to an lvalue that is the result of applying 
a conversion function to an initializer expression. Overload resolution is used to select the conversion function to be 

Draft 


257 Overloading 13.3 Overloadresolution 

invoked. Assuming that “cv1 T” is the underlying type of the reference being initialized, and “cv S” is the type of the 
initializer expression, with S a class type, the candidate functions are selected as follows: 

— The conversion functions of S and its base classes are considered. Those that are not hidden within S and yield 
type “reference to cv2 T2”, where “cv1 T”is reference-compatible(8.5.3)with “cv2 T2”, are candidate functions. 
2 The argument list has one argument, whichis the initializerexpression.[ Note: this argument will be compared against 
the implicit object parameter of the conversion functions. — end note ] 

13.3.2 Viable functions [over.match.viable] 
1 From the setof candidate functions constructed foragiven context(13.3.1),a setof viable functionsis chosen, from 
which thebest function willbeselectedby comparing argument conversionsequences for the best fit(13.3.3). The 
selectionof viable functions considers relationships between arguments and function parameters otherthan the ranking 
of conversion sequences. 

2 First, to be a viable function, a candidate function shall have enough parameters to agree in number with the arguments 
in the list. 

— If there are m arguments in the list, all candidate functions having exactly m parameters are viable. 
— Acandidate function having fewer thanm parameters is viable only if it has an ellipsis in its parameter list(8.3.5). 
Forthe purposesofoverload resolution,anyargumentfor which thereisno corresponding parameteris considered 
to “match the ellipsis”(13.3.3.1.3). 
— Acandidate function having more thanm parameters is viable only if the (m+1)-st parameter has a default argument(8.3.6).127) For the purposes of overload resolution, the parameter list is truncated on the right, so that there 
are exactly m parameters. 
3 Second, for F to be a viable function, there shall exist for each argument an implicit conversion sequence (13.3.3.1)that 
converts that argument to the correspondingparameter of F. If the parameter has reference type, the implicit conversion 
sequence includesthe operationofbindingthe reference,andthefactthata referenceto non-const cannot be bound to 
an rvalue can affect the viability of the function (see 13.3.3.1.4). 

13.3.3 BestViable Function [over.match.best] 
1 Define ICSi(F)as follows: 

— if F is a static member function, ICS1(F)is defined such thatICS1(F)is neither better nor worse than ICS1(G)for 
anyfunction G, and, symmetrically, ICS1(G)is neither better nor worse than ICS1(F)128);otherwise, 
— let ICSi(F)denote the implicit conversion sequence that converts thei-th argument in the list to the type of the 
i-th parameter of viable function F. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what 
it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence 
than another. 
127) According to 8.3.6, parameters following the (m+1)-st parameter must also have default arguments. 
128) If a function is a static member function, this definition means that the first argument, the implied object parameter, has no effect in the 
determination of whether the function is better or worse than anyother function. 

Draft 


13.3 Overloadresolution Overloading 258 
Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all 
arguments i, ICSi(F1)is not a worse conversion sequence than ICSi(F2), and then 

— for some argument j, ICSj(F1)is a better conversion sequence than ICSj(F2), or, if not that, 
— F1 is a non-template function and F2 is a function template specialization, or, if not that, 
— F1 and F2 are function template specializations, and the function template for F1 is more specialized than the 
template for F2 according to the partial ordering rules described in 14.5.5.2, or, if not that, 
— the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6)and the standard conversion sequence from the return type of F1 to the destination type (i.e., thetypeof the entity being initialized)is 
a better conversion sequence than the standard conversion sequence from the return type of F2 to the destination 
type.[ Example: 
struct A {
A ();


operator int (); 
operator double (); 
} a; 
int i = a; // a.operator int() followed by no conversion 
// is better than a.operator double() followedby 
// a conversion to int 
float x = a; // ambiguous: both possibilities require conversions, 
// and neither is better than the other 

— end example ] 
If there is exactly one viable function that is a better function than all other viable functions, then it is the one
selected by overload resolution; otherwise the call is ill-formed129).
[Example:


void Fcn ( const int * , short );
void Fcn(int*, int);


int i;
short s =0;


void f() {
Fcn(&i, s); // is ambiguous because
// &i int* is better than &i const int*


. !

// buts short is also better than s int 

. . 

Fcn(&i, 1L); // calls Fcn(int*, int), because 
// &i int* is better than &i const int* 

. !

// and 1L short and 1L int are indistinguishable 

!. 

129) The algorithm for selecting the best viable function is linear in the number of viable functions. Run a simple tournament to find a function W that 
isnotworsethananyopponentitfaced. Although another function F that W did notface might be at least as good as W, F cannot be the best function 
because at some point in the tournament F encountered another function G such that F was not better than G. Hence, W is either the best function or 
there is no best function. So, make a second pass over the viable functions to verify that W is better than all other functions. 

Draft 


259 Overloading 13.3 Overloadresolution 

Fcn (&i,’c’); // calls Fcn(int*, int), because 
// &i int* is better than &i const int* 

. !

// and c int is better than c short 

. . 

} 

— end example ] 
3 If the best viable function resolves to a function for which multiple declarations were found, and if at least two 
of these declarations — or the declarations they refer to in the case of using-declarations — specify a default 
argument that made the function viable, the programis ill-formed.[ Example: 

namespace A { 

extern "C" void f(int = 5);
}
namespace B {


extern "C" void f(int = 5);
}


using A::f;
using B::f;


void use () { 
f (3); // OK, default argument was not used for viability 
f (); // Error: found default argument twice 

} 

— end example ] 
13.3.3.1 Implicit conversion sequences [over.best.ics] 
1 An implicit conversion sequence is a sequence of conversions used to convert an argument in a function call to the type 
of the corresponding parameter of the function being called. The sequence of conversions is an implicit conversion 
as definedin clause 4, which meansitisgovernedby the rules for initializationof an object or referencebya single 
expression(8.5, 8.5.3). 

2 Implicit conversion sequences are concerned only with the type, cv-qualification, and lvalue-ness of the argument and 
how these are converted to match the corresponding properties of theparameter. Other properties, such as the lifetime, 
storage class, alignment, or accessibility of the argument and whether or not the argument is a bit-field are ignored. So, 
although an implicit conversion sequence can be defined for a given argument-parameter pair, the conversion from the 
argument to the parameter might still be ill-formed in the final analysis. 

3 Awell-formed implicit conversion sequence is one of the following forms: 

— a standard conversion sequence (13.3.3.1.1), 
— a user-defined conversion sequence (13.3.3.1.2), or 
— an ellipsis conversion sequence (13.3.3.1.3). 
Draft 


13.3 Overloadresolution Overloading 260 
4 However, when considering the argument of a user-defined conversion function that is a candidate by 13.3.1.3 when 
invoked for the copying of the temporary in the second step of a class copy-initialization, or by 13.3.1.4, 13.3.1.5, or 

13.3.1.6 in all cases, only standard conversion sequences and ellipsis conversion sequences are allowed. 
5 For the case where the parameter type is a reference, see13.3.3.1.4. 

6 When the parameter type is not a reference, the implicit conversion sequence models a copy-initialization of the parameter from the argument expression. The implicit conversion sequence is the one required to convert the argument 
expression to an rvalue of the type of the parameter.[Note: when the parameter has a class type, this is a conceptual 
conversion defined for the purposes of clause 13;the actual initialization is defined in terms of constructors and is not 
a conversion. — end note ]Anydifference in top-level cv-qualification is subsumed by the initialization itself and does 
not constitute a conversion. [Example: a parameter of type A can be initialized from an argument of type const A. 
The implicit conversion sequence for that case is the identity sequence; it contains no “conversion” from const A to 

A. — end example ]When the parameter has a class type and the argument expression has the same type, the implicit 
conversion sequence is an identity conversion. When the parameter has a class type and the argument expression has a 
derived class type, the implicit conversion sequence is a derived-to-base Conversion from the derived class to the base 
class. [Note: there is no such standard conversion; this derived-to-base Conversion exists only in the description of 
implicit conversion sequences. — end note ]Aderived-to-base Conversion has Conversion rank(13.3.3.1.1). 
7 Inall contexts, when convertingtothe implicit object parameteror when convertingtothe left operandofan assignment 
operation only standard conversion sequences that create no temporary object for the result are allowed. 

8 Ifnoconversions are requiredto matchanargumenttoaparameter type,the implicit conversion sequenceisthe standard 
conversion sequence consistingof the identity conversion(13.3.3.1.1). 

9 If no sequence of conversions can be foundto convert an argument to a parameter type or the conversion is otherwise 
ill-formed, an implicit conversion sequence cannot be formed. 

10 If several different sequences of conversions exist that each convert the argument to the parameter type, the implicit 
conversion sequence associated with the parameter is defined to be the unique conversion sequence designated the 
ambiguous conversion sequence. For the purpose of ranking implicit conversion sequences as described in 13.3.3.2, 
the ambiguous conversion sequence is treated as a user-defined sequence that is indistinguishable from anyother userdefinedconversion sequence130).Ifa functionthat usesthe ambiguousconversion sequenceis selectedasthebest viable 
function, the call willbe ill-formed because the conversionof oneof the argumentsinthe callis ambiguous. 

130) The ambiguous conversion sequence is ranked with user-defined conversion sequences because multiple conversion sequences for an argument 
can exist only if theyinvolve different user-defined conversions. The ambiguous conversion sequence is indistinguishable from anyother user-defined 
conversion sequence becauseit representsat leasttwo user-defined conversion sequences, each withadifferent user-defined conversion,andanyother 
user-defined conversion sequence must be indistinguishable from at least one of them. 

This rule prevents a function from becoming non-viable because of an ambiguous conversion sequence for one of its parameters. Consider this 
example, 

class B;
class A { A (B&); };
class B { operator A (); };
class C { C (B&); };
void f(A) { }
void f(C) { }
B b;
f(b); // ambiguous because bC via constructor and


!

// bA via constructor or conversion function. 

!

If it were not for this rule, f(A) would be eliminated as a viable function for the call f(b) causing overload resolution to select f(C) as the function 
to call even though it is not clearly the best choice. On the other hand, if an f(B) were to be declared then f(b) would resolve to that f(B) because 
the exact match with f(B) is better than anyof the sequences required to match f(A). 

Draft 


261 Overloading 13.3 Overloadresolution 

11 The three forms of implicit conversion sequences mentioned above are defined in the following subclauses. 

13.3.3.1.1 Standard conversion sequences [over.ics.scs] 
1 Table 10 summarizes the conversions defined in clause 4 and partitions them into four disjoint categories: Lvalue 
Transformation, Qualification Adjustment, Promotion, and Conversion. [Note: these categories are orthogonal with 
respect to lvalue-ness, cv-qualification, and data representation: the Lvalue Transformations do not change the cvqualification or data representation of the type; the Qualification Adjustments do not change the lvalue-ness or data 
representation of the type; and the Promotions and Conversions do not change the lvalue-ness or cv-qualification of the 
type. — end note ] 

2[Note: As describedin clause 4,a standardconversion sequenceis eitherthe Identityconversionby itself(thatis,no 
conversion) or consists of one to three conversions from the other four categories. At most one conversion from each 
category is allowed in a single standard conversion sequence. If there are two or more conversions in the sequence, 
the conversions are applied in the canonical order: LvalueTransformation, Promotion or Conversion, Qualification 
Adjustment. — end note ] 

3 Each conversion inTable 10 also has an associatedrank (Exact Match, Promotion, or Conversion). These are used to 
rank standardconversion sequences(13.3.3.2).Therankofaconversionsequenceis determinedbyconsideringtherank 
of each conversion in the sequence and the rank of anyreference binding(13.3.3.1.4). If anyof those has Conversion 
rank, the sequence has Conversion rank; otherwise, if anyof those has Promotion rank, the sequence has Promotion 
rank; otherwise, the sequence has Exact Match rank. 

Table 10: conversions 

Conversion Category Rank Subclause 
No conversions required Identity 
Lvalue-to-rvalue conversion 4.1 
Array-to-pointer conversion Lvalue Transformation Exact Match 4.2 
Function-to-pointer conversion 4.3 
Qualification conversions Qualification Adjustment 4.4 
Integral promotions Promotion Promotion 4.5 
Floating point promotion 4.6 
Integral conversions 4.7 
Floating point conversions 4.8 
Floating-integral conversions Conversion Conversion 4.9 
Pointer conversions 4.10 
Pointer to member conversions 4.11 
Boolean conversions 4.12 

13.3.3.1.2 User-defined conversion sequences [over.ics.user] 
A user-defined conversion sequence consists of an initial standard conversion sequence followed by a user-defined 
conversion(12.3)followedbya second standardconversion sequence. If the user-defined conversionis specifiedby 
a constructor(12.3.1), the initial standard conversion sequence converts the source typeto the type requiredby the 

Draft 


13.3 Overloadresolution Overloading 262 
argumentof the constructor. If the user-defined conversionis specifiedbya conversionfunction(12.3.2), the initial 
standard conversion sequence converts the source type to the implicit object parameter of the conversion function. 

2 The second standard conversion sequence converts the result of the user-defined conversion to the target type for the 
sequence. Since an implicit conversion sequence is an initialization, the special rules for initialization by user-defined 
conversion apply when selecting the best user-defined conversion fora user-defined conversion sequence (see 13.3.3 and 
13.3.3.1). 

3 If the user-defined conversion is specified by a template conversion function, the second standard conversion sequence 
must have exact match rank. 

4 Aconversion of an expression of class type to the same class type is given Exact Match rank, and a conversion of an 
expressionof classtypetoabase classofthattypeisgivenConversionrank,inspiteofthefactthatacopyconstructor 
(i.e.,a user-defined conversionfunction)is called for those cases. 

13.3.3.1.3 Ellipsis conversion sequences [over.ics.ellipsis] 
1 An ellipsis conversion sequence occurs when an argument in a function call is matched with the ellipsis parameter 
specification of the function called. 

13.3.3.1.4 Reference binding [over.ics.ref] 
1 Whena parameterof referencetype binds directly(8.5.3)toanargumentexpression,the implicit conversion sequence 
is the identity conversion, unless the argument expression has a type that is a derived class of the parameter type, in 
which case the implicit conversion sequenceisa derived-to-base Conversion(13.3.3.1).[Example: 

struct A {};
struct B : public A {} b;
int f(A&);
int f(B&);
int i = f(b); // Calls f(B&), an exact match, rather than


// f(A&), a conversion 

— end example ]If the parameter binds directly to the result of applying a conversion function to the argument expression, the implicit conversion sequenceisa user-defined conversion sequence(13.3.3.1.2), with the second standard 
conversion sequence either an identity conversion or, if the conversion function returns an entity of a type that is a 
derived class of the parameter type, a derived-to-base Conversion. 
2 When a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the 
one required to convert the argument expression to the underlying type of the reference according to 13.3.3.1. Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the underlying type with the argument 
expression.Anydifferenceintop-level cv-qualificationis subsumedbythe initialization itselfanddoesnot constitutea 
conversion. 

3 Astandard conversion sequence cannot be formed if it requires binding a reference to non-const to an rvalue (except 
when bindingan implicit objectparameter; seethespecial rulesfor that casein 13.3.1).[Note: this means, forexample, 
that a candidate function cannot be a viable function if it has a non-const reference parameter (other than the implicit 
object parameter) and the corresponding argument is a temporary or would require one to be created to initialize the 
reference (see 8.5.3). — end note ] 

4 Other restrictions on binding a reference to a particular argument that are not based on the types of the reference and 
the argument do not affect the formation of a standard conversion sequence, however. [Example: a function with a 

Draft 


263 Overloading 13.3 Overloadresolution 

“reference to int” parameter canbea viable candidate evenif the corresponding argumentis an int bit-field. The 
formation of implicit conversion sequences treats the int bit-field as an int lvalue andfinds an exact match with the 
parameter. If the function is selected by overload resolution, the call will nonetheless be ill-formed because of the 
prohibition on binding a non-const reference to a bit-field(8.5.3). — end example ] 

5 The binding of a reference to an expression that is reference-compatible with added qualification influences the rank of 
a standard conversion; see 13.3.3.2 and 8.5.3. 

13.3.3.2 Ranking implicit conversion sequences [over.ics.rank] 
1 13.3.3.2 definesapartialorderingofimplicitconversion sequencesbasedonthe relationships better conversion sequence 
and better conversion.Ifan implicitconversion sequenceS1is definedby these rulestobea better conversion sequence 
than S2, then it is also the case that S2 is a worse conversion sequence than S1. If conversion sequence S1 is neither 
better than nor worse than conversion sequence S2, S1 and S2 are said to be indistinguishable conversion sequences. 
2 When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1) 

— a standard conversion sequence(13.3.3.1.1)isa better conversion sequence thana user-definedconversion sequence or an ellipsis conversion sequence, and 
— a user-defined conversion sequence(13.3.3.1.2)isa better conversion sequence than an ellipsis conversion sequence(13.3.3.1.3). 
3 Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of the 
following rules apply: 

— Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if 
— S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form defined by 
13.3.3.1.1, excluding any LvalueTransformation; the identity conversion sequence is considered to be a 
subsequence of anynon-identity conversion sequence) or, if not that, 
— the rank of S1 is better than the rank of S2, or S1 and S2 have the same rank and are distinguishable by the 
rules in the paragraph below, or, if not that, 
— S1 and S2 differ onlyintheir qualification conversion and yield similar types T1 and T2 (4.4), respectively, 
and the cv-qualification signature of type T1 is a proper subset of the cv-qualification signature of type T2, 
and S1 is not the deprecated stringliteral array-to-pointer conversion(4.2).[Example: 
int f(const int *);
int f(int *);
int i;
int j = f(&i); // Calls f(int*)


— end example ]or, if not that, 
— S1 and S2 are referencebindings(8.5.3),andthetypestowhichthe referencesreferarethesametypeexcept 
for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified 
than the type to which the reference initializedby S1 refers.[ Example: 
int f(const int &);
int f(int &);
int g(const int &);


Draft 


13.3 Overloadresolution Overloading 264 
int g(int); 

int i;
int j = f(i); // Calls f(int &)
int k = g(i); // ambiguous


class X { 

public :
void f () const ;
void f ();


};
void g(const X& a, X b)
{


a.f (); // Calls X::f() const 
b.f (); // Calls X::f()
}
— end example ] 
— User-defined conversion sequence U1 is a better conversion sequence than another user-defined conversion sequence U2 if they contain the same user-defined conversion function or constructor and if the second standard 
conversion sequence of U1 is better than the second standard conversion sequence of U2.[ Example: 
struct A { 

operator short ();
} a;
int f(int);
int f(float);
int i = f(a); // Calls f(int), because short int is
!

// better than short float.

. 

— end example ] 
Standard conversion sequences are orderedby their ranks: an ExactMatchisa better conversionthana Promotion, 
which is a better conversion than a Conversion. Two conversion sequences with the same rank are indistinguishable 
unless one of the following rules applies: 

— Aconversion that is not a conversion of a pointer, or pointer to member, tobool is better than another conversion 
that is such a conversion. 
— If class B is derived directly or indirectly from class A, conversion of B* to A* is better than conversion of B* to 
void*, and conversion of A* to void* is better than conversion of B* to void*. 
— If class B is derived directly or indirectly from class A and class C is derived directly or indirectly from B, 
— conversion of C* to B* is better than conversion of C* to A*,[Example: 
struct A {};
struct B : public A {};
struct C : public B {};
C *pc;
int f(A *);


Draft 


265 Overloading 13.4 Address of overloaded function 

int f(B *);
int i = f(pc); // Calls f(B*)


— end example ] 
— binding of an expression of type C to a reference of type B& is better than binding an expression of type C to 
a reference of type A&, 
— conversion of A::* to B::* is better than conversion of A::* to C::*, 
— conversion of C to B is better than conversion of C to A, 
— conversion of B* to A* is better than conversion of C* to A*, 
— binding of an expression of type B to a reference of type A& is better than binding an expression of type C to 
a reference of type A&, 
— conversion of B::* to C::* is better than conversion of A::* to C::*, and 
— conversion of B to A is better than conversion of C to A. 
[Note: compared conversion sequences will have different source types only in the context of comparing the 
second standard conversion sequence of an initialization by user-defined conversion (see 13.3.3); in all other 
contexts, the source types will be the same and the target types will be different. — end note ] 

13.4 Address of overloaded function [over.over] 
1 A use of an overloaded function name without arguments is resolved in certain contexts to a function, a pointer to 
function or a pointer to member function for a specific function from the overload set. A function template name is 
considered to name a set of overloaded functions in such contexts. The function selected is the one whose type matches 
the target type required in the context. The target can be 

— an object or reference being initialized(8.5, 8.5.3), 
— the left sideof an assignment(5.17), 
— a parameterofa function(5.2.2), 
— a parameterofa user-definedoperator(13.5), 
— the returnvalueofa function, operator function, or conversion(6.6.3), 
— anexplicit type conversion(5.2.3, 5.2.9, 5.4), or 
— a non-type template-parameter (14.3.2). 
Theoverloaded function namecanbe precededbythe & operator.Anoverloaded functionnameshallnotbeused without 
arguments in contexts other than those listed. [Note: any redundant set of parentheses surrounding the overloaded 
function nameis ignored(5.1). — end note ] 

2 If the name isa function template, template argumentdeductionis done(14.8.2.2), andif the argument deduction 
succeeds, the resulting template argument list is used to generate a single function template specialization, which is 
addedtothesetofoverloaded functions considered.[ Note: As described in 14.8.1, if deductionfails and the function 
template name is followed by an explicit template argument list, the template-id is then examined to see whether it 

Draft 


13.4 Address of overloaded function Overloading 266 
identifies a single function template specialization. If it does, the template-id is considered to be an lvalue for that 
function template specialization. The target type is not used in that determination. — end note ] 

3 Non-member functions and static member functions match targets of type “pointer-to-function” or “reference-to-function.” Nonstatic member functions match targets of type “pointer-to-member-function;” the function type of the pointer 
to member is used to select the member function from the set of overloadedmember functions. If a non-static member 
function is selected, the reference to the overloaded function name is required to have the form of a pointer to member 
as described in 5.3.1. 

4 If more than one function is selected, any function template specializations in the set are eliminated if the set also 
contains a non-template function, and anygiven function template specialization F1 is eliminated if the set contains a 
second function template specialization whose function template is more specialized than the function template of F1 
accordingtothe partial ordering rulesof 14.5.5.2. Aftersuch eliminations,ifany, there shallremainexactlyone selected 
function. 

5 [Example: 

int f( double );
int f(int);
int (*pfd)(double) = &f; // selects f(double)
int (*pfi)(int) = &f; // selects f(int)
int (*pfe)(...) = &f; // error: type mismatch
int (&rfi)(int) = f; // selects f(int)
int (&rfd)(double) = f; // selects f(double)
void g() {


(int (*)(int))&f; // cast expression as selector
}


The initialization of pfe is ill-formed because no f() with type int(...) has been declared, and not because of any 
ambiguity.For anotherexample, 

struct X {
int f(int);
static int f(long);


}; 

int (X::*p1)(int) = &X::f; // OK
int (*p2)(int) = &X::f; // error: mismatch
int (*p3)(long) = &X::f; // OK
int (X::*p4)(long) = &X::f; // error: mismatch
int (X::*p5)(int) = &(X::f); // error: wrong syntax for


// pointer to member
int (*p6)(long) = &(X::f); // OK


— end example ] 
6[Note: if f() and g() are both overloaded functions, the cross product of possibilities must be considered to resolve 
f(&g), or the equivalent expression f(g). — end note ] 

7 [Note: thereareno standardconversions(clause 4)ofonepointer-to-functiontypeinto another.In particular,evenifB 
is a public base of D, we have 

Draft 


267 Overloading 13.5 Overloaded operators 

D* f();
B* (*p1)() = &f; // error


void g(D *);
void (*p2)(B*) = &g; // error


— end note ] 
13.5 Overloaded operators [over.oper] 
1 Afunction declaration having one ofthe followingoperator-function-ids as its name declares an operator function. An 
operator function is said to implement the operator named in its operator-function-id. 

operator-function-id:
operator operator
operator operator < template-argument-listopt >


operator: one of 

new delete new[] delete[]
+-* / % ^ & |


~ 

!= < > += -= *= /= %= 
^= &= |= << >> >>= <<= == != 
<= >= && || ++ --, ->* -> 
() [] 

[Note: the last two operators are function call(5.2.2)and subscripting(5.2.1). The operators new[], delete[], (), and 
[] are formed from more than onetoken. — end note ] 

2 Both the unary and binary forms of 

+-* & 

can be overloaded. 
3 The following operators cannotbe overloaded: 

. .* :: ?: 

nor can the preprocessing symbols # and ## (clause 16). 
4 Operator functions are usually not called directly; instead they are invoked to evaluate the operators they implement 

(13.5.1 -13.5.7). They can be explicitly called, however, using the operator-function-id as the name of the function in 
the function call syntax(5.2.2).[Example: 
complex z = a.operator+(b); // complex z = a+b;
void* p = operator new(sizeof(int)*n);


— end example ] 
5 The allocation and deallocation functions, operator new, operator new[], operator delete and operator delete[],are described completely in3.7.3. The attributes and restrictions found in the rest of this subclause do not apply 
to them unless explicitly stated in 3.7.3. 

Draft 


13.5 Overloaded operators Overloading 268 
6 An operator functionshall eitherbea non-staticmember functionorbea non-member functionandhaveatleast one 
parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration. It is not 
possible to change the precedence, grouping, or number of operands of operators. The meaning of the operators =, 
(unary) &, and , (comma), predefinedfor each type, canbe changedfor specific classand enumeration typesby defining 
operator functions that implement these operators. Operator functions are inherited in the same manner as other base 
class functions. 

7 The identities among certain predefined operators applied to basic types (for example, ++a = a+=1)need not hold for 
operator functions. Some predefined operators, such as +=, require an operand to be an lvalue when applied to basic 
types; this is not required by operator functions. 

8 An operator functioncannothave default arguments(8.3.6),except whereexplicitly stated below. Operator functions 
cannot have more or fewer parameters than the number required for the corresponding operator, as described in the rest 
of this subclause. 

9 Operators not mentioned explicitly in subclauses 13.5.3 through 13.5.7 act as ordinary unary and binary operators 
obeying the rules of 13.5.1 or 13.5.2. 

13.5.1 Unary operators [over.unary] 
1Aprefixunaryoperatorshallbeimplementedbyanon-staticmember function(9.3)withno parametersoranon-member 
function with one parameter. Thus, for anyprefix unary operator @, @x can be interpreted as either x.operator@() or 
operator@(x).Ifboth formsofthe operator functionhave been declared,the rulesin 13.3.1.2 determine which,ifany, 
interpretation is used. See 13.5.7 for an explanation of the postfix unary operators ++ and -. 

2 Theunaryand binary formsofthe same operator are consideredtohavethe same name. [Note: consequently, a unary 
operator can hide a binary operator from an enclosing scope, and vice versa. — end note ] 

13.5.2 Binary operators [over.binary] 
1Abinary operator shallbe implemented eitherbya non-static member function(9.3)with one parameterorbya nonmember function with two parameters. Thus, for anybinary operator @, x@y can be interpreted as either x.operator@(y) or operator@(x,y). If both forms of the operator function have been declared, the rules in 13.3.1.2 determine 
which, if any, interpretation is used. 

13.5.3 Assignment [over.ass] 
1 An assignment operator shall be implemented by a non-static member function with exactly one parameter. Because a 
copy assignment operator operator= isimplicitly declaredfora classifnot declaredbythe user(12.8),abase class 
assignment operator is always hidden by the copyassignment operator of the derived class. 

2 Anyassignment operator,eventhecopyassignmentoperator, canbe virtual. [Note: for a derived class D with a base 
class B for which a virtual copyassignment has been declared, the copyassignment operator in D does not override B’s 
virtual copyassignment operator.[ Example: 

struct B {
virtual int operator = ( int );
virtual B& operator= (const B&);


}; 

struct D : B{
virtual int operator = ( int );
virtual D& operator= (const B&);


Draft 


269 Overloading 13.5 Overloaded operators 

}; 

D dobj1 ; 

D dobj2 ; 

B* bptr = &dobj1; 

void f() { 

bptr ->operator=(99); // calls D::operator=(int) 

* bptr = 99; // ditto
bptr ->operator=(dobj2); // calls D::operator=(const B&)
* bptr = dobj2 ; // ditto
dobj1 = dobj2 ; // calls implicitly-declared
// D::operator=(const D&)
}


— end example ] — end note ] 
13.5.4 Function call [over.call] 
1 operator() shall be a non-static member function with an arbitrary number of parameters. It can have default arguments. It implements thefunction call syntax 

postfix-expression ( expression-listopt ) 

where the postfix-expression evaluates toa class object and the possibly empty expression-list matches the parameter list 
of an operator() member function of the class. Thus, a call x(arg1,...) is interpreted as x.operator()(arg1, 
...) for a class object x of type T if T::operator()(T1, T2, T3) exists and if the operator is selected as the best 
match functionby theoverload resolution mechanism(13.3.3). 

13.5.5 Subscripting [over.sub] 
1 operator[] shallbea non-static member function withexactly one parameter.It implementsthe subscripting syntax 

postfix-expression [ expression ] 

Thus, a subscripting expression x[y] is interpreted as x.operator[](y) for a class object x of type T if T::operator[](T1) exists and if the operator is selected as the best match function by the overload resolution mechanism 
(13.3.3). 

13.5.6 Class member access [over.ref] 
1 operator-> shall be a non-static member function taking no parameters. It implements class member access using -> 

postfix-expression -> id-expression 

An expression x->m is interpreted as (x.operator->())->m for a class object x of type T if T::operator->() exists 
andif the operatoris selected as the best match functionby theoverload resolutionmechanism(13.3). 

13.5.7 Increment and decrement [over.inc] 
1 The user-defined function called operator++ implements the prefix and postfix ++ operator.Ifthis functionisamember 
function with no parameters, or a non-member function with one parameter of class or enumeration type, it defines the 
prefix increment operator ++ for objects of that type. If the function is a member function with one parameter (which 
shall be of type int)or a non-member function with two parameters (the second of which shall be of type int), it 

Draft 


13.6 Built-in operators Overloading 270 
defines the postfix increment operator ++ for objects of that type. When the postfix increment is called as a result of 
using the ++ operator, the int argument willhavevalue zero.131)[Example: 

class X { 

public :
X& operator ++(); // prefix ++a
X operator ++( int ); // postfixa++


}; 

class Y {}; 

Y& operator ++( Y &); // prefix ++b 

Y operator++(Y&, int); // postfixb++ 

void f(X a, Y b) {
++a; // a.operator++();
a ++; // a.operator++(0);
++b; // operator++(b);
b ++; // operator++(b, 0);


a. operator ++(); // explicit call: like ++a; 
a. operator ++(0); // explicit call: like a++; 
operator ++( b ); // explicit call: like ++b; 
operator++(b, 0); // explicit call: like b++;
}
— end example ] 
2 The prefix and postfix decrement operators -are handled analogously. 
13.6 Built-in operators [over.built] 
1 The candidate operator functions that represent thebuilt-in operators definedin clause 5are specifiedin this subclause. 
These candidate functions participate in the operator overload resolution process as described in 13.3.1.2 and are used 
for no other purpose.[ Note: becausebuilt-in operators take only operands with non-class type, andoperatoroverload 
resolution occurs only when an operandexpression originally has class or enumeration type, operatoroverload resolution 
canresolvetoabuilt-inoperatoronlywhenanoperandhasaclasstypethathasauser-definedconversiontoa non-class 
type appropriateforthe operator,orwhenanoperandhasan enumerationtypethatcanbeconvertedtoatype appropriate 
fortheoperator.Alsonotethatsomeofthe candidateoperator functionsgiveninthis subclausearemorepermissivethan 
thebuilt-in operators themselves. As describedin 13.3.1.2, afterabuilt-in operatoris selectedbyoverload resolution 
theexpressionis subjecttothe requirementsforthebuilt-in operatorgivenin clause 5,andthereforetoanyadditional 
semantic constraintsgiventhere.Ifthereisauser-writtencandidatewiththesamenameandparametertypesasabuilt-in 
candidate operatorfunction,thebuilt-in operatorfunctionis hiddenandisnot includedinthesetofcandidate functions. 

— end note ] 
2 In this subclause, the term promoted integral type is used to refer to those integral types which are preservedby integral 
promotion (including e.g. int and long but excluding e.g. char). Similarly, the term promoted arithmetic type refers 
to floating types plus promoted integral types.[ Note: in all cases wherea promotedintegral type or promoted arithmetic 
type is required, an operand of enumeration type will be acceptable by way of the integralpromotions. — end note ] 

131) Calling operator++ explicitly, as in expressions like a.operator++(2), has no special properties: The argument to operator++ is 2. 

Draft 


271 Overloading 13.6 Built-in operators 

3 Forevery pair(T,VQ),whereTis an arithmetic type, and VQ is either volatile or empty,thereexist candidate operator 
functions of the form 

VQ T & operator ++( VQ T &);
T operator ++( VQ T & , int );


4 Forevery pair(T, VQ), where T is an arithmetic type other than bool, and VQ is either volatile or empty, there exist 
candidate operator functions of the form 

VQ T & operator --(VQ T &);
T operator --( VQ T & , int );


5 Forevery pair(T, VQ), where T is a cv-qualified or cv-unqualified object type, and VQ is either volatile or empty, 
there exist candidate operator functions of the form 

T *VQ & operator ++( T *VQ &);
T *VQ & operator --( T *VQ &);
T * operator ++( T *VQ & , int );
T * operator --( T *VQ & , int );


6 For every cv-qualified or cv-unqualified object typeT, there exist candidate operator functions of the form 

T & operator *( T *); 

7 For every function typeT, there exist candidate operator functions of the form 

T & operator *( T *); 

8 For every typeT, there exist candidate operator functions of the form 

T * operator +( T *); 

9 For every promoted arithmetic typeT, there exist candidate operator functions of the form 

T operator +( T );
T operator -( T );


10 For every promoted integral typeT, there exist candidate operator functions of the form 

T operator (T ); 

11 Forevery quintuple(C1, C2, T, CV1, CV2), where C2 is a class type, C1 is the same type as C2 or is a derived class 
of C2, T is an object type or a function type, and CV1 and CV2 are cv-qualifier-seqs, there exist candidate operator 
functions of the form 

CV12 T & operator ->*( CV1 C1 *, CV2 T C2 ::*); 

where CV12 is the union of CV1 and CV2. 
12 For every pair of promoted arithmetic typesLand R, there exist candidate operator functions of the form 

Draft 


13.6 Built-in operators Overloading 272 
LR operator *( L , R );
LR operator /( L , R );
LR operator +( L , R );
LR operator -( L , R );
bool operator <( L , R );
bool operator >( L , R );
bool operator <=( L , R );
bool operator >=( L , R );
bool operator ==( L , R );
bool operator !=( L , R );


where LR is the result of the usual arithmetic conversions between types Land R. 
13 For every cv-qualified or cv-unqualified object typeT there exist candidate operator functions of the form 

T * operator +( T *, std :: ptrdiff_t );
T & operator []( T *, std :: ptrdiff_t );
T * operator -( T *, std :: ptrdiff_t );
T * operator +( std :: ptrdiff_ t , T *);
T & operator []( std :: ptrdiff_ t , T *);


14 For everyT, where T is a pointer to object type, there exist candidate operator functions of the form 

std :: ptrdiff_t operator -( T , T ); 

15 For every pointer or enumeration typeT, there exist candidate operator functions of the form 

bool operator <( T , T );
bool operator >( T , T );
bool operator <=( T , T );
bool operator >=( T , T );
bool operator ==( T , T );
bool operator !=( T , T );


16 For every pointer to member typeT, there exist candidate operator functions of the form 

bool operator ==( T , T );
bool operator !=( T , T );


17 For every pair of promoted integral typesLand R, there exist candidate operator functions of the form 

LR operator %( L , R );
LR operator &( L , R );
LR operator ^( L , R );
LR operator |( L , R );
L operator <<( L , R );
L operator >>( L , R );


where LR is the result of the usual arithmetic conversions between types Land R. 

18 For every triple(L, VQ, R), where L is an arithmetic type, VQ is either volatile or empty, and R is a promoted 
arithmetic type, there exist candidate operator functions of the form 

Draft 


273 Overloading 13.6 Built-in operators 

VQ L & operator = ( VQ L &, R );
VQ L & operator *=( VQ L &, R );
VQ L & operator /=( VQ L &, R );
VQ L & operator +=( VQ L &, R );
VQ L & operator -=( VQ L &, R );


19 Forevery pair(T,VQ),whereTis anytype and VQ is either volatile or empty,thereexist candidate operator functions 
of the form 

T *VQ & operator = ( T *VQ &, T *); 

20 Forevery pair(T, VQ), where Tis an enumeration or pointer to member type and VQ is either volatile or empty, there 
exist candidate operator functions of the form 

VQ T & operator = ( VQ T &, T ); 

21 Forevery pair(T, VQ), where T is a cv-qualified or cv-unqualified object type and VQ is either volatile or empty, 
there exist candidate operator functions of the form 

T *VQ & operator +=( T *VQ & , std :: ptrdiff_t );
T *VQ & operator -=( T *VQ & , std :: ptrdiff_t );


22 Forevery triple(L, VQ, R), where Lis an integral type, VQ is either volatile or empty, and Ris a promoted integral 
type, there exist candidate operator functions of the form 

VQ L & operator %=( VQ L &, R );
VQ L & operator < <= ( VQ L &, R );
VQ L & operator > >= ( VQ L &, R );
VQ L & operator &=( VQ L &, R );
VQ L & operator ^=( VQ L &, R );
VQ L & operator |=( VQ L &, R );


23 There also exist candidate operator functions of the form 

bool operator !( bool );
bool operator &&( bool , bool );
bool operator ||( bool , bool );


24 For every pair of promoted arithmetic typesLand R, there exist candidate operator functions of the form 

LR operator ?( bool , L , R ); 

where LR is the result of the usual arithmetic conversions between types Land R.[ Note: as with all these descriptions 
of candidate functions,thisdeclaration servesonlyto describethebuilt-in operatorfor purposesofoverload resolution. 
The operator “?” cannot be overloaded. — end note ] 

25 For every typeT, where T isa pointer or pointer-to-member type, thereexist candidate operator functionsof theform 

T operator ?( bool , T , T ); 

Draft 


13.6 Built-in operators Overloading 274 
Draft 


Chapter 14 Templates [temp]


1 Atemplate definesafamilyof classes or functions. 

template-declaration:
exportopt template < template-parameter-list > declaration


template-parameter-list:
template-parameter
template-parameter-list , template-parameter


The declaration in a template-declaration shall 

— declare or define a function or a class, or 
— define a member function, a member class or a static data member of a class template or of a class nested within 
a class template, or 
— define a member template of a class or class template. 
Atemplate-declaration is a declaration.A template-declaration is also a definition if its declaration defines a function, 
a class, or a static data member. 

2Atemplate-declaration can appear only as a namespace scope or class scope declaration. In a function template declaration, the declarator-id shall be a template-name (i.e., not a template-id).[Note: in a class template declaration, if the 
class name is a template-id, the declaration declares a class template partial specialization(14.5.4). — end note ] 

3 Ina template-declaration, explicit specialization, or explicit instantiation the init-declarator-list in the declaration shall 
contain at most one declarator. When such a declaration is used to declare a class template, no declarator is permitted. 

4 A template name has linkage(3.5). A non-member function template can have internal linkage; any other template 
name shall have external linkage. Entities generated from a template with internal linkage are distinct from all entities 
generatedin other translation units.Atemplate,a templateexplicit specialization(14.7.3),anda class template partial 
specialization shall nothaveClinkage. Useofa linkage specification other thanC or C++ with anyof these constructs 
is conditionally-supported, with implementation-defined semantics. Template definitions shall obeythe one definition 
rule(3.2).[Note: default arguments for function templates and for member functions of class templates are considered 
definitions for the purposeof template instantiation(14.5)and must also obeythe one definition rule. — end note ] 

5 Aclass template shall not have the same name as anyother template, class, function, object, enumeration, enumerator, 
namespace,ortypeinthe samescope(3.3),exceptas specifiedin(14.5.4). Exceptthata function templatecanbe 
overloaded either by (non-template) functions with the same name or by other function templates with the same name 
(14.8.3),a template name declaredin namespace scope orin class scope shallbe uniqueinthat scope. 


14.1 Template parameters Templates 276 
6Atemplate-declaration may be preceded by the export keyword. Such a template is said to beexported. Declaring 
exportedaclass templateisequivalentto declaringexportedallofits non-inline member functions, staticdata members, 
member classes, member class templates, and non-inline member function templates. 

7 If a template is exported in one translation unit, it shall be exported in all translation units in which it appears; no 
diagnosticis required.Adeclarationof anexported template shall appear with the export keyword before anypoint of 
instantiation(14.6.4.1)ofthat templateinthat translation unit.In addition,thefirst declarationofanexported template 
containing the export keyword must not follow the definition of that template. Theexport keyword shall not be used 
in a friend declaration. 

8 Templates defined in an unnamed namespace, inline functions, and inline function templates shall not be exported. An 
exported non-class template shall be defined only once in a program; no diagnostic is required. An exported non-class 
template need only be declared (and not necessarily defined) in a translation unit in which it is instantiated. 

9 Anon-exported non-class template mustbe definedinevery translation unitin whichitis implicitly instantiated(14.7.1), 
unless the corresponding specializationisexplicitly instantiated(14.7.2)in some translation unit; no diagnosticis required. 

10 [Note: animplementationmay requirethatatranslationunit containingthe definitionofanexported templatebe compiled before anytranslation unit containing an instantiation of that template. — end note ] 

14.1 Template parameters [temp.param] 
1 The syntax for template-parameters is: 

template-parameter:
type-parameter
parameter-declaration


type-parameter:
class identifieropt
class identifieropt = type-id
typename identifieropt
typename identifieropt = type-id
template < template-parameter-list > class identifieropt
template < template-parameter-list > class identifieropt = id-expression


2 There is no semantic difference between class and typename in a template-parameter. typename followed by an 
unqualified-id names a template type parameter. typename followed by a qualified-id denotes the type in a non-type 
132) parameter-declaration.Astorage class shall notbe specifiedina template-parameter declaration.[ Note: atemplate 
parametermaybea classtemplate.Forexample, 

template < class T > class myarray { /* ... * / }; 

template < class K , class V , template < class T > class C = myarray > 

class Map {
C<K> key;
C<V > value ;


// ... 

132) Since template template-parameters and templatetemplate-argumentsare treated as types for descriptivepurposes, the terms non-type parameter 
and non-type argument are used to refer to non-type, non-template parameters and arguments. 

Draft 


277 Templates 14.1 Template parameters 

}; 

— end note ] 
3Atype-parameter defines its identifier to be a typedef-name (if declared with class or typename)ortemplate-name (if 
declared with template)inthe scopeofthe template declaration.[Note: becauseofthe name lookup rules,a template-
parameter that could be interpreted as either a non-type template-parameter or a type-parameter (because its identifier 
is the name of an already existing class) is taken as a type-parameter.For example, 

class T { /* ... * / };
int i;


template <class T, T i> void f(T t) 

{
T t1 = i; // template-parametersT and i
::T t2 = ::i; // global namespace membersT and i


} 

Here, the template f has a type-parameter called T, rather than an unnamed non-type template-parameter of class T. 

— end note ] 
4 Anon-typetemplate-parameter shall have one of the following (optionally cv-qualified)types: 
— integral or enumeration type, 
— pointer to object or pointer to function, 
— reference to object or reference to function, 
— pointer to member. 
5[Note: other types are disallowed either explicitly below or implicitly by the rules governing the form of template-
arguments(14.3). — end note ]The top-levelcv-qualifiers on the template-parameter are ignored when determining its 
type. 

6 A non-type non-reference template-parameter is not an lvalue. It shall not be assigned to or in any other way have 
its value changed. A non-type non-reference template-parameter cannot have its address taken. When a non-type 
non-reference template-parameter is used as an initializer forareference,a temporaryisalways used.[ Example: 

template <const X& x, int i> void f()
{
i ++; // error: change of template-parameter value


&x; // OK
&i; // error: address of non-reference template-parameter


int& ri = i; // error: non-const reference bound to temporary
const int& cri = i; // OK: const reference bound to temporary
}


— end example ] 
7 Anon-typetemplate-parameter shallnotbe declaredtohavefloatingpoint,class,orvoidtype.[ Example: 
Draft 


14.1 Template parameters Templates 278 
template <double d> class X; // error
template<double* pd> class Y; // OK
template<double& rd> class Z; // OK


— end example ] 
8 Anon-typetemplate-parameter of type “array of T” or “function returning T” is adjusted to be of type “pointer to T” or 
“pointer to function returning T”, respectively.[Example: 

template < int *a > struct R { /* ... * / };
template <int b[5]> struct S { /* ... * / };
int p;
R<&p> w; // OK
S<&p> x; // OK due to parameter adjustment
int v [5];
R<v> y; // OK due to implicit argument conversion
S<v> z; // OK due to both adjustment and conversion


— end example ] 
9Adefault template-argument is a template-argument (14.3)specified after= in a template-parameter. Adefaulttemplate-argument may be specified for anykind of template-parameter (type, non-type, template).Adefault template-argument may be specified in a template declaration. Adefault template-argument shall not be specified in the template-
parameter-lists of the definition of a member of a class template that appears outside of the member’s class. Adefault 
template-argument shall not be specified in a friend class template declaration. If a friend function template declaration specifies a default template-argument, that declaration shall be a definition and shall be the only declaration ofthe 
function template in the translation unit. 

10 The set of default template-argumentsavailable for use witha template declaration or definitionis obtainedby merging 
the default arguments from the definition (if in scope) and all declarations in scope in the same way default function 
arguments are(8.3.6).[Example: 

template<class T1, class T2 = int> class A;
template<class T1 = int, class T2> class A;


is equivalent to 

template<class T1 = int, class T2 = int> class A; 

— end example ] 
11 Ifa template-parameter of a class template has a default template-argument, all subsequent template-parameters shall 
have a default template-argument supplied.[ Note: This is not a requirement for function templates because template 
arguments mightbe deduced(14.8.2).[Example: 

template<class T1 = int, class T2> class B; // error 

— end example ] — end note ] 
12 Atemplate-parameter shallnotbegivendefaultargumentsbytwodifferent declarationsinthe same scope.[ Example: 
template<class T = int> class X;
template < class T = int > class X { /* ... * / }; // error


Draft 


279 Templates 14.2 Names of template specializations 

— end example ] 
13 The scope of a template-parameter extends from its point of declaration until the end of its template. In particular, 
a template-parameter can be used in the declaration of subsequent template-parameters and their default arguments. 
[Example: 

template <class T, T* p, class U = T> class X { /* ... * / };
template <class T> void f(T* p = new T);


— end example ] 
14 Atemplate-parameter shall not be used in its own default argument. 
15 Whenparsinga default template-argument for a non-type template-parameter, the first non-nested > is taken as the end 
of the template-parameter-list rather thana greater-than operator.[ Example:
template<int i = 3 > 4 > // syntax error
class X { /* ... * / };


template <int i = (3 > 4) > // OK
class Y { /* ... * / };


— end example ] 
16 Atemplate-parameter of a template template-parameter is permitted to have a default template-argument. When such 
default arguments are specified, theyapply to the template template-parameter in the scope of the template template-
parameter.[ Example: 

template < class T = float > struct B {};
template < template < class TT = float > class T > struct A {
inline void f ();


inline void g ();
};
template < template < class TT > class T > void A <T >:: f () {


T<> t; // error -TT has no default template argument
}
template <template <class TT = char > class T> void A<T>::g() {


T<> t; // OK -T<char> 

— end example ] 
14.2 Names of template specializations [temp.names] 
1 Atemplate specialization(14.7)canbe referredtobya template-id: 

template-id:
template-name < template-argument-listopt >


template-name:
identifier


template-argument-list:
template-argument
template-argument-list , template-argument


Draft 


14.2 Names of template specializations Templates 280 
template-argument:
assignment-expression
type-id
id-expression


[Note: thenamelookuprules(3.4)areusedto associatetheuseofanamewithatemplate declaration;thatis,toidentify 
a name as a template-name. — end note ] 

2 Foratemplate-name tobeexplicitly qualifiedbythetemplatearguments,the name mustbeknownto refertoa template. 

3 After name lookup(3.4)finds thata nameisatemplate-name, if this name is followed by a <, the < is always taken 
as the beginning of a template-argument-list and never as a name followed by the less-than operator. When parsing a 
template-id,the first non-nested>133) is taken as the end of the template-argument-list rather thanagreater-thanoperator. 
[Example: 

template < int i > class X { /* ... * / }; 

X< 1>2 > x1; // syntax error
X<(1>2)> x2; // OK


template < class T > class Y { /* ... * / };
Y< X<1> > x3; // OK
Y<X<6>> 1> > x4; // OK: Y < X < (6>>1) > >


— end example ] 
4 Whenthe nameofamember template specialization appears after . or -> ina postfix-expression,or afteranested-namespecifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2) 
butdoesnotrefertoamemberofthe current instantiation(14.6.2.1),themembertemplatenamemustbeprefixedby 
thekeyword template. Otherwisethe nameis assumedto namea non-template.[ Example: 

class X { 

public :
template <std::size _t > X* alloc();
template < std :: size _t > static X * adjust ();


};
template <class T> void f(T* p)
{


T* p1 = p->alloc <200>();
// ill-formed: < means less than


T* p2 = p->template alloc<200>();
// OK: < starts template argument list


T:: adjust <100 >();
// ill-formed: < means less than
T:: template adjust <100 >(); 
// OK: < starts template argument list
}


133) A > that encloses the type-id of a dynamic_cast, static_cast, reinterpret_cast or const_cast, or which encloses the template-
arguments of a subsequent template-id, is considered nested for the purpose of this description. 

Draft 


281 Templates 14.3 Template arguments 

— end example ] 
5 Ifa name prefixedby thekeyword template is not the name of a template, the program is ill-formed. [Note: the 
keywordtemplate may not be applied to non-template members of class templates. — end note ]Furthermore, names 
of member templates shallnotbeprefixedbythekeyword template if the postfix-expression or qualified-id does not 
appearinthe scopeofa template.[ Note: just as is the case with the typename prefix, the template prefix is allowed in 
cases where it is not strictly necessary; i.e., when the expression on the left of the -> or ., or the nested-name-specifier 
is not dependent on a template-parameter. — end note ] 

6 Atemplate-id that names a class template specialization is a class-name (clause9). 

14.3 Template arguments [temp.arg] 
1 There are three forms of template-argument, corresponding to the three forms of template-parameter: type, non-type 
and template. The type and form of each template-argument specified in a template-id shall match the type and form 
specified for the correspondingparameter declared by the template in its template-parameter-list.[ Example: 

template < class T > class Array {
T* v;
int sz;


public :
explicit Array ( int );
T& operator []( int );
T& elem(int i) { return v[i]; }


// ... 

}; 

Array <int > v1(20);
typedef std :: complex < double > dcomplex ; // std::complex is a standard
// library template


Array < dcomplex > v2 (30);
Array < dcomplex > v3 (40);


void bar () {
v1[3] = 7;
v2[3] = v3.elem(4) = dcomplex(7,8);


} 

— end example ] 
2 Ina template-argument, an ambiguity between a type-id and an expression is resolved to a type-id, regardless of the 
form of the corresponding template-parameter.134)[Example: 

template < class T > void f ();
template < int I > void f ();


void g()
{
f<int () >(); // int() is a type-id: call the first f()


134) There is no such ambiguity in a default template-argument because the form of the template-parameter determines the allowable forms of the 
template-argument. 

Draft 


14.3 Template arguments Templates 282 
} 

— end example ] 
3 The name of a template-argument shall be accessible at the point where it is used as a template-argument.[Note: if 
the name of the template-argument is accessible at the point where it is used as a template-argument, there is no further 
access restriction in the resulting instantiation where the corresponding template-parameter name is used. — end note ] 
[Example: 

template < class T > class X {
static T t;
};


class Y { 

private :
struct S { /* ... * / };
X<S> x; // OK: S is accessible


// X<Y::S> has a static member of type Y::S
// OK: even though Y::S is private
};


X<Y::S> y; // error: S not accessible 

— end example ]For a template-argument of class type, the template definition has no special access rights to the 
inaccessible members of the template argument type. 
4 When default template-arguments are used, a template-argument list can be empty. In that case the empty <> brackets 
shall still be used as the template-argument-list. [Example: 

template < class T = char > class String ;
String <>* p; // OK: String<char>
String* q; // syntax error


— end example ] 
5 Anexplicit destructorcall(12.4)foranobjectthathasatypethatisa class template specializationmayexplicitlyspecify 
the template-arguments.[ Example: 

template < class T > struct A { 

~A();
};
void f(A<int >* p, A<int >* q) {


p->A<int >::~A(); // OK: destructor call
q->A<int >::~A<int >(); // OK: destructor call
}


— end example ] 
6 If the use of a template-argument gives rise to an ill-formed construct in the instantiation of a template specialization, 
the program is ill-formed. 

Draft 


283 Templates 14.3 Template arguments 

7 When the template in a template-id is anoverloadedfunction template, bothnon-template functionsin theoverload set 
and function templates in the overload set for which the template-arguments do not match the template-parameters are 
ignored. If none of the function templates have matching template-parameters, the program is ill-formed. 

14.3.1 Template type arguments [temp.arg.type] 
1 Atemplate-argument for a template-parameter which is a type shall be a type-id. 

2 Atype without linkage(3.5)shall notbe used asatemplate-argument for a template type-parameter. 

[Example: 

template < class T > class X { /* ... * / };
void f()
{


struct S { /* ... * / }; 

X<S> x3; // error: local type used as template-argument
X<S*> x4; // error: pointer to local type used as template-argument
}


— end example ][Note: a template type argument maybe an incomplete type(3.9). — end note ] 
3 Ifa declaration acquiresa function type througha type dependent ona template-parameter and this causesa declaration 
thatdoesnotusethe syntacticformofa function declaratortohave functiontype,the programis ill-formed.[ Example: 

template < class T > struct A { 

static T t;
};
typedef int function ();
A<function > a; // ill-formed: would declare A<function>::t


// as a static member function 

— end example ] 
4 Ifa template-argument for a template-parameter T names a type “reference to cv1 S”, an attempt to create the type 
“reference to cv2 T” creates the type “reference to cv12 S”, where cv12 is the union of the cv-qualifiers cv1 and cv2. 
Redundant cv-qualifiers areignored.[ Example: 

template < class T > class X {
void f(const T&);


... 

/* / 

};
X<int&> x; // X<int&>::f has the parameter type const int&


— end example ] 
14.3.2 Template non-type arguments [temp.arg.nontype] 
1 Atemplate-argument for a non-type, non-template template-parameter shall be one of: 

— an integral constant-expression of integral or enumerationtype; or 
— the name of a non-type template-parameter;or 
Draft 


14.3 Template arguments Templates 284 
— the address of an object or function with external linkage, including function templates and function template-ids 
but excluding non-static class members, expressed as& id-expression wherethe & is optional if the name refers to 
a function or array, or if the corresponding template-parameter is a reference; or 
— a constant expression that evaluates to a null pointer value (4.10); or 
— aconstantexpressionthatevaluatestoanullmember pointervalue (4.11);or 
— a pointer to member expressed as described in 5.3.1. 
2 [Note: Astring literal(2.13.4)does not satisfythe requirementsof anyof these categories and thusis not an acceptable 
template-argument.[ Example: 

template < class T , char * p > class X { 

// ... 

X();
X(const char* q) { /* ... * / }
};


X<int,"Studebaker"> x1; // error: string literal as template-argument 

char p[] = "Vivisectionist";
X<int,p> x2; // OK


— end example ] — end note ] 
3 [Note: Addresses of array elements and names or addresses of non-static class members are not acceptable template-
arguments.[ Example: 

template <int* p> class X { }; 

int a [10];
struct S { int m; static int s; } s;


X<&a[2]> x3; // error: address of array element
X<&s.m> x4; // error: address of non-static member
X<&s.s> x5; // error: &S::s must be used
X<&S::s> x6; // OK: address of static member


— end example ] — end note ] 
4[Note: Temporaries, unnamed lvalues, and named lvalues that do not have external linkage are not acceptabletemplate
arguments when the corresponding template-parameter has reference type.[ Example:
template < const int & CRI > struct B { /* ... * / };


B<1> b2; // error: temporary would be required for template argument 

int c =1;
B<c> b1; // OK


— end example ] — end note ] 
Draft 


285 Templates 14.3 Template arguments 

The following conversions are performed on each expression used as a non-type template-argument. If a non-type 
template-argument cannot be converted to the type of the corresponding template-parameter then the program is ill-
formed. 

— for a non-type template-parameter of integral or enumeration type, integral promotions(4.5)and integral conversions(4.7)are applied. 
— for a non-type template-parameter of type pointer to object, qualification conversions(4.4)andthe array-topointer conversion(4.2)are applied. [Note: In particular, neither the null pointer conversion(4.10)nor the 
derived-to-base conversion(4.10)are applied. Although 0 is a valid template-argument for a non-type template-
parameter of integral type, it is not a valid template-argument for a non-type template-parameter of pointer type. 
However,(int*)0 isavalidtemplate-argument foranon-type template-parameter of type “pointer to int.” — end 
note ] 
— For a non-typetemplate-parameter of type reference to object, no conversions apply. The type referred to by the 
reference may be more cv-qualified than the (otherwise identical) type of the template-argument. The template-
parameter is bound directly to the template-argument, which must be an lvalue. 
— For a non-type template-parameter of type pointer to function, only the function-to-pointer conversion(4.3)is 
applied. If the template-argument represents a set of overloaded functions (or a pointer to such), the matching 
functionis selected from the set(13.4). 
— For a non-typetemplate-parameter of type reference to function, no conversions apply. If the template-argument 
representsa setofoverloaded functions, the matching functionis selected from the set(13.4). 
— For a non-type template-parameter of type pointer to member function, no conversions apply. If the template-
argument represents a set of overloaded member functions, the matching member function is selected from the 
set(13.4). 
— For a non-typetemplate-parameter of type pointer to data member, qualification conversions(4.4)are applied. 
[Example: 

template < const int * pci > struct X { /* ... * / };
int ai [10];
X<ai> xi; // array to pointer and qualification conversions


struct Y { /* ... * / };
template <const Y& b> struct Z { /* ... * / };
Y y;
Z<y> z; // no conversion,but noteextra cv-qualification


template < int (& pa )[5] > struct W { /* ... * / };
int b [5];
W<b> w; // no conversion


void f( char );
void f( int );


template <void (*pf)(int)> struct A { /* ... * / }; 

A<&f> a; // selects f(int) 

Draft 


14.4 Type equivalence Templates 286 
— end example ] 
14.3.3 Template template arguments [temp.arg.template] 
1Atemplate-argument for a template template-parameter shall be the name of a class template, expressed as id-expression. Only primaryclass templates are considered when matching the template template argument with the corresponding parameter; partial specializations are not considered even if their parameter lists match thatof the template template 
parameter. 

2 Any partial specializations(14.5.4)associated with the primary classtemplate are considered whena specialization 
based on the template template-parameter is instantiated. If a specialization is not visible at the point of instantiation, 
anditwouldhave been selectedhadit been visible, the programis ill-formed; no diagnosticis required.[ Example: 

template < class T > class A { // primary template 

int x;
};
template <class T> class A<T*> { // partial specialization


long x;
};
template < template < class U > class V > class C {


V<int > y; 

V<int*> z;
};
C<A> c; // V<int> within C<A> uses the primary template,


// so c.y.x has type int
// V<int*> within C<A> uses the partial specialization,
// so c.z.x has type long


— end example ] 
14.4 Type equivalence [temp.type] 
1 Twotemplate-ids refer to the same class or function if their template names are identical, they refer to the same template, their type template-arguments are the same type, their non-type template-arguments of integral or enumeration 
type have identical values, their non-type template-arguments of pointer or reference type refer to the same external 
object or function, and their template template-arguments refer to the same template.Twotemplate-ids refer to the same 
class or function if 

— their template-names refer to the same template, and 
— their corresponding type template-arguments are the same type, and 
— their corresponding non-type template-arguments of integral or enumeration type have identical values, and 
— their corresponding non-type template-arguments of pointer type refer to the same external object or function or 
are both the null pointer value, and 
— their corresponding non-type template-arguments of pointer-to-member type refer to the same class member or 
are both the null member pointer value, and 
— their corresponding non-type template-arguments of reference type refer to the same external object or function, 
and 

Draft 


287 Templates 14.5 Template declarations 

— their corresponding template template-arguments refer to the same template. 
[Example: 

template < class E , int size > class buffer { /* ... * / };
buffer <char ,2*512> x;
buffer <char ,1024> y;


declares x and y to be of the same type, and 

template < class T , void (* err_fct )() > class list { /* ... * / };
list<int,&error_handler1> x1;
list<int,&error_handler2> x2;
list<int,&error_handler2> x3;
list<char,&error_handler2> x4;


declares x2 and x3 to be of the same type. Their type differs from the types of x1 and x4. — end example ] 

14.5 Template declarations [temp.decls] 
1Atemplate-id, that is, the template-name followed by a template-argument-list shall not be specified in the declaration 
ofa primary template declaration.[ Example: 

template<class T1, class T2, int I> class A<T1, T2, I> { }; // error
template<class T1, int I> void sort<T1, I>(T1 data[I]); // error


— end example ][Note: however, this syntaxis allowedin class template partial specializations(14.5.4). — end note ] 
2 For purposes of name lookup and instantiation, default arguments of function templates and default arguments of member functions of class templates are considered definitions; each default argument is a separate definition which is 
unrelated to the function template definition or to anyother default arguments. 

14.5.1 Class templates [temp.class] 
1 A class template defines the layout and operations for an unbounded set of related types. [Example: a single class 
template List might provide a common definition for list of int, list of float, and list of pointers to Shapes. — end 
example] 

[Example: An array class template might be declared like this: 

template < class T > class Array {
T* v;
int sz;


public :
explicit Array ( int );
T& operator []( int );
T& elem(int i) { return v[i]; }


// ... 

}; 

2 The prefix template <class T> specifies that a template is being declared and that a type-name T will be used in the 
declaration. In other words, Array is a parameterized type with T as its parameter. — end example ] 

Draft 


14.5 Template declarations Templates 288 
3 When a member function, a member class, a static data member or a member template of a class template is defined 
outside of the class template definition, the member definition is defined as a template definition in which the template-
parameters are thoseof the class template. The namesof the template parameters usedin thedefinitionof the member 
may be different from the template parameter names used in the class template definition. The template argument list 
following the class template name in the member definition shall name the parameters in the same order as the one used 
in the template parameterlistof the member.[ Example: 

template < class T1 , class T2 > struct A {
void f1 ();
void f2 ();


}; 

template<class T2, class T1> void A<T2,T1>::f1() { } // OK
template<class T2, class T1> void A<T1,T2>::f2() { } // error


— end example ] 
4 In a redeclaration, partial specialization, explicit specialization or explicit instantiation of a class template, the class-key 
shall agreein kind with theoriginal class template declaration(7.1.5.3). 

14.5.1.1 Member functions of class templates [temp.mem.func] 
1 Amember function of a class template may be defined outside of the class template definition in which it is declared. 
[Example: 

template < class T > class Array {
T* v;
int sz;


public :
explicit Array ( int );
T& operator []( int );
T& elem(int i) { return v[i]; }


// ... 

}; 

declares three function templates. The subscript function might be defined like this: 

template<class T> T& Array<T>::operator[](int i) 

{
if (i<0 || sz<=i) error("Array: range error");
return v[i];


} 

— end example ] 
2 The template-arguments for a member function of a class template are determined by the template-arguments of the 
typeof the object for which the member functionis called.[ Example: the template-argument for Array<T> :: operator [] () will be determined by the Array to which the subscripting operation is applied. 

Array <int > v1(20);
Array < dcomplex > v2 (30);


Draft 


289 Templates 14.5 Template declarations 

v1[3] = 7; // Array<int>::operator[]()
v2 [3] = dcomplex (7 ,8); // Array<dcomplex>::operator[]()


— end example ] 
14.5.1.2 Member classes of class templates [temp.mem.class] 
1 Aclass memberofa class template maybe defined outside the class template definitionin whichitisdeclared.[Note: 
the class member mustbedefined before its first use that requires an instantiation(14.7.1).Forexample, 

template < class T > struct A { 

class B;
};
A<int >::B* b1; // OK: requires A tobe definedbut not A::B
template <class T> class A<T>::B { };
A<int >::B b2; // OK: requires A::B to be defined


— end note ] 
14.5.1.3 Static data members of class templates [temp.static] 
1 A definition for a static data member may be provided in a namespace scope enclosing the definition of the static 
member’s class template.[ Example: 

template < class T > class X { 

static T s;
};
template <class T> T X<T>::s = 0;


— end example ] 
14.5.2 Member templates [temp.mem] 
1 Atemplate can be declared within a class or class template; such a template is called a member template. Amember 
template canbe defined within or outside its class definition or class template definition.Amember templateofa class 
template that is defined outside of its class template definition shall be specified with the template-parameters of the 
class template followed by the template-parametersof the member template.[Example: 

template < class T > class string { 

public :
template < class T2 > int compare ( const T2 &);
template < class T2 > string ( const string <T2 >& s ) { /* ... * / }
// ...


}; 

template < class T > template < class T2 > int string <T >:: compare ( const T2 & s)
{


// ... 

} 

— end example ] 
Draft 


14.5 Template declarations Templates 290 
2 Alocal class shall not have member templates. Access control rules (clause 11)apply to member template names. A 
destructor shall notbea member template.Anormal (non-template) member function withagiven name and type and 
a member function template of the same name, which could be used to generate a specialization of the same type, can 
both be declared in a class. When both exist, a use of that name and type refers to the non-template member unless an 
explicit template argument listis supplied.[Example: 

template < class T > struct A {
void f(int);
template <class T2> void f(T2);


}; 

template <> void A<int>::f(int) { } // non-template member
template <> template <> void A<int >::f<>(int) { } // template member


int main () 

{
A<char > ac;
ac.f (1); // non-template
ac.f(’c’); // template
ac.f < >(1); // template


} 

— end example ] 
3 Amember function template shall notbe virtual.[Example: 
template < class T > struct AA {
template <class C> virtual void g(C); // error
virtual void f (); // OK


}; 

— end example ] 
4 Aspecializationofa member function template does notoverridea virtual functionfroma base class.[Example: 
class B {
virtual void f(int);
};


class D : public B {
template <class T> void f(T); // does not override B::f(int)
void f(int i) { f<>(i); } // overriding function that calls


// the template instantiation 

}; 

— end example ] 
5 Aspecialization of a template conversion function is referenced in the same way as a non-template conversion function 
that converts to the same type.[ Example: 

struct A {
template < class T > operator T *();


Draft 


291 Templates 14.5 Template declarations 

};
template <class T> A::operator T*(){ return 0; }
template <> A::operator char*(){ return 0; } // specialization
template A::operator void*(); // explicit instantiation


int main () 

{
A a;
int* ip;


ip = a.operator int*(); // explicit call to template operator
// A::operator int*()
}


— end example ][Note: because the explicit template argument list follows the function template name, and because 
conversion member function templates and constructor member function templates are called without using a function 
name, there is no way to provide an explicit template argument list for these function templates. — end note ] 
6 A specialization of a template conversion function is not found by name lookup. Instead, any template conversion 
functions visible in the context of the use are considered. For each such operator, if argument deduction succeeds 
(14.8.2.3), the resulting specializationis used asif foundby name lookup. 

7 Ausing-declaration in a derived class cannot refer to a specialization of a template conversion function in a base class. 

8 Overload resolution(13.3.3.2)and partial ordering(14.5.5.2)are used to select the best conversion function among 
multiple template conversion functions and/or non-template conversion functions. 

14.5.3 Friends [temp.friend] 
1 Afriend of a class or class template can be a function template or class template, a specialization of a function template 
orclasstemplate,oranordinary(non-template) functionorclass.Forafriend function declarationthatisnotatemplate 
declaration: 

— if the name of the friend is a qualified or unqualified template-id, the friend declaration refers to a specialization 
of a function template, otherwise 
— if the name of the friend is a qualified-id and a matching non-template function is found in the specified class or 
namespace, the friend declaration refers to that function, otherwise, 
— if the name of the friend is a qualified-id and a matching specialization of a function template is found in the 
specified class or namespace, the friend declaration refers to that function template specialization, otherwise, 
— the name shall be an unqualified-id that declares (or redeclares)an ordinary (non-template) function.
[Example:
template < class T > class task ;
template<class T> task<T>* preempt(task<T>*);


template < class T > class task { 

// ... 

friend void next_time ();
friend void process(task<T>*);


Draft 


14.5 Template declarations Templates 292 
friend task <T >* preempt <T >( task <T >*); 

template <class C> friend int func(C); 

friend class task <int >; 

template <class P> friend class frd; 

// ... 

}; 

Here, each specialization of the task class template has the function next_time as a friend; because process does 
not haveexplicit template-arguments, each specialization of the task class template has an appropriately typed function 
process asa friend,andthis friendisnota function template specialization; becausethe friend preempt has anexplicit 
template-argument <T>, each specialization of thetask classtemplatehasthe appropriate specializationofthefunction 
template preempt as a friend; andeach specialization of the task class template has all specializations of the function 
template func as friends. Similarly, each specialization of the task class template has the class template specialization 
task<int> as a friend, and has all specializations of the class template frd as friends. — end example ] 

2 Afriend template may be declared within a class or class template. Afriend function template may be defined within 
aclassor class template,buta friend class templatemaynotbe definedina classor class template.In these cases,all 
specializationsofthefriendclassorfriend functiontemplateare friendsoftheclassorclasstemplategranting friendship. 
[Example: 

class A {
template <class T> friend class B; // OK
template <class T> friend void f(T){ /* ... * / } // OK


}; 

— end example ] 
3 Atemplate friend declaration specifies that all specializations of that template, whether theyare implicitly instantiated 
(14.7.1), partially specialized(14.5.4)orexplicitly specialized(14.7.3), are friendsofthe class containing the template 
friend declaration.[ Example: 

class X {
template < class T > friend struct A;
class Y {};


}; 

template <class T> struct A { X::Y ab; }; // OK
template <class T> struct A<T*> { X::Y ab; }; // OK


— end example ] 
4 When a function is defined in a friend function declaration in a class template, the function is instantiated when the 
function is used. The same restrictions on multiple declarations and definitions that apply to non-template function 
declarations and definitions also apply to these implicit definitions. 

5 Amember of a class template may be declared to be a friend of a non-template class. In this case, the corresponding 
memberofevery specializationof the class templateisa friendof the class granting friendship.[ Example: 

template < class T > struct A {
struct B { };


Draft 


293 Templates 14.5 Template declarations 

void f();
};


class C {
template <class T> friend struct A<T>::B;
template <class T> friend void A<T>::f();


}; 

— end example ] 
6[Note: a friend declaration may firstdeclarea memberof an enclosing namespace scope(14.6.5). — end note ] 
7 Afriend template shall not be declared in a local class. 
8 Friend declarations shall notdeclare partial specializations.[ Example: 
template < class T > class A { }; 

class X {
template <class T> friend class A<T*>; // error


}; 

— end example ] 
9 When a friend declaration refers to a specialization of a function template, the function parameter declarations shall not 
include default arguments, nor shall the inline specifier be used in such a declaration. 

14.5.4 Class template partial specializations [temp.class.spec] 
1Aprimary class template declarationis onein which the class template nameis an identifier.Atemplate declarationin 
whichthe class template nameisa template-id, isapartial specialization oftheclass template namedinthe template-id. 
Apartial specialization of a class template provides an alternative definition of the template that is used instead of the 
primary definition when the argumentsina specialization match thosegivenin the partial specialization(14.5.4.1). The 
primary template shall be declared before anyspecializations of that template. If a template is partially specialized then 
that partial specialization shall be declared before the first use of that partial specialization that would cause an implicit 
instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. 

2 When a partial specialization is used within the instantiation of an exported template, and the unspecialized template 
name is non-dependent in the exported template, a declaration of the partial specialization must be declared before the 
definition of the exported template, in the translation unit containing that definition. A similar restriction applies to 
explicit specialization; see 14.7. 

3 Each class template partialspecializationisa distinct templateand definitions shallbeprovidedforthe membersofa 
template partial specialization(14.5.4.3). 

4 [Example: 

template < class T1 , class T2 , int I > class A { }; // #1
template <class T, int I> class A<T, T*, I> { }; // #2
template<class T1, class T2, int I> class A<T1*, T2, I> { }; // #3
template<class T> class A<int, T*, 5> { }; // #4
template<class T1, class T2, int I> class A<T1, T2*, I> { }; // #5


Draft 


14.5 Template declarations Templates 294 
The firstdeclaration declares the primary (unspecialized) class template. The second and subsequent declarations declare 
partial specializationsofthe primary template. — end example ] 

5 The template parameters are specified in the angle bracket enclosed list that immediately follows thekeyword template. For partial specializations, the template argument list is explicitly written immediately following the class 
template name. For primary templates, this list is implicitly described by the template parameter list. Specifically, the 
order of the template arguments is the sequence in which they appear in the template parameter list. [Example: the 
template argument list for the primary template in the example above is <T1, T2, I>. — end example ][Note: the 
template argument list shallnotbe specifiedin the primary template declaration.Forexample, 

template<class T1, class T2, int I> class A<T1, T2, I> { }; // error 

— end note ] 
6 A class template partial specialization may be declared or redeclared in any namespace scope in which its definition 
maybe defined(14.5.1 and 14.5.2).[Example: 

template < class T > struct A {
struct C {
template < class T2 > struct B { };
};
};


// partial specialization ofA<T>::C::B<T2>
template < class T > template < class T2 >
struct A<T>::C::B<T2*> { };


A<short >::C::B<int*> absip; // uses partial specialization 

— end example ] 
7 Partial specialization declarationsthemselves are not foundby name lookup. Rather, when the primary template name 
is used, anypreviously declared partial specializations of the primary template are also considered. One consequence is 
that a using-declaration which refers to a class template does not restrict the set of partial specializations which may be 
found through the using-declaration.[ Example: 

namespace N {
template < class T1 , class T2 > class A { }; // primary template
}


using N::A; // refers to the primary template 

namespace N {
template <class T> class A<T, T*> { }; // partial specialization
}


A<int,int*> a; // uses the partial specialization, whichis found through
// the using declaration which refers to the primary template


— end example ] 
Draft 


295 Templates 14.5 Template declarations 

8 A non-type argument is non-specialized if it is the name of a non-type parameter. All other non-type arguments are 
specialized. 

9 Within the argument list of a class template partial specialization, the following restrictions apply: 

— Apartially specialized non-typeargumentexpression shallnotinvolvea template parameterofthepartial specialization except when the argument expression is a simple identifier.[ Example: 
template < int I , int J > struct A {};
template <int I> struct A<I+5, I*2> {}; // error


template < int I , int J > struct B {};
template <int I> struct B<I, I> {}; // OK


— end example ] 
— The type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a 
parameterof the specialization.[ Example: 
template < class T , T t > struct C {};
template <class T> struct C<T, 1>; // error


template< int X, int (*array_ptr)[X] > class A {};
int array [5];
template < int X > class A <X ,& array > { }; // error


— end example ] 
— The argument list of the specialization shall not be identical to the implicit argument list of the primary template. 
The template parameterlistofa specialization shall not contain default template argumentvalues.135) 
14.5.4.1 Matching of class template partial specializations [temp.class.spec.match] 
1 Whena class templateis usedina context that requiresan instantiationofthe class,itis necessaryto determine whether 
the instantiationistobegenerated usingtheprimary templateor oneofthe partial specializations. Thisis doneby 
matching the template arguments of the class template specialization with the template argument lists of the partial 
specializations. 

— If exactly one matching specialization is found, the instantiation is generated from that specialization. 
— If more than one matching specialization is found, the partial order rules(14.5.4.2)are used to determine whether 
one of the specializations is more specialized than the others. If none of the specializations is more specialized 
than all of the other matching specializations, then the use of the class template is ambiguous and the program is 
ill-formed. 
— If no matches are found, the instantiation is generated from the primary template. 
2 Apartial specialization matches a given actual template argument list if the template arguments of the partial specialization canbe deduced fromthe actual template argument list(14.8.2).[Example: 

135) There is no way in which theycould be used. 

Draft 


14.5 Template declarations Templates 296 
A<int , int , 1> a1; // uses #1
A<int , int*, 1> a2; // uses #2, T is int, I is 1
A<int , char*, 5> a3; // uses #4, T is char
A<int , char*, 1> a4; // uses #5, T1 is int, T2 is char, I is 1
A<int*, int*, 2> a5; // ambiguous: matches #3 and #5


— end example ] 
3 Anon-typetemplate argument can alsobe deduced from thevalueof an actual template argumentofa non-type parameterof the primary template.[ Example: the declaration of a2 above. — end example ] 

4 In a type name that refers to a class template specialization, (e.g., A<int, int, 1>)the argument list must match 
the template parameter list of the primary template. The template arguments of a specialization are deduced from the 
arguments of the primary template. 

14.5.4.2 Partial ordering of class template specializations [temp.class.order] 
1 For two class template partial specializations, the first is at least as specialized as the second if, given the following 
rewrite to two function templates, the first function template is at least as specialized as the second according to the 
ordering rules for function templates(14.5.5.2): 

— the first function template has the same template parameters as the first partial specialization andhasa single 
function parameter whose type is a class template specialization with the template arguments of the first partial 
specialization, and 
— the second function template has the same template parameters as the second partial specialization and hasasingle 
function parameter whosetypeisaclass template specializationwiththe templateargumentsofthe second partial 
specialization. 
2 [Example: 

template <int I, int J, class T> class X { };
template <int I, int J> class X<I, J, int > { }; // #1
template <int I> class X<I, I, int > { }; // #2


template <int I, int J> void f(X<I, J, int >); // #A
template <int I> void f(X<I, I, int >); // #B


The partial specialization #2 is more specialized than the partial specialization #1 because the function template #B is 
more specialized than the function template #A according to the ordering rules for function templates. — end example ] 

14.5.4.3 Members of class template specializations [temp.class.spec.mfunc] 
1 Thetemplateparameterlistofamemberofaclasstemplatepartial specializationshallmatchthetemplate parameterlist 
oftheclasstemplatepartial specialization.Thetemplateargumentlistofamemberofaclasstemplatepartial specialization shall match the template argument listof the class template partialspecialization.Aclass template specializationis 
a distinct template. The members of the class template partial specialization are unrelated to the members of the primary 
template. Class template partial specialization members that are usedinaway that requiresadefinition shallbe defined; 
the definitions of members of the primary template are never used as definitions for members of a class template partial 

Draft 


297 Templates 14.5 Template declarations 

specialization. An explicit specialization of a member of a class template partial specialization is declared in the same 
way as anexplicit specializationof the primary template.[Example: 

// primary template 

template < class T , int I > struct A {
void f();
};


template <class T, int I> void A<T,I>::f() { } 

// class template partial specialization 

template <class T> struct A<T,2> {
void f();
void g();
void h();


}; 

// member of class template partial specialization 

template <class T> void A<T,2>::g() { } 

// explicit specialization 

template <> void A<char ,2>::h() { } 

int main () 

{
A<char ,0> a0;
A<char ,2> a2;
a0.f (); // OK, uses definition of primary template’s member
a2.g (); // OK, uses definition of


// partial specialization’s member
a2.h (); // OK, uses definition of
// explicit specialization’s member
a2.f (); // ill-formed, no definition of f for A<T,2>
// the primary template is not used here


} 

— end example ] 
Ifa member templateofaclass templateis partiallyspecialized,the member template partial specializations are member 
templates of the enclosing class template; if the enclosing class template is instantiated(14.7.1, 14.7.2),a declaration for 
every membertemplate partial specializationis also instantiated as partof creating the membersof the class template 
specialization. If the primary member template is explicitly specialized for a given (implicit) specialization of the 
enclosing class template, the partial specializations of the member template are ignored for this specialization of the 
enclosing class template.Ifa partial specializationofthe member templateisexplicitly specializedforagiven (implicit) 
specialization of the enclosing class template, the primary member template and its other partial specializations are still 
considered for this specializationof the enclosing class template.[ Example: 

template < class T > struct A {
template < class T2 > struct B {}; // #1
template<class T2> struct B<T2*> {}; // #2


Draft 


14.5 Template declarations Templates 298 
}; 

template<> template<class T2> struct A<short>::B {}; // #3 

A<char >::B<int*> abcip; // uses #2
A<short >::B<int*> absip; // uses #3
A<char >::B<int > abci; // uses #1


— end example ] 
14.5.5 Function templates [temp.fct] 
1 A function template defines an unbounded set of related functions. [Example: a family of sort functions might be 
declared like this: 

template < class T > class Array { };
template < class T > void sort ( Array <T >&);


— end example ] 
2 A function template can be overloaded with other function templates and with normal (non-template) functions. A 
normal function is not related to a function template (i.e., it is never considered to be a specialization), even if it has the 
same name and type as a potentially generated function template specialization.136) 

14.5.5.1 Function template overloading [temp.over.link] 
1 It is possible to overload function templates so that two different function template specializations have the same type. 
[Example: 

// file1.c // file2.c 

template <class T> template <class T>
void f(T*); void f(T);
void g(int* p) { void h(int* p) {
f(p ); // call f(p ); // call
// f<int>(int*) // f<int*>(int*)
}}


— end example ] 
2 Such specializations are distinct functions and do not violate the one definition rule(3.2). 

3 The signature of a function template specialization consists of the signature of the function template and of the actual 
template arguments (whether explicitly specified or deduced). 

4 Thesignatureofafunctiontemplateconsistsofitsfunctionsignature,itsreturntypeanditstemplateparameterlist.The 
names of the template parameters are significant only for establishing the relationship between the template parameters 
andtherestofthe signature.[ Note: twodistinct function templates may haveidentical function return types and function 
parameter lists, even if overload resolution alone cannot distinguish them. 

136) That is, declarations of non-template functions do not merely guide overload resolution of function template specializations with the same name. 
If such a non-template function is used in a program, it must be defined; it will not be implicitly instantiated using the function template definition. 

Draft 


299 Templates 14.5 Template declarations 

template < class T > void f (); 

template < int I > void f (); // OK: overloads the first template
// distinguishable with an explicit template argument list


— end note ] 
5 When an expression that references a template parameter is used in the function parameter list or the return type in the 
declaration of a function template, the expression that references the template parameter is part of the signature of the 
function template. This is necessary to permit a declaration of a function template in one translation unit to be linked 
with another declaration of the function template in another translation unit and, conversely, to ensure that function 
templatesthatare intendedtobe distinctarenotlinkedwithone another.[ Example: 

template <int I, int J> A<I+J> f(A<I>, A<J>); // #1
template <int K, int L> A<K+L> f(A<K>, A<L>); // same as #1
template <int I, int J> A<I-J> f(A<I>, A<J>); // different from #1


— end example ][Note: Most expressions that use template parameters use non-type template parameters, but it is 
possible for an expression to reference a type parameter. For example, a template type parameter can be used in the 
sizeof operator. — end note ] 
6 Two expressions involving template parameters are considered equivalent if two function definitions containing the 
expressions would satisfy the one definition rule(3.2), except that the tokens used to name the template parameters may 
differ as long as a token used to name a template parameter in one expression is replaced by another token that names 
the same template parameterin the otherexpression.[ Example: 

template <int I, int J> void f(A<I+J>); // #1
template <int K, int L> void f(A<K+L>); // same as #1


— end example ]Two expressions involving template parameters that are not equivalent arefunctionally equivalent if, 
for anygiven set of template arguments, the evaluation of the expression results in the same value. 
7 Two function templates are equivalent if they are declared in the same scope, have the same name, have identical 
template parameter lists, and have return types and parameter lists that are equivalent using the rules described above 
to compare expressions involving template parameters. Two function templates arefunctionally equivalent if they are 
equivalent except that one or more expressions that involve template parameters in the return types and parameter lists 
are functionally equivalent using the rules described above to compare expressions involving template parameters. If a 
program containsdeclarationsof function templatesthat are functionallyequivalentbutnotequivalent,the programis 
ill-formed; no diagnostic is required. 

8 [Note: This rule guarantees that equivalent declarations will be linked with one another, while not requiring implementationstouseheroiceffortsto guaranteethat functionallyequivalentdeclarationswillbe treatedas distinct.Forexample, 
the last two declarations are functionally equivalent and would cause a program to be ill-formed: 

// Guaranteed to be the same 

template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+10>);


// Guaranteed to be different 

template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+11>);


Draft 


14.5 Template declarations Templates 300 
// Ill-formed, no diagnostic required 

template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+1+2+3+4>);


— end note ] 
14.5.5.2 Partial orderingoffunction templates [temp.func.order] 
1 If a function template is overloaded, the use of a function template specialization might be ambiguous because template 
argument deduction(14.8.2)may associate the function template specialization with more than one function template 
declaration. Partial orderingof overloaded function template declarations is used in the following contexts to select the 
function template to which a function template specialization refers: 

— duringoverload resolutionfora calltoa function template specialization(13.3.3); 
— when the address of a function template specialization is taken; 
— when a placement operator delete that is a function template specialization is selected to match a placement 
operator new(3.7.3.2, 5.3.4); 
— whena friendfunction declaration(14.5.3), anexplicit instantiation(14.7.2)or anexplicit specialization(14.7.3) 
refers to a function template specialization. 
2Partialordering selectswhichoftwofunction templatesismore specializedthantheotherbytransformingeachtemplate 
in turn (see next paragraph) and performing template argument deduction using the function parameter types, or in the 
case of a conversion function the return type. The deduction process determines whether one of the templates is more 
specialized than the other. If so, the more specialized template is the one chosen by the partial ordering process. 

3 Toproduce the transformed template, for each type, non-type, or template template parameter synthesizea unique type, 
value, or class template respectively and substitute it for each occurrence of that parameter in the function type of the 
template. 

4 Usingthe transformed functiontemplate’s function parameterlist,orinthe caseofaconversionfunctionits transformed 
return type, perform type deduction against the function parameter list (or return type) of the other function. The 
mechanism for performing these deductions is given in 14.8.2.4. 

[Example: 

template < class T > struct A { A (); }; 

template <class T> void f(T);
template <class T> void f(T*);
template <class T> void f(const T*);


template <class T> void g(T);
template <class T> void g(T&);


template <class T> void h(const T&);
template <class T> void h(A<T>&);


void m() {
const int *p;


Draft 


301 Templates 14.6 Nameresolution 

f(p); // f(const T*) is more specialized than f(T) or f(T*)
float x;
g(x); // Ambiguous:g(T) or g(T&)
A<int > z;
h(z); // overload resolution selects h(A<T>&)
const A<int > z2;
h(z2 ); // h(const T&) is called because h(A<T>&) is not callable


} 

— end example ] 
5 The presence of unused ellipsis and default arguments has no effect on the partial ordering of function templates. 
[Example: 

template <class T> void f(T); // #1
template<class T> void f(T*, int=1); // #2
template <class T> void g(T); // #3
template<class T> void g(T*, ...); // #4


int main () {
int* ip;
f(ip ); // calls #2
g(ip ); // calls #4


} 

— end example ] 
14.6 Name resolution [temp.res] 
1 Three kinds of names can be used within a template definition: 

— The name of the template itself, and names declared within the template itself. 
— Names dependent on a template-parameter (14.6.2). 
— Names from scopes which are visible within the template definition. 
2 Aname usedina templatedeclaration or definition and thatis dependent ona template-parameter is assumed not to 
nameatype unlessthe applicable namelookup findsatype nameorthe nameis qualifiedbythekeyword typename. 
[Example: 

// no B declared here 

class X; 

template < class T > class Y {
class Z; // forwarddeclaration of member class


void f() {
X* a1; // declare pointer to X
T* a2; // declare pointer to T


Draft 


14.6 Name resolution Templates 302 
Y* a3; // declare pointer to Y<T>
Z* a4; // declare pointer to Z
typedef typename T::A TA;
TA* a5; // declare pointer to T’s A
typename T::A* a6; // declare pointer to T’s A


T::A* a7; // T::A is not a type name:
// multiplyT::A by a7;ill-formed,
// no visible declaration of a7
B* a8; // B is not a type name:
// multiplyB by a8;ill-formed,
// no visible declarations of B and a8


}
};


— end example ] 
3 AWhen a qualified-id that refers to a type and in which the nested-name-specifier depends on a template-parameter 
(14.6.2)butdoesnotrefertoa memberofthe currentinstantiation(14.6.2.1)isintendedtorefertoatype,it shallbe 
prefixedby thekeyword typename, to indicate that the qualified-id denotes a type, forming a typename-specifier. If the 
qualified-id in a typename-specifier does not denote a type, the program is ill-formed. 

typename-specifier:
typename ::opt nested-name-specifier identifier
typename ::opt nested-name-specifier templateopt template-id


4 If a specialization of a template is instantiated for a set of template-arguments such that the qualified-id prefixed by 
typename does not denotea type, the specializationis ill-formed. The usualqualified name lookup(3.4.3)is usedto 
find the qualified-id even in the presence of typename.[ Example: 

struct A {
struct X { };
int X;


};
struct B {


struct X { };
};
template <class T> void f(T t) {


typename T::X x;
}
void foo () {


A a;
B b;
f(b ); // OK: T::X refers to B::X
f(a ); // error: T::X refers to the data member A::X not the struct A::X


} 

— end example ] 
5 Thekeyword typename shall only be used in template declarations and definitions, including in the return type of a 
functiontemplateormemberfunctiontemplate,inthereturntypeforthedefinitionofamemberfunctionofa classtemplate or of a class nested within a class template, and in the type-specifier for the definition of a static member of a class 

Draft 


303 Templates 14.6 Nameresolution 

template orofa class nested withina class template. Thekeyword typename shall be applied only to qualified names, 
but those names need not be dependent. Thekeyword typename shall be used only in contexts in which dependent 
names canbe used. Thisincludes template declarations and definitionsbutexcludesexplicit specialization declarations 
andexplicitinstantiation declarations.Aqualified name used as the nameina mem-initializer-id,a base-specifier, or an 
elaborated-type-specifier is implicitly assumed to name a type, without the use of the typename keyword.[Note: the 
typename keyword is not permitted by the syntax of these constructs. — end note ] 

6 Withinthe definitionofa class templateor withinthe definitionofa memberofa class template,thekeywordtypename 
isnotrequiredwhenreferringtothe unqualifiednameofapreviouslydeclaredmemberoftheclasstemplatethat declares 
a type.[Example: 

template < class T > struct A {
typedef int B;
B b; // OK, no typename required


}; 

— end example ] 
7 Knowing which names are type names allows the syntax of every template definition to be checked. No diagnostic 
shall be issued for a template definition for which a valid specialization can be generated. If no valid specialization 
canbe generatedforatemplate definition, and thattemplateis not instantiated, the template definitionis ill-formed, no 
diagnostic required. If a type used in a non-dependent name is incomplete at the point at which a template is defined 
but is complete at the point at which an instantiation is done, and if the completeness of that type affects whether or not 
the program is well-formed or affects the semantics of the program, the program is ill-formed; no diagnostic is required. 
[Note: if a template is instantiated, errors will be diagnosed according to the other rules in this Standard. Exactly when 
these errors are diagnosed is a quality of implementation issue. — end note ][Example: 

int j;
template < class T > class X {


// ... 

void f(T t, int i, char* p)
{
t = i; // diagnosed if X::f is instantiated
// and the assignment to t is an error
p = i; // may be diagnosed even if X::f is
// not instantiated
p = j; // may be diagnosed even if X::f is
// not instantiated


}
void g(T t) {


+; // may be diagnosed even if X::g is
// not instantiated
}
};


— end example ] 
8 Whenlookingforthe declarationofanameusedinatemplate definition,theusuallookuprules(3.4.1,3.4.2)areused 
for non-dependent names. The lookup of names dependent on the template parameters is postponed until the actual 
template argumentis known(14.6.2).[Example: 

Draft 


14.6 Name resolution Templates 304 
# include < iostream >
using namespace std ;


template < class T > class Set {
T* p;
int cnt ;


public :
Set ();
Set <T >( const Set <T >&);
void printall ()
{


for (int i = 0; i<cnt; i++)
cout << p[i] << ’\n’;
}


// ... 

}; 

in the example, i is the local variable i declared in printall, cnt is the member cnt declared in Set, and cout is 
the standard output stream declared in iostream. However, not every declaration can be found this way; the resolution 
of some names must be postponed until the actual template-arguments are known. For example, even though the name 
operator<< is known within the definition of printall() and a declaration of it can be found in <iostream>, the 
actual declaration of operator<< needed to print p[i] cannot be known until it is known what type T is(14.6.2). 

— end example ] 
If a name does not depend on a template-parameter (as defined in 14.6.2), a declaration (or set of declarations) for 
that name shall be in scope at the point where the name appears in the template definition; the name is bound to the 
declaration (or declarations) found at that point and this binding is not affected by declarations that are visible at the 
pointof instantiation.[ Example: 

void f( char ); 

template <class T> void g(T t) 

{
f (1); // f(char)
f(T (1)); // dependent
f(t); // dependent
dd ++; // not dependent


// error: declaration for dd not found 

} 

enum E { e };
void f(intE);


double dd ;
void h()
{


g (2e ) ; // will cause one call of f(char) followed
// by two calls off(intE)
g(’a’); // will cause three calls of f(char)
}


Draft 


305 Templates 14.6 Nameresolution 

— end example ] 
10 [Note: forpurposesof name lookup,defaultargumentsof function templatesanddefaultargumentsof member functions 
of class templates are considered definitions(14.5). — end note ] 

14.6.1 Locally declared names [temp.local] 
1 Likenormal(non-template)classes,classtemplateshavean injected-class-name(clause 9).The injected-class-namecan 
be used with or without a template-argument-list. When it is used without a template-argument-list, it is equivalent to 
the injected-class-name followed by the template-parametersof the classtemplate enclosedin <>. When it is used with 
atemplate-argument-list,it refers to the specified class template specialization, which could be the current specialization 
or another specialization. 

2Withinthescopeofaclasstemplate specializationorpartial specialization,whentheinjected-class-nameisnotfollowed 
bya<,itisequivalenttotheinjected-class-name followedbythetemplate-argumentsof theclass template specialization 
or partial specialization enclosed in <>.[ Example: 

template <class T> class Y; 

template <> class Y<int > {
Y* p; // meaningY<int>
Y<char >* q; // meaningY<char>


}; 

— end example ] 
3 Theinjected-class-nameofaclasstemplateorclasstemplate specializationcanbeusedeitherwithorwithouta templateargument-list whereveritisin scope.[ Example: 

template < class T > struct Base {
Base* p;
};


template < class T > struct Derived : public Base <T > {
typename Derived::Base* p; // meaningDerived::Base<T>
};


— end example ] 
4 Alookupthatfindsaninjected-class-name(10.2)canresultinanambiguityin certain cases(forexample,ifitisfound 
in more than one base class). If all of the injected-class-names that are found refer to specializations of the same class 
template, and if the name is followed by a template-argument-list, the reference refers to the class template itself and 
nota specialization thereof, andis not ambiguous.[ Example: 

template < class T > struct Base { }; 

template <class T> struct Derived: Base<int>, Base<char> {
typename Derived::Base b; // error: ambiguous
typename Derived::Base<double> d; // OK


}; 

— end example ] 
Draft 


14.6 Name resolution Templates 306 
5 When the normal name of the template (i.e., the name from the enclosing scope, not the injected-class-name) is used 
withouta template-argument-list,it referstothe class template itselfandnota specializationofthe template.[Example: 

template < class T > class X {
X* p; // meaningX<T>
X<T>* p2;
X<int >* p3;
::X* p4; // error: missing template argument list


// ::X does not refer to the injected-class-name
};


— end example ] 
6 The scope of a template-parameter extends from its point of declaration until the end of its template. A template-
parameter hides anyentity with the same name in the enclosing scope.[ Note: this implies that a template-parameter 
can be used in the declaration of subsequent template-parameters and their default argumentsbut cannot be used in 
preceding template-parameters or their default arguments.Forexample, 

template <class T, T* p, class U = T> class X { /* ... * / };
template <class T> void f(T* p = new T);


This also implies that a template-parameter canbe usedin the specificationof base classes.Forexample, 

template < class T > class X : public Array <T > { /* ... * / };
template < class T > class Y : public T { /* ... * / };


The useofa template-parameter as a base class implies that a class used as a template-argument must be defined and 
not just declared when the class template is instantiated. — end note ] 

7Atemplate-parameter shall not be redeclared within its scope (including nested scopes). Atemplate-parameter shall 
nothave the same name as the template name.[ Example: 

template < class T , int i > class Y {
int T; // error: template-parameter redeclared
void f() {


char T; // error: template-parameter redeclared
}
};


template <class X> class X; // error: template-parameter redeclared 

— end example ] 
8 In the definition of a member of a class template that appears outside of the class template definition, the name of a 
member of this template hides the name of a template-parameter.[ Example: 

template < class T > struct A {
struct B { /* ... * / };
void f();


}; 

template <class B> void A<B>::f() { 

Draft 


307 Templates 14.6 Nameresolution 

B b; // A’s B, not the template parameter
}


— end example ] 
9 In the definition of a member of a class template that appears outside of the namespace containing the class template 
definition, the name of a template-parameter hides the nameofa memberofthis namespace.[ Example: 

namespace N {
class C {};
template < class T > class B {


void f(T); 

};
}
template <class C> void N::B<C>::f(C) {


C b; // C is the template parameter, not N::C
}


— end example ] 
10 In the definition of a class template or in the definition of a member of such a template that appears outside of the 
template definition,foreachbaseclasswhichdoesnotdependona template-parameter (14.6.2), if the name of the base 
class or the name of a member of the base class is the same as the name of a template-parameter, the base class name 
or member name hides the template-parameter name(3.3.7).[Example: 

struct A {
struct B { /* ... * / };
int a;
int Y;


}; 

template < class B , class a > struct X : A {
B b; // A’s B
a b; // error: A’s a isn’ta type name


}; 

— end example ] 
14.6.2 Dependent names [temp.dep] 
1 Inside a template, some constructs have semantics which may differ from one instantiation to another. Such a construct 
depends on the template parameters. In particular, types and expressions may depend on the type and/or value of 
template parameters (as determinedby the template arguments) and this determines the contextfor name lookup for 
certain names. Expressions may be type-dependent (on the type of a template parameter) or value-dependent (on the 
value of a non-type template parameter). In an expression of the form: 

postfix-expression ( expression-listopt ) 

where the postfix-expression is an identifier,theidentifier denotesa dependent name if and onlyif anyof theexpressions 
in the expression-list isa type-dependentexpression(14.6.2.2).Ifan operandofan operatorisa type-dependentexpression,theoperatoralsodenotesadependent name.Suchnamesareunboundandarelookedupatthepointofthetemplate 
instantiation(14.6.4.1)in both the context of the template definition and the context of the point of instantiation. 

Draft 


14.6 Name resolution Templates 308 
2 [Example: 

template <class T> struct X : B<T> {
typename T::A* pa;
void f(B<T>* pb) {


static int i = B<T>::i;
pb ->j ++;
}
};


the base class name B<T>, the type name T::A, the names B<T>::i and pb->j explicitly depend on the template-
parameter. — end example ] 

3 In the definition of a class template or a member of a class template, if a base class of the class template depends on a 
template-parameter,thebaseclassscopeisnotexaminedduring unqualifiednamelookupeitheratthepointof definition 
of the class template or member or during an instantiationof the class template or member.[ Example: 

typedef double A;
template < class T > class B {


typedef int A;
};
template <class T> struct X : B<T> {


A a; // a has type double
};


The type name A in the definition of X<T> binds to the typedef name defined in the global namespace scope, not to the 
typedef name defined in the base class B<T>. — end example ][Example: 

struct A {
struct B { /* ... * / };
int a;
int Y;


}; 

int a; 

template < class T > struct Y : T {
struct B { /* ... * / };
B b; // The B defined in Y
void f(int i) { a = i; } // ::a
Y* p; // Y<T>


}; 

Y<A> ya; 

The members A::B, A::a, and A::Y of the template argument A do not affect the binding of names in Y<A>. — end 
example] 

14.6.2.1 Dependent types [temp.dep.type] 
1 In the definition of a class template, a nested class of a class template, a member of a class template, or a member of a 
nested class of a class template, a name refers to the current instantiation if it is 

Draft 


309 Templates 14.6 Nameresolution 

— the injected-class-name(9)of the class template or nested class, 
— in the definition of a primary class template, the name of the class template followed by the template argument 
list of the primary template (as described below) enclosed in <>, 
— in the definition of a nested class of a class template, the name of the nested class referenced as a member of the 
current instantiation, or 
— in the definition of a partial specialization, the name of the class template followed by the template argument list 
of the partial specialization enclosed in <>. 
2 The template argument list of a primary template is a template argument list in which the nth template argument has the 
value of the nth template parameter of the class template. 

3 Atemplate argument that is equivalent to a template parameter (i.e., has the same constant value or the same type as the 
template parameter) can be used in place of that template parameter in a reference to the current instantiation. In the 
case of a non-type template argument, the argument must have been given the value of the template parameter and not 
anexpressioninvolving the template parameter.[ Example: 

template < class T > class A { 

A* p1; // A is the current instantiation 

A<T>* p2; // A<T> is the current instantiation 

A<T*> p3; // A<T*> is not the current instantiation 

::A<T>* p4; // ::A<T> is the current instantiation 

class B { 

B* p1; // B is the current instantiation 

A<T>::B* p2; // A<T>::B is the current instantiation 

typename A<T*>::B* p3; // A<T*>::B is not the 

// current instantiation 

};
};


template <class T> class A<T*> {
A<T*>* p1; // A<T*> is the current instantiation
A<T>* p2; // A<T> is not the current instantiation
};


template < class T1 , class T2 , int I > struct B { 

B<T1, T2, I>* b1; // refers to the current instantiation 

B<T2, T1, I>* b2; // not the current instantiation 

typedef T1 my_ T1 ; 

static const int my _I = I; 

static const int my_I2 = I +0; 

static const int my_I3 = my _I ; 

B<my _T1 , T2 , my _I >* b3; // refers to the current instantiation 

B<my _T1, T2, my _I2>* b4; // not the current instantiation 

B<my _T1, T2, my _I3>* b5; // refers to the current instantiation 

}; 

— end example ] 
4 Anameisa member of the current instantiation if it is 
Draft 


14.6 Name resolution Templates 310 
— An unqualified name that, when looked up, refers to a member of a class template. [ Note: this can only occur 
whenlooking up a name in a scope enclosed by the definition of a class template. — end note ] 
— Aqualified-id in which the nested-name-specifier refers to the current instantiation. 
— [Example: 
template < class T > class A { 

static const int i = 5; 
int n1[i]; // i refers to a member of the current instantiation 
int n2[A::i]; // A::i refers to a member of the current instantiation 
int n3[A<T>::i]; // A<T>::i refers to a member of the current instantiation 
int f (); 

}; 

template <class T> int A<T>::f()
{
return i ; // i refers to a member of the current instantiation
}


— end example ] 
5 Anameisamember of an unknown specialization ifthe nameisa qualified-id in which the nested-name-specifier names 
a dependent type thatis notthe current instantiation. 
6 Atype is dependent if it is 

— a template parameter, 
— a member of an unknown specialization, 
— a nested class that is a member of the current instantiation, 
— a cv-qualified type where the cv-unqualified type is dependent, 
— a compound type constructedfrom anydependent type, 
— an array type constructed from any dependent type or whose size is specified by a constant expression that is 
value-dependent, or 
— a template-id in which eitherthe template nameisa templateparameter or anyof the template argumentsisa 
dependent type or an expression that is type-dependent or value-dependent. 
7 [Note: because typedefs do not introduce new types, but instead simply refer to other types, a name that refers to a 
typedef that is a member of the current instantiation is dependent only if the type referred to is dependent. — end note ] 

14.6.2.2 Type-dependent expressions [temp.dep.expr] 
1 Except as described below, an expression is type-dependent if anysubexpression is type-dependent. 
2 this is type-dependentif the class typeof the enclosing member functionis dependent(14.6.2.1). 
3 An id-expression is type-dependent if it contains: 

— an identifier that was declared with a dependent type, 
Draft 


311 Templates 14.6 Nameresolution 

— a template-id that is dependent, 
— a conversion-function-id that specifiesa dependenttype, 
— a nested-name-specifier or a qualified-id that names a member of an unknown specialization. 
Expressionsof the following forms are type-dependent onlyif the type specifiedby the type-id, simple-type-specifier or 
new-type-id is dependent, even if anysubexpression is type-dependent: 

simple-type-specifier ( expression-listopt )
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt ( type-id ) new-initializeropt
dynamic_cast < type-id >( expression )
static_cast < type-id >( expression )
const_cast < type-id >( expression )
reinterpret_cast < type-id >( expression )
( type-id ) cast-expression


4 Expressions of the following forms are never type-dependent (because the type of the expression cannot be dependent): 

literal
postfix-expression . pseudo-destructor-name
postfix-expression -> pseudo-destructor-name
sizeof unary-expression
sizeof ( type-id )
typeid ( expression )
typeid ( type-id )
::opt delete cast-expression
::opt delete [ ] cast-expression
throw assignment-expressionopt


[Note: Forthe standard library macro offsetof, see 18.1. — end note ] 

5 Aclass member accessexpression(5.2.5)is type-dependentif the typeof the referenced memberis dependent.[Note: 
in an expression of the form x.y or xp->y the type of the expression is usually the type of the member y of the class of 
x (or the class pointed to by xp). However, if x or xp refers to a dependent type that is not the current instantiation, the 
type of y is always dependent. If x or xp refers to a non-dependent type or refers to the current instantiation, the type of 
y is the type of the class member access expression. — end note ] 

14.6.2.3 Value-dependent expressions [temp.dep.constexpr] 
1 Except as described below, a constant expression is value-dependent if anysubexpression is value-dependent. 
2 An identifier is value-dependent if it is: 

— a name declared with a dependent type, 
— the name of a non-type template parameter, 
— a constant with integral or enumeration type andis initialized with anexpressionthatisvalue-dependent. 
Expressions ofthe following form are value-dependent if the unary-expression is type-dependent or the type-id is dependent (even if sizeof unary-expression and sizeof ( type-id ) are not type-dependent): 

Draft 


14.6 Name resolution Templates 312 
sizeof unary-expression
sizeof ( type-id )


[Note: Forthe standard library macro offsetof, see 18.1. — end note ] 

3 Expressions of the following form are value-dependent if either the type-id or simple-type-specifier is dependent or the 
expression or cast-expression is value-dependent: 

simple-type-specifier ( expression-listopt )
static_cast < type-id >( expression )
const_cast < type-id >( expression )
reinterpret_cast < type-id >( expression )
( type-id ) cast-expression


14.6.2.4 Dependent template arguments [temp.dep.temp] 
1 Atypetemplate-argument is dependent if the type it specifies is dependent.
2 An integral non-type template-argument is dependent if the constant expression it specifies is value-dependent.
3 Anon-integral non-typetemplate-argument is dependent if its type is dependent or it has either of the following forms


qualified-id 
& qualified-id 
and contains a nested-name-specifier which specifies a class-name that names a dependent type. 
4 Atemplatetemplate-argument is dependent if it names a template-parameter or isa qualified-id with a nested-namespecifier which contains a class-name that names a dependent type. 

14.6.3 Non-dependent names [temp.nondep] 
1 Non-dependent names used in a template definition are found using the usual name lookup and bound at the point they 
are used.[ Example: 

void g( double );
void h();


template < class T > class Z {
public :


void f() {
g (1); // calls g(double)
h ++; // ill-formed: cannot increment function;


// this could be diagnosed either here or
// at the point of instantiation


}
};


void g( int ); // not in scope at the point of the template
// definition, not considered for the call g(1)


Draft 


313 Templates 14.6 Nameresolution 

— end example ] 
14.6.4 Dependent name resolution [temp.dep.res] 
1 In resolving dependent names, names from the following sources are considered: 

— Declarations that are visible at the point of definition of the template. 
— Declarations from namespaces associated with the types of the function arguments both from the instantiation 
context(14.6.4.1)and from the definition context. 
14.6.4.1 Point of instantiation [temp.point] 
1 For a function template specialization, a member function template specialization, or a specialization for a member 
function or static data member of a class template, if the specialization is implicitly instantiated because it is referenced 
fromwithin anothertemplate specializationandthecontextfromwhichitis referenceddependsonatemplate parameter, 
the point of instantiation of the specialization is the point of instantiation of the enclosing specialization. Otherwise, the 
point of instantiation for such a specialization immediately follows the namespace scope declaration or definition that 
refers to the specialization. 

2 If a function template or member function of a class template is called in a way which uses the definition of a default 
argument of that function template or member function, the point of instantiation of the default argument is the point of 
instantiation of the function template or member function specialization. 

3 For a class template specialization, a class member template specialization, or a specialization for a class member of 
a class template, if the specialization is implicitly instantiated because it is referenced from within another template 
specialization, if the context from which the specialization is referenced depends on a template parameter, and if the 
specialization is not instantiated previous to the instantiation of the enclosing template, the point of instantiation is 
immediately before the point of instantiation of the enclosing template. Otherwise, the point of instantiation for such a 
specialization immediately precedes the namespace scope declaration or definition that refers to the specialization. 

4 Ifa virtual functionis implicitly instantiated,itspointof instantiationis immediately followingthepointof instantiation 
of its enclosing class template specialization. 

5 Anexplicit instantiation directiveisan instantiationpointforthe specializationor specializations specifiedbytheexplicit 
instantiation directive. 

6 The instantiationcontextofanexpressionthatdependsonthetemplateargumentsisthesetof declarationswithexternal 
linkage declaredpriortothepointof instantiationofthe template specializationinthe same translation unit. 

7 Aspecialization for a function template, a member function template, or of a member function or static data member of 
a class templatemayhavemultiple pointsof instantiationswithina translation unit.Aspecializationforaclass template 
hasatmostonepointofinstantiationwithina translationunit. Aspecializationforanytemplatemayhavepointsof 
instantiation in multiple translation units. If two different points of instantiation give a template specialization different 
meanings accordingtotheone definitionrule(3.2),the programis ill-formed,no diagnostic required. 

14.6.4.2 Candidate functions [temp.dep.candidate] 
1 For a function call that depends on a template parameter, if the function name is anunqualified-id but not atemplate-id, 
the candidate functions arefound using the usual lookup rules(3.4.1, 3.4.2)except that: 

Draft 


14.7 Template instantiation and specialization Templates 314 
— For the part of the lookup using unqualified name lookup(3.4.1), only function declarations with external linkage 
from the template definition context are found. 
— Forthepartofthelookupusing associated namespaces(3.4.2),only function declarationswithexternallinkage 
found in either the template definition context or the template instantiation context are found. 
If the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just 
considering those declarations found in the template definition and template instantiation contexts, then the program has 
undefined behavior. 

14.6.5 Friend names declared withina class template [temp.inject] 
1 Friend classes or functions can be declaredwithin a class template. When a template is instantiated, the names of its 
friends are treated as if the specialization had been explicitly declared at its point of instantiation. 

2 As with non-template classes, the names of namespace-scope friend functions of a class template specialization are not 
visible duringan ordinary lookup unlessexplicitly declaredat namespace scope(11.4). Such namesmaybe found under 
the rules for associated classes(3.4.2).137)[Example: 

template < typename T > class number {
public :
number ( int );


// ... 

friend number gcd ( number x , number y ) { return 0; };
private :


// ... 

}; 

void g()
{
number < double > a (3) , b (4);


// ... 

a = gcd(a,b); // finds gcd because number<double> is an
// associated class, making gcd visible
// in its namespace (global scope)


b = gcd (3 ,4); // ill-formed; gcd is not visible
}


— end example ] 
14.7 Template instantiation and specialization [temp.spec] 
1 The act of instantiating a function, a class, a member ofa class template or a member template is referred to as template 
instantiation. 

2 A function instantiated from a function template is called an instantiated function. A class instantiated from a class 
templateis called an instantiated class.Amember function,a member class, ora static data memberofa class template 
instantiated from the member definitionof the class templateis called, respectively, an instantiated member function, 

137) Friend declarations do not introduce new names into anyscope, either when the template is declared or when it is instantiated. 

Draft 


315 Templates 14.7 Template instantiation and specialization 

member class or static data member. A member function instantiated from a member function template is called an 
instantiated member function. A member class instantiated from a member class template is called an instantiated 
member class. 

3 An explicit specialization may be declared for a function template, a class template, a member of a class template or 
a member template. An explicit specialization declaration is introduced by template<>. In an explicit specialization 
declaration for a class template, a member of a class template or a class member template, the name of the class that 
is explicitly specialized shall be a template-id. In the explicit specialization declaration for a function template or a 
member function template, the name of the function or member function explicitly specialized may be a template-id. 
[Example: 

template < class T = int > struct A { 

static int x;
};
template <class U> void g(U) { }


template <> struct A<double > { }; // specialize forT == double
template<> struct A<> { }; // specialize forT == int
template<> void g(char) { } // specialize forU == char


// U is deduced from the parameter type
template<> void g<int>(int) { } // specialize forU == int
template <> int A<char >::x = 0; // specialize forT == char


template < class T = int > struct B { 

static int x;
};
template <> int B<>::x = 1; // specialize forT == int


— end example ] 
4 An instantiated templatespecialization canbe either implicitlyinstantiated(14.7.1)foragivenargument listorbeexplicitly instantiated(14.7.2).Aspecializationisaclass, function,orclassmemberthatiseither instantiatedorexplicitly 
specialized(14.7.3). 

5 Foragiven template andagiven setoftemplate-arguments, 

— an explicit instantiation shall appear at most once in a program, 
— an explicit specialization shall be defined at most once in a program (according to 3.2), and 
— both an explicit instantiation and a declaration of an explicit specialization shall not appear in a program unless 
the explicit instantiation follows a declaration of the explicit specialization. 
An implementation is not required to diagnose a violation of this rule. 
6 Each class template specialization instantiated froma template has itsown copyof anystatic members.[ Example: 

template < class T > class X {
static T s;


// ... 

};
template <class T> T X<T>::s = 0;
X<int > aa;


Draft 


14.7 Template instantiation and specialization Templates 316 
X<char*> bb; 

X<int> has a static member s of type int and X<char*> has a static member s of type char*. — end example ] 

14.7.1 Implicit instantiation [temp.inst] 
1 Unless a class template specialization has been explicitly instantiated(14.7.2)or explicitly specialized(14.7.3), the 
class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a 
completely-defined object type or when the completeness of the class type affects the semantics of the program. The 
implicit instantiationofa class template specialization causes the implicit instantiationof the declarations,but notof 
the definitions or default arguments, of the class member functions, member classes, static data members and member 
templates; and it causes the implicit instantiation of the definitions of member anonymous unions. Unless a member of 
a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the 
member is implicitly instantiated when the specialization is referenced in a context that requires the member definition 
to exist; in particular, the initialization (and anyassociated side-effects) of a static data member does not occur unless 
the staticdata memberisitselfusedinawaythat requiresthe definitionofthestaticdata membertoexist. 

2 Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function 
definition to exist. Unless a call is to a function template explicit specialization or to a member function of an explicitly specialized class template, a default argument for a function template or a member function of a class template is 
implicitly instantiated when the function is called in a context that requires the value of the default argument. 

3 [Example: 

template < class T > class Z { 

public :
void f();
void g();


}; 

void h() 

{
Z<int > a; // instantiation of class Z<int> required
Z<char >* p; // instantiation of class Z<char> not


// required
Z<double >* q; // instantiation of class Z<double>
// not required


a.f (); // instantiation of Z<int>::f() required
p->g (); // instantiation of class Z<char> required, and
// instantiation of Z<char>::g() required
}


Nothing in this example requires class Z<double>, Z<int>::g(), or Z<char>::f() to be implicitly instantiated. 

— end example ] 
4 Aclass template specialization is implicitly instantiated if the class type is used in a context that requires a completely-
defined object type or if the completeness of the class type might affect the semantics of the program. [Note: in 

Draft 


317 Templates 14.7 Template instantiation and specialization 

particular, if the semantics of an expression depend on the member or base class lists of a class template specialization, 
the class template specialization is implicitly generated. For instance, deleting a pointer to class type depends on 
whether or not the class declares a destructor, and conversion between pointer to class types depends on the inheritance 
relationship between the two classes involved. — end note ][Example: 

template < class T > class B { /* ... * / };
template <class T> class D : public B<T> { /* ... * / };


void f( void *);
void f(B<int >*);


void g(D<int>* p, D<char>* pp, D<double> ppp)
{
f(p); // instantiation of D<int> required: call f(B<int>*)


B<char >* q = pp; // instantiation of D<char> required:
// convert D<char>* to B<char>*


delete ppp ; // instantiation of D<double> required
}


— end example ] 
5 If the overload resolution process can determine the correct function to call without instantiating a class template definition,itis unspecified whether that instantiation actually takes place.[ Example: 

template < class T > struct S { 

operator int ();
};
void f( int );
void f(S<int >&);
void f(S<float >);


void g(S<int >& sr) {
f(sr ); // instantiation of S<int> allowedbut notrequired
// instantiation of S<float> allowedbut notrequired
};


— end example ] 
6 If an implicit instantiationofa class template specializationis required and the templateis declaredbut not defined, the 
programis ill-formed.[ Example: 

template <class T> class X; 

X<char > ch; // error: definition of X required 

— end example ] 
7 The implicit instantiation of a class template does not cause any static data members of that class to be implicitly 
instantiated. 

Draft 


14.7 Template instantiation and specialization Templates 318 
8 If a function template or a member function template specialization is used in a way that involves overload resolution, a 
declaration of the specialization is implicitly instantiated(14.8.3). 

9 An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member function, a member class or a static data member of a class template that does not require instantiation. It is unspecified 
whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual 
member function would not otherwise be instantiated. The use of a template specialization in a default argument shall 
not cause the template to be implicitly instantiated except that a class template may be instantiated where its complete 
type is needed to determine the correctness of the default argument. The use of a default argument in a function call 
causes specializationsinthedefaultargumenttobe implicitly instantiated. 

10 Implicitlyinstantiated class and function template specializations are placed in the namespace where the template is 
defined. Implicitly instantiated specializations for members of a class template are placed in the namespace where the 
enclosing class template is defined. Implicitly instantiated member templates are placed in the namespace where the 
enclosing class or class templateis defined.[ Example: 

namespace N {
template < class T > class List {
public :


T* get (); 

// ... 

};
}


template < class K , class V > class Map { 

N::List <V> lt;
V get(K);
// ... 

}; 

void g(Map<char*,int>& m)
{
int i = m.get("Nicholas");


// ... 

} 

a call of lt.get() from Map<char*,int>::get() would place List<int>::get() in the namespace N rather than 
in the global namespace. — end example ] 

11 If a function template f iscalledinawaythat requiresadefaultargumentexpressiontobeused,thedependent names 
are looked up, the semantics constraints are checked, and the instantiation of anytemplate used in the default argument 
expressionisdoneasifthedefaultargumentexpressionhadbeenanexpressionusedinafunction template specialization 
with the same scope, the same template parameters and the same access as that of the function template f used at that 
point. This analysis is called default argument instantiation. The instantiated default argument is then used as the 
argument of f. 

12 Each default argumentis instantiated independently.[ Example: 

template <class T> void f(T x, T y = ydef(T()), T z = zdef(T())); 

class A {}; 

Draft 


319 Templates 14.7 Template instantiation and specialization 

A zdef(A); 

void g(A a, Ab, A c) {
f(a, b, c); // no default argument instantiation
f(a, b); // default argument z = zdef(T()) instantiated
f(a); // ill-formed; ydef is not declared


} 

— end example ] 
13 [Note: 14.6.4.1 defines the point of instantiation of a template specialization. — end note ] 
14 There is an implementation-defined quantity that specifies the limit on the total depth of recursive instantiations, which 
couldinvolve more than one template. The resultof an infinite recursionin instantiationis undefined.[ Example: 

template < class T > class X {
X<T>* p; // OK
X<T*> a; // implicitgenerationofX<T> requires


// the implicit instantiation of X<T*> which requires
// the implicit instantiation of X<T**> which ...
};


— end example ] 
14.7.2 Explicit instantiation [temp.explicit] 
1Aclass,a functionormembertemplate specializationcanbeexplicitly instantiatedfromitstemplate.Amemberfunction, member class or static data member of a class template can be explicitly instantiated from the member definition 
associated with its classtemplate. 

2 The syntax for explicit instantiation is: 

explicit-instantiation: 

template declaration 
If the explicit instantiation is for a class, a function or a member template specialization, the unqualified-id in the 
declaration shall be either a template-id or, where all template arguments can be deduced, a template-name.[Note: 
the declaration may declare a qualified-id, in which case the unqualified-id of the qualified-id must be a template-id. 

— end note ]If the explicit instantiation is for a member function, a member class or a static data member of a class 
template specialization, the name of the class template specialization in the qualified-id for the member name shall be a 
template-id.Anexplicit instantiation shall appearinan enclosing namespaceofits template.Ifthe name declaredinthe 
explicit instantiation is an unqualified name, the explicit instantiation shall appear in the namespace where its template 
is declared.[ Note: regarding qualified namesindeclarators, see 8.3. — end note ][Example: 
template < class T > class Array { void mf (); };
template class Array <char >;
template void Array <int >::mf();


template < class T > void sort ( Array <T >& v ) { /* ... * / }
template void sort(Array <char >&); // argument is deduced here


Draft 


14.7 Template instantiation and specialization Templates 320 
namespace N { 

template <class T> void f(T&) { }
}
template void N::f<int>(int&);


— end example ] 
3 Adeclaration of a function template shall be in scope at the point of the explicit instantiation of the function template. 
Adefinition of the class or class template containing a member function template shallbe in scope at the point of the 
explicit instantiationofthe member functiontemplate.Adefinitionof a class templateorclass member template shall 
be in scope at the point of the explicit instantiation of the class template or class member template. Adefinition of a 
class template shall be in scope at the point of an explicit instantiation of a member function or a static data member 
of the class template. A definition of a member class of a class template shall be in scope at the point of an explicit 
instantiation of the member class. If the declaration of the explicit instantiation names an implicitly-declared special 
member function (clause 12), the program is ill-formed. 

4 For a given set of template parameters, if an explicit instantiation of a template appears after a declaration of an explicit 
specialization for that template, the explicit instantiation has no effect. Otherwise, the definition of a non-exported 
function template,a non-exported member function template,ora non-exportedmember functionor staticdata member 
of a class template shall be present in every translation unit in which it is explicitly instantiated. 

5 Anexplicit instantiationofaclassor function template specializationisplacedinthe namespacein whichthe templateis 
defined. An explicit instantiation for a member of a class template is placed in the namespace where the enclosing class 
template is defined. An explicit instantiation for a member template is placed in the namespace where the enclosing 
class or class templateis defined.[ Example: 

namespace N {
template < class T > class Y { void mf () { } };
}


template class Y<int >; // error: class template Y not visible
// in the global namespace


using N::Y;
template class Y<int >; // OK: explicit instantiation in namespace N


template class N::Y<char*>; // OK: explicit instantiation in namespace N
template void N::Y<double >::mf(); // OK: explicit instantiation
// in namespace N


— end example ] 
6 Atrailingtemplate-argument can be left unspecified in an explicit instantiation of a function template specialization or 
ofa member function template specializationprovideditcanbe deducedfromthetypeofa function parameter(14.8.2). 
[Example: 

template < class T > class Array { /* ... * / };
template <class T> void sort(Array <T>& v);


// instantiate sort(Array<int>&) -template-argument deduced
template void sort <>(Array <int >&);


Draft 


321 Templates 14.7 Template instantiation and specialization 

— end example ] 
7 Theexplicit instantiationofa class template specialization impliestheinstantiationofallalsoexplicitlyinstantiates each 
ofits members not(notincludingmembersinheritedfrombase classes)whosedefinitionisvisibleatthepointofinstantiation and that has not been previously explicitly specialized in the translation unit containing the explicit instantiation. 

8 Theusualaccesscheckingrulesdonotapplyto namesusedtospecifyexplicitinstantiations.[ Note: In particular, the 
template arguments and names used in the function declarator (including parameter types, return types and exception 
specifications) may be private types or objects which would normally not be accessible and the template may be a 
member template or member function which would not normally be accessible. — end note ] 

9 Anexplicit instantiationdoesnot constitutea useofadefaultargument,sodefaultargument instantiationisnot done. 
[Example: 

char* p =0;
template <class T> T g(T = &p);
template int g<int >(int); // OK even though &p isn’tan int.


— end example ] 
14.7.3 Explicit specialization [temp.expl.spec] 
1 An explicit specialization of anyof the following: 

— function template 
— class template 
— member function of a class template 
— static data member of a class template 
— member classofa classtemplate 
— member class template of a class template 
— member function template of a class template
can be declared by a declaration introduced by template<>;that is:
explicit-specialization:
template < > declaration


[Example: 

template < class T > class stream ; 

template <> class stream <char > { /* ... * / }; 

template < class T > class Array { /* ... * / };
template < class T > void sort ( Array <T >& v ) { /* ... * / }


template<> void sort<char*>(Array<char*>&) ; 

Given these declarations, stream<char> will be used as the definition of streams of chars; other streams will be 
handled by class template specializations instantiated from the class template. Similarly, sort<char*> will be used as 

Draft 


14.7 Template instantiation and specialization Templates 322 
the sort function for arguments of type Array<char*>;otherArray types will be sortedby functions generated from 
the template. — end example ] 

An explicit specialization shall be declared in the namespace of which the template is a member, or, for member templates,inthe namespaceof whichthe enclosing classorenclosing class templateisa member.Anexplicit specialization 
of a member function, member class or static data member of a class template shall be declared in the namespace of 
which the class template is a member. Such a declaration may also be a definition. If the declaration is not a definition, 
the specialization maybedefined later(7.3.1.2). 

2 A declaration of a function template or class template being explicitly specialized shall be in scope at the point of 
declarationof anexplicit specialization.[ Note: a declaration,but nota definitionof the templateis required. — end 
note ]The definition of a class or class template shall be in scope at the point of declaration of an explicit specialization 
fora member templateofthe class or class template.[ Example: 

template <> class X<int > { /* ... * / }; // error: X not a template 

template <class T> class X; 

template <> class X<char*> { /* ... * / }; // OK: X is a template 

— end example ] 
3 A member function, a member class or a static data member of a class template may be explicitly specialized for a 
class specializationthatis implicitly instantiated;inthiscase,the definitionoftheclasstemplateshallbeinscopeatthe 
point of declaration of the explicit specialization for the member of the class template. If such an explicit specialization 
for the member of a class template names an implicitly-declared special member function (clause 12), the program is 
ill-formed. 

4 Amemberof anexplicitly specialized classis notimplicitly instantiated from the member declarationof the class template; instead,the memberofthe class template specialization shall itselfbeexplicitly defined.Inthis case,the definition 
of the class template explicit specialization shallbe in scope at the point of declaration of the explicit specialization of 
the member. The definition of an explicitly specialized class is unrelated to the definition of a generated specialization. 
Thatis,itsmembersneednothavethesamenames,types,etc.asthemembersofageneratedspecialization. Definitions 
of members of an explicitly specialized class are defined in the same manner as members of normal classes, and not 
using theexplicit specialization syntax.[ Example: 

template < class T > struct A {
void f(T) { /* ... * / }
};


template <> struct A<int > {
void f(int);
};


void h()
{
A<int > a;


a.f (16); // A<int>::f must be defined somewhere
}
Draft 


323 Templates 14.7 Template instantiation and specialization 

// explicit specialization syntax not used for a member of
// explicitly specialized class template specialization


void A<int >::f() { /* ... * / } 

— end example ] 
5 If a template, a member template or the member of a class template is explicitly specialized then that specialization 
shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in 
every translationunitinwhichsuchauseoccurs;nodiagnosticisrequired.Iftheprogramdoesnotprovidea definition 
for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to 
take place or the member is a virtual member function, the program is ill-formed, no diagnostic required. An implicit 
instantiationis never generated for anexplicit specialization thatis declaredbut notdefined.[ Example: 

template < class T > class Array { /* ... * / };
template < class T > void sort ( Array <T >& v ) { /* ... * / }


void f(Array <String >& v)
{
sort (v); // use primary template
// sort(Array<T>&), T is String
}


template<> void sort<String>(Array<String>& v); // error: specialization
// after use of primary template
template <> void sort <>(Array <char*>& v); // OK: sort<char*> not yet used


— end example ] 
6 The placement of explicit specialization declarations for function templates, class templates, member functions of class 
templates, static data members of class templates, member classes of class templates, member class templates of class 
templates, member function templates of class templates, member functions of member templates of class templates, 
member functions of member templates of non-template classes, member function templates of member classes of class 
templates, etc., and the placement of partial specialization declarations of class templates, member class templates of 
non-template classes, member class templates of class templates, etc., can affect whether a program is well-formed 
according to the relative positioning of the explicit specialization declarations and their points of instantiation in the 
translation unit as specified above and below. When writing a specialization, be careful about its location; or to make it 
compile will be such a trial as to kindle its self-immolation. 

7 Whena specializationforwhichanexplicitspecializationexistsis used withinthe instantiationofanexported template, 
and the unspecialized template name is non-dependent in the exported template, a declaration of the explicit specialization shall be declared before the definition of the exported template, in the translation unit containing that definition. 
[Example: 

// file #1 

# include < vector >
// Primary class templatevector


export template <class T> void f(t) { 

std :: vector <T >; vec ; // should matchthe specialization
...


/* / 

} 

Draft 


14.7 Template instantiation and specialization Templates 324 
// file #2 

# include < vector >
class B {};
// Explicit specialization ofvector for vector<B>
namespace std {


template <> class vector <B> { /* ... * / };
}
template <class T> void f(T);
void g(B b) {


f(b); // ill-formed:
// f<B> should refer to vector<B>,but the
// specialization was not declared with the
// definition of f in file #1


} 

— end example ]
8Atemplateexplicit specializationisinthe scopeofthe namespacein whichthetemplatewas defined.[Example:
namespace N {
template < class T > class X { /* ... * / };
template < class T > class Y { /* ... * / };


template <> class X<int > { /* ... * / }; // OK: specialization
// in same namespace
template <> class Y<double >; // forwarddeclare intent to
// specialize fordouble
}


template <> class N::Y<double > { /* ... * / }; // OK: specialization
// in same namespace


— end example ] 
9A template-id that names a class templateexplicit specialization that has beendeclaredbut not defined canbe used 
exactly like the namesof other incompletely-defined classes(3.9).[Example: 

template <class T> class X; // X is a class template
template <> class X<int >;


X<int >* p; // OK: pointer to declared class X<int>
X<int > x; // error: object of incomplete class X<int>


— end example ] 
10 Atrailingtemplate-argument can be left unspecified in the template-id naming an explicit function template specialization providedit canbe deduced from the function argument type.[ Example: 

template < class T > class Array { /* ... * / };
template <class T> void sort(Array <T>& v);


Draft 


325 Templates 14.7 Template instantiation and specialization 

// explicit specialization for sort(Array<int>&)
// with deduces template-argument of type int
template <> void sort(Array <int >&);


— end example ] 
11 [Note: This paragraph is intentionallyempty. — end note ] 
12 Afunction with the same name asa template anda typethatexactly matches thatofa template specializationis not an 
explicit specialization(14.5.5). 
13 An explicit specialization of a function template is inline only if it is explicitly declared to be, and independently of 
whether its function template is.[ Example: 
template <class T> void f(T) { /* ... * / } 
template <class T> inline T g(T) { /* ... * / } 

template<> inline void f<>(int) { /* ... * / } // OK: inline
template <> int g<>(int) { /* ... * / } // OK: not inline


— end example ] 
14 An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; 
otherwise, it is a declaration. [Note: there is no syntax for the definition of a static data member of a template that 
requires default initialization. 

template <> X Q<int >::x; 

15 Thisisa declaration regardlessof whetherX canbe default initialized(8.5). — end note ] 

16 A member or a member template of a class template may be explicitly specialized for a given implicit instantiation 
of the class template, even if the member or member template is defined in the class template definition. An explicit 
specializationofa member or member templateis specified using the templatespecialization syntax.[ Example: 

template < class T > struct A {
void f(T);
template<class X1> void g1(T, X1);
template<class X2> void g2(T, X2);
void h(T) { }


}; 

// specialization 

template <> void A<int >::f(int); 

// out of class member template definition 

template<class T> template<class X1> void A<T>::g1(T, X1) { } 

// member template specialization 

template<> template<class X1> void A<int>::g1(int, X1); 

//member template specialization 

template <> template <> 

Draft 


14.7 Template instantiation and specialization Templates 326 
void A<int>::g1(int, char); // X1 deduced as char
template <> template <>
void A<int>::g2<char>(int, char); // X2 specified as char


// member specialization even if defined in class definition 

template<> void A<int>::h(int) { } 

— end example ] 
17 Amember or a member template may be nested within manyenclosing class templates. In an explicit specialization for 
such a member, the member declaration shall be preceded by a template<> for each enclosing class template that is 
explicitly specialized.[Example: 

template < class T1 > class A {
template < class T2 > class B {
void mf ();


};
};
template <> template <> class A<int >::B<double >;
template <> template <> void A<char >::B<char >::mf();


— end example ] 
18 Inanexplicit specialization declarationforamemberofaclasstemplateoramembertemplatethatappearsin namespace 
scope,the member templateand someofitsenclosingclasstemplatesmay remain unspecialized,exceptthatthe declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized 
as well. In suchexplicit specialization declaration, thekeyword template followed by a template-parameter-list shall 
be provided instead of the template<> preceding the explicit specialization declaration of the member. The types of 
the template-parameters in the template-parameter-list shall be the same as those specified in the primary template 
definition.[ Example: 

template < class T1 > class A { 

template < class T2 > class B {
template < class T3 > void mf1 ( T3 );
void mf2 ();


};
};
template <> template <class X>


class A<int >::B {
template <class T> void mf1(T);
};
template <> template <> template <class T>
void A<int >::B<double >::mf1(T t) { }
template <class Y> template <>
void A<Y>::B<double >::mf2() { } // ill-formed; B<double> is specializedbut
// its enclosing class template A is not


— end example ] 
19 Aspecialization of a member function template or member class template of a non-specialized class template is itself a 
template. 

Draft 


327 Templates 14.8 Function template specializations 

20 Anexplicit specializationdeclaration shall notbea friend declaration. 

21 Default function arguments shall not be specified in a declaration or a definition for one of the following explicit specializations: 

— the explicit specialization of a function template; 
— the explicit specialization of a member function template; 
— the explicit specialization of a member function of a class template where the class template specialization to 
which the member function specialization belongs is implicitly instantiated. [Note: default function arguments 
may be specified in the declaration or definition of a member function of a class template specialization that is 
explicitly specialized. — end note ] 
14.8 Function template specializations [temp.fct.spec] 
1 Afunction instantiated fromafunction templateis calleda function template specialization; sois anexplicit specialization of a function template. Template arguments can be explicitly specified when naming the function template 
specialization, deduced from the context (e.g., deduced from the function arguments in a call to the function template 
specialization, see 14.8.2), or obtained from default template arguments. 

2 Each function template specialization instantiated froma template has itsown copyof anystaticvariable.[ Example: 

template <class T> void f(T* p)
{
static T s;


// ... 

}; 

void g(int a, char* b) 

{
f(&a); // call f<int>(int*)
f(&b); // call f<char*>(char**)


} 

Here f<int>(int*) has a static variable s of type int and f<char*>(char**) has a static variable s of type char*. 

— end example ] 
14.8.1 Explicit template argument specification [temp.arg.explicit] 
1 Template arguments can be specified when referring to a function template specialization by qualifying the function 
template name with thelist of template-arguments in the same way as template-arguments are specified in uses of a 
class template specialization.[ Example: 

template <class T> void sort(Array <T>& v);
void f(Array<dcomplex>& cv, Array<int>& ci)
{


sort < dcomplex >( cv ); // sort(Array<dcomplex>&)
sort<int >(ci); // sort(Array<int>&)
}


and 

Draft 


14.8 Function template specializations Templates 328 
template <class U, class V> U convert(V v); 

void g(double d) 

{
int i = convert<int,double>(d); // int convert(double)
char c = convert<char,double>(d); // char convert(double)


} 

— end example ] 
2 Atemplate argument list may be specified when referring to a specialization of a function template 
— when a function is called, 
— when the address of a function is taken, when a function initializes a reference to function, or when a pointer to 
member function is formed, 
— in an explicit specialization, 
— in an explicit instantiation, or 
— in a friend declaration. 
3 Trailing template arguments that canbe deduced(14.8.2)or obtained from default template-arguments may be omitted 
from the list of explicit template-arguments. If all of the template arguments can be deduced, theymay all be omitted; 
in this case, the empty template argument list <> itself may also be omitted. In contexts where deduction is done and 
fails, or in contexts where deduction is not done, if a template argument list is specified and it, along with anydefault 
template arguments, identifiesa single function template specialization, then the template-id is an lvalue for the function 
template specialization.[ Example: 

template <class X, class Y> X f(Y);
void g()
{


int i = f<int >(5.6); // Y is deduced to be double
int j = f (5.6); // ill-formed: X cannot be deduced
f<void >(f<int , bool >); // Y for outer f deduced to be


// int (*)(bool)
f<void >(f<int >); // ill-formed: f<int> does not denote a
// single function template specialization


} 

— end example ] 
4 [Note: An empty template argument list can be used to indicate that a given use refers to a specialization of a function 
templateeven whena normal (i.e., non-template) functionis visible thatwould otherwisebe used.Forexample: 

template <class T> int f(T); // #1
int f(int); // #2
int k = f(1); // uses #2
int l = f<>(1); // uses #1


— end note ] 
Draft 


329 Templates 14.8 Function template specializations 

5 Template arguments that are present shall be specified in the declaration order of their correspondingtemplate-parameters. The template argument list shall not specify more template-arguments than there are corresponding template-parameters.[ Example: 

template <class X, class Y, class Z> X f(Y,Z);
void g()
{


f<int,char*,double >("aa" ,3.0);
f<int,char*>("aa" ,3.0); // Z is deduced to be double
f<int >("aa" ,3.0); // Y is deduced to be char*, and


// Z is deduced to be double
f("aa" ,3.0); // error: X cannot be deduced
}


— end example ] 
6 Implicitconversions(clause 4)willbe performedonafunctionargumenttoconvertittothetypeofthecorresponding 
function parameter if the parameter type contains no template-parameters that participatein template argument deduction.[ Note: template parametersdo notparticipatein template argument deductionif they areexplicitly specified.For 
example, 

template <class T> void f(T); 

class Complex { 

// ... 

Complex ( double );
};


void g()
{
f< Complex >(1); // OK, means f<Complex>(Complex(1))
}


— end note ] 
7[Note: becausetheexplicittemplateargumentlistfollowsthe functiontemplatename,and becauseconversionmember 
function templatesand constructor member function templates are called withoutusinga function name, thereisnoway 
to provide an explicit template argument list for these function templates. — end note ] 

8 [Note: For simple function names, argument dependent lookup(3.4.2)applies even when the functionname is not 
visible within the scopeof the call. Thisis because the call still has the syntactic formofa function call(3.4.1). But 
when a function template with explicit template arguments is used, the call does not have the correct syntactic form 
unless there is a function template with that name visible at the point of the call. If no such name is visible, the call is 
not syntactically well-formed and argument-dependent lookup does not apply. If some such name is visible, argument 
dependent lookup applies andadditional function templates maybe foundin other namespaces.[ Example: 

namespace A {
struct B { };
template <int X> void f(B);


}
namespace C {


Draft 


14.8 Function template specializations Templates 330 
template <class T> void f(T t);
}
void g(A::B b) {


f <3 >( b); // ill-formed: not a function call 

A::f <3 >( b ); // well-formed 
C::f <3 >( b ); // ill-formed; argument dependent lookup
// applies only to unqualified names
using C::f;
f <3 >( b); // well-formed because C::f is visible; then
// A::f is found by argument dependent lookup
}


— end example ] — end note ] 
14.8.2 Template argument deduction [temp.deduct] 
1 Whenafunction template specializationisreferenced,allofthe templateargumentsmusthavevalues. Thevalues canbe 
explicitly specified or, in some cases, be deduced from the use or obtained from default template-arguments.[ Example: 

void f(Array<dcomplex>& cv, Array<int>& ci) 

{
sort (cv ); // call sort(Array<dcomplex>&)
sort (ci ); // call sort(Array<int>&)


} 

and 

void g(double d) 

{
int i = convert<int>(d); // call convert<int,double>(double)
int c = convert <char >(d); // call convert<char,double>(double)


} 

— end example ] 
2 When an explicit template argument list is specified, the template arguments must be compatible with the template 
parameterlistandmust resultinavalid functiontypeas describedbelow; otherwisetypedeductionfails. Specifically, 
thefollowingstepsare performedwhenevaluatinganexplicitly specified templateargumentlistwith respecttoagiven 
function template: 

— The specified template arguments must match the template parameters in kind (i.e., type, non-type, template), and 
there must notbe more arguments than there are parameters; otherwise type deductionfails. 
— Non-type arguments must match the types of the corresponding non-type template parameters, or must be convertible to the types of the corresponding non-type parameters as specified in 14.3.2, otherwise type deduction 
fails. 
— All references in the function type of the function template to the corresponding template parameters are replaced 
by the specified template argument values. If a substitution in a template parameter or in the function type 
of the function template results in an invalid type, type deductionfails. [Note: The equivalent substitution in 
Draft 


331 Templates 14.8 Function template specializations 

exception specifications is done only when the function is instantiated, at which point a program is ill-formed if 
the substitution resultsin aninvalid type.]Type deduction mayfail for the followingreasons: 

— Attempting to create an array with an element type that is void, a function type, a reference type, or an 
abstract classtype,or attemptingto createan arraywithasizethatis zeroornegative.[ Example: 
template <class T> int f(T[5]);
int I = f<int >(0);
int j = f<void >(0); // invalid array


— end example ] 
— Attemptingtouseatypethatisnotaclasstypeina qualified name.[ Example: 
template <class T> int f(typename T::B*);
int i = f<int >(0);


— end example ] 
— Attempting to use a type in a nested-name-specifier of a qualified-id when that type does not contain the 
specified member, or 
— the specified member is not a type where a type is required, or 
— the specified member is not a template where a template is required, or 
— the specified member is not a non-type where a non-type is required.
[Example:
template < int I > struct X { };
template < template < class T > class > struct Z { };
template <class T> void f(typename T::Y*){}
template <class T> void g(X<T::N>*){}
template <class T> void h(Z<T::template TT>*){}
struct A {};
struct B { int Y; };
struct C {


typedef int N;
};
struct D {


typedef int TT;
};


int main ()
{


// Deduction fails in eachof these cases:
f<A >(0); // A does not contain a member Y
f<B >(0); // The Y member of B is not a type
g<C >(0); // The N member of C is not a non-type
h<D >(0); // The TT member of D is not a template


} 

Draft 


14.8 Function template specializations Templates 332 
— end example ] 
— Attempting to create a pointer to reference type. 
— Attempting to create a reference to void. 
— Attempting to create “pointer to member of T” when T is nota class type.[ Example: 
template <class T> int f(int T::*);
int i = f<int >(0);


— end example ] 
— Attemptingtogiveaninvalidtypetoa non-type template parameter.[ Example: 
template < class T , T > struct S {};
template <class T> int f(S<T, T()>*);
struct X {};
int i0 = f<X>(0);


— end example ] 
— Attemptingtoperformaninvalidconversionineitheratemplateargumentexpression,oranexpressionused 
in the function declaration.[ Example: 
template <class T, T*> int f(int);
int i2 = f<int ,1>(0); // can’tconv 1 to int*


— end example ] 
— Attempting to create a function type in which a parameter has a type of void. 
Afterthis substitutionisperformed,the function parametertype adjustments describedin 8.3.5are performed.[ Example: 
Aparameter type of“void ()(const int, int[5])” becomes “void(*)(int,int*)”. — endexample ][Note: A 
top-level qualifierina function parameter declaration does notaffect the function typebut stillaffects the typeof the 
function parameter variable within the function. — end note ][Example: 

template <class T> void f(T t);
template <class X> void g(const X x);
template <class Z> void h(Z, Z*);


int main ()
{
// #1: function type is f(int), t is non const
f<int >(1);


// #2: function type is f(int), t is const
f< const int >(1);


// #3: function type is g(int), x is const
g<int >(1);


// #4: function type is g(int), x is const 

Draft 


333 Templates 14.8 Function template specializations 

g< const int >(1); 

// #5: function type is h(int, const int*)
h< const int >(1 ,0);
}


— end example ] 
4[Note: f<int>(1) and f<const int>(1) call distinct functions even though both of the functions called have the 
same function type. — end note ] 

5 The resulting substituted and adjusted function type is used asthe type of the function templatefor template argument 
deduction.Ifa templateargumenthasnotbeen deduced,itsdefault templateargument,ifany,isused.[ Example: 

template < class T , class U = double >
void f(T t =0, U u =0);


void g() 

{
f(1, ’c’); // f<int,char>(1,’c’)
f (1); // f<int,double>(1,0)
f (); // error: T cannot be deduced
f<int >(); // f<int,double>(0,0)
f<int ,char >(); // f<int,char>(0,0)


} 

— end example ] 
When all template arguments have been deduced or obtained from default template arguments, all uses of template 
parameters in non-deduced contexts are replaced with the corresponding deduced or default argument values. If the 
substitution resultsin aninvalid type, as described above, type deductionfails. 

6 Exceptas describedabove,theuseofaninvalidvalueshallnot causetype deductiontofail.[ Example: In the following 
example 1000isconvertedtosigned char andresultsinanimplementation-definedvalueas specifiedin(4.7).In other 
words,both templatesare consideredeventhough1000,whenconvertedtosigned char,results in an implementation-
defined value. 

template <int > int f(int);
template <signed char > int f(int);
int i1 = f<1>(0); // ambiguous
int i2 = f <1000 >(0); // ambiguous


— end example ] 
14.8.2.1 Deducing template arguments from a function call [temp.deduct.call] 
1Templateargumentdeductionisdoneby comparingeach function template parametertype(callitP)with the type of 
the corresponding argument of the call (call it A)as described below. 

2 If P is not a reference type: 

Draft 


14.8 Function template specializations Templates 334 
— If A isanarraytype,thepointertypeproducedbythe array-to-pointer standardconversion(4.2)isusedinplace 
of A for type deduction; otherwise, 
— If A isa functiontype,thepointertypeproducedbythe function-to-pointer standardconversion(4.3)isusedin 
place of A for type deduction; otherwise, 
— If A is a cv-qualified type, the top level cv-qualifiers of A’s type are ignored for type deduction. 
3 If P is a cv-qualified type, the top level cv-qualifiers of P’s type are ignored for type deduction. If P is a reference type, 
the type referred to by P is used for type deduction. 

4 In general, the deduction process attempts to find template argument values that will make the deduced A identical to A 
(after the type A is transformed as described above). However, there are three cases that allow a difference: 

— If the original P is a reference type, the deduced A (i.e., the type referred to by the reference) can be more cvqualified than A. 
— A can be another pointer or pointer to member type that can be converted to the deduced A via a qualification 
conversion(4.4). 
— If P is a class, and P has the form template-id, then A can be a derived class of the deduced A. Likewise, if P is a 
pointer to a class of the form template-id, A can be a pointer to a derived class pointed to by the deduced A. 
5 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one possible 
deduced A, the type deductionfails.[Note: if a template-parameter is not used in anyof the function parameters of a 
function template, or is used only in a non-deduced context, its corresponding template-argument cannot be deduced 
from a function call and the template-argument must be explicitly specified. — end note ] 

6 WhenPisa functiontype,pointerto functiontype,orpointertomember functiontype: 

— If the argument is an overload set containing one or more function templates, the parameter is treated as a non-
deduced context. 
— Iftheargumentisanoverloadset(not containing function templates), trialargument deductionis attemptedusing 
each of the members of the set. If deduction succeeds for only one of the overload set members, that member is 
used as the argument value for the deduction. If deduction succeeds for more than one member of the overload 
set the parameter is treated as a non-deduced context. 
7[Example: 

// Only one function of an overload set matches the call so the function
// parameter is a deduced context.


template <class T> int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g); // calls f(int (*)(int))


— end example ] 
8[Example: 

// Ambiguous deduction causes the second function parameter to be a
// non-deduced context.


template <class T> int f(T, T (*p)(T)); 

Draft 


335 Templates 14.8 Function template specializations 

int g(int);
char g(char);
int i = f(1, g); // calls f(int, int (*)(int))


— end example ] 
9[Example: 

// The overload set contains a template, causing the second function
// parameter to be a non-deduced context.


template <class T> int f(T, T (*p)(T));
char g(char);
template <class T> T g(T);
int i = f(1, g); // calls f(int, int (*)(int))


— end example ] 
14.8.2.2 Deducing template arguments taking the address of a function template [temp.deduct.funcaddr] 
1Templateargumentscanbe deducedfromthetype specifiedwhentakingtheaddressofanoverloaded function(13.4). 
The function template’s function type andthe specified type are used as the types of P and A, and the deduction is done 
as described in 14.8.2.5. 

14.8.2.3 Deducing conversion function template arguments [temp.deduct.conv] 
1 Template argument deduction is done by comparing the return type of the template conversion function (call itP)with 
the type thatis required asthe resultof the conversion (callit A)as described in 14.8.2.5. 

2 If A is not a reference type: 

— If P isanarraytype,thepointertypeproducedbythe array-to-pointer standardconversion(4.2)isusedinplace 
of P for type deduction; otherwise, 
— If P isa functiontype,thepointertypeproducedbythe function-to-pointer standardconversion(4.3)isusedin 
place of P for type deduction; otherwise, 
— If P is a cv-qualified type, the top level cv-qualifiers of P’s type are ignored for type deduction. 
3 If A is a cv-qualified type, the top level cv-qualifiers of A’s type are ignored for type deduction. If A is a reference type, 
the type referred to by A is used for type deduction. If P is a reference type, the type referred to by P is used for type 
deduction. 

4 In general, the deduction process attempts to find template argument values that will make the deduced A identical to A. 
However,therearetwo casesthatallowadifference: 

— If the original A is a reference type, A can be more cv-qualified than the deduced A (i.e., the type referred toby the 
reference) 
— The deduced A can be another pointer or pointer to member type that can be converted to A via a qualification 
conversion. 
Draft 


14.8 Function template specializations Templates 336 
5 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one possible 
deduced A, the type deductionfails. 

6 When the deduction process requires a qualification conversion for a pointer or pointer to member type as described 
above, the following process is used to determine the deduced template argument values: 

If A is a type 

cv1,0 “pointer to ...” cv1,n-1 “pointer to” cv1,nT1 

and P is a type 

cv2,0 “pointer to ...” cv2,n-1 “pointer to” cv2,nT2 

The cv-unqualified T1 and T2 are used as the types of A and P respectively for type deduction.[ Example: 

struct A { 

template < class T > operator T ***(); 

}; 

A a; 

const int * const * const * p1 = a; // T is deduced as int, not const int 

— end example ] 
14.8.2.4 Deducing template arguments during partial ordering [temp.deduct.partial] 
1 Template argument deduction is done by comparing certain types associated with the two function templates being 
compared. 

2 Two sets of types are used to determine the partial ordering. For each of the templates involved there is the original 
function type and the transformed function type.[ Note: the creation of the transformed type is described in 14.5.5.2. 

— end note ]The deduction process uses the transformed type as the argument template and the original type of the 
other template as the parameter template. This process is done twice for each type involved in the partial ordering 
comparison: once using the transformed template-1 as the argument template and template-2 as the parameter template 
and again using the transformed template-2 as the argument template and template-1 as the parameter template. 
3 The types used to determine the ordering depend on the context in which the partial ordering is done: 

— In the context of a function call, the function parameter types are used. 
— In the context of a call to a conversion operator, the return types of the conversion function templates are used. 
— In other contexts(14.5.5.2)the function template’s function typeis used. 
4 Each type from the parameter template and thecorresponding type from the argument template are used asthe typesof 
P and A. 
5 Before the partial orderingis done, certain transformations are performed on the types used for partial ordering: 

— If P is a reference type, P is replaced by the type referredto. 
— If A is a reference type, A is replaced by the type referredto. 
Draft 


337 Templates 14.8 Function template specializations 

6 If both P and A were reference types (before being replaced with the type referred to above), determine which of the 
two types (if any) is more cv-qualified than the other; otherwise the types are considered to be equally cv-qualified for 
partial ordering purposes. The result of this determination will be used below. 

7 Remove anytop-level cv-qualifiers: 

— If P is a cv-qualified type, P is replaced by the cv-unqualified version of P. 
— If A is a cv-qualified type, A is replaced by the cv-unqualified version of A. 
8 Using the resulting types P and A the deduction is then done as described in 14.8.2.5. If deduction succeeds for a given 
type, the type from the argument template is considered to be at least as specialized as the type from the parameter 
template. 

9 If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transformations above) 
and if the type from the argument template is more cv-qualified than the type from the parameter template (as described 
above) that type is considered to be more specialized than the other. If neither type is more cv-qualified than the other 
then neither type is more specialized than the other. 

10 If for each type being considered a given template is at least as specialized for all types and more specialized for some 
set of types and the other template is not more specialized for anytypes or is not at least as specialized for anytypes, 
thenthegiven templateis more specializedthanthe othertemplate. Otherwise, neither templateis more specializedthan 
the other. 

11 In most cases, all template parameters must have values in order for deductionto succeed, but for partial ordering 
purposes a template parameter may remain without a value provided it is not used in the types being used for partial 
ordering.[ Note: a template parameter usedin a non-deduced context is considered used. — end note ][Example: 

template <class T> T f(int); // #1
template <class T, class U> T f(U); // #2
void g() {


f<int >(1); // Calls #1
}


— end example ] 
14.8.2.5 Deducing template arguments from a type [temp.deduct.type] 
1 Template arguments canbe deducedin several different contexts,butin each casea type thatis specifiedin termsof 
template parameters (call it P)is compared with an actual type (call it A), and an attempt is made to find template 
argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) 
that will make P, after substitution of the deduced values (call it the deduced A), compatible with A. 

2 In some cases,the deductionisdoneusingasinglesetoftypes P and A,in other cases, therewillbeasetof corresponding 
types P and A.Typededuction is done independently for each P/A pair, and the deduced template argument values are 
then combined. If type deduction cannot be done for any P/A pair, or if for anypair the deduction leads to more than one 
possible set of deduced values, or if different pairs yield different deduced values, or if anytemplate argument remains 
neither deduced norexplicitly specified, template argument deductionfails. 

3 Agiven typeP can be composed from a number of other types, templates, and non-type values: 

Draft 


14.8 Function template specializations Templates 338 
— Afunction type includesthe typesof eachof the function parameters and the returntype. 
— Apointerto membertypeincludesthetypeofthe class object pointedtoandthetypeofthe member pointedto. 
— Atype thatisa specializationofa class template (e.g.,A<int>)includes the types, templates, and non-typevalues 
referenced by the template argument list of the specialization. 
— An array type includes the array element type and the value of the array bound. 
4 In most cases, the types, templates, and non-type values that are used to compose P participate in template argument 
deduction. That is, theymay be used to determine the value of a template argument, and the value so determinedmust 
be consistent with the values determined elsewhere. In certain contexts, however, the value does not participate in type 
deduction,but instead uses thevaluesof template arguments that were eitherdeduced elsewhere orexplicitly specified. 
Ifatemplate parameterisusedonlyin non-deduced contextsandisnotexplicitly specified, templateargument deduction 
fails. 

5 The non-deduced contexts are: 

— The nested-name-specifier of a type that was specified using a qualified-id. 
— Anon-type template argument or an array bound that is an expression that references a template parameter. 
— Atemplate parameter used in the parameter type of a function parameter that has a default argument that is being 
used in the call for which argument deduction is being done. 
— Afunction parameter for which argument deduction cannot be done because the associated function argument is 
a function, ora setofoverloaded functions(13.4), and one or moreof the following apply: 
— more than one function matches the function parameter type (resultingin an ambiguousdeduction), or 
— no function matches the function parameter type, or 
— the set of functions supplied as an argument contains one or more function templates. 
— An array bound that is an expression that references a template-parameter. 
6 Whenatype nameis specifiedinawaythat includesa non-deduced context,allofthetypesthatcomprisethattype name 
are also non-deduced. However,acompound type can include both deduced andnon-deduced types.[ Example: Ifatype 
is specified as A<T>::B<T2>, both T and T2 are non-deduced. Likewise, if a type is specified as A<I+J>::X<T>, I, J, 
and T are non-deduced. If a type is specified as void f(typename A<T>::B, A<T>), the T in A<T>::B is non-deduced 
but theT in A<T> is deduced. — end example ] 

7 [Example: Here is an example in which different parameter/argument pairs produce inconsistent template argument 
deductions: 

template <class T> void f(T x, T y) { /* ... * / } 

struct A { /* ... * / }; 

struct B : A { /* ... * / }; 

int g(A a, B b) 

{ 

f(a,b); // error: T could be A or B
f(b,a); // error: T could be A or B
f(a,a); // OK: T is A
f(b,b); // OK: T is B


Draft 


339 Templates 14.8 Function template specializations 

} 

Here is an example where two template arguments are deduced from a single function parameter/argument pair. This 
can lead to conflicts that cause type deduction tofail: 

template <class T, class U> void f( T (*)( T, U, U ) ); 

int g1 ( int , float , float );
char g2 ( int , float , float );
int g3 ( int , char , float );


void r() 

{
f(g1 ); // OK: T is int and U is float
f(g2 ); // error: T could be char or int
f(g3 ); // error: U could be char or float


} 

Here is an example where a qualification conversion applies between the argument type on the function call and the 
deduced template argumenttype: 

template <class T> void f(const T*) {}
int *p;
void s()
{


f(p); // f(const int*)
}


Hereisanexamplewherethetemplateargumentisusedto instantiateaderivedclasstypeofthe corresponding function 
parameter type: 

template < class T > struct B { };
template <class T> struct D : public B<T> {};
struct D2 : public B<int > {};
template <class T> void f(B<T>&){}
void t()
{


D<int > d;
D2 d2;
f(d); // calls f(B<int>&)
f(d2 ); // calls f(B<int>&)


} 

— end example ] 
Atemplate type argumentT, a template template argument TT or a template non-type argument i can be deduced if P 
and A have one of the following forms: 

T
cv-list T
T*


Draft 


14.8 Function template specializations Templates 340 
T&
T[integer-constant ]
template-name <T> (where template-name refers to a class template )
type (T)
T()
T(T)
T type ::*
type T ::*
T T::*
T( type ::*)()
type (T ::*)()
type ( type ::*)( T)
type (T ::*)( T)
T( type ::*)( T)
T (T::*)()
T (T::*)(T)
type [i]
template-name <i> (where template-name refers to a class template )
TT <T>
TT <i>
TT <>


where (T) represents argument lists where at least one argument type contains a T, and () represents argument lists 
where no parameter containsa T. Similarly, <T> represents template argument lists where at leastone argument contains 
a T, <i> represents template argument lists where at least one argument contains an i and <> represents template 
argument lists where no argument contains a T or an i. 

9 These forms can be used in the same way as T isfor further compositionoftypes.[ Example: 

X<int> (*)(char[6]) 

is of the form 

template-name <T > (*)( type [i]) 

which is a variant of 

type (*)( T) 

where type is X<int> and T is char[6]. — end example ] 
10 Template arguments cannot be deduced from function arguments involving constructs other than the ones specified 
above. 
11 Atemplate type argument cannot be deduced from the type of a non-typetemplate-argument. 

12 [Example: 

template <class T, T i> void f(double a[10][i]);
int v [10][20];
f(v); // error: argument for template-parameter T cannot be deduced


Draft 


341 Templates 14.8 Function template specializations 

— end example ] 
13 [Note: except for reference and pointer types, a major array bound is not part of a function parameter type and cannot 
be deduced from an argument: 

template <int i> void f1(int a[10][i]);
template <int i> void f2(int a[i][20]);
template <int i> void f3(int (&a)[i][20]);


void g() 

{
int v [10][20];
f1(v); // OK: i deduced to be 20
f1 <20>(v); // OK
f2(v); // error: cannot deduce template-argument i
f2 <10>(v); // OK
f3(v); // OK: i deduced to be 10


} 

14 If,inthe declarationofa function templatewitha non-type template parameter,the non-type template parameterisused 
in anexpressionin the function parameter list, theexpressionisa non-deduced context.[ Example: 

template < int i > class A { /* ... * / };
template <int i> void g(A<i+1>);
template <int i> void f(A<i>, A<i+1>);
void k() {


A<1> a1;
A<2> a2;
g(a1 ); // error: deduction fails for expression i+1
g <0 >( a1 ); // OK
f(a1, a2); // OK


} 

— endexample ] — end note ][Note: template parameters do not participate in template argument deduction if theyare 
used onlyin non-deduced contexts.Forexample, 
template <int i, typename T>
T deduce(typename A<T>::X x, // T is not deduced here
T t, // butT is deduced here


typename B<i>::Y y); // i is not deduced here
A<int > a;
B<77> b;


int x = deduce <77>(a.xm, 62, y.ym);
// T is deduced to be int, a.xm must be convertible to
// A<int>::X
// i is explicitly specified to be 77, y.ym must be convertible
// to B<77>::Y


— end note ] 
Draft 


14.8 Function template specializations Templates 342 
15 If,inthedeclarationofafunction templatewithanon-type template-parameter, the non-type template-parameter is used 
in an expression in the function parameter-list and, if the corresponding template-argument is deduced, the template-
argument type shall match the type of the template-parameter exactly, except that a template-argument deduced from 
an array bound maybeof anyintegral type.138)[Example: 

template < int i > class A { /* ... * / };
template <short s> void f(A<s>);
void k1() {


A<1> a; 
f(a ); // error: deduction fails for conversion from int to short 
f <1 >( a ); // OK 

} 

template < const short cs > class B { };
template <short s> void h(B<s>);
void k2() {


B<1> b;
g(b ); // OK: cv-qualifiers are ignored on template parameter types
}


— end example ] 
16 Atemplate-argument can be deduced from a function, pointer to function, or pointer to member function type. 
[Example: 

template <class T> void f(void(*)(T,int));
template <class T> void foo(T,int);
void g(int,int);
void g(char ,int);


void h(int,int,int);
void h(char ,int);
int m()
{


f(&g); // error: ambiguous
f(&h); // OK: void h(char,int) is a unique match
f(& foo ); // error: type deduction fails because foo is a template


} 

— end example ] 
17 Atemplatetype-parameter cannotbe deduced from the typeofa function default argument.[ Example: 
template <class T> void f(T = 5, T = 7);
void g()
{


f (1); // OK: call f<int>(1,7)
f (); // error: cannot deduce T


138) Although the template-argument corresponding to a template-parameter of type bool may be deduced from an array bound, the resulting value 
will always be true because the array bound will be non-zero. 

Draft 


343 Templates 14.8 Function template specializations 

f<int >(); // OK: call f<int>(5,7)
}


— end example ] 
18 The template-argument corresponding to a template template-parameter is deduced from the type of the template-
argument ofa class template specialization usedin the argument listofa function call.[Example: 

template < template < class T > class X > struct A { }; 

template <template <class T> class X> void f(A<X>) { } 

template < class T > struct B { }; 

A<B> ab; 

f(ab ); // calls f(A<B>) 

— end example ] 
19 [Note: a default template-argument cannotbe specifiedina function template declarationor definition; thereforedefault 
template-arguments cannot be used to influence template argument deduction. — end note ] 

14.8.3 Overload resolution [temp.over] 
1 Afunction template can be overloaded either by (non-template) functions of its name or by (other) function templates 
of the same name. When a call to that name is written (explicitly, or implicitly using the operator notation), template 
argument deduction(14.8.2)and checkingof anyexplicit template arguments(14.3)are performed for each function 
template to find the template argument values (if any) that can be used with that function template to instantiate a 
function template specializationthatcanbeinvokedwiththecallarguments.Foreach function template,iftheargument 
deduction and checking succeeds, the template-arguments (deduced and/or explicit) are used to instantiate a single 
function template specialization which is added to the candidate functions set to be used in overload resolution. If, for 
agiven functiontemplate,argumentdeductionfails,nosuch functionis addedtothesetof candidate functionsforthat 
template. The complete set of candidate functions includes all the function templates instantiated in this way and all 
of the non-template overloaded functions of the same name. The function template specializations are treated like any 
other functions in the remainder of overload resolution, except as explicitly noted in 13.3.3.139) 

[Example: 

template <class T> T max(T a, T b) { return a>b?a:b; } 

void f(int a, int b, char c, char d) 

{
int m1 = max(a,b); // max(int a, int b)
char m2 = max(c,d); // max(char a, char b)
int m3 = max(a,c); // error: cannotgenerate max(int,char)


} 

2 Adding the non-template function 

139) The parameters of function template specializations contain no template parameter types. The set of conversions allowed on deduced arguments 

is limited, because the argument deduction process produces function templates with parameters that either match the call arguments exactly or differ 

only in ways that can be bridged by the allowed limited conversions. Non-deduced arguments allow the full range of conversions. Note also that 

13.3.3 specifies that a non-template function will be given preference over a template specialization if the two functions are otherwise equally good 
candidates for an overload match. 
Draft 


14.8 Function template specializations Templates 344 
int max(int,int); 

totheexampleabovewould resolvethethirdcall,byprovidingafunctionthatcouldbecalledfor max(a,c) after using 
the standard conversion of char to int for c. 

3 Here is an example involving conversions on a function argument involved in template-argument deduction: 

template < class T > struct B { /* ... * / };
template <class T> struct D : public B<T> { /* ... * / };
template <class T> void f(B<T>&);


void g(B<int>& bi, D<int>& di) 

{
f(bi ); // f(bi)
f(di ); // f((B<int>&)di)


} 

4 Here is an example involving conversions on a function argument not involved in template-parameter deduction: 

template <class T> void f(T*,int); // #1
template <class T> void f(T,char); // #2


void h(int* pi, int i, char c) 

{
f(pi ,i ); // #1: f<int>(pi,i)
f(pi ,c ); // #2: f<int*>(pi,c)


f(i,c); // #2: f<int>(i,c);
f(i,i); // #2: f<int>(i,char(i))
}


— end example ] 
5 Only the signature of a function template specialization is needed to enter the specialization in a set of candidate functions. Thereforeonlythefunction template declarationis neededto resolveacallfor whicha template specializationis 
a candidate.[Example: 

template <class T> void f(T); // declaration 

void g()
{
f(" Annemarie " ); // call of f<const char*>
}


6 The call of f is well-formed even if the template f is only declaredand not defined at the point of the call. The program 
will be ill-formed unless a specialization for f<const char*>, either implicitly orexplicitly generated,ispresentin 
some translation unit. — end example ] 

Draft 


Chapter 15 Exception handling [except]


1 Exception handling provides a way of transferring control and information from a point in the execution of a program 
toanexception handler associatedwithapointpreviouslypassedbytheexecution.Ahandlerwillbeinvokedonlybya 
throw-expression invoked in code executed in the handler’s try block or in functions called from the handler’s try block . 

try-block:
try compound-statement handler-seq


function-try-block:
try ctor-initializeropt function-body handler-seq


handler-seq:
handler handler-seqopt


handler:
catch ( exception-declaration ) compound-statement


exception-declaration:
type-specifier-seq declarator
type-specifier-seq abstract-declarator
type-specifier-seq


... 

throw-expression:
throw assignment-expressionopt


2Atry-block is a statement (clause6).A throw-expression is of type void. Code that executes a throw-expression is said 
to “throw anexception;” code that subsequently gets controlis calleda “handler.”[ Note: within this clause “try block” 
is taken to mean both try-block and function-try-block. — end note ] 

3 Agoto or switch statement shallnotbeusedto transfer controlintoatry blockorintoa handler.[ Example: 

void f() {
goto l1 ; // Ill-formed
goto l2 ; // Ill-formed
try {


goto l1 ; // OK
goto l2 ; // Ill-formed
l1: ;


} catch (...) {
l2: ;
goto l1 ; // Ill-formed
goto l2 ; // OK


} 


15.1 Throwing an exception Exception handling 346 
} 

— end example ]Agoto, break, return, or continue statement can be used to transfer control out of a try block or 
handler. Whenthis happens,eachvariable declaredinthetry blockwillbe destroyedinthe contextthat directly contains 
its declaration.[ Example: 
lab: try {
T1 t1;
try {


T2 t2;
if ( condition )
goto lab ;
} catch (...) { /* handler 2 * / }
} catch (...) { /* handler 1 * / }


Here, executing goto lab; will destroy first t2, then t1, assuming the condition does not declare a variable. Any 
exception raised while destroying t2 will result in executing handler2;any exception raised while destroying t1 will 
result in executing handler1. — end example ] 

4Afunction-try-block associates a handler-seq with the ctor-initializer, if present, and the function-body. An exception 
thrown during the execution of the initializer expressions in the ctor-initializer or duringthe execution of the function-
body transfers control to a handler in a function-try-block in the same way as an exception thrown during the execution 
of a try-block transfers control to other handlers.[ Example: 

int f(int); 

class C {
int i;
double d;


public :
C(int , double);
};


C::C(int ii , double id)
try
: i(f(ii)), d(id)
{


// constructor function body 

}
catch (...)
{


// handles exceptions thrown from the ctor-initializer
// and from the constructor function body


} 

— end example ] 
15.1 Throwing an exception [except.throw] 
1 Throwing an exception transfers control to a handler. An object is passed and the type of that object determines which 
handlers can catch it.[ Example: 

Draft 


347 Exception handling 15.1 Throwing an exception 

throw "Help!"; 

can be caught by a handler of const char* type: 

try { 

// ... 

}
catch(const char* p) {


// handle character string exceptions here 

} 

and 

class Overflow { 

// ... 

public :
Overflow(char ,double ,double);
};


void f(double x)
{


// ... 

throw Overflow(’+’,x,3.45e107);
}


can be caught by a handler for exceptions of type Overflow 

try { 

// ... 

f (1.2); 

// ... 

}
catch ( Overflow & oo ) {
// handle exceptions of type Overflow here
}


— end example ] 
2 Whenanexceptionisthrown, controlis transferredtothe nearest handlerwitha matchingtype(15.3); “nearest” means 
the handler for which the compound-statement, ctor-initializer, or function-body following the try keyword was most 
recently enteredbythe threadof controlandnotyetexited. 

3 Athrow-expression initializes a temporary object, called the exception object, the type of which is determined by removing anytop-level cv-qualifiers from the static type of the operand of throw and adjusting the type from “array of T” 
or “function returning T” to “pointer to T” or “pointer to function returning T”, respectively.[Note: the temporary object 
created fora throw-expression thatisastring literalisneveroftype char* or wchar_t*;that is, the special conversions 
for string literals from the types “array of const char” and“array of const wchar_t”to the types “pointer to char” 
and “pointer to wchar_t”, respectively(4.2), are never applied toa throw-expression. — end note ]The temporary is 
an lvalue and is used to initialize the variable named in the matching handler (15.3). The type ofthe throw-expression 
shall not be an incomplete type, or a pointer to an incomplete type other than (possibly cv-qualified) void. Except for 

Draft 


15.2 Constructors and destructors Exception handling 348 
these restrictions and the restrictions on type matching mentioned in 15.3, the operand of throw is treated exactly as a 
function argumentina call(5.2.2)or the operandofa return statement. 

4 Thememoryforthe temporarycopyoftheexceptionbeingthrownis allocatedinan unspecifiedway,exceptasnotedin 

3.7.3.1. The temporary persists as long as there is a handler being executed for that exception. In particular, if a handler 
exits by executing a throw; statement, that passes control to another handler for the same exception, so the temporary 
remains. When the last remaining active handler for theexceptionexitsby any means other than throw; the temporary 
object is destroyed and the implementation may deallocate the memory for the temporary object; anysuch deallocation 
is done in an unspecified way. The destruction occurs immediately after the destruction of the object declared in the 
exception-declaration in the handler. 
5 If the use of the temporary object can be eliminated without changing the meaning of the program except for the 
executionof constructorsanddestructors associated withthe useofthe temporary object(12.2),thentheexceptionin 
the handler can be initialized directly with the argument of the throw expression. When the thrown object is a class 
object,andthecopyconstructorusedto initializethe temporarycopyisnot accessible,the programis ill-formed(even 
when the temporary object could otherwise be eliminated). Similarly, if the destructor for that object is not accessible, 
the program is ill-formed (even when the temporary object could otherwise be eliminated). 

6 Anexceptionis considered caught whena handler for thatexception becomes active(15.3).[Note: an exception can 
have active handlers and still be considered uncaught if it is rethrown. — end note ] 

7 A throw-expression with no operand rethrows the currently handled exception(15.3). The exception is reactivated 
withtheexistingtemporary; nonew temporaryexception objectis created. Theexceptionisno longer consideredto 
be caught; therefore, the value of std::uncaught_exception() will again be true.[Example: code that must be 
executed because of an exception yet cannot completely handle the exception can be written like this: 

try { 

// ... 

} 

catch (...) { // catchall exceptions
// respond (partially) to exception
throw ; // pass the exception to some


// other handler 

} 

— end example ] 
8 If no exception is presently being handled, executing a throw-expression with no operand calls std::terminate() 
(15.5.1). 

15.2 Constructors and destructors [except.ctor] 
1 As control passes from a throw-expression to a handler, destructors are invoked for all automatic objects constructed 
since the try block was entered. The automatic objects are destroyed in the reverse order of the completion of their 
construction. 

2 Anobjectthatis partiallyconstructedor partially destroyedwillhave destructorsexecutedforallofitsfully constructed 
subobjects,thatis,for subobjectsforwhichthe constructorhas completedexecutionandthe destructorhasnotyetbegun 
execution. Should a constructor for an element of an automatic array throw an exception, only the constructed elements 
of that array will be destroyed. If the object or array was allocated in a new-expression, the matching deallocation 
function(3.7.3.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object. 

Draft 


349 Exception handling 15.3 Handling an exception 

3 The processof calling destructorsfor automatic objects constructedonthepathfromatry blocktoa throw-expression is 
called “stackunwinding.”[ Note: If a destructor called during stack unwinding exits with an exception, std::terminate is called(15.5.1).So destructors should generallycatchexceptionsandnotletthem propagateoutofthe destructor. 

— end note ] 
15.3 Handling an exception [except.handle] 
1 The exception-declaration in a handler describes the type(s) of exceptions that can cause that handler to be entered. 
The exception-declaration shall not denote an incomplete type. The exception-declaration shall not denote a pointer or 
reference to an incomplete type, other than void*, const void*, volatile void*, or const volatile void*.Types 
shall not be defined in an exception-declaration. 

2 Ahandler of type “array ofT” or “function returning T” is adjusted to be of type “pointer to T” or “pointer to function 
returning T”, respectively. 

3 Ahandler is a match for an exception object of type E if 

— The handler is of type cv T or cv T& and E and T are the same type (ignoring the top-level cv-qualifiers), or 
— the handler is of type cv T or cv T& and T is an unambiguous public base class of E, or 
— the handler is of type cv1 T* cv2 and E is a pointer type that can be converted to the type of the handler by either 
or both of 
— a standard pointer conversion(4.10)not involving conversions to pointers to private or protected or ambiguous classes 
— a qualification conversion 
[Note: a throw-expression which is an integral constant expression of integer type that evaluates to zero does not 
matchahandlerofpointertype;thatis,thenullpointer constantconversions(4.10,4.11)donotapply. — end 
note ] 

[Example: 

class Matherr { /* ... * / virtual vf (); };
class Overflow : public Matherr { /* ... * / };
class Underflow : public Matherr { /* ... * / };
class Zerodivide : public Matherr { /* ... * / };


void f()
{
try {
g ();
}


catch ( Overflow oo ) { 

// ... 

}
catch ( Matherr mm ) {


// ... 

}
}


Draft 


15.3 Handling an exception Exception handling 350 
Here, the Overflow handler will catch exceptions of type Overflow and the Matherr handler will catch exceptions of type Matherr and of all types publicly derived from Matherr including exceptions of type Underflow 
and Zerodivide. — end example ] 
4 The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that can 
never be executed, for example by placing a handler for a derived class after a handler for a corresponding base 
class. 
5 A ... in a handler’s exception-declaration functions similarly to ... in a function parameter declaration; it 
specifies a match for any exception. If present, a ... handler shall be the last handler for its try block. 
6 If no match is found among the handlers for a try block, the search for a matching handler continues in a dynamically surrounding try block. 
7 Ahandler is considered active when initialization is complete for the formal parameter (if any)of the catch clause. 
[Note: the stack will have been unwound at that point. — end note ]Also, an implicit handler is considered active 
when std::terminate() or std::unexpected() is entered due to a throw. Ahandler is no longer considered 
active when the catch clause exits or when std::unexpected() exits after being entered due to a throw. 
8 The exception with the most recently activated handler that is still active is called the currently handled exception. 
9 If no matching handler is found in a program, the function std::terminate() is called; whether or not the stack 
is unwound before this call to std::terminate() is implementation-defined(15.5.1). 
10 Referring to anynon-static member or base class of an object in the handler for a function-try-block of a constructor or destructor for that object results in undefined behavior. 
11 The fully constructed base classes and members of an object shall be destroyed before entering the handler of a 
function-try-block of a constructor or destructor for that object. 
12 The scope and lifetime of the parameters of a function or constructor extend into the handlers of a function-tryblock. 
13 Exceptions thrown in destructors of objects with static storage duration or in constructors of namespace-scope 
objects are not caught by a function-try-block on main(). 
14 If a return statement appears in a handler of the function-try-block of a constructor, the program is ill-formed. 
15 The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block of a 
constructor or destructor. Otherwise, a function returns when control reaches the end of a handler for the function-
try-block (6.6.3). Flowing offthe end of a function-try-block is equivalent to a return with no value; this results 
in undefined behavior in a value-returning function (6.6.3). 
16 When the exception-declaration specifies a class type, a copy constructor is used to initialize either the object 
declared in the exception-declaration or, if the exception-declaration does not specify a name, a temporary object 
of that type. The object shall not have an abstract class type. The object is destroyed when the handler exits, after 
the destruction of anyautomatic objects initialized within the handler. The copyconstructor and destructor shall 
be accessible in the context of the handler. If the copyconstructor and destructor are implicitly declared(12.8), 
such a use in the handler causes these functions to be implicitly defined; otherwise, the program shall provide a 
definition for these functions. 
17 If the use of a temporary object can be eliminated without changing the meaning of the program except for 
execution of constructors and destructors associated with the use of the temporary object, then the optional name 
Draft 


351 Exception handling 15.4 Exception specifications 

can be bound directly to the temporaryobject specified in a throw-expression causing the handler to be executed. 
Thecopyconstructorand destructorassociatedwiththeobjectshallbe accessibleevenwhenthe temporaryobject 
is eliminated. 

18 When the handler declares a non-constant object, anychanges to that object will not affect the temporary object 
thatwas initializedbyexecutionofthe throw-expression. When the handler declaresa reference toanon-constant 
object, any changes to the referenced object are changes to the temporary object initialized when the throw-
expression was executed and will have effect should that object be rethrown. 

15.4 Exception specifications [except.spec] 
1 A function declaration lists exceptions that its function might directly or indirectly throw by using an exception-
specification as a suffix of its declarator. 
exception-specification: 
throw ( type-id-listopt ) 

type-id-list:
type-id
type-id-list , type-id


2 An exception-specification shall appear only on a function declarator for a function type, pointer to function type, 
reference to function type, or pointer to member function type that is the top-level type of a declaration or definition, 
or on such a type appearing as a parameter or return type in a function declarator. An exception-specification shall not 
appearina typedef declaration.[ Example: 

void f() throw(int); // OK
void (* fp )() throw ( int ); // OK
void g( void pfa () throw ( int )); // OK
typedef int (* pf )() throw ( int ); // ill-formed


— endexample ]Atype denoted in anexception-specification shallnotdenotean incompletetype.Atype denotedinan 
exception-specification shall not denote a pointer or reference to an incomplete type, other than void*, const void*, 
volatile void*, or const volatile void*. 
3 If anydeclaration of a function has an exception-specification, all declarations, including the definition and an explicit 
specialization, of that function shall have an exception-specification with the same set of type-ids.Ifanydeclarationofa 
pointer to function, reference to function, or pointer to member function has an exception-specification, all occurrences 
of that declaration shall havean exception-specificationwith the same set of type-ids. In anexplicit instantiation directive 
an exception-specification may be specified,but is not required. If an exception-specification is specified in an explicit 
instantiation directive, it shall havethe same set of type-idsas other declarationsof that function.Adiagnosticis required 
only if the sets of type-ids are different within a single translation unit. 

4 If a virtual function has an exception-specification, all declarations, including the definition, of anyfunction that overridesthat virtual functioninanyderivedclassshallonlyallowexceptionsthatareallowedbythe exception-specification 
of the base class virtual function.[ Example: 

struct B {
virtual void f () throw ( int , double );
virtual void g ();


}; 

Draft 


15.4 Exception specifications Exception handling 352 
struct D: B {
void f (); // ill-formed
void g () throw ( int ); // OK


}; 

The declaration of D::f is ill-formed because it allows all exceptions, whereas B::f allows only int and double. 

— end example ]A similar restriction applies to assignment to and initialization of pointers to functions, pointers to 
member functions, and references to functions: the target entity shall allow at least theexceptions allowedby the source 
valuein the assignment orinitialization.[Example: 
class A { /* ... * / };
void (* pf1 )(); // no exception specification
void (*pf2)() throw(A);


void f() 

{
pf1 = pf2; // OK: pf1 is less restrictive
pf2 = pf1; // error: pf2 is more restrictive


} 

— end example ] 
5 Insuch an assignment or initialization, exception-specificationson return types and parameter types shall matchexactly. 
In other assignments or initializations, exception-specifications shall match exactly. 

6 Types shall not be defined inexception-specifications. 

7 An exception-specification can include the same type more than once and can include classes that are related by inheritance, even though doing so is redundant. An exception-specification can also include the class std::bad_exception 
(18.6.2.1). 

8 Afunction is said toallow an exception of type E if its exception-specification contains a type T for which a handler of 
type T wouldbea match(15.3)for anexceptionof typeE. 

9 Whenever anexceptionis thrown and the search fora handler(15.3)encounters the outermost blockofa function with 
an exception-specification, the function std::unexpected() is called(15.5.2)if theexception-specification does not 
allow theexception.[ Example: 

class X {};
class Y {};
class Z: public X { };
class W {};


void f() throw (X, Y) 

{
int n =0;
if (n) throw X(); // OK
if (n) throw Z(); // also OK
throw W (); // will call std::unexpected()


} 

Draft 


353 Exception handling 15.5 Special functions 

— end example ] 
10 The function std::unexpected() may throw an exception that will satisfy the exception-specification for which it 
was invoked, and in this case the search for another handler will continue at the call of the function with this exception-
specification (see 15.5.2), or it may call std::terminate(). 

11 An implementation shall not reject an expression merely because when executed it throws or might throw an exception 
that the containing functiondoes not allow.[ Example: 

extern void f() throw(X, Y); 

void g() throw(X)
{
f (); // OK
}


the call to f is well-formed even though when called, f might throw exception Y that g does not allow. — end example ] 

12 A function with no exception-specification allows all exceptions. A function with an empty exception-specification, 
throw(), does not allow anyexceptions. 

13 An exception-specification is not considered part of a function’s type. 

14 An implicitly declared special member function (clause 12)shall haveanexception-specification. If f is an implicitly declared default constructor, copyconstructor, destructor, or copyassignment operator, its implicit exception-specification 
specifies the type-id T if and only if T is allowed by the exception-specification of a function directly invoked by f’s 
implicit definition; f shallallowallexceptionsifanyfunctionit directlyinvokesallowsallexceptions,and f shall allow 
noexceptionsifevery functionit directlyinvokes allows noexceptions.[ Example: 

struct A {
A();
A( const A &) throw ();
~A() throw(X);


}; 

struct B {
B() throw ();
B( const B &) throw ();
~B() throw(Y);


}; 

struct D : public A , public B {
// Implicit declaration ofD::D();
// Implicit declaration ofD::D(const D&) throw();
// Implicit declaration ofD::D() throw(X,Y);


}; 

Furthermore, if A::~A() or B::~B() were virtual, D::~D() would not be as restrictive as that of A::~A, and the 
programwouldbe ill-formed sincea function thatoverridesa virtual function froma base class shallhave an exception-
specification at least as restrictive as thatin the base class. — end example ] 

15.5 Special functions [except.special] 
1 Theexception handlingmechanism reliesontwo functions, std::terminate() and std::unexpected(), for coping 

Draft 


15.5 Special functions Exception handling 354 
with errors related to the exception handling mechanism itself(18.6). 

15.5.1 The std::terminate() function [except.terminate] 
1 In the following situations exception handling must be abandoned for less subtle error handling techniques: 

— whentheexception handling mechanism, after completingevaluationoftheexpressiontobethrownbut before 
the exception is caught(15.1), calls a user function that exits via an uncaught exception,140) 
— when theexception handling mechanism cannot finda handler fora thrownexception(15.3), or 
— when the destructionof anobject during stack unwinding(15.2)exits using anexception, or 
— when constructionor destructionofa non-localobjectwith static storagedurationexitsusinganexception(3.6.2), 
or 
— when execution of a function registered with std::atexit exits using anexception(18.3), or 
— when a throw-expression with no operand attempts to rethrow an exception and no exception is being handled 
(15.1), or 
— when std::unexpected throws an exception which is not allowed by the previously violated exception-specification, and std::bad_exception is not included in that exception-specification (15.5.2), or 
— when the implementation’s default unexpectedexception handleris called(18.6.2.2) 
2 In such cases, std::terminate() is called(18.6.3). In the situation where no matching handler is found, it is 
implementation-defined whether or not the stack is unwound before std::terminate() is called. In all other situations, the stack shall not be unwound before std::terminate() is called. An implementation is not permitted to 
finish stack unwinding prematurely based on a determination that the unwind process will eventually cause a call to 
std::terminate(). 

15.5.2 The std::unexpected() function [except.unexpected] 
1 If a function with an exception-specification throws an exception that is not listed in the exception-specification, the 
function std::unexpected() is called(18.6.2)immediately after completing the stack unwinding for the former function 

2 The std::unexpected() function shall not return, but it can throw (or re-throw) an exception. If it throws a new 
exception which is allowed by the exception specification which previously was violated, then the search for another 
handler will continue at the call of the function whose exception specification was violated. If it throws or rethrows an 
exception that the exception-specification does not allow then the followinghappens: If the exception-specification does 
not include the class std::bad_exception (18.6.2.1)then the functionstd::terminate() is called, otherwise the 
thrownexceptionis replacedbyan implementation-definedobjectofthetype std::bad_exception and the search for 
another handler will continue at the call of the function whose exception-specification was violated. 

3 Thus, an exception-specification guarantees that onlythe listed exceptions will be thrown. If the exception-specification 
includes the type std::bad_exception then any exception not on thelist maybe replacedby std::bad_exception 

140) For example, if the object being thrown is of a class with a copyconstructor,std::terminate() will be called if that copyconstructor exits 
with an exception during a throw. 

Draft 


355 Exception handling 15.6 Exceptions and access 

within the function std::unexpected(). 

15.5.3 The std::uncaught_exception() function [except.uncaught] 
1 The function std::uncaught_exception() returns true after completing evaluation of the object to be thrown until 
completing the initialization of the exception-declaration in the matching handler(18.6.4). This includes stack unwinding.Iftheexceptionis rethrown(15.1), std::uncaught_exception() returns true fromthe point of rethrow until 
the rethrown exception is caught again. 

15.6 Exceptions and access [except.access] 
1 If the exception-declaration in a catch clause has class type, and the function in which the catch clause occurs does not 
have access to the destructor of that class, the program is ill-formed. 

2 An object can be thrown if it can be copied and destroyed in the context of the function in which the throw-expression 
occurs. 

Draft 


15.6 Exceptions and access Exception handling 356 
Draft 


Chapter 16 Preprocessing directives [cpp]


Apreprocessing directive consists of a sequence of preprocessing tokens. The first token in the sequence is a# preprocessingtokenthat (atthestartoftranslationphase4)iseitherthefirst characterinthe sourcefile (optionallyafterwhite 
space containing no new-line characters) or that follows white space containing at least one new-line character. The last 
token in the sequence is the first new-line character that follows the first token in the sequence.141) Anew-line character 
endsthepreprocessingdirective even ifitoccurs withinwhatwould otherwisebeaninvocationofafunction-like macro. 

preprocessing-file:
groupopt


group:
group-part
group group-part


group-part: 

pp-tokensopt new-line 

if-section
control-line


text-line
#non-directive


if-section:
if-group elif-groupsopt else-groupopt endif-line


if-group:
# if constant-expression new-line groupopt
# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt


elif-groups:
elif-group
elif-groups elif-group


elif-group:
# elif constant-expression new-line groupopt


else-group:
# else new-line groupopt


endif-line:
# endif new-line


141) Thus, preprocessing directives are commonly called “lines.” These “lines” have no other syntactic significance, as all white space is equivalent 
except in certain situations during preprocessing (see the # character string literal creation operator in 16.3.2, for example). 


Preprocessing directives 358 

control-line: 

# include pp-tokens new-line 

# define identifier replacement-list new-line 

# define identifier lparen identifier-listopt ) replacement-list new-line 

# define identifier lparen ... ) replacement-list new-line 

# define identifier lparen identifier-list, ... ) replacement-list new-line 

# undef identifier new-line
# line pp-tokens new-line
# error pp-tokensopt new-line
# pragma pp-tokensopt new-line
# new-line


text-line:
pp-tokensopt new-line


non-directive:
pp-tokensopt new-line


lparen: 

the left-parenthesis character without precedingwhite-space 

a ( character not immediately preceded by white-space 

identifier-list:
identifier
identifier-list , identifier


replacement-list:
pp-tokensopt


pp-tokens:
preprocessing-token
pp-tokens preprocessing-token


new-line: 

the new-line character 
2 Atext line shall not begin with a # preprocessingtoken.Anon-directive shallnotbeginwithany ofthedirective names 
appearing in the syntax. 

3 Whenina groupthatis skipped(16.1),thedirective syntaxisrelaxed toallow any sequenceofpreprocessingtokensto 
occur between the directive name and the following new-line character. 

4 The only white-space characters that shall appear betweenpreprocessing tokenswithina preprocessing directive (from 
just after the introducing # preprocessing token through just before the terminating new-line character) are space and 
horizontal-tab (including spaces that have replaced comments or possibly other white-space characters in translation 
phase 3). 

5 The implementation can process and skip sections of source files conditionally, include other source files, and replace 
macros. These capabilities are called preprocessing, because conceptually they occur before translation of the resulting 
translation unit. 

6 The preprocessing tokens within a preprocessing directive are not subject to macro expansion unless otherwise stated. 

[Example: In: 

#define EMPTY 

Draft 


359 Preprocessing directives 16.1 Conditional inclusion 

EMPTY # include <file.h> 

the sequence of preprocessing tokenson the second line is not apreprocessingdirective, becauseit does notbegin witha 
#at the start of translation phase 4, even though it will do so after the macro EMTPY has been replaced. — end example ] 

16.1 Conditional inclusion [cpp.cond] 
1 The expression that controls conditional inclusion shall be an integral constant expression except that: it shall not 
containacast; identifiers (includingthoselexically identicaltokeywords)are interpretedas describedbelow;142)andit 
may contain unary operator expressions of the form 

defined identifier 

or 

defined ( identifier ) 

which evaluate to 1 if the identifier is currently defined as a macro name (that is, if it is predefined or if it has been the 
subject of a #define preprocessing directive without an intervening #undef directive with the same subject identifier), 
zero0 if it is not. 

2 Each preprocessingtoken that remains afterallmacro replacementshave occurred shallbeinthelexical formofatoken 
(2.6). 

3 Preprocessing directivesofthe forms 

# if constant-expression new-line groupopt
# elif constant-expression new-line groupopt


check whether the controlling constant expression evaluates to nonzero. 

4 Prior to evaluation, macro invocations in the list of preprocessing tokens that will become the controlling constant 
expression are replaced(except for those macro names modifiedby the defined unary operator), just as in normal text. 
If the token defined is generated as a result of this replacement process or use of the defined unary operator does not 
match one ofthe two specified forms prior to macro replacement, the behavior is undefined. After all replacements due 
to macro expansion and the defined unary operator have been performed, all remaining identifiers andkeywords143), 
except for true and false, are replaced with the pp-number 0,and then each preprocessingtokenis convertedintoa 
token.Theresultingtokenscomprisethecontrolling constantexpressionwhichisevaluatedaccordingtotherulesof 5.19 
using arithmetic that has at least the ranges specified in 18.2, except that int and unsigned intall signed and unsigned 
integer types act as if theyhave the same representation as, respectively, long long int and unsigned long long int. 
This includes interpreting character literals,whichmayinvolveconvertingescape sequencesintoexecution characterset 
members. Whetherthenumericvalueforthese character literalsmatchesthevalueobtainedwhenanidentical character 
literal occursinanexpression(otherthan withina #if or #elif directive)is implementation-defined.144) Also, whether 

142) Because the controlling constant expressionisevaluated during translation phase4, all identifiers either are or are not macro names — there 

simply are nokeywords, enumeration constants, and so on. 
143) An alternative token(2.5)is not an identifier, even when its spelling consists entirely of letters and underscores. Therefore it is not subject to this 

replacement. 
144) Thus, the constant expression in the following #if directive and if statement is not guaranteed to evaluate to the same value in these two 

contexts. 

#if’z’-’a’ == 25
if (’z’ -’a’ == 25)


Draft 


16.2 Source file inclusion Preprocessing directives 360 
a single-character character literal may have a negative value is implementation-defined. Each subexpression with type 
bool is subjected to integral promotion before processing continues. 

5 Preprocessing directivesofthe forms 

# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt


check whether the identifier is or is not currently defined as a macro name. Their conditions are equivalent to #if 
defined identifier and #if !defined identifier respectively. 

6 Each directive’s condition is checked in order. If it evaluates to false (zero), the group that it controls is skipped: 
directivesareprocessedonlythroughthenamethat determinesthedirectiveinordertokeeptrackofthelevelofnested 
conditionals; the rest of the directives’ preprocessing tokens are ignored, as are the other preprocessing tokens in the 
group. Only the first group whose controlcondition evaluates to true (nonzero) is processed. If none of the conditions 
evaluates to true, and there is a #else directive, the group controlled by the #else is processed; lacking a #else 
directive, all the groups until the #endif are skipped.145) 

16.2 Source file inclusion [cpp.include] 
1A#include directive shall identifyaheader or source file that canbe processedby the implementation. 
2 Apreprocessing directiveofthe form 

# include <h-char-sequence> new-line 

searchesasequenceofimplementation-definedplacesforaheader identifieduniquelybythespecified sequence between 
the < and > delimiters, and causes the replacement of that directive by the entire contents of the header. How the places 
are specified or the header identified is implementation-defined. 

3 Apreprocessing directiveofthe form 

# include "q-char-sequence" new-line 

causes the replacement of that directive by the entire contents of the source file identified by the specified sequence 
between the " delimiters. The named source file is searched for in an implementation-defined manner. If this search is 
not supported, orif the searchfails, the directiveis reprocessed asifit read 

# include <h-char-sequence> new-line 

with the identical contained sequence (including > characters, if any) from the original directive. 
4 Apreprocessing directiveofthe form 

# include pp-tokens new-line 

(that does not match one of the two previous forms) is permitted. The preprocessing tokens after include in the 
directive are processed just as in normal text (each identifier currently defined as a macro name is replaced by its 
replacementlistofpreprocessingtokens).Ifthe directiveresultingafterall replacementsdoesnotmatchoneofthetwo 
previous forms, the behavior is undefined.146) The method by which a sequence of preprocessing tokens between a < 

145) As indicated by the syntax, a preprocessing token shall not follow a #else or #endif directive before the terminating new-line character. 

However, comments may appear anywhere in a source file, including within a preprocessing directive. 
146) Note that adjacent string literals are not concatenated into a single string literal (see the translation phases in 2.1); thus, an expansion that results 

in two string literals is an invalid directive. 

Draft 


361 Preprocessing directives 16.3 Macroreplacement 

and a > preprocessing token pair or a pair of " characters is combined into a single header name preprocessing token is 
implementation-defined. 

5 The mapping between the delimited sequence and the external source file name is implementation-defined. The implementation provides unique mappings for sequences consisting of one or more nondigits or digits(2.10)followed by a 
period(.)and a singlenondigit. The first character shall not be a digit. The implementation may ignore the distinctions 
of alphabetical case. 

6A#include preprocessing directive may appear in a source file that has been read because of a #include directive in 
another file, up to an implementation-defined nesting limit. 

[Example: The most common uses of #include preprocessing directives are as in the following: 

#include <stdio.h>
#include "myprog.h"


— end example ]
[Example: Here is a macro-replaced #include directive:
#if VERSION == 1
#define INCFILE "vers1.h"
# elif VERSION == 2
#define INCFILE "vers2.h" // and so on */
# else


#define INCFILE "versN.h"
# endif
# include INCFILE


— end example ] 
16.3 Macro replacement [cpp.replace] 
1 Two replacement lists are identical if and only if the preprocessing tokens in both have the same number, ordering, 
spelling, and white-space separation, where all white-space separations are considered identical. 

2 An identifier currently defined as a macro without useof lparen(an object-like macro)maybe redefinedby another 
#define preprocessing directive provided that the second definition is an object-like macro definition and the two 
replacement lists are identical, otherwise the program is ill-formed. ALikewise, an identifier currently defined as a 
macro using lparen(a function-like macro)maybe redefinedbyanother #define preprocessing directive provided that 
the second definition is a function-like macro definition that has the same number and spelling of parameters, and the 
two replacement lists areidentical, otherwise the programis ill-formed. 

3 There shall be white-space between the identifier and the replacement list in the definition of an object-like macro. 

4 TheIf the identifier-list in the macro definition does not end with an ellipsis, the number of arguments (including those 
arguments consisting of no preprocessing tokens) in an invocation of a function-like macro shall agree withequal the 
number of parameters in the macro definition, and there . Otherwise, there shall be more arguments in the invocation 
than there are parameters in the macro definition (excluding the ...). There shall exist a ) preprocessing token that 

terminates the invocation. 

The identifier _ _ VA_ARGS _ _ shall occur only in the replacement-list of a function-like macro that uses the ellipsis 
notation in the parameters. 

Draft 


16.3 Macro replacement Preprocessing directives 362 
6 Aparameter identifierinafunction-like macro shallbe uniquely declared within its scope. 

7 The identifier immediatelyfollowing the define is called the macro name. There is one name space for macro names. 
Anywhite-space characters preceding or following the replacement list of preprocessing tokens are not considered part 
of the replacement list for either form of macro. 

8 Ifa # preprocessing token, followed by an identifier, occurs lexically at the point at which a preprocessing directive 
could begin, the identifier is not subject to macro replacement. 

9 Apreprocessing directiveofthe form 

# define identifier replacement-list new-line 

defines an object-like macroobject-like macro that causes each subsequent instance of the macro name147) to be replaced 
by the replacement listof preprocessing tokens that constitute the remainder of the directive.148) The replacement list is 
then rescanned for more macro names as specified below. 

10 Apreprocessing directiveofthe form 

# define identifier lparen identifier-listopt ) replacement-list new-line 

# define identifier lparen ... ) replacement-list new-line
# define identifier lparen identifier-list , ... ) replacement-list new-line


defines a function-like macrofunction-like macro with parameters, similar syntactically to a function call. The parameters are specified by the optional list of identifiers, whose scope extends from their declaration in the identifier list until 
the new-line character that terminates the #define preprocessing directive. Each subsequent instance of the function-
like macro name followedbya ( as the nextpreprocessing token introduces the sequence of preprocessing tokens that is 
replaced by the replacement list in the definition (an invocation of the macro). The replaced sequence of preprocessing 
tokens is terminated by the matching ) preprocessing token, skipping intervening matched pairs of left and right parenthesis preprocessing tokens. Within the sequence of preprocessing tokens making up an invocation of a function-like 
macro, new-line is considered a normal white-space character. 

11 The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of arguments 
for the function-like macro. The individual arguments within the list are separated by comma preprocessing tokens, 
but comma preprocessing tokens between matching inner parentheses do not separate arguments. If (before argument 
substitution) any argument consists of no preprocessing tokens, the behavior is undefined. If there are sequences of 
preprocessing tokens within the list of arguments that would otherwise act as preprocessing directives, the behavior is 
undefined. 

12 If thereisa ... in the identifier-list in the macro definition, then the trailing arguments, including any separating comma 
preprocessingtokens,are merged toformasingle item:thevariablearguments.The numberofargumentsso combinedis 
such that, following merger, the number of arguments is one more than the number of parameters in the macro definition 
(excluding the ...). 

16.3.1 Argument substitution [cpp.subst] 
1 After the arguments for the invocation of a function-like macro have been identified, argument substitution takes place. 

147) Since,by macro-replacement time, all character literals and string literals are preprocessing tokens, not sequences possibly containing identifier-

like subsequences (see 2.1.1.2, translation phases), theyare never scanned for macro names or parameters. 
148) An alternative token(2.5)is not an identifier,even when its spelling consists entirely of letters and underscores. Therefore it is not possible to 

define a macro whose name is the same as that of an alternative token. 

Draft 


363 Preprocessing directives 16.3 Macroreplacement 

Aparameterinthe replacementlist, unlessprecededbya# or ## preprocessing token or followedbya ## preprocessing 
token (see below),is replacedbythe corresponding argument after all macros contained thereinhave beenexpanded. 
Before being substituted, each argument’s preprocessing tokens are completely macro replaced as if theyformed the rest 
of the translation unit preprocessing file;no other preprocessing tokens are available. 

2 An identifier _ _ VA_ARGS _ _ thatoccursinthereplacementlistshallbe treatedasifitwereaparemeter, andthevariable 
arguments shall form the preprocessing tokensused to replace it. 

16.3.2 The # operator [cpp.stringize] 
1 Each # preprocessingtokeninthe replacement listfora function-like macro shallbe followedbya parameterasthenext 
preprocessing token in the replacement list. 

2 If, in the replacement list, a parameter is immediately preceded by a # preprocessing token, both are replaced by a 
single character string literal preprocessing token that contains the spelling of the preprocessing token sequence for 
the corresponding argument. Each occurrence of white space between the argument’s preprocessing tokens becomes a 
single space character in the character string literal. White space before the first preprocessing token and after the last 
preprocessing token comprising the argument is deleted. Otherwise, the original spelling of each preprocessing token 
in the argument is retained in the character string literal, except for special handling for producing the spelling of string 
literals and character literals: a \ character is inserted before each " and \ characterofa character literal or stringliteral 
(including the delimiting " characters). If the replacement thatresults is not a valid character string literal, the behavior 
is undefined. The character string literal corresponding to an empty argument is "". The order of evaluation of # and ## 
operators is unspecified. 

16.3.3 The ## operator [cpp.concat] 
1A## preprocessing token shall not occur at the beginning or at the end of a replacement list for either form of macro 
definition. 

2 If, in the replacement list of a function-like macro, a parameter is immediately preceded or followed by a ## preprocessingtoken,the parameteris replacedbythe correspondingargument’s preprocessingtoken sequence.;however, 
if an argument consists of no preprocessing tokens, the parameter is replaced by a placemarker preprocessing token 

instead.149) 

For both object-like and function-like macro invocations, before the replacement list is reexamined for more macro 
names to replace, each instance of a ## preprocessing token in the replacement list (not from an argument) is deleted 
and the preceding preprocessing token is concatenated with the following preprocessing token. Placemarker preprocessing tokensare handled specially; concatenation of two placemarkers results in a single placemarker preprocessing 
token,and concatenation of a placemarker with a non-placemarker preprocessing tokenresults in the non-placemarker 
preprocessing token.If the result is not a valid preprocessing token, the behavior is undefined. The resulting token is 
available for further macro replacement. The order of evaluation of ## operators is unspecified. 

[Example: In the following fragment: 

#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
char p[] = join(x, y); // equivalent to


149)Placemarker preprocessing tokensdo not appear in the syntax because they are temporary entities that exist only within translation phase 4. 

Draft 


16.3 Macro replacement Preprocessing directives 364 
// char p[] = "x ## y"; 

The expansion produces, at various stages: 

join(x, y)
in_between(x hash_hash y)
in_between(x ## y)
mkstr(x ## y)
"x ## y"


In other words, expanding hash_hash producesanew token,consistingoftwo adjacentsharpsigns,butthisnew token 
is not the ## operator. — end example ] 

16.3.4 Rescanning and furtherreplacement [cpp.rescan] 
1 After all parameters in the replacement list have been substituted, and # and ## processing has taken place, all place-
marker preprocessing tokensare removed. Then the resulting preprocessing token sequence is rescanned, along with all 
subsequent preprocessing tokens of the source file, for more macro names to replace. 

2 If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the 
source file’s preprocessing tokens), it is not replaced. Furthermore,if anynested replacements encounter the name of the 
macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available 
for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token 
would otherwise have been replaced. 

3 The resulting completely macro-replaced preprocessing token sequence is not processed as a preprocessing directive 
evenifit resembles one,but all pragma unaryoperatorexpressions withinit are then processed as specifiedin 16.9 
below. 

16.3.5 Scope of macro definitions [cpp.scope] 
1 Amacro definition lasts (independent of block structure) until a corresponding #undef directive is encountered or (if 
none is encountered) until the end of the translation unit. Macro definitions have no significance after translation phase 

4. 
2 Apreprocessing directiveofthe form 

# undef identifier new-line 

causes the specified identifier no longer to be defined as a macro name. It is ignored if the specified identifier is not 
currently defined as a macro name. 

3 [Note: The simplestuseofthisfacilityisto definea “manifest constant,”asin 

# define TABSIZE 100
int table [ TABSIZE ];


4 The following defines a function-like macro whose value is the maximum of its arguments. It has the advantages of 
working for any compatible types of the arguments and of generating in-line code without the overhead of function 
calling. It has the disadvantages of evaluating one or the other of its arguments a second time (including side effects) 
and generating more code than a function if invoked several times. It also cannot have its address taken, as it has none. 

#define max(a, b) ((a) > (b) ? (a) : (b)) 

Draft 


365 Preprocessing directives 16.3 Macroreplacement 

The parentheses ensure that the arguments and the resulting expression are bound properly. 
5 To illustrate the rules for redefinition and reexamination, the sequence 

# define x 3
#define f(a) f(x * (a))
# undef x
# define x 2
# define g f
# define z z [0]
#define h g(~
#define m(a) a(w)
#define w 0,1
#define t(a) a


#define p() int
#define q(x) x
#define r(x,y) x ## y
#define str(x) # x


f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m


(f)^ m(m); 
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };


results in 

f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * ( 5)) & f(2 * (0,1))^m(0,1);


int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };


6 To illustrate the rules for creating character string literals and concatenating tokens, the sequence 

#define str(s) # s
#define xstr(s) str(s)
#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", \


x ## s, x ## t) 
#define INCFILE(n) vers ## n /* from previous #include example */ 
#define glue(a, b) a ## b 
#define xglue(a, b) glue(a, b) 
# define HIGHLOW " hello " 
# define LOW LOW " , world " 

debug (1 , 2);
fputs(str(strncmp("abc\0d", "abc", ’\4’) // this goes away */


== 0) str(: @\n), s);
#include xstr(INCFILE(2).h)
glue(HIGH , LOW);
xglue(HIGH , LOW)


results in 

Draft 


16.3 Macro replacement Preprocessing directives 366 
printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", ’\\4’) == 0" ": @\n", s);
#include "vers2.h" (after macro replacement, before file access)
" hello ";
" hello " " , world "


or, after concatenation of the character string literals, 

printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", ’\\4’) == 0: @\n", s);
#include "vers2.h" (after macro replacement, before file access)
" hello ";
"hello , world "


Space around the # and ## tokens in the macro definition is optional. 

Toillustrate the rules for placemarker preprocessing tokens,the sequence 

#define t(x,y.z) x ## y ## z
int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),


t(10,,), t(,11,), t(,,12), t(,,) }; 

results in 

int j[] = { 123, 45, 67, 89,
10, 11, 12, };


8 Andfinally, To demonstrate the redefinition rules, the following sequenceisvalid. 

# define OBJ_LIKE (1 -1)
# define OBJ_LIKE /* white space*/ (1-1)/* other*/
#define FTN_LIKE(a) ( a )
# define FTN_LIKE ( a )( /* note the white space*/\


a /* other stuff on this line 

* / ) 
9 But the following redefinitions are invalid: 

# define OBJ_LIKE (0) // different token sequence */ 
# define OBJ_LIKE (1 -1) // different white space */ 
#define FTN_LIKE(b) ( a ) // different parameter usage */ 
#define FTN_LIKE(b) ( b ) // different parameter spelling */ 

— end note ] 
10 Finally, toshow thevariableargumentlist macrofacilities: 
#define debug(...) fprintf(stderr, _ _ VA_ARGS _ _) 

#define showlist(...) puts(#_ _ VA_ARGS _ _) 

#define report(test, ...) ((test) ? puts(#test) : printf(_ _ VA_ARGS _ _)) 

debug("Flag"); 
debug("X = %d\n", x); 

Draft 


367 Preprocessing directives 16.4 Line control 

showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);


results in 

fprintf(stderr, "Flag" );
fprintf(stderr, "X = %d\n", x );
puts( "The first, second, and third items." );
((x>y) ? puts("x>y") : printf("x is %d but y is %d", x, y));


16.4 Line control [cpp.line] 
1 The string literal of a #line directive,if present, shallbea character string literal. 

2 The line number of the current source line is one greater than the number of new-line characters read or introduced in 
translationphase1(2.1)while processingthe sourcefiletothe currenttoken. 

3 Apreprocessing directiveofthe form 

# line digit-sequence new-line 

causes the implementation to behave as if the following sequence of source lines begins with a source line that has a 
line number as specifiedby the digit sequence(interpreted asa decimal integer). If thedigit sequence specifies zero or 
a number greater than 327672147483647, the behavior is undefined. 

4 Apreprocessing directiveofthe form 

# line digit-sequence " s-char-sequenceopt " new-line 

sets the line number similarly and changes the presumed name of the source file to be the contents of the character string 
literal. 

5 Apreprocessing directiveofthe form 

# line pp-tokens new-line 

(that does not match one of the two previous forms) is permitted. The preprocessing tokens after line on the directive 
are processedjustasinnormaltext(each identifier currently definedasamacro nameis replacedbyits replacementlist 
of preprocessing tokens). If the directive resulting after all replacements does not match one of the two previous forms, 
the behavior is undefined; otherwise, the result is processed as appropriate. 

16.5 Error directive [cpp.error] 
1 Apreprocessing directiveofthe form 

# error pp-tokensopt new-line 

causestheimplementationtoproduceadiagnosticmessagethat includesthe specified sequenceof preprocessingtokens, 
and renders the program ill-formed. 

16.6 Pragma directive [cpp.pragma] 
1 Apreprocessing directiveofthe form 

# pragma pp-tokensopt new-line 

Draft 


16.7 Null directive Preprocessing directives 368 
causes the implementation to behave in an implementation-defined manner. The behavior might cause translation to 
fail or cause the translator or the resulting program to behave in a non-conforming manner. Any pragma that is not 
recognized by the implementation is ignored. 

16.7 Null directive [cpp.null] 
1 Apreprocessing directiveofthe form 

# new-line 

has no effect. 

16.8 Predefined macro names [cpp.predefined] 
1 The following macro namesshallbe definedby the implementation: 

_ _ cplusplus
The name _ _ cplusplus is defined to the value [tbd] when compilingaC++ translation unit.150)


_ _ DATE__ 
The date of translation of the source file (a character string literal of the form "Mmm dd yyyy", where the names 
of the months are the same as those generated by the asctime function, and the first character of dd is a space 
characterifthevalueislessthan10).Ifthedateof translationisnotavailable,an implementation-definedvalid 
date is supplied. 

_ _ FILE__ 

The presumed name of the source file (a character string literal). 

_ _ LINE__ 

The line number of the current source line (a decimal constant). 

_ _ STDC_HOSTED _ _ 

The integer constant 1 if the implementation is a hosted implementation or the integer constant 0 if it is not. 

_ _ TIME__ 
Thetimeoftranslationofthe sourcefile(acharacterstring literaloftheform "hh:mm:ss" asinthe timegenerated 
by the asctime function). If the time of translationis not available, an implementation-defined valid time is 
supplied. 

2 The following macro names are conditionally defined by the implementation: 

_ _ STDC__
Whether __STDC _ _ is predefined and if so, what its value is, are implementation-defined.


_ _ STDC_VERSION _ _ 

Whether _ _ STDC_VERSION _ _ is predefined and if so, what its value is, are implementation-defined. 

_ _ STDC_ISO_10646 _ _ 

An integer constant of the form yyyymmL (for example, 199712L), intended to indicate that values of type 
wchar_t are the coded representations of the characters defined by ISO/IEC 10646, along with all amendments 
and technical corrigenda as of the specified year and month. 

150) It is intended that future versions of this standard will replace the value of this macro with a greater value. Non-conforming compilers should 
use a value with at most five decimal digits. 

Draft 


369 Preprocessing directives 16.9 Pragma operator 

3 Thevaluesofthe predefined macros(exceptfor __LINE _ _ and _ _ FILE__)remain constant throughout the translation 
unit. 

4 If any of the pre-defined macro names in this subclause, or the identifier defined, is the subject of a #define or 
a #undef preprocessing directive, the behavior is undefined. Any other predefined macro names shall begin with a 
leading underscore followed by an uppercase letter or a second underscore. 

16.9 Pragma operator [cpp.pragma.op] 
Aunary operator expression of the form: 

_Pragma ( string-literal ) 

is processed as follows: The string literal is destringized by deleting the L prefix, if present, deleting the leading and 
trailing double-quotes, replacing each escape sequence \" bya double-quote, and replacing each escape sequence \\ by 
asinglebackslash.Theresultingsequenceofcharactersisprocessedthrough translationphase3toproducepreprocessing tokensthat are executed as if they were the pp-tokens in a pragma directive. The original four preprocessing tokens 
in the unary operator expression are removed. 

[Example: 

#pragma listing on "..\listing.dir" 

can also be expressed as: 

_Pragma ( listing on "\"..\\listing.dir\"" ) 

The latter form is processed in the same way whether it appears literally as shown, or results from macro replacement, 

as in: 

#define LISTING(x) PRAGMA(listing on #x) 

#define PRAGMA(x) _Pragma(#x) 

LISTING( ..\listing.dir ) 

— end example ] 
Draft 


16.9 Pragma operator Preprocessing directives 370 
Draft 


Chapter 17 Library introduction [lib.library]


1 This clause describes the contents of the C++ Standard Library, how a well-formed C++ program makes use of the 
library,andhowa conformingimplementationmayprovidethe entitiesinthe library. 

2 TheC++ Standard Library provides an extensible framework, and contains components for: language support, diagnostics, general utilities, strings, locales, containers, iterators, algorithms, numerics, and input/output. The language support 
components are requiredby certain partsoftheC++ language, such as memory allocation(5.3.4, 5.3.5)andexception 
processing (clause 15). 

3 The general utilities include components used by other library elements, such as a predefined storage allocator for 
dynamic storage management(3.7.3).The diagnostics componentsprovidea consistent frameworkforreporting errors 
in aC++ program, including predefined exception classes. 

4 The strings components provide support for manipulating text represented as sequences of type char, sequences of 
type wchar_t,or sequencesofanyother “character-like” type. The localization componentsextend internationalization 
support for such text processing. 

5 The containers, iterators, and algorithms provideaC++ program with access to a subset of the most widely used algorithms and data structures. 

6 Numeric algorithms and the complex number components extend support for numeric processing. The valarray components provide support for n-at-a-time processing, potentially implemented as parallel operations on platforms that 
support such processing. 

7 The iostreams components are the primary mechanism forC++ program input/output. They can be used with other 
elements of the library, particularly strings, locales, and iterators. 

8 Thislibraryalsomakesavailablethefacilitiesofthe StandardClibrary,suitablyadjustedto ensurestatictypesafety. 

9 The following subclauses describethe definitions(17.1),and methodof description(17.3)forthe library. Clause17.4, 
and clauses 18 through27, and Annex Dspecify the contentsof the library, and libraryrequirements and constraints on 
both well-formedC++ programs and conforming implementations. 

17.1 Definitions [lib.definitions] 
17.1.1 arbitrary-positional stream [defns.arbitrary.stream] 
a stream (describedinclause 27)thatcanseektoanyintegralpositionwithinthelengthofthe stream.Every arbitrary-
positional stream is also a repositional stream(17.1.16). 

17.1.2 character [defns.character] 
in clauses 21, 22, and 27, means anyobject which, when treated sequentially, can represent text. The term does not only 


17.1 Definitions Library introduction 372 
mean char and wchar_t objects,but any value that canbe representedbya type that provides the definitions specified 
in these clauses. 

17.1.3 character containertype [defns.character.container] 
a class or a type used to represent a character (17.1.2). It is used for one of the template parameters of the string and 
iostream class templates.Acharacter container class shallbea POD(3.9)type. 

17.1.4 comparison function [defns.comparison] 
an operator function(13.5)for anyof the equality(5.10)or relational(5.9)operators. 

17.1.5 component [defns.component] 
a group of library entities directly related as members, parameters, or return types. For example, the class template 
basic_string and the non-member function templates that operate on strings are referred to as the string component. 

17.1.6 default behavior [defns.default.behavior] 
adescription of replacement function and handler function semantics.Anyspecific behaviorprovidedbytheimplementation, within the scope of the required behavior. 

17.1.7 handler function [defns.handler] 
a non-reserved function whose definition maybe providedbyaC++ program. AC++ program may designate a handler 
functionatvariouspointsinitsexecution,bysupplyingapointertothe functionwhencallinganyofthelibrary functions 
that install handler functions (clause 18). 

17.1.8 iostream class templates [defns.iostream.templates] 
templates, defined in clause 27, that take two template arguments: charT and traits. The argument charT is a 
character container class, and the argument traits is a structure which defines additional characteristics and functions 
of the character type represented by charT necessary to implement the iostream class templates. 

17.1.9 modifier function [defns.modifier] 
a class member function(9.3), other than constructors, assignment, or destructor, that alters the stateof an objectof the 
class. 

17.1.10 object state [defns.obj.state] 
the currentvalueof all non-static class membersof an object(9.2). The stateof an object canbe obtainedby using one 
or more observer functions. 

17.1.11 narrow-oriented iostream classes [defns.narrow.iostream] 
the instantiations of the iostream class templates on the character container class char and the default value of the 

Draft 


373 Library introduction 17.1 Definitions 

traits parameter. The traditionaliostream classes are regarded as the narrow-oriented iostream classes(27.3.1). 

17.1.12 NTCTS [defns.ntcts] 
a sequence of values that have character type, that precede the terminating null character type value charT(). 

17.1.13 observer function [defns.observer] 
a class member function(9.3)that accessesthe state of an object of the class,but does not alter that state. Observer 
functions are specified as const member functions(9.3.2). 

17.1.14 replacement function [defns.replacement] 
a non-reserved function whose definitionisprovidedbyaC++ program. Only one definition for such a function is in 
effectforthe durationofthe program’sexecution,asthe resultof creatingthe program(2.1)and resolvingthe definitions 
of all translation units(3.5). 

17.1.15 required behavior [defns.required.behavior] 
a description of replacement function and handler function semantics, applicable to both the behavior provided by the 
implementation and the behavior that shall be provided by anyfunction definition in the program. If a function defined 
in aC++ programfailstomeettherequiredbehaviorwhenitexecutes,thebehavioris undefined. 

17.1.16 repositional stream [defns.repositional.stream] 
a stream (described in clause 27)that can seek only to a position that was previously encountered. 

17.1.17 reserved function [defns.reserved.function] 
a function, specified as partof theC++ StandardLibrary,thatmustbe definedbythe implementation.IfaC++ program 
provides a definition for any reserved function, the results are undefined. 

17.1.18 stable algorithm [defns.stable] 
an algorithm that preserves, as appropriate to the particular algorithm, the order of elements. 

— For thesort algorithms the relative order of equivalent elements is preserved. 
— For theremove algorithms the relative order of the elements that are not removed is preserved. 
— For the merge algorithms, for equivalent elements in the original two ranges, the elements from the first range 
precede the elements from the second range. 
17.1.19 traits class [defns.traits] 
a class that encapsulates a set of types and functions necessary for class templates and function templates to manipulate 
objects of types for which they are instantiated. Traits classes definedin clauses21, 22 and 27 are chararacter traits, 
which provide the character handling support needed by the string and iostream classes. 

17.1.20 wide-oriented iostream classes [defns.wide.iostream] 
the instantiations of the iostream class templates on the character container class wchar_t and the default value of the 

Draft 


17.2 Additional definitions Library introduction 374 
traits parameter(27.3.2). 

17.2 Additional definitions [defns.additional] 
1 1.3 defines additional terms usedelsewhere in this International Standard. 
17.3 Method of description (Informative) [lib.description] 
1 17.3 describes the conventions used to describe theC++ Standard Library. It describes the structures of the normative 
clauses18 through27(17.3.1), Annex D and other editorial conventions(17.3.2). 
17.3.1 Structure of each subclause [lib.structure] 
1 17.4.1providesa summaryoftheC++Standard library’s contents. Other Library clauses provide detailed specifications 
for eachof the componentsin the library, as showninTable 11. 
Table 11: Library Categories 

Clause Category 
18 Language support 
19 Diagnostics 
20 General utilities 
21 Strings 
22 Localization 
23 Containers 
24 Iterators 
25 Algorithms 
26 Numerics 
27 Input/output 

2 Each Library clause contains the following elements, as applicable:151) 

— Summary 
— Requirements 
— Detailed specifications 
— References to the StandardClibrary 
17.3.1.1 Summary [lib.structure.summary] 
1 TheSummaryprovidesasynopsisofthecategory,and introducesthe first-level subclauses.Each subclausealsoprovides 
a summary, listing the headers specified in the subclause and the library entities provided in each header. 

2 Paragraphs labelled “Note(s):” or “Example(s):” are informative, other paragraphs are normative. 

3 The summary and the detailedspecifications are presented in the order: 

151) To save space, items that do not apply to a clause are omitted. For example, if a clause does not specify anyrequirements, there will be no 
“Requirements” subclause. 

Draft 


375 Library introduction 17.3 Method of description (Informative) 

— Macros 
— Values 
— Types 
— Classes 
— Functions 
— Objects 
17.3.1.2 Requirements [lib.structure.requirements] 
1 The library canbeextendedbyaC++ program. Each clause, as applicable, describes the requirements that such extensions must meet. Such extensions are generally one of the following: 

— Template arguments 
— Derived classes 
— Containers, iterators, and/or algorithms that meet an interface convention 
2 The string and iostreams components use an explicit representation of operations required of template arguments. They 
use a class template char_traits to define these constraints. 

3 Interface convention requirements are statedas generallyas possible. Insteadof stating “classXhasto definea member 
function operator++(),” the interface requires “for any object x of class X, ++x is defined.” That is, whether the 
operator is a member is unspecified. 

4 Requirements are stated in terms of well-defined expressions, which define valid terms of the types that satisfy the 
requirements.Forevery setof requirements thereisa table that specifies an initial setof thevalidexpressions and their 
semantics(20.1.6, 23.1, 24.1). Anygeneric algorithm (clause 25)that uses the requirements is described in terms of the 
valid expressions for its formal type parameters. 

5 Template argument requirements are sometimes referenced by name. See17.3.2.1. 

6 In some cases the semantic requirements are presented asC++ code. Such code is intended as a specification of equivalence of a construct to another construct, not necessarily as the way the construct must be implemented.152) 

17.3.1.3 Specifications [lib.structure.specifications] 
1 The detailed specifications each contain the following elements:153) 

— Name and brief description 
— Synopsis (class definition or function prototype, as appropriate) 
— Restrictions on template arguments, if any 
— Description of class invariants 
152) Althoughin some cases the codegivenis unambiguously the optimum implementation.
153)Theformofthese specificationswas designedtofollowtheconventions establishedbyexistingC++library vendors.


Draft 


17.3 Method of description (Informative) Library introduction 376 
— Description of function semantics 
2 Descriptions of class member functions follow the order (as appropriate):154) 
— Constructor(s) and destructor 
— Copying&assignment functions 
— Comparison functions 
— Modifier functions 
— Observer functions 
— Operators and other non-member functions 
3 Descriptions of function semantics contain the following elements (as appropriate):155) 
— Requires: the preconditions for calling the function 
— Effects: the actions performed by the function 
— Postconditions:the observable results established by the function 
— Returns: a description of the value(s) returned by the function 
— Throws: any exceptions thrownby the function, and the conditions thatwould cause theexception 
— Complexity: the time and/or space complexity of the function 
4 For non-reserved replacement and handler functions, clause 18 specifies two behaviors for the functions in question: 
their required and default behavior. The default behavior describesafunction definition providedbythe implementation. 
The required behavior describesthe semanticsofa function definitionprovidedby eitherthe implementationoraC++ 
program. Where no distinction is explicitly made in the description, the behavior described is the required behavior. 

5 Complexity requirements specified in the library clauses are upper bounds, and implementations that provide better 
complexity guarantees satisfy the requirements. 

17.3.1.4 CLibrary [lib.structure.see.also] 
1 Paragraphs labelled “SEE ALSO:” contain cross-references to the relevant portions of this Standard and the ISO C 
standard, whichis incorporated into this Standardby reference. 

17.3.2 Other conventions [lib.conventions] 
1 This subclausedescribesseveral editorialconventionsusedto describethe contentsoftheC++ Standard Library. These 

154)Tosavespace,itemsthatdonotapplytoaclassare omitted.Forexample,ifaclassdoesnotspecifyanycomparison functions,therewillbeno 
“Comparison functions” subclause. 
155)Tosavespace,itemsthatdonotapplytoa functionare omitted.Forexample,ifa functiondoesnotspecifyanyfurther preconditions,therewill 
be no “Requires” paragraph. 

Draft 


377 Library introduction 17.3 Method of description (Informative) 

conventions are for describing implementation-defined types(17.3.2.1), and member functions(17.3.2.2). 

17.3.2.1 Type descriptions [lib.type.descriptions] 
1 The Requirements subclauses may describe names that are used to specify constraints on template arguments.156) These 
namesareusedin clauses 20,23,25,and 26to describethetypesthatmaybe suppliedasargumentsbyaC++ program 
when instantiating template components from the library. 

2 Certain types defined in clause 27 are used to describe implementation-defined types. They are based on other types, 
but with added constraints. 

17.3.2.1.1 Enumerated types [lib.enumerated.types] 
1 Several types defined in clause 27 are enumerated types. Each enumerated type may be implemented as an enumeration 
or as a synonym for an enumeration.157) 

2 The enumerated type enumerated can be written: 

enum enumerated { V0 , V1 , V2 , V3 , .....}; 

static const enumerated C0 ( V0 );
static const enumerated C1 ( V1 );
static const enumerated C2 ( V2 );
static const enumerated C3 ( V3 );


..... 

3 Here, the names C0, C1, etc. represent enumerated elements for this particular enumerated type. All such elements have 
distinct values. 

17.3.2.1.2 Bitmask types [lib.bitmask.types] 
1 Several types definedin clauses 18 through27 andAnnex Dare bitmask types. Each bitmask type can be implemented 
as an enumerated type that overloads certain operators, as an integer type, or as a bitset (23.3.5). 

2 The bitmask type bitmask can be written: 

enum bitmask {
V0 =1 << 0, V1 =1 << 1, V2 =1 << 2, V3 = 1 << 3, .....
};


static const bitmask C0 (V0 );
static const bitmask C1 (V1 );
static const bitmask C2 (V2 );
static const bitmask C3 (V3 );


..... 

bitmask operator & ( bitmask X , bitmask Y ) 

// For exposition only.
// int_type is an integral type capable of


156) Examples from 20.1 include: EqualityComparable, LessThanComparable, CopyConstructable, etc. Examples from 24.1 include: InputIterator, ForwardIterator, Function, Predicate, etc. 
157) Such as an integer type, with constant integervalues(3.9.1). 

Draft 


17.3 Method of description (Informative) Library introduction 378 
// representing all values of bitmask 

{ return static _cast <bitmask >( 

static_ cast < int _type >( X )& 

static_ cast < int _type >( Y )); } 

bitmask operator | ( bitmask X , bitmask Y ) 

{ return static _cast <bitmask >( 

static_ cast < int _type >( X )| 

static_ cast < int _type >( Y )); } 

bitmask operator ^ ( bitmask X , bitmask Y ) 

{ return static _cast <bitmask >( 

static_ cast < int _type >( X )^ 

static_ cast < int _type >( Y )); } 

bitmask operator ~ ( bitmask X ) 

{ return static _cast <bitmask >(static_cast < int _type >( X )); } 

bitmask & operator& =( bitmask & X , bitmask Y ) 

{ X = X &Y ; return X ;} 

bitmask & operator |=( bitmask & X , bitmask Y ) 

{ X = X |Y ; return X ;} 

bitmask & operator ^=( bitmask & X , bitmask Y ) 

{ X = X ^Y ; return X ;} 

3 Here, the names C0, C1, etc. representbitmask elements for this particular bitmask type. All such elements have distinct 
values such that, for anypair Ci and Cj, Ci &Ci is nonzero and Ci &Cj is zero. 

4 The following terms apply to objects and values of bitmask types: 

— Toset a value Y in an object Xis to evaluate the expression X|= Y. 
— Toclear a value Y in an object Xis to evaluate the expression X&= Y. 
— The value Y is setin the object Xif the expression X&Y is nonzero. 
17.3.2.1.3 Character sequences [lib.character.seq] 
1 The StandardClibrary makes widespread useof characters andcharacter sequences that followafew uniform conventions: 

— Aletter is anyof the 26 lowercase or 26 uppercase letters in the basic execution character set.158) 
— The decimal-point character is the (single-byte) character used by functions that convert between a (single-byte) 
character sequenceandavalueof oneofthe floating-point types.Itis usedinthe character sequenceto denotethe 
beginningofa fractionalpart.Itis representedin clauses 18through27andAnnex Dbyaperiod, ’.’, which is 
also its value in the "C" locale,butmaychangeduring programexecutionbyacallto setlocale(int, const 
char*),159) or by a change to a locale object, as described in clauses 22.1 and 27. 
158) Note that this definition differs from the definitionin ISOCsubclause 7.1.1.
159) declared in <clocale> (22.3).


Draft 


379 Library introduction 17.3 Method of description (Informative) 

— Acharacter sequence is an array object(8.3.4)Athat can be declared as TA [N ], where T is anyof the types 
char,unsigned char,orsigned char (3.9.1),optionally qualifiedbyanycombinationofconst or volatile. 
The initial elements of the array have defined contents up to and including an element determined by some 
predicate.Acharacter sequence canbe designatedbya pointervalue Sthat points to its first element. 
17.3.2.1.3.1 Byte strings [lib.byte.strings] 
1Anull-terminated byte string, or NTBS, is a character sequence whose highest-addressed element with defined content 
has the value zero (the terminating null character).160) 

2 The length of an NTBS is the number of elements that precede the terminating null character. An empty NTBS has a 
length of zero. 

3 The value ofan NTBS isthe sequenceofvaluesofthe elementsuptoand includingthe terminatingnullcharacter. 

4 Astatic NTBS is an NTBS with static storage duration.161) 

17.3.2.1.3.2 Multibyte strings [lib.multibyte.strings] 
1A null-terminated multibyte string, or NTMBS, is an NTBS that constitutes a sequence of valid multibyte characters, 
beginning and ending in the initial shift state.162) 

2 Astatic NTMBS is an NTMBS with static storage duration. 

17.3.2.1.3.3 Wide-character sequences [lib.wide.characters] 
1A wide-character sequence is an array object(8.3.4)A that can be declared as TA [N ], where T is type wchar_t 
(3.9.1), optionally qualifiedby anycombination of const or volatile. The initial elements of the array have defined 
contents up to and including an element determined by some predicate. Acharacter sequence can be designated by a 
pointer value Sthat designates its first element. 

2A null-terminated wide-character string, or NTWCS, is a wide-character sequence whose highest-addressed element 
with defined content has the value zero.163) 

3 The length of an NTWCS is the number of elements that precede the terminating null wide character. An empty NTWCS 
has a length of zero. 

4 The value ofan NTWCS isthe sequenceofvaluesofthe elementsuptoand includingthe terminatingnull character. 

5 Astatic NTWCS is an NTWCS with static storage duration.164) 

17.3.2.2 Functions within classes [lib.functions.within.classes] 
1Forthesakeofexposition, clauses18through27andAnnex Ddonot describecopyconstructors, assignment operators, 
or (non-virtual)destructorswiththe same apparent semanticsasthosethatcanbe generatedbydefault(12.1,12.4,12.8). 

160) Manyof the objects manipulated by function signatures declared in <cstring> (21.4)are character sequences or NTBSs. The size of some of 

these character sequences is limited by a length value, maintained separately from the character sequence. 
161)Astring literal, such as"abc",isa static NTBS 
162) An NTBS that contains characters only from the basic execution character set is also an NTMBS. Each multibyte character then consists of a 

single byte.
163) Manyof the objects manipulatedby function signatures declaredin <cwchar> are wide-character sequences or NTWCSs.
164)Awide string literal, such asL"abc" is a static NTWCS.


Draft 


17.4 Library-wide requirements Library introduction 380 
2 It is unspecified whether the implementation provides explicit definitions for such member function signatures, or for 
virtual destructors that canbe generatedby default. 

17.3.2.3 Private members [lib.objects.within.classes] 
1 Clauses18 through27 and Annex Ddo not specify the representationofclasses, and intentionally omit specificationof 
class members(9.2).An implementationmay define staticor non-static classmembers,or both,as neededto implement 
the semanticsof the member functions specifiedin clauses 18 through27 and Annex D. 

2 Objects of certain classes are sometimes required by the external specifications of their classes to store data, apparently 
in member objects. For the sake of exposition, some subclauses provide representative declarations, and semantic 
requirements, for private member objects of classes that meet the external specifications of the classes. The declarations 
forsuchmemberobjectsandthe definitionsof relatedmembertypesare enclosedinacommentthatendswith exposition 
only, as in: 

// streambuf* sb; exposition only 

3 Anyalternate implementation that provides equivalent external behavior is equally acceptable. 

17.4 Library-wide requirements [lib.requirements] 
1 This subclause specifies requirements that apply to the entireC++Standard library. Clauses 18 through27and Annex D 
specify the requirements of individual entities within the library. 

2 Thefollowing subclauses describethe library’s contentsandorganization(17.4.1),how well-formedC++programsgain 
accesstolibrary entities(17.4.2),constraintsonsuch programs(17.4.3),and constraintsonconforming implementations 
(17.4.4). 

17.4.1 Library contents and organization [lib.organization] 
1 This subclause providesa summaryof the entities definedin theC++ Standard Library. In general, these entites are 
defined in library headers, which subclause 17.4.1.2 lists alphabetically. 

17.4.1.1 Library contents [lib.contents] 
1 TheC++ Standard Library provides definitions for the following types of entities: Macros,Values,Types,Templates, 
Classes, Functions, Objects. 

2 All library entities except macros, operator new and operator delete are defined within the namespace std or 
namespaces nested within namespace std. 

3 Whenever a name x defined in the standard library is mentioned, the name x is assumed to be fully qualified as 
::std::x, unless explicitly described otherwise. For example, if the Effects section for library function F is described 
as calling library function G, the function ::std::G is meant. 

17.4.1.2 Headers [lib.headers] 
1 The elementsof theC++ Standard Library are declared or defined (as appropriate) in a header.165) 

Draft 


381 Library introduction 17.4 Library-wide requirements 

Table 12:C++Library Headers 

<algorithm> <iomanip> <list> <queue> <streambuf> 
<bitset> <ios> <locale> <set> <string> 
<complex> <iosfwd> <map> <sstream> <typeinfo> 
<deque> <iostream> <memory> <stack> <utility> 
<exception> <istream> <new> <stdexcept> <valarray> 
<fstream> <iterator> <numeric> <strstream> <vector> 
<functional> <limits> <ostream> 

Table 13:C++ Headers forCLibraryFacilities 

<cassert> <ciso646> <csetjmp> <cstdio> <ctime> 
<cctype> <climits> <csignal> <cstdlib> <cwchar> 
<cerrno> <clocale> <cstdarg> <cstring> <cwctype> 
<cfloat> <cmath> <cstddef> 

2 The C++ Standard Library provides 33 C++ headers, as shown in Table 12. 
3 The facilities of the Standard CLibrary are provided in 18 additional headers, as shown in Table 13. 
4 Except as noted in clauses 18 through 27 and Annex D the contents of each header cname shall be the same as that 
of the corresponding header name.h, as specified in ISO/IEC 9899:1990 Programming Languages C (clause 7), or 
ISO/IEC:1990 Programming Languages — CAMENDMENT 1: CIntegrity, (clause 7), as appropriate, as if by inclusion. In the C++ Standard Library, however, the declarations and definitions (except for names which are defined as 
macros in C) are within namespace scope (3.3.5)of the namespacestd. 
5 Names which are defined as macros in Cshall be defined as macros in the C++Standard Library, even if Cgrants license 
for implementation as functions. [ Note: the names defined as macros in Cinclude the following: assert, offsetof, 
setjmp, va_arg, va_end, and va_start. — end note ] 
6 Names that are defined as functions in Cshall be defined as functions in the C++ Standard Library.166) 
7 Identifiers that are keywords or operators in C++ shall not be defined as macros in C++ standard library headers.167) 
8 D.5, Standard Clibrary headers, describes the effects of using the name.h (C header) form in a C++program.168) 
17.4.1.3 Freestanding implementations [lib.compliance] 
1 Twokinds of implementations are defined:hosted and freestanding (1.4). For ahosted implementation, this International 
Standard describes the set of available headers. 
2 Afreestanding implementation has an implementation-defined set of headers. This set shall include at least the following 

Draft 


17.4 Library-wide requirements Library introduction 382 
Table 14:C++Headers for Freestanding Implementations 

Subclause Header(s) 
18.1 Types <cstddef> 
18.2 Implementation properties <limits> 
18.3 Start and termination <cstdlib> 
18.4 Dynamic memory management <new> 
18.5 Type identification <typeinfo> 
18.6 Exception handling <exception> 
18.7 Other runtime support <cstdarg> 

headers, as showninTable 14. 

3 The supplied version of the header <cstdlib> shall declare at least the functions abort(), atexit(), and exit() 
(18.3). 

17.4.2 Using the library [lib.using] 
1 This subclause describeshowaC++programgains accesstothefacilitiesoftheC++Standard Library. 17.4.2.1 describes 
effects during translationphase4, while 17.4.2.2 describeseffects during phase8(2.1). 

17.4.2.1 Headers [lib.using.headers] 
1 The entitiesin theC++ Standard Library are defined in headers, whose contents are made available to a translation unit 
when it contains the appropriate #include preprocessing directive(16.2). 

2 Atranslation unitmay include library headersinanyorder (clause2). Eachmaybe included more than once, withno 

effect different from being included exactly once, except that the effect of including either <cassert> or <assert.h> 

depends each time on the lexically current definition of NDEBUG.169) 

3 A translation unit shall include a header only outside of any external declaration or definition, and shall include the 
header lexically before the first reference to anyof the entities it declares in that translation unit. 

17.4.2.2 Linkage [lib.using.linkage] 
1 Entitiesin theC++ Standard Libraryhaveexternal linkage(3.5). Unlessotherwise specified, objects and functionshave 
the default extern "C++" linkage(7.5). 

2 Whethera name fromthe StandardClibrarydeclared withexternal linkagehas extern "C" or extern "C++" linkage 
is implementation-defined.Itis recommendedthatan implementationuse extern "C++" linkage for this purpose.170) 

165)Aheaderis not necessarilya source file, nor are the sequences delimitedby< and > in header names necessarily valid source file names(16.2). 

166) This disallows the practice, allowed in C, of providing a "masking macro" in addition to the function prototype. The only way to achieve 

equivalent "inline" behaviorinC++is to provide a definition as an extern inline function. 

167)In particular, including the standard header <iso646.h> or <ciso646> has no effect. 

168) The ".h" headersdumpalltheir namesintotheglobal namespace, whereasthenewerformskeeptheir namesin namespace std. Therefore, the 

newer forms are the preferred forms for all usesexcept forC++programs which are intended to be strictly compatible with C. 

169) Thisis the same as the StandardClibrary. 

170)Theonly reliablewayto declareanobjector function signaturefromthe StandardClibraryisby includingthe headerthat declaresit, notwith

standing the latitude grantedin subclause 7.1.7of theCStandard. 

Draft 


383 Library introduction 17.4 Library-wide requirements 

3 Objectsand functions definedinthe libraryand requiredbyaC++program are included in the program prior to program 
startup. 

SEEALSO: replacement functions(17.4.3.4), run-time changes(17.4.3.5). 

17.4.3 Constraints on programs [lib.constraints] 
1 This subclause describes restrictions onC++ programs that use thefacilitiesof theC++ Standard Library. The following 
subclauses specify constraints on the program’s namespace(17.4.3.1), its use of headers(17.4.3.2), classes derived from 
standard library classes(17.4.3.3), definitionsof replacement functions(17.4.3.4), and installationof handler functions 
during execution(17.4.3.5). 

17.4.3.1 Reserved names [lib.reserved.names] 
1 Itis undefined foraC++ program to add declarations or definitions to namespace std or namespaces within names-
pace std unless otherwise specified.Aprogrammayaddtemplate specializationsforanystandard library templateto 
namespace std. Such a specialization (complete or partial) of a standard library template results in undefined behavior 
unlessthedeclarationdependsonauser-definedtypeofexternallinkageandunlessthe specializationmeetsthe standard 
library requirements for the original template.171) Aprogram may explicitly instantiate anytemplates in the standard 
libraryonlyifthe declaration dependsonthe nameofa user-definedtypeofexternal linkageandthe instantiation meets 
the standard library requirements for the original template. 

2 TheC++ Standard Library reserves the following kinds of names: 

— Macros 
— Global names 
— Names with external linkage 
3 Iftheprogram declaresordefinesanameinacontextwhereitis reserved,otherthanasexplicitlyallowedbythisclause, 
the behavior is undefined. 

17.4.3.1.1 Macro names [lib.macro.names] 
1 Each name defined as a macro in a header is reserved to the implementation for any use if the translation unit includes 
the header.172) 

2 A translation unit that includes a header shall not contain any macros that define names declared or defined in that 
header.Nor shallsucha translationunit define macrosfor nameslexically identicaltokeywords. 

17.4.3.1.2 Global names [lib.global.names] 
1 Certain sets of names and function signatures are always reserved to the implementation: 

— Each name that contains a double underscore __ or begins with an underscore followed by an uppercase letter 
(2.11)is reserved to the implementation for anyuse. 
171) Anylibrary code that instantiates other library templates must be prepared to work adequately with any user-supplied specialization that meets 
the minimum requirements of the Standard. 
172)Itisnot permissibleto removea library macro definitionbyusingthe #undef directive. 

Draft 


17.4 Library-wide requirements Library introduction 384 
— Each name that begins with an underscore is reserved to the implementation for use as a name in the global 
namespace.173) 
17.4.3.1.3 External linkage [lib.extern.names] 
1 Each name declared as an object with external linkage in a header is reserved to the implementation to designate that 
library object withexternallinkage,174) bothin namespace std and in the global namespace. 

2 Each global function signature declared with external linkage in a header is reserved to the implementation to designate 
that function signature with external linkage.175) 

3 Each namehavingtwo consecutive underscores(2.11)is reservedtothe implementationfor useasa namewithboth 
extern "C" and extern "C++" linkage. 

4 Each name fromthe StandardClibrary declared withexternal linkageis reservedtothe implementationfor useasa 
name with extern "C" linkage, both in namespace std and in the global namespace. 

5 Each functionsignaturefromthe StandardClibrary declaredwithexternallinkageis reservedtotheimplementationfor 
use as a function signature with both extern "C" and extern "C++" linkage,176) or as a name of namespace scope in 
the global namespace. 

17.4.3.1.4 Types [lib.extern.types] 
1 For each typeT from the StandardC library,177) the types ::T and std::T are reserved to the implementation and, 
when defined, ::T shall be identical to std::T. 

17.4.3.2 Headers [lib.alt.headers] 
1 Ifa file witha nameequivalenttothe derived file namefor oneoftheC++ Standard Libraryheaders is not provided 
aspartoftheimplementation,andafilewiththat nameisplacedinanyofthe standardplacesfora sourcefiletobe 
included(16.2), the behavioris undefined. 

17.4.3.3 Derived classes [lib.derived.classes] 
1 Virtual member function signatures definedfora base classin theC++ Standard library may be overridden in a derived 
class definedin the program(10.3). 

17.4.3.4 Replacement functions [lib.replacement.functions] 
1 Clauses18 through27 and Annex Ddescribe the behaviorof numerousfunctions definedby theC++ Standard Library. 
Under some circumstances, however, certain of these function descriptions also apply to replacement functions defined 
in the program(17.1). 

173) Such names are also reserved in namespace ::std (17.4.3.1).
174) The list of such reserved names includes errno, declared or defined in <cerrno>.
175) The list of such reserved function signatures with external linkage includes setjmp(jmp_buf), declared or defined in <csetjmp>, and va_


end(va_list), declared or defined in <cstdarg>. 
176) The function signatures declared in <cwchar> and <cwctype> are always reserved, notwithstanding the restrictions imposed in subclause 4.5.1 
of Amendment1to theCStandard for these headers. 
177) These types are clock_t, div_t, FILE, fpos_t, lconv, ldiv_t, mbstate_t, ptrdiff_t, sig_atomic_t, size_t, time_t, tm, va_list, 
wctrans_t, wctype_t, and wint_t. 

Draft 


385 Library introduction 17.4 Library-wide requirements 

2 AC++ program may provide the definition for anyof eight dynamic memory allocation function signatures declared in 
header <new> (3.7.3, clause 18): 
— operator new(std::size_t) 
— operator new(std::size_t, const std::nothrow_t&) 
— operator new[](std::size_t) 
— operator new[](std::size_t, const std::nothrow_t&) 
— operator delete(void*) 
— operator delete(void*, const std::nothrow_t&) 
— operator delete[](void*) 
— operator delete[](void*, const std::nothrow_t&) 

3 The program’s definitions are usedinsteadof thedefaultversions suppliedby the implementation(18.4). Such replacementoccurspriorto program startup(3.2,3.6).The program’s definitionsshallnotbe specifiedas inline. No 
diagnostic is required. 

17.4.3.5 Handler functions [lib.handler.functions] 
1 TheC++ Standard Library provides default versions of the following handler functions (clause 18): 

— unexpected_handler 
— terminate_handler 
2 AC++programmay installdifferent handler functions duringexecution,by supplyinga pointertoa function definedin 
the program or the library as an argument to (respectively): 

— set_new_handler 
— set_unexpected 
— set_terminate
SEE ALSO: subclauses18.4.2, Storage allocation errors, and 18.6, Exception handling.
17.4.3.6 Other functions [lib.res.on.functions] 
1 In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), theC++ Standard Library depends on components suppliedbyaC++ program. If these components 
do not meet their requirements, the Standard places no requirements on the implementation. 

2 In particular, the effects are undefined in the following cases: 

— for replacement functions(18.4.1),if the installed replacement function does not implement the semanticsof the 
applicable Required behavior: paragraph. 
Draft 


17.4 Library-wide requirements Library introduction 386 
— for handler functions(18.4.2.2, 18.6.3.1, 18.6.2.2), if the installed handler function does not implement the semantics of the applicable Required behavior: paragraph 
— for types used as template arguments when instantiating a template component, if the operations on the type do 
not implement the semantics of the applicable Requirements subclause(20.1.6, 23.1, 24.1, 26.1). Operations on 
such types can reportafailureby throwing anexception unless otherwise specified. 
— if anyreplacement function or handler function or destructor operation throws an exception, unless specifically 
allowed in the applicable Required behavior: paragraph. 
— if an incomplete type(3.9)is used asa template argument when instantiatinga template component. 
17.4.3.7 Function arguments [lib.res.on.arguments] 
1 Each of the following statements applies to all arguments to functions defined in the C++ Standard Library, unless 
explicitly stated otherwise. 

— Ifanargumenttoa functionhasaninvalidvalue(suchasavalue outsidethe domainofthe function,ora pointer 
invalid for its intended use), the behavior is undefined. 
— Ifa functionargumentis describedasbeinganarray,thepointeractuallypassedtothe functionshallhaveavalue 
such that all address computations and accesses to objects (that would be valid if the pointer did point to the first 
elementof such an array)areinfactvalid. 
17.4.3.8 Required paragraph [lib.res.on.required] 
1 Violation of the preconditions specified in a function’s Required behavior: paragraph results in undefined behavior 
unless the function’s Throws: paragraph specifies throwing an exception when the precondition is violated. 

17.4.4 Conforming implementations [lib.conforming] 
1 This subclause describesthe constraints upon,and latitudeof, implementationsoftheC++Standard library. The followingsubclauses describe an implementation’s useof headers(17.4.4.1), macros(17.4.4.2), global functions(17.4.4.3), 
member functions(17.4.4.4), reentrancy(17.4.4.5), access specifiers(17.4.4.6), class derivation(17.4.4.7), andexceptions(17.4.4.8). 

17.4.4.1 Headers [lib.res.on.headers] 
1 AC++header may include otherC++headers.178) 

2 Certain types and macros are defined in more than one header. For such an entity, a second or subsequent header that 
also definesitmaybe included afterthe headerthatprovidesits initial definition(3.2). 

3 Header inclusion is limited as follows: 

— TheC headers( .h form, described in Annex D, D.5)shall include only their corresponding C++ header, as 
described above(17.4.1.2). 
178)C++headers must includeaC++header that contains anyneeded definition(3.2). 

Draft 


387 Library introduction 17.4 Library-wide requirements 

17.4.4.2 Restrictions on macro definitions [lib.res.on.macro.definitions] 
1 The names or global function signatures described in 17.4.1.1 are reserved to the implementation. 

2 All object-like macros definedbythe StandardClibraryand describedin thisclauseasexpandingto integral constant 
expressions are also suitable for use in #if preprocessing directives, unless explicitly stated otherwise. 

17.4.4.3 Global or non-member functions [lib.global.functions] 
1 Itis unspecified whetheranyglobalor non-member functionsintheC++Standard Library are defined as inline (7.1.2). 

2Acalltoaglobalornon-member functionsignature describedin clauses18through27andAnnex Dbehavesthesame 
as if the implementation declares no additional global or non-member function signatures.179) 

3 Aglobal or non-member function cannot be declared by the implementation as taking additional default arguments. 

4 Unless otherwise specified, no global or non-member function in the standard library shall use a function from another 
namespace which is found through argument-dependent name lookup (3.4.2). [Note: The phrase “unless otherwise 
specified” is intended to allow argument-dependent lookup in cases like that of ostream_iterators: Effects: 

*out_stream << value;
if ( delim != 0)
*out_stream << delim;
return (* this );


— end note ] 
17.4.4.4 Member functions [lib.member.functions] 
1 Itis unspecified whether any member functionsin theC++ Standard Library are defined as inline (7.1.2). 
2 An implementation can declare additional non-virtual member function signatures within a class: 

— by adding arguments with default values to a member function signature;180) The same latitude does not extend 
to the implementation of virtual or global or non-member functions, however. 
— by replacing a member function signature with default values by two or more member function signatures with 
equivalent behavior; 
— by adding a member function signature for a member function name. 
3 Acalltoa member function signature describedintheC++ Standard library behaves the same as if the implementation 
declares no additional member function signatures.181) 

179)AvalidC++program always calls the expected library global or non-member function. An implementation may also define additional global or 

non-member functions thatwould otherwise notbe calledbyavalidC++program. 
180) Hence, taking the address of a member function has an unspecified type. 
181)AvalidC++program always calls the expected library member function, or one with equivalent behavior. An implementation may also define 

additional member functions thatwould otherwise notbe calledbyavalidC++program. 

Draft 


17.4 Library-wide requirements Library introduction 388 
17.4.4.5 Reentrancy [lib.reentrancy] 
1 Whichof the functionsin theC++ Standard Library are not reentrant subroutines is implementation-defined. 

17.4.4.6 Protection within classes [lib.protection.within.classes] 
1 Itis unspecified whethera function signatureor class describedin clauses 18 through27and Annex Disa friend of 
another classin theC++ Standard Library. 

17.4.4.7 Derived classes [lib.derivation] 
1 Itis unspecified whethera classin theC++Standard Library is itself derived from other classes (with names reserved to 
the implementation). 

2 Certain classes definedintheC++ Standard Library are derived from other classesin theC++ Standard Library: 

— Itis unspecified whethera class describedin theC++ Standard Library as derived from another class is derived 
from that class directly, or through other classes (with names reserved to the implementation) that are derived 
from the specified base class. 
In anycase: 

— Abase class described asvirtual is always virtual; 
— Abase class described asvirtual"" non-is never virtual; 
— Unless explicitly stated otherwise, types with distinct names are distinct types.182) 
17.4.4.8 Restrictions on exception handling [lib.res.on.exception.handling] 
1 Anyof the functions defined in theC++ Standard Library can reportafailureby throwing anexceptionof the type(s) 
described in their Throws: paragraph and/or their exception-specification (15.4). An implementation may strengthen 
the exception-specification for a non-virtual function by removing listed exceptions.183) 

2 Noneofthe functionsfromthe StandardClibrary shallreportan errorbythrowinganexception,184) unlessit callsa 
program-supplied function that throws an exception.185) 

No destructor operation definedintheC++StandardLibrarywillthrowanexception.Anyother functions definedinthe 
C++ Standard Library that do not have an exception-specification may throw implementation-defined exceptions unless 
otherwise specified.186) An implementation may strengthen this implicit exception-specification by adding an explicit 

187)

one.

182) An implicit exception to this rule are types described as synonyms for basic integral types, such as size_t (18.1)andstreamoff (27.4.1). 

183) That is, an implementation of the function will have an explicit exception-specification that lists fewer exceptions than those specified in this 
International Standard. It may not, however, change the types of exceptions listed in the exception-specification from those specified, nor add others. 
184) Thatis,theClibrary functionsallhavea throw() exception-specification. This allows implementations to make performance optimizations 

based on the absence of exceptions at runtime. 
185) The functions qsort() and bsearch() (25.4)meet this condition. 
186)In particular,they canreportafailureto allocate storagebythrowinganexceptionoftype bad_alloc, or a class derived from bad_alloc 

(18.4.2.1). Library implementations are encouraged (but not required) to report errors by throwing exceptions from (or derived from) the standard 
exception classes(18.4.2.1, 18.6, 19.1). 
187) That is, an implementation may provide an explicit exception-specification that defines the subset of “any” exceptions thrown by that function. 
This impliesthatthe implementationmaylist implementation-definedtypesinsuchan exception-specification. 

Draft 


Chapter 18 Language support library 
[lib.language.support] 

1 This clause describes the function signatures that are called implicitly, and the types of objects generated implicitly, 
during theexecutionof someC++ programs. It also describes the headers that declare these function signatures and 
define anyrelated types. 

2 The following subclauses describe common type definitions used throughout the library,characteristics of the predefined 
types, functions supporting start and terminationofaC++ program, support for dynamic memory management, support 
for dynamictype identification, supportforexception processing,and other runtime support,as summarizedinTable 15. 

Table 15: Language support library summary 

Subclause Header(s) 
18.1 Types <cstddef> 
18.2 Implementation properties 
<limits> 
<climits> 
<cfloat> 
18.3 Start and termination <cstdlib> 
18.4 Dynamic memory management <new> 
18.5 Type identification <typeinfo> 
18.6 Exception handling <exception> 
18.7 Other runtime support 
<cstdarg> 
<csetjmp> 
<ctime> 
<csignal> 
<cstdlib> 

18.1 Types [lib.support.types] 
1 Common definitions. 
Header <cstddef> (Table 16). 

2 The contents are the same as the StandardClibrary header <stddef.h>, with the following changes: 

3 The macro NULL is an implementation-definedC++ null pointer constantinthis International Standard(4.10).188) 

188) Possible definitions include 0 and 0L,but not (void*)0. 


18.2 Implementation properties Language support library 390 
Table 16: Header<cstddef> synopsis 

Type Name(s) 
Macros: NULL offsetof 
Types: ptrdiff_t size_t 

The macrooffsetofacceptsarestrictedsetoftypeargumentsinthisInternationalStandard.IftypeisnotaPOD structure 
ora POD union (clause9)the results are undefined. The resultofapplying the offsetof macrotoa field thatisa static 
data member or a function member is undefined. The macro offsetof(type, member-designator)accepts a restricted 
set of type arguments in this International Standard. If type is nota POD structure ora POD union (clause9), the results are undefined.189) Theexpression offsetof(type, member-designator)is never type-dependent(14.6.2.2)and it is 
value-dependent(14.6.2.3)if and only if type is dependent. The result of applying the offsetof macro to a field that is 

a static data member or a function member is undefined. 

SEE ALSO: subclause 5.3.3, Sizeof, subclause 5.7, Additive operators, subclause 12.5, Free store, and ISO C subclause 7.1.6. 

18.2 Implementation properties [lib.support.limits] 
1 The headers <limits>, <climits>, and <cfloat> supply characteristics of implementation-dependent fundamental 
types(3.9.1). 

18.2.1 Numeric limits [lib.limits] 
1 The numeric_limits component providesaC++ program with information about various properties of the implementation’s representation of the fundamental types. 
2 Specializations shall be provided for each fundamental type, both floating point and integer, including bool. The 
member is_specialized shall be true for all such specializations of numeric_limits. 
3 For all members declaredstatic const in the numeric_limits template, specializations shall define these values in 
such a way that they are usable as integral constant expressions. 
4 Non-fundamental standard types, such as complex<T> (26.2.2), shall not have specializations. 
Header <limits> synopsis 

namespace std {
template <class T> class numeric_limits;
enum float_round_style;
enum float_denorm_style;


template <> class numeric_limits <bool >; 

template <> class numeric_limits <char >;
template <> class numeric_limits <signed char >;
template <> class numeric_limits <unsigned char >;
template <> class numeric_limits <wchar _t >;


189)Note that offsetof is required to work as specified even if unary operator& is overloaded for anyof the types involved. 

Draft 


391 Language support library 18.2 Implementation properties 

template <> class numeric_limits <short >;
template <> class numeric_limits <int >;
template <> class numeric_limits <long >;
template <> class numeric_limits <unsigned short >;
template <> class numeric_limits <unsigned int >;
template <> class numeric_limits <unsigned long >;


template <> class numeric_limits <float >; 

template <> class numeric_limits <double >; 

template <> class numeric_limits <long double >; 

} 

18.2.1.1 Class template numeric_limits [lib.numeric.limits] 
namespace std { 

template <class T> class numeric_limits { 

public : 

static const bool is_specialized = false ; 

static T min () throw (); 

static T max () throw (); 

static const int digits = 0; 

static const int digits10 = 0; 

static const bool is_signed = false ; 

static const bool is_integer = false ; 

static const bool is_ exact = false ; 

static const int radix = 0; 

static T epsilon () throw (); 

static T round_error() throw(); 

static const int min_exponent = 0; 

static const int min_exponent10 = 0; 

static const int max_exponent = 0; 

static const int max_exponent10 = 0; 

static const bool has_infinity = false;
static const bool has_quiet_NaN = false;
static const bool has_signaling_NaN = false;
static const float_denorm_style has_denorm = denorm_absent;
static const bool has_denorm_loss = false;
static T infinity () throw ();
static T quiet_NaN () throw ();
static T signaling_NaN() throw();
static T denorm_min() throw();


static const bool is_iec559 = false ; 

static const bool is_bounded = false ; 

static const bool is_modulo = false ; 

static const bool traps = false ; 

Draft 


18.2 Implementation properties Language support library 392 
} 
s t a t i c 
s t a t i c 
} ; 
c o n s t 
c o n s t 
b o o l t i n y n e s s _ b e f o r e = f a l s e ; 
f l o a t _ r o u n d _ s t y l e r o u n d _ s t y l e = r o u n d _ t o w a r d _ z e r o ; 
1 The member is_specialized makes it possible to distinguish between fundamental types, which have specializations, 
and non-scalar types, which do not. 
2 The default numeric_limits<T> template shall have all members, but with 0 or false values. 
18.2.1.2 numeric_limits members [lib.numeric.limits.members] 
1 
s t a t i c T m i n ( ) t h r o w ( ) ; 
Minimum finite value.190) 
2 For floating types with denormalization, returns the minimum positive normalized value. 
3 Meaningful for all specializations in which is_bounded != false,oris_bounded == false && is_signed 
== false. 
4 
s t a t i c T m a x ( ) t h r o w ( ) ; 
Maximum finite value.191) 
5 Meaningful for all specializations in which is_bounded != false. 
s t a t i c c o n s t i n t d i g i t s ; 
6 Number of radix digits that can be represented without change. 
7 
8 
For built-in integer types, the number of non-sign bits in the representation. 
For floating point types, the number ofradix digits in the mantissa.192) 
9 
s t a t i c c o n s t i n t d i g i t s 1 0 ; 
Number of base 10 digits that can be represented without change.193) 
10 Meaningful for all specializations in which is_bounded != false. 
s t a t i c c o n s t b o o l i s _ s i g n e d ; 
11 True if the type is signed. 
12 Meaningful for all specializations. 
s t a t i c c o n s t b o o l i s _ i n t e g e r ; 
13 True if the type is integer. 
14 Meaningful for all specializations. 
190) Equivalent to CHAR_MIN, SHRT_MIN, FLT_MIN, DBL_MIN, etc. 
191) Equivalent to CHAR_MAX, SHRT_MAX, FLT_MAX, DBL_MAX, etc. 
192) Equivalent to FLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG. 
193) Equivalent to FLT_DIG, DBL_DIG, LDBL_DIG. 
Draft 


393 Language support library 18.2 Implementation properties 

static const bool is_exact ; 

15 Trueifthetype usesanexact representation. Allintegertypesareexact,butnotallexacttypesareinteger.For 
example, rational and fixed-exponent representations areexactbut not integer. 

16 Meaningful for all specializations. 

static const int radix ; 
17 For floating types, specifies the base or radix of the exponent representation (often 2).194) 
18 For integer types, specifies the base of the representation.195) 
19 Meaningful for all specializations. 

static T epsilon () throw (); 
20 Machine epsilon: the difference between1and the leastvalue greater than1thatis representable.196) 
21 Meaningful for all floating point types. 

static T round_error () throw (); 

22 Measure of the maximum rounding error.197) 

static const int min_exponent; 

23 Minimum negativeinteger such that radix raisedtothepowerofonelessthanthatintegerisanormalized floating 
point number.198) 

24 Meaningful for all floating point types. 

static const int min_exponent10 ; 

25 Minimum negative integer such that 10 raised to that power is in the range of normalized floating point numbers.199) 

26 Meaningful for all floating point types. 

static const int max_exponent; 

27 Maximum positive integer such that radix raised to the power one less than that integer is a representable finite 
floating point number.200) 

28 Meaningful for all floating point types. 

static const int max_exponent10 ; 

194) Equivalent to FLT_RADIX. 

195) Distinguishes types with bases other than2(e.g. BCD). 

196) Equivalent to FLT_EPSILON, DBL_EPSILON, LDBL_EPSILON. 

197) Rounding erroris describedin ISO/IEC 10967-1 Language independent arithmetic -Part1Section 5.2.8 and AnnexARationale Section A.5.2.8 

-Rounding constants. 

198) Equivalent to FLT_MIN_EXP, DBL_MIN_EXP, LDBL_MIN_EXP. 

199) Equivalent to FLT_MIN_10_EXP, DBL_MIN_10_EXP, LDBL_MIN_10_EXP. 

200) Equivalent to FLT_MAX_EXP, DBL_MAX_EXP, LDBL_MAX_EXP. 

Draft 


18.2 Implementation properties Language support library 394 
29 Maximum positive integer such that 10 raised to that power is in the range of representable finite floating point 
numbers.201) 

30 Meaningful for all floating point types. 

static const bool has_infinity; 

31 True if the type has a representation for positive infinity.
32 Meaningful for all floating point types.
33 Shall be true for all specializations in which is_iec559 != false.


static const bool has_quiet_NaN; 

34 True if the type has a representation for a quiet (non-signaling) “Not a Number.”202)
35 Meaningful for all floating point types.
36 Shall be true for all specializations in which is_iec559 != false.


static const bool has_signaling_NaN; 

37 True if the type has a representation for a signaling “Not a Number.”203)
38 Meaningful for all floating point types.
39 Shall be true for all specializations in which is_iec559 != false.


static const float_denorm_style has_denorm; 

40 denorm_present ifthetypeallows denormalizedvalues(variable numberofexponentbits)204),denorm_absent 
ifthetype does not allowdenormalizedvalues,and denorm_indeterminate if it is indeterminate at compile time 
whether the type allows denormalized values. 

41 Meaningful for all floating point types. 

static const bool has_denorm_loss; 

42 Trueif lossof accuracyisdetected asa denormalization loss, rather than as an inexact result.205) 

static T infinity () throw (); 

43 Representation of positive infinity, if available.206) 

44 Meaningful for all specializations for which has_infinity 
is_iec559 != false. 

static T quiet_NaN () throw (); 

201) Equivalent to FLT_MAX_10_EXP, DBL_MAX_10_EXP, LDBL_MAX_10_EXP.
202) Requiredby LIA-1.
203) Requiredby LIA-1.
204) Requiredby LIA-1.
205) See IEC 559.
206) Requiredby LIA-1.


Draft 

!= false. Required in specializations for which 


395 Language support library 18.2 Implementation properties 

45 Representation of a quiet “Not a Number,” if available.207) 

46 Meaningful for all specializationsforwhich has_quiet_NaN != false. Required in specializations for which 
is_iec559 != false. 

static T signaling_NaN () throw (); 

47 Representation of a signaling “Not a Number,” if available.208) 

48 Meaningful for all specializationsforwhich has_signaling_NaN != false. Required in specializations for 
which is_iec559 != false. 

static T denorm_min () throw (); 
49 Minimum positive denormalized value.209) 
50 Meaningful for all floating point types. 
51 In specializations for which has_denorm == false, returns the minimum positive normalized value. 

static const bool is_iec559; 
52 True if and only if the type adheres to IEC 559 standard.210) 
53 Meaningful for all floating point types. 

static const bool is_bounded; 

54 Trueif the setofvalues representableby the typeis finite.211) Allbuilt-in types are bounded, this memberwould 
befalse for arbitrary precision types. 

55 Meaningful for all specializations. 

static const bool is_modulo; 

56 Trueifthetypeis modulo.212)Atypeis moduloifitis possibletoaddtwopositive numbersandhavea resultthat 
wraps around to a third number that is less. 

57 Generally, this is false for floating types, true for unsigned integers, and true for signed integers on most 
machines. 

58 Meaningful for all specializations. 

static const bool traps ; 

59 true if trapping is implemented for the type.213) 

60 Meaningful for all specializations. 

207) Requiredby LIA-1.
208) Requiredby LIA-1.
209) Requiredby LIA-1.
210) International Electrotechnical Commission standard 559 is the same as IEEE 754.
211) Requiredby LIA-1.
212) Requiredby LIA-1.
213) Requiredby LIA-1.


Draft 


18.2 Implementation properties Language support library 396 
static const bool tinyness_before; 

61 true if tinyness is detected before rounding.214) 

62 Meaningful for all floating point types. 

static const float_round_style round_style; 

63 The rounding style for the type.215) 

64 Meaningful for all floating point types. Specializations for integer types shall return round_toward_zero. 

18.2.1.3 Typefloat_round_style [lib.round.style] 
namespace std { 

enum float_round_style {
round_indeterminate = -1,
round_toward_zero = 0,
round_to_nearest = 1,
round_toward_infinity = 2,
round_toward_neg_infinity = 3


};
}


1 The rounding mode for floating point arithmetic is characterized by the values: 

— round_indeterminate if the rounding style is indeterminable 
— round_toward_zero if the rounding style is toward zero 
— round_to_nearest if the rounding style is to the nearest representable value 
— round_toward_infinity if the rounding style is towardinfinity 
— round_toward_neg_infinity if the rounding style is toward negative infinity 
18.2.1.4 Typefloat_denorm_style [lib.denorm.style] 
namespace std { 

enum float_denorm_style {
denorm_indeterminate = -1,
denorm_absent = 0,
denorm_present = 1


};
}


1 The presence or absenceofdenormalization(variable numberofexponent bits)is characterizedby thevalues: 

— denorm_indeterminate if it cannot be determined whether or not the type allows denormalized values 
214) Refer to IEC 559. Required by LIA-1.
215) Equivalent to FLT_ROUNDS. Requiredby LIA-1.


Draft 


397 Language support library 18.2 Implementation properties 

— denorm_absent if the type does not allow denormalized values 
— denorm_present if the type does allow denormalized values 
18.2.1.5 numeric_limits specializations [lib.numeric.special] 
1 All members shall be provided for all specializations. However, many values are only required to be meaningful under certain conditions (for example, epsilon() is only meaningful if is_integer is false). Any value that is not 
“meaningful” shallbe setto0 or false. 

2 [Example: 

namespace std {
template <> class numeric_limits <float > {
public :


static const bool is_specialized = true ; 

inline static float min() throw() { return 1.17549435E-38F; }
inline static float max() throw() { return 3.40282347E+38F; }


static const int digits = 24;
static const int digits10 = 6;


static const bool is_signed = true ;
static const bool is_integer = false ;
static const bool is_ exact = false ;


static const int radix = 2;
inline static float epsilon() throw() { return 1.19209290E-07F; }
inline static float round_error() throw() { return 0.5F; }


static const int min_exponent = -125;
static const int min_exponent10 = -37;
static const int max_exponent = +128;
static const int max_exponent10 = + 38;


static const bool has_infinity = true;
static const bool has_quiet_NaN = true;
static const bool has_signaling_NaN = true;
static const float_denorm_style has_denorm = denorm_absent;
static const bool has_denorm_loss = false;


inline static float infinity () throw () { return ...; }
inline static float quiet_NaN () throw () { return ...; }
inline static float signaling_NaN () throw () { return ...; }
inline static float denorm_min () throw () { return min (); }


static const bool is_iec559 = true ;
static const bool is_bounded = true ;
static const bool is_modulo = false ;


Draft 


18.2 Implementation properties Language support library 398 
static const bool traps = true ;
static const bool tinyness_before = true;


static const float_round_style round_style = round_to_nearest; 
}; 
} 

— end example ]
The specialization for bool shall be provided as follows:
namespace std {
template <> class numeric_limits <bool > {
public :


static const bool is_specialized = true ;
static bool min () throw () { return false ; }
static bool max () throw () { return true ; }


static const int digits = 1;
static const int digits10 = 0;
static const bool is_signed = false ;
static const bool is_integer = true;
static const bool is_ exact = true ;
static const int radix = 2;
static bool epsilon () throw () { return 0; }
static bool round_error () throw () { return 0; }


static const int min_exponent = 0;
static const int min_exponent10 = 0;
static const int max_exponent = 0;
static const int max_exponent10 = 0;


static const bool has_infinity = false;
static const bool has_quiet_NaN = false;
static const bool has_signaling_NaN = false;
static const float_denorm_style has_denorm = denorm_absent;
static const bool has_denorm_loss = false;
static bool infinity () throw () { return 0; }
static bool quiet_NaN () throw () { return 0; }
static bool signaling_NaN () throw () { return 0; }
static bool denorm_min () throw () { return 0; }


static const bool is_iec559 = false ;
static const bool is_bounded = true;
static const bool is_modulo = false ;


static const bool traps = false ;
static const bool tinyness_before = false;
static const float_round_style round_style = round_toward_zero;


};
}


Draft 


399 Language support library 18.3 Start and termination 
1 
18.2.2 CLibrary 
Header <climits> (Table 17) 
[lib.c.limits] 
Table 17: Header<climits> synopsis 

Type Name(s) 
Values: 
CHAR_BIT INT_MAX LONG_MIN SCHAR_MIN UCHAR_MAX USHRT_MAX 
CHAR_MAX INT_MIN MB_LEN_MAX SHRT_MAX UINT_MAX 
CHAR_MIN LONG_MAX SCHAR_MAX SHRT_MIN ULONG_MAX 

2 The contents are the same as the StandardClibrary header <limits.h>. 
3 Header <cfloat> (Table 18) 

Table 18: Header<cfloat> synopsis 


Type Name(s) 
Values: 

DBL_DIG DBL_MIN_EXP FLT_MIN_10_EXP LDBL_MAX_10_EXP 
DBL_EPSILON FLT_DIG FLT_MIN_EXP LDBL_MAX_EXP 
DBL_MANT_DIG FLT_EPSILON FLT_RADIX LDBL_MIN 
DBL_MAX FLT_MANT_DIG FLT_ROUNDS LDBL_MIN_10_EXP 
DBL_MAX_10_EXP FLT_MAX LDBL_DIG LDBL_MIN_EXP 
DBL_MAX_EXP FLT_MAX_10_EXP LDBL_EPSILON 
DBL_MIN FLT_MAX_EXP LDBL_MANT_DIG 
DBL_MIN_10_EXP FLT_MIN LDBL_MAX 


4 The contents are the same as the StandardClibrary header <float.h>. 
SEEALSO: ISOCsubclause 7.1.5, 5.2.4.2.2, 5.2.4.2.1. 

18.3 Start and termination [lib.support.start.term] 
1 Header <cstdlib> (partial),Table 19: 

Table 19: Header<cstdlib> synopsis 

Type Name(s) 
Macros: EXIT_FAILURE EXIT_SUCCESS 
Functions: abort atexit exit 

2 
3 
The contents are the same as the Standard Clibrary header <stdlib.h>, with the following changes: 
a b o r t ( v o i d ) 
The function abort() has additional behavior in this International Standard: 
Draft 


18.3 Start and termination Language support library 400 
— The program is terminated without executing destructors for objects of automatic or static storage duration 
and without calling the functions passed to atexit() (3.6.3). 
extern "C" int atexit(void (* f )( void ))
extern "C++" int atexit(void (* f )( void ))


4 Effects: The atexit() functions register the function pointed to by f , to be called without arguments at normal 
program termination. 
5 For the execution of a function registered withatexit(), if control leaves the functionbecause it provides no 
handler for a thrown exception, terminate() is called(18.6.3.3). 
6 Implementation limits: The implementation shall support the registration of at least 32 functions. 
7 Returns: The atexit() function returns zeroif the registration succeeds, nozeroifitfails. 

exit ( int status ) 

8 The function exit() has additional behavior in this International Standard: 

— First, objects with static storage duration are destroyed and functions registeredbycalling atexit are called. 
Non-local objects with static storage duration are destroyed in the reverse order of the completion of their 
constructor. (Automatic objects are not destroyed as a result of calling exit().)216) Functions registered 
with atexit are called in the reverse order of their registration, except that a function is called after any 
previously registered functions that had already been called at the time it was registered.217) A function 
registered with atexit before a non-local object obj1 of static storage duration is initialized will not be 
called until obj1’s destruction has completed. Afunction registered withatexit after a non-local object 
obj2 of static storage durationis initialized will be called before obj2’s destruction starts. Alocal static 
object obj3 isdestroyedatthesametimeitwouldbeifafunctioncallingthe obj3 destructor were registered 
with atexit at the completion of the obj3 constructor. 
— Next, all open C streams (as mediated by the function signatures declared in <cstdio>)with unwritten 
buffered data are flushed, all open C streams are closed, and all files created by calling tmpfile() are 
removed.218) 
— Finally, control is returned to the host environment. If status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If status is EXIT_FAILURE, an 
implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined.219) 
9 The function exit() never returns to its caller. 

SEEALSO: subclauses3.6, 3.6.3, ISOCsubclause 7.10.4. 

216) Objects with automatic storage duration are all destroyed in a program whose function main() contains no automatic objects andexecutesthe 

call to exit(). Control can be transferred directly to such a main() by throwing an exception that is caught in main(). 
217)Afunctionis called forevery timeitis registered. 
218) AnyCstreams associated with cin, cout, etc(27.3)are flushed and closed when static objects are destroyed in the previous phase. The function 

tmpfile() is declared in <cstdio>.
219) The macros EXIT_FAILURE and EXIT_SUCCESS are defined in <cstdlib>.


Draft 


401 Language support library 18.4 Dynamic memory management 

18.4 Dynamic memory management [lib.support.dynamic] 
1 The header <new> defines several functions that manage the allocation of dynamic storage in a program. It also defines 
components for reporting storage management errors. 

Header <new> synopsis 

namespace std { 

class bad_alloc ; 

struct nothrow_t {}; 

extern const nothrow_t nothrow ; 

typedef void (* new_handler )(); 

new_handler set_new_handler(new_handler new_p ) throw (); 

} 

void * operator new ( std :: size_ t size ) throw ( std :: bad_alloc );
void * operator new ( std :: size_ t size , const std :: nothrow_t &) throw ();
void operator delete ( void * ptr ) throw ();
void operator delete ( void * ptr , const std::nothrow_t&) throw();
void * operator new []( std :: size_ t size ) throw ( std :: bad_alloc );
void * operator new []( std :: size_ t size , const std :: nothrow_t &) throw ();
void operator delete []( void * ptr ) throw ();
void operator delete []( void * ptr , const std :: nothrow_t &) throw ();


void * operator new ( std :: size_ t size , void * ptr ) throw ();
void * operator new []( std :: size_ t size , void * ptr ) throw ();
void operator delete ( void * ptr , void *) throw ();
void operator delete []( void * ptr , void *) throw ();


SEE ALSO: 1.7, 3.7.3, 5.3.4, 5.3.5, 12.5, 20.4. 

18.4.1 Storage allocation and deallocation [lib.new.delete] 
1 Exceptwhere otherwise specified,theprovisionsof(3.7.3)applytothelibraryversionsofoperator new and operator delete. 

18.4.1.1 Single-objectforms [lib.new.delete.single] 
void* operator new(std::size_t size ) throw ( std :: bad_alloc ); 

1 Effects:The allocation function (3.7.3.1)called by a new-expression (5.3.4)to allocate size bytes of storage 
suitably aligned to represent anyobject of that size. 

2 Replaceable: aC++ program may define a function with this function signature that displaces the default version 
definedby theC++Standard library. 

3 Required behavior: Return a non-null pointer to suitably aligned storage(3.7.3), or else throw a bad_alloc 
exception. This requirementis binding on a replacement version of this function. 

4 Default behavior: 

— Executes a loop: Within the loop, the function first attempts to allocate the requested storage. Whether the 
attemptinvolvesacalltotheStandardClibrary function malloc is unspecified. 
Draft 


18.4 Dynamic memory management Language support library 402 
— Returns a pointer to the allocated storage if the attempt is successful. Otherwise, if the last argument to 
set_new_handler() was a null pointer, throw bad_alloc. 
— Otherwise, the function calls the current new_handler (18.4.2.2). If the called function returns, the loop 
repeats. 
— The loop terminates when an attempt to allocate the requested storage is successful or when a called new_
handler function does not return. 
void* operator new(std::size_t size , const std :: nothrow_t &) throw (); 

5 Effects: Same as above, except that it is called by a placement version of a new-expression when aC++ program 
prefers a null pointer resultas an error indication, instead of a bad_alloc exception. 

6 Replaceable: aC++ program may define a function with this function signature that displaces the default version 
definedby theC++Standard library. 

7 Required behavior: Return a non-null pointer to suitably aligned storage(3.7.3), or else return a null pointer. 
This nothrow version of operator new returns a pointer obtained as if acquired from the ordinary version. This 
requirement is binding on a replacement version of this function. 

8 Default behavior: 

— Executes a loop: Within the loop, the function first attempts to allocate the requested storage. Whether the 
attemptinvolvesacalltotheStandardClibrary function malloc is unspecified. 
— Returns a pointer to the allocated storage if the attempt is successful. Otherwise, if the last argument to 
set_new_handler() was a null pointer, return a nullpointer. 
— Otherwise, the function calls the current new_handler (18.4.2.2). If the called function returns, the loop 
repeats. 
— The loop terminates when an attempt to allocate the requested storage is successful or when a called new_
handler function does not return. If the called new_handler function terminates by throwing a bad_alloc 
exception, the function returns a null pointer. 
9 [Example: 

T* p1 = new T; // throws bad_alloc if it fails
T* p2 = new(nothrow) T; // returns 0 if it fails


— end example ] 
void operator delete ( void * ptr ) throw ();
void operator delete ( void * ptr , const std :: nothrow_t &) throw ();


10 Effects: The deallocation function (3.7.3.2)calledbyadelete-expression to render the value of ptr invalid. 

11 Replaceable: aC++ program may define a function with this function signature that displaces the default version 
definedby theC++Standard library. 

12 Requires: the value of ptr is null or the value returned by an earlier call to the default operator new(std:: 
size_t) or operator new(std::size_t,const std::nothrow_t&). 

13 Default behavior: 

Draft 


403 Language support library 18.4 Dynamic memory management 

— For a null value ofptr , do nothing. 
— Anyother value of ptr shall be a value returned earlier by a call to the default operator new, which was 
not invalidated by an intervening call to operator delete(void*) (17.4.3.7). For such a non-null value 
of ptr , reclaims storage allocatedby the earlier call to the default operator new. 
14 Remarks: Itis unspecifiedunderwhat conditionspartorallofsuch reclaimedstorageis allocatedbyasubsequent 
call to operator new or anyof calloc, malloc, or realloc, declared in <cstdlib>. 

18.4.1.2 Arrayforms [lib.new.delete.array] 
void * operator new []( std :: size_t size ) throw ( std :: bad_alloc ); 

1 Effects: The allocation function (3.7.3.1)called by the array form of anew-expression (5.3.4)to allocate size 
bytes of storage suitably aligned to represent anyarray object of that size or smaller.220) 

2 Replaceable: aC++ program can define a function with this function signature that displaces the default version 
definedby theC++Standard library. 

3 Required behavior: Same as for operator new(std::size_t). This requirement is binding on a replacement 
version of this function. 

4 Default behavior: Returns operator new(size ). 

void * operator new []( std :: size_t size , const std :: nothrow_t &) throw (); 

5 Effects: Same as above, except that it is called by a placement version of a new-expression when aC++ program 
prefers a null pointer resultas an error indication, instead of a bad_alloc exception. 

6 Replaceable: aC++ program can define a function with this function signature that displaces the default version 
definedby theC++Standard library. 

7 Required behavior: Same as for operator new(std::size_t,const std::nothrow_t&). This nothrowversion of operator new[] returns a pointer obtained as if acquired from the ordinary version. 

8 Default behavior: Returns operator new(size ,nothrow). 

void operator delete []( void * ptr ) throw ();
void operator delete []( void * ptr , const std :: nothrow_t &) throw ();


9 Effects: The deallocation function (3.7.3.2)called by the array form ofa delete-expression to render the value of 
ptr invalid. 

10 Replaceable: aC++ program can define a function with this function signature that displaces the default version 
definedby theC++Standard library. 

11 Requires: the value of ptr is null or the value returned by an earlier call to operator new[](std::size_t) or 
operator new[](std::size_t,const std::nothrow_t&). 

12 Default behavior: Calls operator delete(ptr ) or operator delete(ptr , std::nothrow) respectively. 

220) It is not the direct responsibility of operator new[](std::size_t) or operator delete[](void*) to note the repetition count or element 
size of the array. Those operations are performed elsewhere in the array new and delete expressions. The array new expression, may, however, 
increase the size argument to operator new[](std::size_t) to obtain space to store supplemental information. 

Draft 


18.4 Dynamic memory management Language support library 404 
18.4.1.3 Placementforms [lib.new.delete.placement] 
1 These functions are reserved,aC++ program may not define functions that displace theversionsin the StandardC++ 
library(17.4.3). The provisions of(3.7.3)do not apply to these reserved placement forms of operator new and 
operator delete. 

void* operator new(std::size_t size , void * ptr ) throw ();
2 Returns: ptr .
3 Remarks: Intentionally performs no other action.
4[Example: This can be useful for constructing an object at a known address:


void * place = operator new ( sizeof ( Something ));
Something* p = new (place) Something();


— end example ] 
void * operator new []( std :: size_t size , void * ptr ) throw ();
5 Returns: ptr .
6 Remarks: Intentionally performs no other action.


void operator delete ( void * ptr , void *) throw (); 

7 Effects: Intentionally performs no action. 

8 Remarks: Default function called when anypart of the initialization in a placement new expression that invokes 
the library’s non-array placement operator new terminates by throwing an exception(5.3.4). 

void operator delete []( void * ptr , void *) throw (); 

9 Effects: Intentionally performs no action. 

10 Remarks: Default function called when anypart of the initialization in a placement new expression that invokes 
the library’s array placement operator new terminatesby throwing anexception(5.3.4). 

18.4.2 Storage allocation errors [lib.alloc.errors] 
18.4.2.1 Class bad_alloc [lib.bad.alloc] 
namespace std {
class bad_alloc : public exception {
public :


bad_alloc () throw ();
bad_alloc(const bad_alloc&) throw();
bad_alloc& operator=(const bad_alloc&) throw();
virtual const char * what () const throw ();


};
}


Draft 


405 Language support library 18.5 Type identification 

1 The class bad_alloc defines the type of objects thrown as exceptions by the implementation to report a failure to 
allocate storage. 

bad_alloc() throw(); 
2 Effects: Constructs an object of class bad_alloc. 
3 Remarks: The result of calling what() on the newly constructed object is implementation-defined. 

bad_alloc ( const bad_alloc &) throw ();
bad_alloc & operator = ( const bad_alloc &) throw ();


4 Effects: Copies an object of class bad_alloc. 

virtual const char * what () const throw (); 

5 Returns: An implementation-defined NTBS. 

18.4.2.2 Typenew_handler [lib.new.handler] 
typedef void (* new_handler )(); 

1 The type of a handler function to be called by operator new() or operator new[]() (18.4.1)when they 
cannot satisfy a request for additional storage. 

2 Required behavior: Anew_handler shall perform one of the following: 

— make more storage available for allocation and then return; 
— throw an exception of type bad_alloc or a class derived from bad_alloc; 
— call either abort() or exit(); 
18.4.2.3 set_new_handler [lib.set.new.handler] 
new_handler set_new_handler(new_handler new_p ) throw (); 
1 Effects: Establishes the function designatedby new_p as the current new_handler . 
2 Returns: 0on the first call, the previous new_handler on subsequent calls. 

18.5 Type identification [lib.support.rtti] 
1 The header <typeinfo> defines a type associated with type information generated by the implementation. It also 
defines two types for reportingdynamic type identification errors. 

Header <typeinfo> synopsis 

namespace std { 

class type_info ; 

class bad_cast ; 

class bad_typeid; 

} 

Draft 


18.5 Type identification Language support library 406 
SEE ALSO: 5.2.7, 5.2.8. 

18.5.1 Class type_info [lib.type.info] 
namespace std {
class type_info {
public :


virtual ~ type_info ();
bool operator ==( const type_info & rhs ) const ;
bool operator !=( const type_info & rhs ) const ;
bool before ( const type_info & rhs ) const ;
const char * name () const ;


private :
type_info(const type_info& rhs );
type_info& operator=(const type_info& rhs );


};
}


1 The class type_info describestype information generatedbythe implementation. Objectsofthis classeffectivelystore 
a pointer to a name for the type, and an encoded value suitable for comparing two types for equality or collating order. 
The names, encoding rule, and collating sequence for types are all unspecified and may differ between programs. 

bool operator == ( const type_info & rhs ) const ; 

2 Effects: Compares the current object with rhs .
3 Returns: true if the two values describe the same type.


bool operator != ( const type_info & rhs ) const ; 

4 Returns: !(*this == rhs ). 

bool before(const type_info& rhs ) const ; 

5 Effects: Compares the current object with rhs .
6 Returns: true if *this precedes rhs in the implementation’s collation order.


const char * name () const ; 

7 Returns: an implementation-defined NTBS. 

8 Remarks: The message maybea null-terminated multibyte string(17.3.2.1.3.2), suitable for conversion and display as a wstring (21.2, 22.2.1.4) 

type_info(const type_info& rhs );
type_info& operator= (const type_info& rhs );


9 Effects: Copies a type_info object. 

10 Remarks: Since the copyconstructor and assignment operator for type_info are private to the class, objects of 
this type cannot be copied. 

Draft 


407 Language support library 18.5 Type identification 

18.5.2 Class bad_cast [lib.bad.cast] 
namespace std {
class bad_cast : public exception {
public :


bad_cast () throw ();
bad_cast ( const bad_cast &) throw ();
bad_cast & operator =( const bad_cast &) throw ();
virtual const char * what () const throw ();


};
}


1 The class bad_cast defines the type of objects thrown as exceptions by the implementation to report the execution of 
an invalid dynamic-cast expression(5.2.7). 

bad _cast () throw (); 

2 Effects: Constructs an object of class bad_cast.
3 Remarks: The result of calling what() on the newly constructed object is implementation-defined.


bad_cast ( const bad_cast &) throw ();
bad_cast & operator = ( const bad_ cast &) throw ();


4 Effects: Copies an object of class bad_cast. 

virtual const char * what () const throw (); 

5 Returns: An implementation-defined NTBS. 

6 Remarks: The message maybea null-terminated multibyte string(17.3.2.1.3.2), suitable for conversion and display as a wstring (21.2, 22.2.1.4) 

18.5.3 Class bad_typeid [lib.bad.typeid] 
namespace std {
class bad_typeid : public exception {
public :


bad_typeid() throw();
bad_typeid(const bad_typeid&) throw();
bad_typeid& operator= (const bad_typeid&) throw();
virtual const char * what () const throw ();


};
}


1 The class bad_typeid defines the type of objects thrown as exceptions by the implementation to report a null pointer 
in a typeid expression(5.2.8). 

bad_typeid () throw (); 

2 Effects: Constructs an object of class bad_typeid.
3 Remarks: The result of calling what() on the newly constructed object is implementation-defined.


Draft 


18.6 Exception handling Language support library 408 
bad_typeid(const bad_typeid&) throw();
bad_typeid & operator = ( const bad_typeid &) throw ();


4 Effects: Copies an object of class bad_typeid. 

virtual const char * what () const throw (); 

5 Returns: An implementation-defined NTBS. 

6 Remarks: The message maybea null-terminated multibyte string(17.3.2.1.3.2), suitable for conversion and display as a wstring (21.2, 22.2.1.4) 

18.6 Exception handling [lib.support.exception] 
1 The header <exception> definesseveral typesandfunctions relatedtothe handlingofexceptionsinaC++ program. 
Header <exception> synopsis 

namespace std {
class exception ;
class bad_exception;


typedef void (* unexpected_handler )();
unexpected_handler set_unexpected(unexpected_handler f ) throw ();
void unexpected ();


typedef void (* terminate_handler )();
terminate_handler set_terminate(terminate_handler f ) throw ();
void terminate ();


bool uncaught_exception() throw();
}


SEE ALSO: 15.5. 

18.6.1 Class exception [lib.exception] 
namespace std {
class exception {
public :


exception () throw ();
exception(const exception&) throw();
exception& operator=(const exception&) throw();
virtual ~ exception () throw ();
virtual const char * what () const throw ();


};
}


1 The class exception defines the base class for the types of objects thrown as exceptions by C++ Standard library 
components, and certain expressions, to report errors detected during program execution. 

exception() throw(); 

Draft 


409 Language support library 18.6 Exception handling 

2 Effects: Constructs an object of class exception. 
3 Remarks: Does not throw anyexceptions. 

exception(const exception&) throw();
exception& operator= (const exception&) throw();


4 Effects: Copies an exception object.
5 Remarks: The effects of calling what() after assignment are implementation-defined.


virtual ~ exception () throw (); 

6 Effects: Destroys an object of class exception. 
7 Remarks: Does not throw anyexceptions. 

virtual const char * what () const throw (); 

8 Returns: An implementation-defined NTBS. 

9 Remarks: The message maybea null-terminated multibyte string(17.3.2.1.3.2), suitable for conversion and display as a wstring (21.2, 22.2.1.4). The return value remains valid until the exception object from which it is 
obtained is destroyed or a non-const member function of the exception object is called. 

18.6.2 Violatingexception-specifications [lib.exception.unexpected] 
18.6.2.1 Class bad_exception [lib.bad.exception] 
namespace std {
class bad_exception : public exception {
public :


bad_exception() throw();
bad_exception(const bad_exception&) throw();
bad_exception& operator= (const bad_exception&) throw();
virtual const char * what () const throw ();


};
}


1 The class bad_exception defines the typeof objects thrown as describedin(15.5.2). 

bad_exception () throw (); 

2 Effects: Constructs an object of class bad_exception.
3 Remarks: The result of calling what() on the newly constructed object is implementation-defined.


bad_exception(const bad_exception&) throw();
bad_exception& operator= (const bad_exception&) throw();


4 Effects: Copies an object of class bad_exception. 

virtual const char * what () const throw (); 

Draft 


18.6 Exception handling Language support library 410 
5 Returns: An implementation-defined NTBS. 

6 Remarks: The message maybea null-terminated multibyte string(17.3.2.1.3.2), suitable for conversion and display as a wstring (21.2, 22.2.1.4). 

18.6.2.2 Typeunexpected_handler [lib.unexpected.handler] 
typedef void (* unexpected_handler )(); 

1 The typeofa handler function tobe calledby unexpected() whena function attempts to throw anexception not 
listed in its exception-specification. 
2 Required behavior: An unexpected_handler shall not return. See also 15.5.2. 
3 Default behavior: The implementation’s default unexpected_handler calls terminate(). 

18.6.2.3 set_unexpected [lib.set.unexpected] 
unexpected_handler set_unexpected(unexpected_handler f ) throw (); 

1 Effects: Establishes the function designatedby f as the current unexpected_handler .
2 Requires: f shall not be a null pointer.
3 Returns: The previous unexpected_handler .


18.6.2.4 unexpected [lib.unexpected] 
void unexpected (); 

1 Called by the implementation when a function exits via an exception not allowed by its exception-specification 
(15.5.2). May also be called directly by the program. 

2 Effects: Calls the unexpected_handler function in effect immediately after evaluating the throw-expression 
(18.6.2.2), if called by the implementation, or calls the current unexpected_handler,if calledby the program. 

18.6.3 Abnormal termination [lib.exception.terminate] 
18.6.3.1 Typeterminate_handler [lib.terminate.handler] 
typedef void (* terminate_handler )(); 

1 The type of a handler function to be called by terminate() when terminating exception processing. 
2 Required behavior: A terminate_handler shall terminate execution of the program without returning to the 
caller. 
3 Default behavior: The implementation’s default terminate_handler calls abort(). 

Draft 


411 Language support library 18.7 Other runtime support 

18.6.3.2 set_terminate [lib.set.terminate] 
terminate_handler set_terminate(terminate_handler f ) throw (); 

1 Effects: Establishes the function designated by f as the current handler function for terminating exception processing. 

2 Requires: f shall not be a null pointer. 

3 Returns: The previous terminate_handler . 

18.6.3.3 terminate [lib.terminate] 
void terminate (); 

1 Calledby the implementation whenexception handling mustbe abandoned for anyof several reasons(15.5.1). 
May alsobe called directlyby the program. 

2 Effects: Calls the terminate_handler function in effect immediately after evaluating the throw-expression 
(18.6.3.1), if called by the implementation, or calls the current terminate_handler function, if called by the 
program. 

18.6.4 uncaught_exception [lib.uncaught] 
bool uncaught_exception () throw (); 

1 Returns: true after completing evaluation of a throw-expression until either completing initialization of the 
exception-declaration in the matching handler or entering unexpected() due to the throw; or after entering 
terminate() for any reason other than an explicit call to terminate(). [Note: This includes stack unwinding 
(15.2). — end note ] 

2 Remarks: When uncaught_exception() is true, throwing an exception can result in a call of terminate() 
(15.5.1). 

18.7 Other runtime support [lib.support.runtime] 
1 Headers <cstdarg> (variable arguments), <csetjmp> (nonlocal jumps), <ctime> (system clock clock(), time()), 
<csignal> (signal handling), and <cstdlib> (runtime environment getenv(), system()). 

Table 20: Header<cstdarg> synopsis 

Type Name(s) 
Macros: va_arg va_end va_start 
Type: va_list 

The contents of these headers are the same as the StandardClibrary headers <stdarg.h>, <setjmp.h>, <time.h>, 
<signal.h>, and <stdlib.h> respectively, with the following changes: 

Draft 


18.7 Other runtime support Language support library 412 
Table 21: Header<csetjmp> synopsis 

Type Name(s) 
Macro: setjmp 
Type: jmp_buf 
Function: longjmp 

Table 22: Header<ctime> synopsis 

Type Name(s) 
Macro: CLOCKS_PER_SEC 
Type: clock_t 
Function: clock 

Table 23: Header<csignal> synopsis 

Type Name(s) 
Macros: SIGABRT SIGILL SIGSEGV SIG_DFL 
SIG_IGN SIGFPE SIGINT SIGTERM SIG_ERR 
Type: sig_atomic_t 
Functions: raise signal 

Table 24: Header<cstdlib> synopsis 


Type Name(s) 
Functions: getenv system 


Draft 


413 Language support library 18.7 Other runtime support 

3 The restrictions that ISO C places on the second parameter to the va_start() macro in header <stdarg.h> are 
different in this International Standard. The parameter parmN is the identifier of the rightmost parameter in the variable 
parameter list of the function definition (the one just before the ...).221) If the parameter parmN is declared with 
a function, array, or reference type, or with a type that is not compatible with the type that results when passing an 
argument for which there is no parameter, the behavior is undefined. 

SEEALSO: ISOCsubclause 4.8.1.1. 

4 The function signature longjmp(jmp_buf jbuf , int val ) has more restricted behavior in this International Standard. If anyautomatic objects would be destroyedby a thrown exception transferring control to another (destination) 
point in the program, then a call to longjmp(jbuf , val ) at the throw point that transfers control to the same (destination) point has undefined behavior. 

SEEALSO: ISOCsubclause 7.10.4, 7.8, 7.6, 7.12. 

5 The common subsetoftheCandC++languages consistsofall declarations, definitions,andexpressionsthatmay appear 
ina well formedC++program andalsoina conformingCprogram.APOF (“plain old function”)isa function that uses 
only features from this common subset, and that does not directly or indirectly use anyfunction that is not a POF. All 
signal handlers shallhaveClinkage.APOF that couldbe used asa signal handlerina conformingCprogram does not 
produce undefined behavior when usedasa signal handlerinaC++ program. The behavior of anyother function used 
asa signal handlerinaC++ program is implementation-defined.222) 

221)Note that va_start is required to work as specified even if unary operator& is overloaded for the type of parmN. 
222) In particular, a signal handler using exception handling is very likely to have problems 

Draft 


18.7 Other runtime support Language support library 414 
Draft 


Chapter 19 Diagnostics library [lib.diagnostics]


1 This clause describes components thatC++ programs may use to detect and report error conditions. 

2 The following subclauses describe components for reporting severalkinds of exceptional conditions, documenting program assertions, anda globalvariable for error number codes, as summarizedinTable 25. 

Table 25: Diagnostics library summary 

Subclause Header(s) 
19.1 Exception classes <stdexcept> 
19.2 Assertions <cassert> 
19.3 Error numbers <cerrno> 

19.1 Exception classes [lib.std.exceptions] 
1 The StandardC++ library provides classes to be used to report certain errors(17.4.4.8)inC++ programs. In the error 
model reflected in these classes, errors are divided into two broad categories: logic errors and runtime errors. 

2 The distinguishingcharacteristic of logic errors is that they are due to errors in the internal logic of the program. In 
theory, they are preventable. 

3 By contrast, runtime errors are due to events beyond the scope of the program. They cannot be easily predicted in 
advance.The header <stdexcept> definesseveral typesof predefinedexceptionsfor reporting errorsinaC++program. 
Theseexceptions are relatedby inheritance. 

Header <stdexcept> synopsis 

namespace std { 

class logic_error;
class domain_error;
class invalid_argument;
class length_error;
class out_of_range;


class runtime_error;
class range_error;
class overflow_error;
class underflow_error;


} 

19.1.1 Class logic_error [lib.logic.error] 

19.1 Exception classes Diagnostics library 416 
namespace std {
class logic_error : public exception {
public :


explicit logic_error(const string& what_arg );
};
}


1 The class logic_error defines the type of objects thrown as exceptions to report errors presumably detectable before 
the program executes, such as violations of logical preconditions or class invariants. 

logic_error(const string& what_arg ); 

2 Effects: Constructs an object of class logic_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.2 Class domain_error [lib.domain.error] 
namespace std {
class domain_error : public logic_error {
public :


explicit domain_error(const string& what_arg );
};
}


1 The class domain_error defines the type of objects thrown as exceptions by the implementation to report domain 
errors. 

domain_error(const string& what_arg ); 

2 Effects: Constructs an object of class domain_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.3 Class invalid_argument [lib.invalid.argument] 
namespace std {
class invalid_argument : public logic_error {
public :


explicit invalid_argument(const string& what_arg );
};
}


1 The class invalid_argument defines the type of objects thrown as exceptions to report an invalid argument. 

invalid_argument(const string& what_arg ); 

2 Effects: Constructs an object of class invalid_argument. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

Draft 


417 Diagnostics library 19.1 Exception classes 

19.1.4 Class length_error [lib.length.error] 
namespace std {
class length_error : public logic_error {
public :


explicit length_error(const string& what_arg );
};
}


1 The class length_error defines the type of objects thrown as exceptions to report an attempt to produce an object 
whose length exceeds its maximum allowable size. 

length_error(const string& what_arg ); 

2 Effects: Constructs an object of class length_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.5 Class out_of_range [lib.out.of.range] 
namespace std {
class out_of_range : public logic_error {
public :


explicit out_of_range(const string& what_arg );
};
}


1 The class out_of_range definesthetypeofobjectsthrownasexceptionsto reportanargumentvaluenotinitsexpected 
range. 

out_of_range(const string& what_arg ); 
2 Effects: Constructs an object of class out_of_range. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.6 Class runtime_error [lib.runtime.error] 
namespace std {
class runtime_error : public exception {
public :


explicit runtime_error(const string& what_arg );
};
}


1 The class runtime_error defines the type of objects thrown as exceptions to report errors presumably detectable only 
when the program executes. 

runtime_error(const string& what_arg ); 

Draft 


19.1 Exception classes Diagnostics library 418 
2 Effects: Constructs an object of class runtime_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.7 Class range_error [lib.range.error] 
namespace std {
class range_error : public runtime_error {
public :


explicit range_error(const string& what_arg );
};
}


1 The class range_error definesthetypeofobjectsthrownasexceptionstoreportrangeerrorsin internal computations. 

range_error(const string& what_arg ); 

2 Effects: Constructs an object of class range_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.8 Class overflow_error [lib.overflow.error] 
namespace std {
class overflow_error : public runtime_error {
public :


explicit overflow_error(const string& what_arg );
};
}


1 The class overflow_error defines the type of objects thrown as exceptions to report an arithmetic overflow error. 

overflow_error ( const string & what_arg ); 
2 Effects: Constructs an object of class overflow_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.1.9 Class underflow_error [lib.underflow.error] 
namespace std {
class underflow_error : public runtime_error {
public :


explicit underflow_error(const string& what_arg );
};
}


1 The class underflow_error defines the type of objects thrown as exceptions to report an arithmetic underflow error. 

underflow_error(const string& what_arg ); 

Draft 


419 Diagnostics library 19.2 Assertions 

2 Effects: Constructs an object of class underflow_error. 
3 Postcondition:strcmp(what(), what_arg .c_str()) == 0. 

19.2 Assertions [lib.assertions] 
1 Provides macros for documentingC++ program assertions, and for disabling the assertion checks. 
Header <cassert> (Table 26): 

Table 26: Header<cassert> synopsis 

Type Name(s) 
Macro: assert 

2 The contents are the same as the StandardClibrary header <assert.h>. 
SEEALSO: ISOCsubclause 7.2. 

19.3 Error numbers [lib.errno] 
1 Header <cerrno> (Table 27): 

Table 27: Header<cerrno> synopsis 

Type Name(s)
Macros: EDOM EILSEQ ERANGE errno


The contents are the same as the StandardClibrary header <errno.h>, except that errno shall be defined as a macro. 
SEEALSO: ISOCsubclause 7.1.4, 7.2,Amendment1subclause 4.3. 

Draft 


19.3 Error numbers Diagnostics library 420 
Draft 


Chapter 20 General utilities library [lib.utilities]


1 This clause describes components usedby other elementsofthe StandardC++ library. These components may also be 
used byC++programs. 

2 The following clauses describe utility and allocator requirements, utility components, function objects, dynamic memory 
management utilities, anddate/time utilities, as summarizedinTable 28. 

Table 28: General utilitieslibrary summary 

Subclause Header(s) 
20.1 Requirements 
20.2 Utility components <utility> 
20.3 Function objects <functional> 
<memory> 
20.4 Memory <cstdlib> 
<cstring> 
20.5 Date and time <ctime> 

20.1 Requirements [lib.utility.requirements] 
1 20.1 describes requirements on template arguments. 20.1.1 through 20.1.4 describe requirements on types used to 
instantiate templates. 20.1.6 describes the requirements on storage allocators. 
20.1.1 Equality comparison [lib.equalitycomparable] 
1 InTable 29, T isatypetobe suppliedbyaC++program instantiating a template, a, b and c are values of type const T. 
Table 29:EqualityComparable requirements 

expression return type requirement 

a == b convertible to bool == is an equivalence relation, that is, it satisfies the 
following properties: 

— For alla, a == a. 
— If a == b, then b == a. 
— If a == b and b == c, then a == c. 

20.1 Requirements General utilities library 422 
20.1.2 Less than comparison [lib.lessthancomparable] 
In the followingTable 30, T isatypetobe suppliedbyaC++ program instantiating a template, a and b are values of 
type T. 

Table 30:LessThanComparable requirements 

expression return type requirement 
a<b convertible to bool < is a strict weak ordering relation(25.3) 

20.1.3 Copy construction [lib.copyconstructible] 
In the followingTable 31, T isa typetobe suppliedbyaC++ program instantiating a template, t is a value of type T, 
and u is a value of type const T. 

Table 31:CopyConstructible requirements 

expression return type requirement 
T(t) t is equivalent to T(t) 
T(u) u is equivalent to T(u) 
t.T() 
&t T* denotes the address of t 
&u const T* denotes the address of u 

20.1.4 Swapping [lib.swappable] 
In the followingTable 32, T isa non-consttypetobe suppliedbyaC++ program instantiating a template, and t and u 
are values of type T. 

Table 32:Swappable requirements 

expression return type post-condition 

swap(t,u) void t has thevalue originally heldby u, and u has thevalue originally 
held by t 

TheSwappable requirementis metby satisfying one or moreof the following conditions: 

— T is Swappable if T satisfies the CopyConstructible requirments(20.1.3)and the Assignable requirements(23.1); 
— T is Swappable if a namespace scope function named swap exists in the same namespace as the definition of T, 
such that the expression swap(t,u) isvalid and has the semantics describedinTable 32. 
Draft 


423 General utilities library 20.1 Requirements 

20.1.5 Default construction [lib.default.con.req] 
1 The default constructor is not required. Certain container class member function signatures specify the default constructor as a default argument. T() shallbea well-defined expression(8.5)if oneof those signaturesis called using the 
default argument(8.3.6). 

20.1.6 Allocatorrequirements [lib.allocator.requirements] 
1 The library describes a standard set of requirements for allocators, which are objects that encapsulate the information 
about an allocation model. This information includes the knowledge of pointer types, the type of their difference, the 
type of the size of objects in this allocation model, as well as the memory allocation and deallocation primitives for it. 
All of the containers (clause 23)are parameterized in terms of allocators. 

2 Table33 describes the requirements on types manipulated through allocators. All the operations on the allocators are 
expectedtobe amortized constant time.Table 34 describesthe requirementson allocator types. 

Table 33: Descriptive variable definitions 

Variable Definition 
T, U anynon-const, non-reference type 
X an Allocator class for type T 
Y the corresponding Allocator class for type U 
t a value of type const T& 
a, a1, a2 values of type X& 
b a value of type Y 
p a value of type X::pointer, obtained by calling a1.allocate, 
where a1 == a 
q a value of type X::const_pointer obtained by conversion from 
a value p. 
r a value of type X::reference obtained by the expression *p. 
s a value of type X::const_reference obtained by the 
expression *q or by conversion from a value r. 
u a value of type Y::const_pointer obtained by calling 
Y::allocate, or else 0. 
n a value of type X::size_type. 

Draft 


20.1 Requirements General utilities library 424 
Table 34: Allocator requirements 

expression return type assertion/note 
pre/post-condition 
X::pointer Pointer to T. 
X::const_pointer Pointer to const T. 
X::reference T& 
X::const_reference T const& 
X::value_type Identical to T 
X::size_type unsigned integral 
type 
a type that can represent the size of the largest 
object in the allocation model. 
X::difference_type signed integral type a type that can represent the difference between 
anytwo pointers in the allocation model. 
typename X::template 
rebind<U>::other 
Y For allU (including T), Y::template 
rebind<T>::other is X. 
a.address(r) X::pointer 
a.address(s) X::const_pointer 
a.allocate(n) 
a.allocate(n,u) 
X::pointer Memory is allocated for n objects of type T but 
objects are not constructed. allocate may raise 
an appropriate exception. The result is a random 
access iterator.223) [Note: If n == 0, the return 
value is unspecified. — end note ] 
a.deallocate(p,n) (not used) All n T objects in the area pointed to by p shall be 
destroyed prior to this call. n shall match the value 
passed to allocate to obtain this memory. Does 
not throw exceptions. [ Note: p shall not be null. 
— end note ] 
a.max_size() X::size_type the largest value that can meaningfully be passed 
to X::allocate() 
a1 == a2 bool returns true iffstorage allocated from each can be 
deallocated via the other. 
a1 != a2 bool same as !(a1 == a2) 
X() creates a default instance. [ Note: a destructor is 
assumed. — end note ] 
X a(b); post: Y(a) == b 
a.construct(p,t) (not used) Effect: ::new((void*)p) T(t) 
a.destroy(p) (not used) Effect: ((T*)p)->T() 

3 The member class template rebind in the table above is effectively a typedef template: if the name Allocator is bound 
to SomeAllocator<T>, then Allocator::rebind<U>::other is the same type as SomeAllocator<U>. 

4 Implementations of containers described in this International Standard are permitted to assume that their Allocator 
template parameter meetsthe followingtwo additional requirementsbeyond thoseinTable 34. 

223)It is intended that a.allocate be an efficient means of allocating a single object of type T, even when sizeof(T) is small. That is, there is no 
need for a container to maintain its own “free list”. 

Draft 


425 General utilities library 20.2 Utility components 

— All instancesofagivenallocatortypearerequiredtobe interchangeableandalwayscompareequaltoeachother. 
— The typedef members pointer, const_pointer, size_type, and difference_type are required to be T*, T 
const*, std::size_t, and std::ptrdiff_t, respectively. 
5 Implementors areencouraged to supplylibraries that can accept allocators thatencapsulate more general memory models 
and that support non-equal instances. In such implementations, anyrequirements imposed on allocators by containers 
beyond those requirements that appear in Table 34, and the semantics of containers and algorithms when allocator 
instances compare non-equal, are implementation-defined. 

20.2 Utility components [lib.utility] 
1 This subclause contains some basic function and class templates that are used throughout the rest of the library. 

Header <utility> synopsis 

namespace std { 

// 20.2.1, operators: 

namespace rel_ops { 

template<class T> bool operator! =(const T&, const T&); 

template <class T> bool operator > (const T&, const T&); 

template <class T> bool operator < =(const T&, const T&); 

template <class T> bool operator > =(const T&, const T&); 

} 

// 20.2.2, pairs: 

template < class T1 , class T2 > struct pair ;
template < class T1 , class T2 >
bool operator==(const pair<T1,T2>&, const pair<T1,T2>&);
template < class T1 , class T2 >
bool operator< (const pair<T1,T2>&, const pair<T1,T2>&);
template < class T1 , class T2 >
bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&);
template < class T1 , class T2 >
bool operator> (const pair<T1,T2>&, const pair<T1,T2>&);
template < class T1 , class T2 >
bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&);
template < class T1 , class T2 >
bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&);
template <class T1, class T2> pair<T1,T2> make_pair(T1, T2);
}


20.2.1 Operators [lib.operators] 
1 To avoid redundant definitions ofoperator!= out of operator== and operators >, <=, and >= out of operator<, the 
library provides the following: 

template <class T> bool operator!=(const T& x, const T& y); 
2 Requires: TypeT is EqualityComparable (20.1.1). 
3 Returns: !(x == y). 

Draft 


20.2 Utility components General utilities library 426 
template <class T> bool operator >(const T& x, const T& y); 

4 Requires: TypeT is LessThanComparable (20.1.2). 

5 Returns: y<x. 

template <class T> bool operator <=(const T& x, const T& y); 

6 Requires: TypeT is LessThanComparable (20.1.2). 

7 Returns: !(y < x). 

template <class T> bool operator >=(const T& x, const T& y); 

8 Requires: TypeT is LessThanComparable (20.1.2). 
9 Returns: !(x < y). 
10 In this library, whenever a declaration is provided for an operator!=, operator>, operator>=, or operator<=, and 
requirements and semantics are not explicitly provided, the requirements and semantics are as specified in this clause. 

20.2.2 Pairs [lib.pairs] 
1 Thelibraryprovidesatemplatefor heterogeneouspairsofvalues.Thelibraryalsoprovidesamatching functiontemplate 
to simplify their construction. 

template < class T1 , class T2 > 

struct pair { 

typedef T1 first_type; 

typedef T2 second_type; 

T1 first ; 

T2 second ; 

pair (); 

pair ( const T1 & x , const T2 & y ); 

template < class U , class V > pair ( const pair <U , V >& p ); 

}; 

pair (); 

2 Effects: Initializes its members asifimplemented: pair() : first(), second() {} 

pair ( const T1 & x , const T2 & y ); 

3 Effects: The constructor initializes first with x and second with y . 

template < class U , class V > pair ( const pair <U , V >& p ); 

4 Effects: Initializes members from the corresponding members of the argument, performing implicit conversions 
as needed. 

template < class T1 , class T2 >
bool operator= =(const pair<T1, T2>& x , const pair <T1 , T2 >& y );


Draft 


427 General utilities library 20.3 Function objects 

5 Returns: x.first == y.first && x.second == y.second. 

template < class T1 , class T2 >
bool operator<(const pair<T1, T2>& x , const pair <T1 , T2 >& y );


6 Returns: x.first < y.first || (!(y.first < x.first) && x.second < y.second). 

template < class T1 , class T2 >
pair<T1, T2> make_pair(T1 x , T2 y );


7 Returns: pair<T1, T2>(x, y).224) 

8[Example: In place of: 
return pair <int , double >(5 , 3.1415926); // explicit types 

aC++ program may contain: 

return make_pair (5 , 3.1415926); // types are deduced 

— end example ] 
20.3 Function objects [lib.function.objects] 
1 Function objects are objects with an operator() defined. In the places where one would expect to pass a pointer to 
a function to an algorithmic template (clause 25), the interface is specified to accept an object with an operator() 
defined.Thisnotonlymakesalgorithmic templatesworkwith pointersto functions,butalso enablesthemtoworkwith 
arbitrary function objects. 

2 Header <functional> synopsis 

namespace std { 

// 20.3.1, base: 

template <class Arg, class Result> struct unary_function;
template <class Arg1 , class Arg2 , class Result > struct binary_function;


// 20.3.2, arithmetic operations: 

template < class T > struct plus ;
template < class T > struct minus ;
template <class T> struct multiplies;
template < class T > struct divides ;
template < class T > struct modulus ;
template < class T > struct negate ;


// 20.3.3, comparisons: 

template < class T > struct equal_to ;
template <class T> struct not_equal_to;
template < class T > struct greater ;
template < class T > struct less ;
template <class T> struct greater_equal;


224) According to(12.8), an implementation is permitted to not perform a copyof an argument, thus avoiding unnecessary copies. 

Draft 


20.3 Function objects General utilities library 428 
template <class T> struct less_equal; 

// 20.3.4, logical operations: 

template <class T> struct logical_and; 
template <class T> struct logical_or; 
template <class T> struct logical_not; 

// 20.3.5, negators: 

template <class Predicate > class unary_negate; 
template < class Predicate > 

unary_negate < Predicate > not1 ( const Predicate &); 
template <class Predicate > class binary_negate; 
template < class Predicate > 

binary_negate < Predicate > not2 ( const Predicate &); 

// 20.3.6, binders: 

template < class Operation > class binder1st ; 
template <class Operation , class T> 

binder1st <Operation > bind1st(const Operation&, const T&); 
template < class Operation > class binder2nd ; 
template <class Operation , class T> 

binder2nd <Operation > bind2nd(const Operation&, const T&); 

// 20.3.7, adaptors: 

template <class Arg, class Result> class pointer_to_unary_function; 
template < class Arg , class Result > 
pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg)); 
template < class Arg1 , class Arg2 , class Result > 
class pointer_to_binary_function; 
template < class Arg1 , class Arg2 , class Result > 
pointer_to_binary_function <Arg1,Arg2,Result> 
ptr_fun ( Result (*)( Arg1 , Arg2 )); 

// 20.3.8, adaptors: 

template < class S , class T > class mem_fun_t ;
template < class S , class T , class A > class mem_fun1_t ;
template <class S, class T>


mem_ fun _t <S,T> mem_fun(S (T::*f)()); 
template <class S, class T, class A> 

mem _fun1_t <S,T,A> mem_fun(S (T::*f)(A)); 
template <class S, class T> class mem_fun_ref_t; 
template <class S, class T, class A> class mem_fun1_ref_t; 
template <class S, class T> 

mem _fun_ref_t <S,T> mem_fun_ref(S (T::*f)()); 
template <class S, class T, class A> 
mem_fun1_ref_t <S,T,A> mem_fun_ref(S (T::*f)(A)); 

template <class S, class T> class const_mem_fun_t;
template <class S, class T, class A> class const_mem_fun1_t;
template <class S, class T>


Draft 


429 General utilities library 20.3 Function objects 

const_mem_ fun_t <S,T> mem_fun(S (T::*f)() const);
template <class S, class T, class A>


const_ mem_fun1_t <S,T,A> mem_fun(S (T::*f)(A) const);
template <class S, class T> class const_mem_fun_ref_t;
template <class S, class T, class A> class const_mem_fun1_ref_t;
template <class S, class T>


const_mem_fun_ref_t <S,T> mem_fun_ref(S (T::*f)() const);
template <class S, class T, class A>
const_mem_fun1_ref_t <S,T,A> mem_fun_ref(S (T::*f)(A) const);
}


3[Example: If aC++program wants to have a by-element addition of two vectors a and b containing double and put the 
result into a, it can do: 

transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double >()); 

— end example ] 
4[Example: To negate every element ofa: 
transform(a.begin(), a.end(), a.begin(), negate <double >()); 

— end example ] 
5 To enable adaptors and other components to manipulate function objects that take one or two arguments it is required 
that the function objects correspondingly provide typedefs argument_type and result_type for function objects that 
take one argument and first_argument_type, second_argument_type, and result_type for function objects that 
take two arguments. 

20.3.1 Base [lib.base] 
1 The following classes are provided to simplify the typedefs of the argument and result types: 

template < class Arg , class Result > 

struct unary_function {
typedef Arg argument_type;
typedef Result result_type;


}; 

template < class Arg1 , class Arg2 , class Result > 

struct binary_function {
typedef Arg1 first_argument_type;
typedef Arg2 second_argument_type;
typedef Result result_type;


}; 

20.3.2 Arithmetic operations [lib.arithmetic.operations] 
1 The library provides basic function object classes for allof the arithmetic operatorsin the language(5.6, 5.7). 

template <class T> struct plus : binary _function <T,T,T> {
T operator()(const T& x , const T& y ) const ;
};


Draft 


20.3 Function objects General utilities library 430 
2 operator() returns x + y . 

template <class T> struct minus : binary_function <T,T,T> {
T operator()(const T& x , const T& y ) const ;
};


3 operator() returns x -y . 

template <class T> struct multiplies : binary_function <T,T,T> {
T operator()(const T& x , const T& y ) const ;
};


4 operator() returns x * y . 

template <class T> struct divides : binary_function <T,T,T> {
T operator()(const T& x , const T& y ) const ;
};


5 operator() returns x / y . 

template <class T> struct modulus : binary_function <T,T,T> {
T operator()(const T& x , const T& y ) const ;
};


6 operator() returns x % y . 

template <class T> struct negate : unary_function <T,T> {
T operator()(const T& x ) const ;
};


7 operator() returns -x . 

20.3.3 Comparisons [lib.comparisons] 
1 The library provides basic function object classes for all of the comparison operators in the language(5.9, 5.10). 

template <class T> struct equal_to : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


2 operator() returns x == y . 

template <class T> struct not_equal_to : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


3 operator() returns x != y . 

template <class T> struct greater : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


4 operator() returns x > y . 

Draft 


431 General utilities library 20.3 Function objects 

template <class T> struct less : binary _function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


5 operator() returns x < y . 

template <class T> struct greater_equal : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


6 operator() returns x >= y . 

template <class T> struct less_equal : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


7 operator() returns x <= y . 

8 For templatesgreater, less, greater_equal, and less_equal, the specializations for anypointer type yield a total 
order,evenif thebuilt-in operators <, >, <=, >= do not. 

20.3.4 Logical operations [lib.logical.operations] 
1 The library provides basic function object classes for allof the logical operatorsinthe language(5.14, 5.15, 5.3.1). 

template <class T> struct logical_and : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


2 operator() returns x && y . 

template <class T> struct logical_or : binary_function <T,T,bool > {
bool operator()(const T& x , const T& y ) const ;
};


3 operator() returns x || y . 

template <class T> struct logical_not : unary_function <T,bool > {
bool operator()(const T& x ) const ;
};


4 operator() returns !x . 

20.3.5 Negators [lib.negators] 
1 Negators not1 and not2 takea unary anda binary predicate, respectively, and return their complements(5.3.1). 

template < class Predicate >
class unary_negate
: public unary _function<typename Predicate::argument_type,bool> {
public :
explicit unary_negate(const Predicate& pred );


Draft 


20.3 Function objects General utilities library 432 
bool operator()(const typename Predicate::argument_type& x ) const ;
};


2 operator() returns !pred (x ). 

template < class Predicate >
unary _negate < Predicate > not1 ( const Predicate & pred );


3 Returns: unary_negate<Predicate>(pred ). 

template < class Predicate >
class binary_negate
: public binary_function < typename Predicate :: first_argument_type ,
typename Predicate::second_argument_type , bool > {


public :
explicit binary_negate(const Predicate& pred );
bool operator()(const typename Predicate::first_argument_type& x ,


const typename Predicate::second_argument_type& y ) const ;
};


4 operator() returns !pred (x ,y ). 

template < class Predicate >
binary_negate < Predicate > not2 ( const Predicate & pred );


5 Returns: 

binary _negate < Predicate >( pred ). 

20.3.6 Binders [lib.binders] 
1 Binders bind1st and bind2nd take a function object f of two arguments and a value x and return a function object of 
one argument constructed out of f with the first or second argument correspondingly bound to x. 

20.3.6.1 Class template binder1st [lib.binder.1st] 
template < class Operation >
class binder1st
: public unary _function <typename Operation::second_argument_type ,
typename Operation :: result_type > {


protected :
Operation op;
typename Operation::first_argument_type value;


public :
binder1st ( const Operation & x ,
const typename Operation::first_argument_type& y );
typename Operation::result_type


operator()(const typename Operation::second_argument_type& x ) const ; 
typename Operation::result_type 
operator()(typename Operation::second_argument_type& x ) const ;
};
Draft 


433 General utilities library 20.3 Function objects 

1 The constructor initializes op with x and value with y . 
2 operator() returns op(value,x ). 

20.3.6.2 bind1st [lib.bind.1st] 
template <class Operation , class T>
binder1st < Operation > bind1st ( const Operation & op , const T& x );


1 Returns: binder1st<Operation>(op , typename Operation::first_argument_type(x )). 

20.3.6.3 Class template binder2nd [lib.binder.2nd] 
template < class Operation > 

class binder2nd 

: public unary _function <typename Operation::first_argument_type , 

typename Operation :: result_type > { 

protected : 

Operation op; 

typename Operation::second_argument_type value; 

public : 

binder2nd ( const Operation & x , 

const typename Operation::second_argument_type& y ); 

typename Operation::result_type 

operator()(const typename Operation::first_argument_type& x ) const ; 
typename Operation::result_type 
operator()(typename Operation::first_argument_type& x ) const ;
};
1 The constructor initializes op with x and value with y . 
2 operator() returns op(x ,value). 

20.3.6.4 bind2nd [lib.bind.2nd] 
template <class Operation , class T>
binder2nd < Operation > bind2nd ( const Operation & op , const T& x );


1 Returns: binder2nd<Operation>(op , typename Operation::second_argument_type(x )). 
2[Example: 

find_if(v.begin(), v.end(), bind2nd(greater<int>(), 5)); 

finds the first integer in vector v greater than 5; 

find_if(v.begin(), v.end(), bind1st(greater<int>(), 5)); 

finds the first integer in v less than 5. — end example ] 

Draft 


20.3 Function objects General utilities library 434 
20.3.7 Adaptorsfor pointers to functions [lib.function.pointer.adaptors] 
1 To allow pointers to (unary and binary) functions to work with function adaptors the library provides: 

template < class Arg , class Result >
class pointer_to_unary_function : public unary_ function <Arg , Result > {
public :


explicit pointer_to_unary_function(Result (* f )( Arg ));
Result operator ()( Arg x ) const ;
};


2 operator() returns f (x ). 

template < class Arg , class Result >
pointer_to_unary_function <Arg , Result > ptr_fun(Result (* f )( Arg ));


3 Returns: pointer_to_unary_function<Arg, Result>(f ). 

template < class Arg1 , class Arg2 , class Result >
class pointer_to_binary_function :
public binary_function<Arg1,Arg2,Result> {


public :
explicit pointer_to_binary_function(Result (* f )( Arg1 , Arg2 ));
Result operator ()( Arg1 x , Arg2 y ) const ;


}; 

4 operator() returns f (x ,y ). 

template < class Arg1 , class Arg2 , class Result >
pointer_to_binary_function <Arg1,Arg2,Result>
ptr_fun ( Result (* f )( Arg1 , Arg2 ));


5 Returns: pointer_to_binary_function<Arg1,Arg2,Result>(f ). 

6[Example: 

int compare(const char*, const char*);
replace_if(v.begin(), v.end(),
not1(bind2nd(ptr _fun(compare), "abc")), "def");


replaces each abc with def in sequence v. — end example ] 

20.3.8 Adaptorsfor pointers to members [lib.member.pointer.adaptors] 
1 The purpose of the following is to provide the samefacilities for pointer to members as those provided for pointers to 
functions in 20.3.7. 

template <class S, class T> class mem_fun_t
: public unary_function <T*, S> {


public :
explicit mem_fun_t(S (T::*p)());
S operator()(T* p) const;


Draft 


435 General utilities library 20.3 Function objects 

}; 

2 mem_fun_t calls the member functionitis initialized withgivena pointer argument. 

template <class S, class T, class A> class mem_fun1_t
: public binary_function <T*, A, S> {


public :
explicit mem_fun1_t(S (T::*p)(A));
S operator()(T* p, A x) const;


}; 

3 mem_fun1_t calls the member function it is initialized with given a pointer argument and an additional argument 
of the appropriate type. 

template <class S, class T> mem _fun _t <S,T>
mem_fun(S (T::*f)());
template <class S, class T, class A> mem_ fun1 _t <S,T,A>
mem_fun(S (T::*f)(A));


4 mem_fun(&X::f) returns an object through which X::f can be called given a pointer to an X followed by the 
argument required for f (if any). 

template <class S, class T> class mem_fun_ref_t
: public unary_function <T , S > {


public :
explicit mem_fun_ref_t(S (T::*p)());
S operator()(T& p) const;


}; 

5 mem_fun_ref_t calls the member function it is initialized with given a reference argument. 

template <class S, class T, class A> class mem_fun1_ref_t
: public binary_function <T , A , S > {


public :
explicit mem_fun1_ref_t(S (T::*p)(A));
S operator()(T& p, A x) const;


}; 

6 mem_fun1_ref_t calls the member function it is initialized with given a reference argument and an additional 
argument of the appropriate type. 

template <class S, class T> mem_fun _ref _t <S,T>
mem_fun_ref(S (T::*f)());
template <class S, class T, class A> mem_fun1_ref _t <S,T,A>
mem_fun_ref(S (T::*f)(A));


7 mem_fun_ref(&X::f) returns an object through which X::f canbe calledgivena referencetoan X followedby 
the argument required for f (if any). 

template <class S, class T> class const_mem_fun_t
: public unary_function <const T*, S> {
public :
explicit const_mem_fun_t(S (T::*p)() const);


Draft 


20.3 Function objects General utilities library 436 
S operator()(const T* p) const;
};


8 const_mem_fun_t calls the member functionitis initialized withgivena pointer argument. 

template <class S, class T, class A> class const_mem_fun1_t
: public binary_function <const T*, A, S> {


public :
explicit const_mem_fun1_t(S (T::*p)(A) const);
S operator()(const T* p, A x) const;


}; 

9 const_mem_fun1_t calls the member functionitisinitialized withgivena pointer argument and an additional 
argument of the appropriate type. 

template <class S, class T> const_mem_fun_t <S,T>
mem_fun(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_t <S,T,A>
mem_fun(S (T::*f)(A) const);


10 mem_fun(&X::f) returns an object through which X::f can be called given a pointer to an X followed by the 
argument required for f (if any). 

template <class S, class T> class const_mem_fun_ref_t
: public unary_function <T , S > {


public :
explicit const_mem_fun_ref_t(S (T::*p)() const);
S operator()(const T& p) const;


}; 

11 const_mem_fun_ref_t calls the member function it is initialized with given a reference argument. 

template <class S, class T, class A> class const_mem_fun1_ref_t
: public binary_function <T , A , S > {


public :
explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
S operator()(const T& p, A x) const;


}; 

12 const_mem_fun1_ref_t calls the member function it is initialized with given a reference argument and an 
additional argument of the appropriate type. 

template <class S, class T> const_mem_fun_ref_t <S,T>
mem_fun_ref(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_ref_t <S,T,A>
mem_fun_ref(S (T::*f)(A) const);


13 mem_fun_ref(&X::f) returns an object through which X::f canbe calledgivena referencetoan X followedby 
the argument required for f (if any). 

Draft 


437 General utilities library 20.4 Memory 

20.4 Memory [lib.memory] 
1 Header <memory> synopsis 

namespace std { 

// 20.4.1, the default allocator: 

template <class T> class allocator; 

template <> class allocator <void >; 

template <class T, class U> 

bool operator ==( const allocator <T >& , const allocator <U >&) throw (); 

template <class T, class U> 

bool operator !=( const allocator <T >& , const allocator <U >&) throw (); 

// 20.4.2, raw storage iterator: 

template <class OutputIterator , class T> class raw_storage_iterator; 

// 20.4.3, temporarybuffers: 

template <class T>
pair <T*,ptrdiff _t > get_temporary_buffer(ptrdiff_t n );
template <class T>
void return_temporary_buffer(T* p );


// 20.4.4, specialized algorithms: 

template < class InputIterator , class ForwardIterator > 
ForwardIterator 
uninitialized_copy ( InputIterator first , InputIterator last , 
ForwardIterator result ); 
template < class ForwardIterator , class T > 
void uninitialized_fill(ForwardIterator first , ForwardIterator last , 
const T & x ); 
template <class ForwardIterator , class Size , class T> 
void uninitialized_fill_n(ForwardIterator first , Size n , const T& x ); 

// 20.4.5, pointers: 

template < class X > class auto_ptr ;
}


20.4.1 The default allocator [lib.default.allocator] 
namespace std {
template <class T> class allocator;


// specialize forvoid: 

template <> class allocator <void > { 

public : 

typedef void * pointer ; 

typedef const void* const_pointer; 

// reference-to-void members are impossible. 

typedef void value_type; 

template < class U > struct rebind { typedef allocator <U > other ; }; 

}; 

Draft 


20.4 Memory General utilities library 438 
template <class T> class allocator { 

public : 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type; 
typedef T* pointer; 
typedef const T* const_pointer; 
typedef T& reference; 
typedef const T& const_reference; 
typedef T value_type ; 
template < class U > struct rebind { typedef allocator <U > other ; }; 

allocator () throw ();
allocator(const allocator&) throw();
template < class U > allocator ( const allocator <U >&) throw ();


~ allocator () throw (); 

pointer address(reference x ) const ;
const_pointer address(const_reference x ) const ;


pointer allocate ( 

size _type , allocator <void >:: const_pointer hint = 0);
void deallocate(pointer p , size_type n );
size_type max_size() const throw();


void construct(pointer p, const T& val);
void destroy(pointer p);
};
}


20.4.1.1 allocator members [lib.allocator.members] 
pointer address(reference x ) const ; 

1 Returns: &x . 

const_pointer address(const_reference x ) const ; 

2 Returns: &x . 

pointer allocate(size_type n , allocator <void >:: const_pointer hint =0); 

3 Remarks: Uses ::operator new(std::size_t) (18.4.1). 
4 Requires: hint either0 or previously obtained from member allocate and not yet passed to member deallocate. The value hint maybeusedbyan implementationtohelpimprove performance225). 
5 Returns: a pointer to the initial element of an array of storage of size n * sizeof(T), aligned appropriately for 
objects of type T. 
6 Remark: the storage is obtained by calling ::operator new(std::size_t),but it is unspecified when or how 

225) In a container member function, the address of an adjacent element is often a good choice to pass for this argument. 

Draft 


439 General utilities library 20.4 Memory 

often this function is called. The use of hint isunspecified,but intendedasanaidtolocalityifanimplementation 
so desires. 

7 Throws: bad_alloc if the storage cannot be obtained. 

void deallocate(pointer p , size_type n ); 

8 Requires: p shall be a pointer value obtained from allocate(). n shall equal the value passed as the first 
argument to the invocation ofallocate which returned p . 
9 Effects: Deallocates the storage referenced by p . 
10 Remarks: Uses ::operator delete(void*) (18.4.1),butitis unspecified whenthis functionis called. 

size_type max_size() const throw(); 

11 Returns: the largest value Nfor which the call allocate(N ,0) might succeed. 

void construct(pointer p , const_reference val ); 
12 Effects: ::new((void *)p ) T(val ) 
void destroy ( pointer p ); 

13 Effects: p ->T() 

20.4.1.2 allocator globals [lib.allocator.globals] 
template < class T1 , class T2 >
bool operator= =(const allocator<T1>&, const allocator<T2>&) throw();


1 Returns: true. 

template < class T1 , class T2 >
bool operator! =(const allocator<T1>&, const allocator<T2>&) throw();


2 Returns: false. 

20.4.2 Raw storage iterator [lib.storage.iterator] 
1 raw_storage_iterator is provided to enable algorithms to store their results into uninitialized memory. The formal 
template parameter OutputIterator is required to have its operator* return an object for which operator& is 
defined and returnsa pointerto T,andisalso requiredto satisfythe requirementsofan output iterator(24.1.2). 

namespace std {
template < class OutputIterator , class T >
class raw_storage_iterator


: public iterator<output_iterator_tag,void,void,void,void> {
public :
explicit raw_storage_iterator(OutputIterator x );


raw_storage_iterator<OutputIterator,T>& operator*(); 

Draft 


20.4 Memory General utilities library 440 
raw_storage_iterator <OutputIterator ,T>& operator=(const T& element ); 
raw_storage_iterator<OutputIterator,T>& operator++(); 
raw_storage_iterator<OutputIterator,T> operator++(int); 

};
}


raw_storage_iterator ( OutputIterator x ); 
2 Effects: Initializes the iterator to point to the same value to which x points. 

raw_storage_iterator <OutputIterator ,T>& operator*(); 

3 Returns: *this 

raw_storage_iterator <OutputIterator ,T>& operator= (const T& element ); 

4 Effects: Constructs a value from element at the location to which the iterator points. 

5 Returns: Areference to the iterator. 

raw_storage_iterator <OutputIterator ,T>& operator++(); 

6 Effects: Pre-increment: advances the iterator and returns a reference to the updated iterator. 

raw_storage_iterator <OutputIterator ,T> operator++(int); 

7 Effects: Post-increment: advances the iterator and returns the old value of the iterator. 

20.4.3 Temporarybuffers [lib.temporary.buffer] 
template <class T> 
pair<T*, ptrdiff _t > get_temporary_buffer(ptrdiff_t n ); 
1 Effects: Obtains a pointer to storage sufficient to store up to n adjacent T objects. 
2 Returns: Apair containingthebuffer’s addressand capacity(inthe unitsof sizeof(T)), ora pairof0 valuesif 
no storage can be obtained or if n <= 0. 
template <class T> void return_temporary_buffer(T* p ); 
3 Effects: Deallocates thebuffer to which p points. 
4 Requires: Thebuffer shallhave beenpreviously allocatedby get_temporary_buffer. 

20.4.4 Specialized algorithms [lib.specialized.algorithms] 
1 All the iterators that are used as formal template parameters in the following algorithms are required to have their 
operator* return an object for which operator& is defined and returns a pointer to T. In the algorithm uninitialized_copy, the formal template parameter InputIterator is required to satisfy the requirements of an input iterator 
(24.1.1). In all of the following algorithms, the formal template parameter ForwardIterator is required to satisfy 
the requirementsofaforward iterator(24.1.3)andalsoto satisfytherequirementsofa mutable iterator(24.1),andis 

Draft 


441 General utilities library 20.4 Memory 

required to have the property that no exceptions are thrown from increment, assignment, comparison, or dereference of 
valid iterators. In the following algorithms, if an exception is thrown there are no effects. 

20.4.4.1 uninitialized_copy [lib.uninitialized.copy] 
template < class InputIterator , class ForwardIterator >
ForwardIterator
uninitialized_copy ( InputIterator first , InputIterator last ,
ForwardIterator result );


1 Effects: 

for (; first != last ; ++ result , ++ first ) 
new ( static_cast < void * >(&* result )) 
typename iterator_ traits <ForwardIterator >::value_type(*first); 

2 Returns: result 

20.4.4.2 uninitialized_fill [lib.uninitialized.fill] 
template <class ForwardIterator , class T>
void uninitialized_fill(ForwardIterator first , ForwardIterator last ,
const T& x );


1 Effects: 

for (; first != last ; ++ first ) 
new ( static_cast < void * >(&* first )) 
typename iterator_ traits <ForwardIterator >::value_type(x); 

20.4.4.3 uninitialized_fill_n [lib.uninitialized.fill.n] 
template <class ForwardIterator , class Size , class T>
void uninitialized_fill_n(ForwardIterator first , Size n , const T& x );


1 Effects: 

for (; n--; ++first) 
new ( static_cast < void * >(&* first )) 
typename iterator_ traits <ForwardIterator >::value_type(x); 

20.4.5 Class template auto_ptr [lib.auto.ptr] 
1 Template auto_ptr stores a pointer to an object obtained via new and deletes that object when it itself is destroyed 
(such as when leaving block scope 6.7). 

2 Templateauto_ptr_ref holdsa referencetoan auto_ptr.Itis usedbythe auto_ptr conversions to allow auto_ptr 
objects to be passed to and returned from functions. 

Draft 


20.4 Memory General utilities library 442 
namespace std {
template <class Y> struct auto_ptr_ref {};


template < class X > class auto_ptr {
public :
typedef X element_type;


// 20.4.5.1 construct/copy/destroy: 

explicit auto_ ptr(X* p =0) throw ();
auto_ptr ( auto_ ptr &) throw ();
template < class Y > auto_ptr ( auto _ptr <Y >&) throw ();
auto_ptr & operator =( auto_ptr &) throw ();
template < class Y > auto_ptr & operator = ( auto_ ptr <Y >&) throw ();
auto_ptr& operator=(auto _ptr_ref<X> r) throw();


~ auto_ptr () throw (); 

// 20.4.5.2 members: 

X& operator *() const throw ();
X* operator ->() const throw ();
X* get () const throw ();
X* release () throw ();
void reset(X* p =0) throw ();


// 20.4.5.3 conversions: 

auto_ptr ( auto_ptr_ref <X >) throw ();
template < class Y > operator auto_ptr _ref <Y >() throw ();
template < class Y > operator auto _ptr <Y >() throw ();


};
}


3 The auto_ptr provides a semantics of strict ownership. An auto_ptr owns the object it holds a pointer to. Copying 
an auto_ptr copies the pointer and transfers ownership to the destination. If more than one auto_ptr owns the same 
objectatthe sametimethebehaviorofthe programis undefined. [Note: The uses of auto_ptr include providing 
temporary exception-safety for dynamically allocated memory, passing ownership of dynamically allocated memory 
to a function, and returning dynamically allocated memory from a function. auto_ptr does not meet the CopyConstructible and Assignable requirements for Standard Library container elements and thus instantiating a Standard 
Library container with an auto_ptr results in undefined behavior. — end note ] 

20.4.5.1 auto_ptr constructors [lib.auto.ptr.cons] 
explicit auto_ptr(X* p =0) throw (); 

1 Postconditions:*this holds the pointer p . 

auto_ptr ( auto_ptr & a ) throw (); 

2 Effects: Calls a .release().
3 Postconditions:*this holds the pointer returned from a .release().


template < class Y > auto_ptr ( auto _ptr <Y >& a ) throw (); 

Draft 


443 General utilities library 20.4 Memory 

4 Requires: Y * can be implicitly converted to X *. 
5 Effects: Calls a .release(). 
6 Postconditions:*this holds the pointer returned from a .release(). 
a u t o _ p t r & o p e r a t o r = ( a u t o _ p t r & a ) t h r o w ( ) ; 
7 Requires: The expression delete get() is well formed. 
8 Effects: reset(a .release()). 
9 Returns: *this. 
t e m p l a t e < c l a s s Y > a u t o _ p t r & o p e r a t o r = ( a u t o _ p t r < Y > & a ) t h r o w ( ) ; 
10 Requires: Y * can be implicitly converted to X *. The expression delete get() is well formed. 
11 Effects: reset(a .release()). 
12 Returns: *this. 
~ a u t o _ p t r ( ) t h r o w ( ) ; 
13 Requires: The expression delete get() is well formed. 
14 Effects: delete get(). 
20.4.5.2 auto_ptr members [lib.auto.ptr.members] 
X & o p e r a t o r * ( ) c o n s t t h r o w ( ) ; 
1 Requires: get() != 0 
2 Returns: *get() 
X * o p e r a t o r -> ( ) c o n s t t h r o w ( ) ; 
3 Returns: get() 
X * g e t ( ) c o n s t t h r o w ( ) ; 
4 Returns: The pointer *this holds. 
X * r e l e a s e ( ) t h r o w ( ) ; 
5 Returns: get() 
6 Postcondition:*this holds the null pointer. 
v o i d r e s e t ( X * p = 0 ) t h r o w ( ) ; 
7 Effects: If get() != p then delete get(). 
8 Postconditions:*this holds the pointer p . 
Draft 


20.4 Memory General utilities library 444 
20.4.5.3 auto_ptr conversions [lib.auto.ptr.conv] 
1 
2 
a u t o _ p t r ( a u t o _ p t r _ r e f < X > r ) t h r o w ( ) ; 
Effects: Calls p.release() for the auto_ptr p that r holds. 
Postconditions:*this holds the pointer returned from release(). 
3 
t e m p l a t e < c l a s s Y > o p e r a t o r a u t o _ p t r _ r e f < Y > ( ) 
Returns: An auto_ptr_ref<Y> that holds *this. 
t h r o w ( ) ; 
4 
5 
t e m p l a t e < c l a s s Y > o p e r a t o r a u t o _ p t r < Y > ( ) t h r o w ( ) ; 
Effects: Calls release(). 
Returns: An auto_ptr<Y> that holds the pointer returned from release(). 
6 
7 
a u t o _ p t r & o p e r a t o r = ( a u t o _ p t r _ r e f < X > r ) t h r o w ( ) 
Effects: Calls reset(p.release()) for the auto_ptr p that r holds a reference to. 
Returns: *this 
1 
20.4.6 CLibrary 
Header <cstdlib> (Table 35): 
[lib.c.malloc] 
Table 35: Header<cstdlib> synopsis 

Type Name(s) 
Functions: calloc malloc 
free realloc 

2 The contents are the same as the StandardClibrary header <stdlib.h>, with the following changes: 

3 The functions calloc(), malloc(), and realloc() do not attempt to allocate storageby calling ::operator new() 
(18.4). 

4 The function free() does not attempt to deallocate storage by calling ::operator delete(). 
SEEALSO: ISOCclause 7.11.2. 

5 Header <cstring> (Table 36): 

Table 36: Header<cstring> synopsis 

Type Name(s) 
Macro: NULL 
Type: size_t 
Functions: memchr memcmp 
memcpy memmove memset 

Draft 


445 General utilities library 20.5 Date and time 

6 The contents are the same as the StandardC library header <string.h>, with the change to memchr() specified in 

21.4.
SEEALSO: ISOCclause 7.11.2.
20.5 Date and time [lib.date.time] 
1 Header <ctime> (Table 37): 

Table 37: Header<ctime> synopsis 

Type Name(s) 
Macros: NULL CLOCKS_PER_SEC 
Types: size_t clock_t time_t 
Struct: tm 
Functions: 
asctime clock 
ctime gmtime 
difftime localtime 
mktime time 
strftime 

The contents are the same as the StandardClibrary header <time.h>. 
SEEALSO: ISOCclause 7.12, Amendment1clause 4.6.4. 

Draft 


20.5 Date and time General utilities library 446 
Draft 


Chapter 21 Strings library [lib.strings]


1 This clause describes components for manipulating sequences of “characters,” where characters may be of any POD 
(3.9)type. In this clause such types are called char-like types, and objects of char-like types are called char-like objects 
or simply “characters.” 

2 The following subclauses describe a character traits class, a string class, and null-terminated sequence utilities, as 
summarized inTable 38: 

Table 38: Strings library summary 

Subclause Header(s) 
21.1 Character traits <string> 
21.2 String classes <string> 
21.4 Null-terminated sequence utilities 
<cctype> 
<cwctype> 
<cstring> 
<cwchar> 
<cstdlib> 

21.1 Character traits [lib.char.traits] 
1 This subclause defines requirements on classes representing character traits, and defines a class template char_
traits<charT>, along with two specializations, char_traits<char> and char_traits<wchar_t>, that satisfy 
those requirements. 

2 Most classes specified in clauses 21.2 and 27 need a set of related types and functions to complete the definition of their 
semantics. These types and functions are provided as a set of member typedefs and functions in the template parameter 
‘traits’ used by each such template. This subclause defines the semantics guaranteedby these members. 

3Tospecializethosetemplatestogenerateastringor iostreamclasstohandleaparticularcharacter containertypeCharT, 
that and its related character traits class Traits are passed as a pair of parameters to the string or iostream template as 
formal parameters charT and traits. Traits::char_type shall be the same as CharT. 

4 This subclause specifiesastruct template, char_traits<charT>,andtwoexplicit specializationsofit,char_traits< 
char> and char_traits<wchar_t>, allof which appearin theheader <string> and satisfy the requirements below. 

21.1.1 Character traitsrequirements [lib.char.traits.require] 
1 InTable 39, X denotesaTraits class defining types and functions for the character container type CharT;c and d denote 


21.1 Character traits Strings library 448 
values of typeCharT;p and q denotevaluesof type const CharT*;s denotesavalueof type CharT*;n,i and j denote 
values of type std::size_t;e and f denote values of type X::int_type;pos denotes a value of type X::pos_type; 
state denotes a value oftype X::state_type;andr denotes an lvalue of type CharT. Operations onTraits shall not 
throw exceptions. 

Table 39:Traits requirements 

expression return type assertion/note 
pre/post condition 
complexity 
X::char_type charT (described in 21.1.2) compile-time 
X::int_type (described in 21.1.2) compile-time 
X::off_type (described in 21.1.2) compile-time 
X::pos_type (described in 21.1.2) compile-time 
X::state_type (described in 21.1.2) compile-time 
X::eq(c,d) bool yields: whether c is to be treated as 
equal to d. 
constant 
X::lt(c,d) bool yields: whether c is to be treated as 
less than d. 
constant 
X::compare(p,q,n) int yields: 0 if for each i in [0,n), 
X::eq(p[i],q[i]) is true; else, a 
negative value if, for some j in 
[0,n), X::lt(p[j],q[j]) is true 
and for each i in [0,j) 
X::eq(p[i],q[i]) is true; else a 
positive value. 
linear 
X::length(p) std::size_t yields: the smallest i such that 
X::eq(p[i],charT()) is true. 
linear 
X::find(p,n,c) const X::char_type* yields: the smallest q in [p,p+n) 
such that X::eq(*q,c) is true, 
zero otherwise. 
linear 
X::move(s,p,n) X::char_type* for each i in [0,n), performs 
X::assign(s[i],p[i]). Copies 
correctly even where the ranges 
[p,p+n) and [s,s+n) overlap. 
yields: s. 
linear 
X::copy(s,p,n) X::char_type* pre: p not in [s,s+n). yields: s. 
for each i in [0,n), performs 
X::assign(s[i],p[i]). 
linear 
X::assign(r,d) (not used) assigns r=d. constant 
X::assign(s,n,c) X::char_type* for each i in [0,n), performs 
X::assign(s[i],c). yields: s. 
linear 

Draft 


449 Strings library 21.1 Character traits 

expression return type assertion/note 
pre/post condition 
complexity 
X::not_eof(e) int_type yields: e if 
X::eq_int_type(e,X::eof()) 
is false, otherwise a value f such 
that 
X::eq_int_type(f,X::eof()) 
is false. 
constant 
X::to_char_type(e) X::char_type yields: if for some c, 
X::eq_int_type(e,X::to_
int_type(c)) is true, c;else 
some unspecified value. 
constant 
X::to_int_type(c) X::int_type yields: some value e, constrained 
by the definitions of 
to_char_type and eq_int_type. 
constant 
X::eq_int_type(e,f) bool yields: for all c and d, 
X::eq(c,d) is equal to X::eq_
int_type(X::to_int_type(c), 
X::to_int_type(d));otherwise, 
yields true if e and f are both 
copies of X::eof();otherwise, 
yields false if one of e and f is a 
copyof X::eof() and the other is 
not; otherwise the value is 
unspecified. 
constant 
X::eof() X::int_type yields: a value e such that 
X::eq_int_type(e,X::to_
int_type(c)) is false for all 
values c. 
constant 

2 The struct template 

template <class charT > struct char_traits; 

shall be provided in the header <string> as a basis for explicit specializations. 
3 In the following subclauses, the token charT represents the parameter of the traits template. 

21.1.2 traits typedefs [lib.char.traits.typedefs] 
typedef CHAR_ T char_type; 

1 The type char_type is used to refer to the character container type in the implementation of the library classes 
defined in 21.2 and clause 27. 

typedef INT_T int_type ; 

Draft 


21.1 Character traits Strings library 450 
2 Requires: Foracertain character container typechar_type,a related container typeINT_T shallbeatypeor class 
whichcan representallofthevalid charactersconvertedfromthe corresponding char_type values, as well as an 
end-of-file value, eof(). The type int_type represents a character container type which can hold end-of-file to 
be used asa return typeofthe iostream class member functions.226) 

typedef OFF_T off_type ;
typedef POS_T pos_type ;


3 Requires: Requirements for off_type and pos_type are described in 27.1.2. 

typedef STATE_ T state_type; 

4 Requires: state_type shall meet the requirements of Assignable (23.1), CopyConstructible (20.1.3), and 
DefaultConstructible (20.1.5)types. 

21.1.3 char_traits specializations [lib.char.traits.specializations] 
namespace std {
template <> struct char_traits <char >;
template <> struct char_traits <wchar _t >;


} 

1 The header <string> declares two structs that are specializations of the template struct char_traits. 
2 The struct char_traits<char> is the char type specialization of the template struct char_traits, which contains 
all of the types and functions necessary to ensure the behavior of the classes in 21.2 and clause 27. 
3 The types and static member functions are described in detail in 21.1.1. 

21.1.3.1 struct char_traits<char> [lib.char.traits.specializations.char] 
namespace std {
template <>
struct char_ traits <char > {


typedef char char_type ;
typedef int int_type ;
typedef streamoff off_type ;
typedef streampos pos_type ;
typedef mbstate_t state_type;


static void assign ( char_type & c1 , const char_type & c2 );
static bool eq(const char_type& c1, const char_type& c2);
static bool lt(const char_type& c1, const char_type& c2);


static int compare(const char_type* s1, const char_type* s2, size_t n);
static size_t length(const char_type* s);
static const char_type* find(const char_type* s, size _t n,


const char_type& a); 
static char_type* move(char_type* s1, const char_type* s2, size_ t n); 

226) If eof() can be held in char_type then some iostreams operations may give surprising results. 

Draft 


451 Strings library 21.1 Character traits 

static char_type* copy(char_type* s1, const char_type* s2, size_ t n);
static char_type* assign(char_type* s, size_t n, char_type a);


static int_type not_eof(const int_type& c);
static char_type to_char_type(const int_type& c);
static int_type to_int_type(const char_type& c);
static bool eq_int_type(const int_type& c1, const int_type& c2);
static int_type eof ();


};
}


1 The header <string> (21.2)declares a specialization of the template structchar_traits for char. It is for narrow-
oriented iostream classes. 

2 The defined types for int_type, pos_type, off_type, and state_type are int, streampos, streamoff, and mbstate_t respectively. 

3 The type streampos is an implementation-definedtype that satisfies the requirements for POS_T in 21.1.2. 

4 The type streamoff is an implementation-definedtype that satisfies the requirements for OFF_T in 21.1.2. 

5 The type mbstate_t is defined in <cwchar> and can represent any of the conversion states possible to occur in an 
implementation-defined set of supported multibyte character encoding rules. 

6 The two-argument members assign, eq, and lt are defined identically to thebuilt-in operators =, ==, and < respectively.The two-argument member assign is defined identically to thebuilt-in operator =. The two-argument members 
eq and lt aredefined identicallytothebuilt-inoperators == and < for type unsigned char. 

7 The member eof() returns EOF. 

21.1.3.2 struct char_traits<wchar_t> [lib.char.traits.specializations.wchar.t] 
namespace std {
template <>
struct char_ traits < wchar_ t > {


typedef wchar_t char_type ;
typedef wint_t int_type ;
typedef streamoff off_type ;
typedef wstreampos pos_type;
typedef mbstate_t state_type;


static void assign ( char_type & c1 , const char_type & c2 );
static bool eq(const char_type& c1, const char_type& c2);
static bool lt(const char_type& c1, const char_type& c2);


static int compare(const char_type* s1, const char_type* s2, size_t n);
static size_t length(const char_type* s);
static const char_type* find(const char_type* s, size _t n,


const char_type& a); 
static char_type* move(char_type* s1, const char_type* s2, size_ t n); 
static char_type* copy(char_type* s1, const char_type* s2, size_ t n); 
static char_type* assign(char_type* s, size_t n, char_type a); 

Draft 


21.2 String classes Strings library 452 
static int_type not_eof(const int_type& c);
static char_type to_char_type(const int_type& c);
static int_type to_int_type(const char_type& c);
static bool eq_int_type(const int_type& c1, const int_type& c2);
static int_type eof ();


};
}


1 The header <string> (21.2)declares a specialization of the template structchar_traits for wchar_t. It is for wide-
oriented iostream classes. 
2 The defined types for int_type, pos_type, and state_type are wint_t, wstreampos, and mbstate_t respectively. 
3 The type wstreampos is an implementation-definedtype that satisfies the requirements for POS_T in 21.1.2. 
4[Note: This paragraph is intentionallyempty. — end note ] 
5 The type mbstate_t is defined in <cwchar> and can represent any of the conversion states possible to occur in an 
implementation-defined set of supported multibyte character encoding rules. 
6 The two-argument members assign,eq,andlt are defined identicallytothebuilt-in operators =,==,and< respectively. 
7 The member eof() returns WEOF. 

21.2 String classes [lib.string.classes] 
1 The header <string> definesabasicstringclass templateandits traitsthatcan handleallchar-like(clause 21)template 
arguments with several function signatures for manipulating varying-length sequences of char-like objects. 
2 The header <string> also defines two specific template classes string and wstring and their special traits. 
3 Header <string> synopsis 

namespace std { 

// 21.1, character traits: 

template < class charT > 

struct char_traits;
template <> struct char_traits <char >;
template <> struct char_traits <wchar _t >;


// 21.3, basic_string: 

template <class charT , class traits = char _traits <charT >,
class Allocator = allocator <charT > >
class basic_string;


template < class charT , class traits , class Allocator >
basic_string < charT , traits , Allocator >


operator+(const basic _string <charT ,traits ,Allocator >& lhs , 
const basic _string <charT ,traits ,Allocator >& rhs ); 
template < class charT , class traits , class Allocator >
basic_string < charT , traits , Allocator >


operator +( const charT * lhs , 
Draft 


453 Strings library 21.2 String classes 

c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > 
o p e r a t o r + ( c h a r T lhs , c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > 
o p e r a t o r + ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t c h a r T * rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > 
o p e r a t o r + ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , c h a r T rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t c h a r T * lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t c h a r T * rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t c h a r T * lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t c h a r T * rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t c h a r T * rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t c h a r T * lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & lhs , 
c o n s t c h a r T * rhs ) ; 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > ( c o n s t c h a r T * lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & rhs ) ; 
Draft 


21.3 Class template basic_string Strings library 454 
template < class charT , class traits , class Allocator >
bool operator <=(const basic _string <charT ,traits ,Allocator >& lhs ,
const basic _string <charT ,traits ,Allocator >& rhs );
template < class charT , class traits , class Allocator >
bool operator <=(const basic _string <charT ,traits ,Allocator >& lhs ,
const charT * rhs );
template < class charT , class traits , class Allocator >
bool operator <=( const charT * lhs ,
const basic _string <charT ,traits ,Allocator >& rhs );
template < class charT , class traits , class Allocator >
bool operator >=(const basic _string <charT ,traits ,Allocator >& lhs ,
const basic _string <charT ,traits ,Allocator >& rhs );
template < class charT , class traits , class Allocator >
bool operator >=(const basic _string <charT ,traits ,Allocator >& lhs ,
const charT * rhs );
template < class charT , class traits , class Allocator >
bool operator >=( const charT * lhs ,
const basic _string <charT ,traits ,Allocator >& rhs );


// 21.3.7.8: 

template < class charT , class traits , class Allocator >
void swap ( basic_string < charT , traits , Allocator >& lhs ,
basic_string < charT , traits , Allocator >& rhs );


template < class charT , class traits , class Allocator >
basic_istream <charT ,traits >&


operator >>(basic _istream <charT ,traits >& is ,
basic_string < charT , traits , Allocator >& str );
template < class charT , class traits , class Allocator >
basic_ostream <charT , traits >&


operator <<(basic _ostream <charT , traits >& os ,
const basic _string <charT ,traits ,Allocator >& str );
template < class charT , class traits , class Allocator >
basic_istream <charT ,traits >&
getline ( basic _istream < charT , traits >& is ,
basic_string < charT , traits , Allocator >& str ,
charT delim );


template < class charT , class traits , class Allocator >
basic_istream <charT ,traits >&
getline ( basic _istream < charT , traits >& is ,
basic_string < charT , traits , Allocator >& str );


typedef basic_string <char > string; 

typedef basic_string < wchar _t > wstring ; 

} 

21.3 Class template basic_string [lib.basic.string] 
1 For a char-like typecharT, the class template basic_string describes objects that can store a sequence consisting of 
a varying number of arbitrary char-like objects (clause 21). The first element of the sequence is at position zero. Such 

Draft 


455 Strings library 21.3 Class template basic_string 

a sequence is also called a “string” if the given char-like type is clear from context. In the rest of this clause, charT 
denotes such a given char-like type. Storage for the string is allocated and freed as necessary by the member functions 
of class basic_string, via the Allocator class passed as template parameter. Allocator::value_type shall be 
the same as charT. 

2 The class template basic_string conformstothe requirementsofa Sequence,asspecifiedin(23.1.1). Additionally, 
because the iterators supportedby basic_string are random access iterators(24.1.5), basic_string conforms to the 
the requirementsofaReversible Container, as specifiedin(23.1). 

3 In all cases, size() <= capacity(). 

4 The functions described in this clause can report two kinds of errors, each associated with a distinct exception: 

— a length error is associated with exceptions of type length_error (19.1.4); 
— an out-of-range error is associated with exceptions of type out_of_range (19.1.5). 
5 For anystring operation, if as a result of the operation,size() would exceed max_size() then the operation throws 
length_error. 

6 References,pointers,and iterators referringtothe elementsofa basic_string sequence may be invalidated by the 
following uses of that basic_string object: 

— As an argument to non-member functions swap() (21.3.7.8),operator>>() (21.3.7.9),andgetline() (21.3.7.9). 
— As an argument to basic_string::swap(). 
— Calling data() and c_str() member functions. 
— Calling non-const member functions, except operator[], at, begin, rbegin, end, and rend. 
— Following construction or anyof the above uses, except the forms ofinsert and erase that return iterators, the 
first call to non-const member functions operator[], at, begin, rbegin, end, or rend. 
7 [Note: Theserulesare formulatedtoallow,butnotrequire,a reference counted implementation.Areferencecounted 
implementation musthavethe same semantics asa non-reference counted implementation.[ Example: 

string s1("abc"); 

string::iterator i = s1.begin();
string s2 = s1;


*i = ’a’; // Must modify only s1 
— end example ] — end note ] 
namespace std {
template <class charT , class traits = char _traits <charT >,


class Allocator = allocator <charT > >
class basic_string {
public :


// types: 

typedef traits traits_type;
typedef typename traits::char_type value_type;


Draft 


21.3 Class template basic_string Strings library 456 
typedef Allocator allocator_type;
typedef typename Allocator :: size_type size_type ;
typedef typename Allocator::difference_type difference_type;


typedef typename Allocator :: reference reference ;
typedef typename Allocator::const_reference const_reference;
typedef typename Allocator :: pointer pointer ;
typedef typename Allocator::const_pointer const_pointer;


typedef implementation-defined iterator ; // See 23.1
typedef implementation-defined const_iterator ; // See 23.1
typedef std::reverse_iterator <iterator > reverse_iterator;
typedef std::reverse_iterator <const _iterator > const_reverse_iterator;
static const size_type npos = -1;


// 21.3.1 construct/copy/destroy: 

explicit basic_string(const Allocator& a = Allocator ());
basic_string(const basic_string& str );
basic_string(const basic_string& str , size_type pos , size_type n = npos ,


const Allocator & a = Allocator ());
basic_string(const charT* s ,


size_type n , const Allocator & a = Allocator ());
basic_string(const charT* s , const Allocator & a = Allocator ());
basic_string ( size_type n , charT c , const Allocator & a = Allocator ());
template < class InputIterator >


basic_string ( InputIterator begin , InputIterator end ,
const Allocator & a = Allocator ());


~basic_string (); 
basic_string& operator= (const basic_string& str ); 
basic_string& operator= (const charT* s ); 
basic_string& operator= (charT c ); 

// 21.3.2 iterators: 

iterator begin ();
const_iterator begin () const ;
iterator end ();
const_iterator end () const ;


reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
reverse_iterator rend();
const_reverse_iterator rend() const;


// 21.3.3 capacity: 

size_type size() const;
size_type length() const;
size_type max_size() const;
void resize ( size_type n , charT c );
void resize ( size_type n );
size_type capacity() const;


Draft 


457 Strings library 21.3 Class template basic_string 

void reserve ( size_type res_arg = 0);
void clear ();
bool empty () const ;


// 21.3.4 element access: 

const_reference operator []( size_type pos ) const ;
reference operator []( size_type pos );
const_reference at(size_type n) const;
reference at(size_type n);


// 21.3.5 modifiers: 

basic_string& operator+=(const basic_string& str );
basic_string& operator+=(const charT* s );
basic_string& operator+=(charT c );
basic_string& append(const basic_string& str );
basic_string& append(const basic_string& str , size_type pos ,


size_type n ); 
basic_string& append(const charT* s , size_type n ); 
basic_string& append(const charT* s ); 
basic_string& append(size_type n , charT c ); 
template < class InputIterator > 

basic_string& append(InputIterator first , InputIterator last ); 
void push_back ( charT c ); 

basic_string& assign(const basic_string& str );
basic_string& assign(const basic_string& str , size_type pos ,


size_type n ); 
basic_string& assign(const charT* s , size_type n ); 
basic_string& assign(const charT* s ); 
basic_string& assign(size_type n , charT c ); 
template < class InputIterator > 

basic_string& assign(InputIterator first , InputIterator last ); 

basic_string& insert(size_type pos1 , const basic_string & str ); 
basic_string& insert(size_type pos1 , const basic_string & str , 

size_type pos2 , size_type n ); 
basic_string& insert(size_type pos , const charT * s , size_type n ); 
basic_string& insert(size_type pos , const charT * s ); 
basic_string& insert(size_type pos , size_type n , charT c ); 
iterator insert ( iterator p , charT c ); 
void insert ( iterator p , size_type n , charT c ); 
template < class InputIterator > 

void insert ( iterator p , InputIterator first , InputIterator last ); 

basic_string& erase(size_type pos = 0 , size_type n = npos );
iterator erase ( iterator position );
iterator erase ( iterator first , iterator last );


basic_string& replace(size_type pos1 , size_type n1 , 
const basic_string & str ); 

Draft 


21.3 Class template basic_string Strings library 458 
basic_string& replace(size_type pos1 , size_type n1 , 
const basic_string & str , 
size_type pos2 , size_type n2 ); 

basic_string& replace(size_type pos , size_type n1 , const charT * s , 

size_type n2 ); 
basic_string& replace(size_type pos , size_type n1 , const charT * s ); 
basic_string& replace(size_type pos , size_type n1 , size_type n2 , 

charT c ); 

basic_string& replace(iterator i1 , iterator i2 , 
const basic_string & str ); 
basic_string& replace(iterator i1 , iterator i2 , const charT * s , 

size_type n ); 
basic_string& replace(iterator i1 , iterator i2 , const charT * s ); 
basic_string& replace(iterator i1 , iterator i2 , 

size_type n , charT c ); 
template < class InputIterator > 
basic_string& replace(iterator i1 , iterator i2 , 
InputIterator j1 , InputIterator j2 ); 

size_type copy(charT* s , size_type n , size_type pos = 0) const ;
void swap(basic_string& str );


// 21.3.6 string operations:
const charT * c_str () const ; // explicit
const charT * data () const ;
allocator_type get_allocator() const;


size_type find (const basic_string& str , size_type pos = 0) const ;
size_type find (const charT* s , size_type pos , size_type n ) const ;
size_type find (const charT* s , size_type pos = 0) const ;
size_type find (charT c , size_type pos = 0) const ;
size_type rfind(const basic_string& str , size_type pos = npos ) const ;
size_type rfind(const charT* s , size_type pos , size_type n ) const ;
size_type rfind(const charT* s , size_type pos = npos ) const ;
size_type rfind(charT c , size_type pos = npos ) const ;


size_type find_first_of(const basic_string& str , 
size_type pos = 0) const ; 
size_type find_first_of(const charT* s , 

size_type pos , size_type n ) const ; 
size_type find_first_of(const charT* s , size_type pos = 0) const ; 
size_type find_first_of(charT c , size_type pos = 0) const ; 
size_type find_last_of (const basic_string& str , 

size_type pos = npos ) const ; 
size_type find_last_of (const charT* s , 

size_type pos , size_type n ) const ; 
size_type find_last_of (const charT* s , size_type pos = npos ) const ; 
size_type find_last_of (charT c , size_type pos = npos ) const ; 

Draft 


459 Strings library 21.3 Class template basic_string 

size_type find_first_not_of(const basic_string& str ,
size_type pos = 0) const ;
size_type find_first_not_of(const charT* s , size_type pos ,


size_type n ) const ; 
size_type find_first_not_of(const charT* s , size_type pos = 0) const ; 
size_type find_first_not_of(charT c , size_type pos = 0) const ; 
size_type find_last_not_of (const basic_string& str , 

size_type pos = npos ) const ; 
size_type find_last_not_of (const charT* s , size_type pos , 
size_type n ) const ; 
size_type find_last_not_of (const charT* s , 
size_type pos = npos ) const ; 
size_type find_last_not_of (charT c , size_type pos = npos ) const ; 

basic_string substr(size_type pos = 0 , size_type n = npos ) const ;
int compare(const basic_string& str ) const ;
int compare ( size_type pos1 , size_type n1 ,


const basic_string & str ) const ; 

int compare ( size_type pos1 , size_type n1 ,
const basic_string & str ,
size_type pos2 , size_type n2 ) const ;


int compare(const charT* s) const;
int compare ( size_type pos1 , size_type n1 ,
const charT * s ) const ;
int compare ( size_type pos1 , size_type n1 ,
const charT * s , size_type n2 ) const ;
};
}


21.3.1 basic_string constructors [lib.string.cons] 
1 In all basic_string constructors, a copyof the Allocator argumentisusedforanymemory allocation performedby 
the constructor or member functions during the lifetime of the object. 

explicit basic_string(const Allocator& a = Allocator ()); 

2 Effects: Constructs an object of class basic_string. The postconditions of this function are indicated inTable 40. 

Table 40:basic_string(const Allocator&) effects 

Element Value 
data() a non-null pointer that is copyable and can have 0 
added to it 
size() 0 
capacity() an unspecified value 

Draft 


21.3 Class template basic_string Strings library 460 
basic_string(const basic_string <charT ,traits ,Allocator >& str ); 

basic_string(const basic_string <charT ,traits ,Allocator >& str ,
size_type pos , size_type n = npos ,
const Allocator & a = Allocator ());


3 Requires: pos <= str .size() 

4 Throws: out_of_range if pos > str .size(). 

5 Effects: Constructs an object of class basic_string and determines the effective length rlen of the initial string 
value as the smaller of n and str .size() -pos , as indicated inTable 41. In the first form, the Allocator 
value used is copied from str.get_allocator(). 

Table 41:basic_string(basic_string, size_type, size_type, const Allocator&) effects 

Element Value 

data() points at the first element of an allocated copyof rlen 
consecutive elements of the string controlled by str 
beginning at position pos 

size() rlen 

capacity() a value at least as large as size() 

basic_string(const charT* s , size_type n ,
const Allocator & a = Allocator ());


6 Requires: s shall not be a null pointer and n < npos.
7[Note: This paragraph is intentionally empty. — end note ]
8 Effects: Constructs an object of class basic_string and determines its initial string value from the array of


charT of length n whose first element is designated by s , as indicatedinTable 42. 

Table 42:basic_string(const charT*, size_type, const Allocator&) effects 

Element Value 

data() points at the first element of an allocated copyof the 

array whose first element is pointed at by s 
size() n 
capacity() a value at least as large as size() 

basic_string(const charT* s , const Allocator & a = Allocator ()); 

9 Requires: s shall not be a null pointer. 
10 Effects: Constructs an object of class basic_string and determines its initial string value from the array of 
charT of length traits::length(s ) whose first element is designated by s , as indicatedinTable 43. 
11 Remarks: Uses traits::length(). 

Draft 


461 Strings library 21.3 Class template basic_string 

Table 43:basic_string(const charT*, const Allocator&) effects 

Element Value 
data() points at the first element of an allocated copyof the 
array whose first element is pointed at by s 
size() traits::length(s) 
capacity() a value at least as large as size() 

basic_string ( size_type n , charT c , const Allocator & a = Allocator ()); 

12 Requires: n < npos 
13 [Note: This paragraph is intentionally empty. — end note ] 
14 Effects: Constructs an object of class basic_string and determines its initial string value by repeating the char-

like object c for all n elements, as indicatedinTable 44: 

Table 44:basic_string(size_t, charT, const Allocator&) effects 

Element Value 

data() points at the first element of an allocated array of n 

elements, each storing theinitialvalue c 
size() n 
capacity() a value at least as large as size() 

template < class InputIterator >
basic_string ( InputIterator begin , InputIterator end ,
const Allocator & a = Allocator ());


15 Effects: If InputIterator is an integral type, equivalentto 
basic_string(static_cast <size_ type >( begin ), static _cast < value _type >( end ), a) 

16 Otherwise constructsa string fromthevaluesinthe range[begin , end ), as indicated in the SequenceRequirements table (see 23.1.1). 

basic _string <charT ,traits ,Allocator >& 

operator = ( const basic_string < charT , traits , Allocator >& str ); 
17 Effects: If *this and str are not the same object, modifies *this as showninTable 45: 

Table 45:operator=(const basic_string<charT, traits, Allocator>&) effects 

Element Value 

data() points at the first element of an allocated copyof the 

array whose first elementis pointedatby str.data() 
size() str.size() 
capacity() a value at least as large as size() 

Draft 


21.3 Class template basic_string Strings library 462 
18 
19 
If *this and str are the same object, the member has no effect. 
Returns: *this 
20 
21 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
o p e r a t o r = ( c o n s t c h a r T * s ) ; 
Returns: *this = basic_string<charT,traits,Allocator>(s ). 
Remarks: Uses traits::length(). 
22 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & o p e r a t o r = ( c h a r T c ) ; 
Returns: *this = basic_string<charT,traits,Allocator>(1,c ). 
21.3.2 basic_string iterator support [lib.string.iterators] 
1 
i t e r a t o r b e g i n ( ) ; 
c o n s t _ i t e r a t o r b e g i n ( ) c o n s t ; 
Returns: an iterator referring to the first character in the string. 
2 
i t e r a t o r e n d ( ) ; 
c o n s t _ i t e r a t o r e n d ( ) c o n s t ; 
Returns: an iterator which is the past-the-end value. 
3 
r e v e r s e _ i t e r a t o r r b e g i n ( ) ; 
c o n s t _ r e v e r s e _ i t e r a t o r r b e g i n ( ) c o n s t ; 
Returns: an iterator which is semantically equivalent to reverse_iterator(end()). 
4 
r e v e r s e _ i t e r a t o r r e n d ( ) ; 
c o n s t _ r e v e r s e _ i t e r a t o r r e n d ( ) c o n s t ; 
Returns: an iterator which is semantically equivalent to reverse_iterator(begin()). 
21.3.3 basic_string capacity [lib.string.capacity] 
1 
s i z e _ t y p e s i z e ( ) c o n s t ; 
Returns: a count of the number of char-like objects currently in the string. 
2 
s i z e _ t y p e l e n g t h ( ) 
Returns: size(). 
c o n s t ; 
3 
4 
s i z e _ t y p e m a x _ s i z e ( ) c o n s t ; 
Returns: The maximum size of the string. 
Remark: See Container requirements table (23.1). 
v o i d r e s i z e ( s i z e _ t y p e n , c h a r T c ) ; 
Draft 


463 Strings library 21.3 Class template basic_string 

5 Requires: n <= max_size()
6 Throws: length_error if n > max_size().
7 Effects: Alters the lengthof the string designatedby *this as follows:


— If n <= size(), the function replaces the string designated by *this with a string of length n whose 
elements are a copyof the initial elements of the original string designated by *this. 
— If n > size(), the function replaces the string designated by *this with a string of length n whose first 
size() elements are a copyof the original string designated by *this, and whose remaining elements are 
all initialized to c . 
void resize ( size_type n ); 

8 Effects: resize(n ,charT()). 

size_type capacity() const; 

9 Returns: the size of the allocated storage in the string. 

void reserve ( size_type res_arg =0); 

10 The member function reserve() is a directive that informs a basic_string object of a planned change in size, 
so that it can manage the storage allocation accordingly. 

11 Effects: After reserve(), capacity() is greater or equal to the argument of reserve.[Note: Calling reserve() with a res_arg argument less than capacity() is in effect a non-binding shrink request. Acall with 
res_arg <= size() is in effect a non-binding shrink-to-fit request. — end note ] 

12 Throws: length_error if res_arg > max_size().227) 

void clear (); 

13 Effects: Behaves as if the function calls: 

erase ( begin () , end ()); 

bool empty () const ; 

14 Returns: size() == 0. 

21.3.4 basic_string element access [lib.string.access] 
const_reference operator []( size_type pos ) const ;
reference operator []( size_type pos );


1 Returns: If pos < size(), returns *(begin() + pos ). Otherwise, if pos == size(), the const version 
returns charT(). Otherwise, the behavior is undefined. 

const_reference at(size_type pos ) const ;
reference at(size_type pos );


227) reserve() uses Allocator::allocate() which may throw an appropriate exception. 

Draft 


21.3 Class template basic_string Strings library 464 
2 Requires: pos < size()
3 Throws: out_of_range if pos >= size().
4 Returns: operator[](pos ).


21.3.5 basic_string modifiers [lib.string.modifiers] 
21.3.5.1 basic_string::operator+= [lib.string::op+=] 
basic _string <charT ,traits ,Allocator >& 

operator +=( const basic_string < charT , traits , Allocator >& str ); 
1 Returns: append(str ). 
basic _string<charT,traits,Allocator>& operator+=(const charT* s ); 

2 Returns: *this += basic_string<charT,traits,Allocator>(s ). 
3 Remarks: Uses traits::length(). 

basic _string<charT,traits,Allocator>& operator+=(charT c ); 

4 Returns: *this += basic_string<charT,traits,Allocator>(1,c ). 

21.3.5.2 basic_string::append [lib.string::append] 
basic _string <charT ,traits ,Allocator >&
append(const basic_string <charT ,traits >& str );


1 Returns: append(str , 0, npos). 

basic _string <charT ,traits ,Allocator >& 
append(const basic_string <charT ,traits >& str , size_type pos , size_type n ); 
2 Requires: pos <= str .size() 
3 Throws: out_of_range if pos > str .size(). 
4 Effects: Determines the effective length rlen of the string to append as the smaller of n and str .size() 

pos . The function then throws length_error if size() >= npos -rlen .
Otherwise, the function replaces the stringcontrolled by *this with a string of length size() + rlen whose
first size() elements are a copyof the original string controlled by *this and whose remaining elements are a
copyof the initial elements of the string controlled by str beginning at position pos .


5 Returns: *this. 

basic _string <charT ,traits ,Allocator >&
append ( const charT * s , size_type n );


6 Returns: append(basic_string<charT,traits,Allocator>(s ,n )). 

Draft 


465 Strings library 21.3 Class template basic_string 

basic _string <charT ,traits ,Allocator >& append(const charT* s ); 

7 Returns: append(basic_string<charT,traits,Allocator>(s )).
8 Remarks: Uses traits::length().


basic _string <charT ,traits ,Allocator >&
append ( size_type n , charT c );


9 Returns: append(basic_string<charT,traits,Allocator>(n ,c )). 

template < class InputIterator >
basic_string& append(InputIterator first , InputIterator last );


10 Returns: append(basic_string<charT,traits,Allocator>(first ,last )). 

void push_back(charT c) 

11 Effects: Equivalent to append(static_cast<size_type>(1), c). 

21.3.5.3 basic_string::assign [lib.string::assign] 
basic _string <charT ,traits ,Allocator >&
assign(const basic_string <charT ,traits >& str );


1 Returns: assign(str , 0, npos). 

basic _string <charT ,traits ,Allocator >&
assign(const basic_string <charT ,traits >& str , size_type pos ,
size_type n );
2 Requires: pos <= str .size()
3 Throws: out_of_range if pos > str .size().


4 Effects: Determines the effectivelength rlen of the string to assign as the smaller of n and str .size() -pos . 
The function then replaces the string controlledby *this witha stringof length rlen whose elements area copy 
of the string controlled by str beginning at position pos . 

5 Returns: *this. 

basic _string <charT ,traits ,Allocator >&
assign ( const charT * s , size_type n );


6 Returns: assign(basic_string<charT,traits,Allocator>(s ,n )). 

basic _string <charT ,traits ,Allocator >& assign(const charT* s ); 

7 Returns: assign(basic_string<charT, traits, Allocator>(s )).
8 Remarks: Uses traits::length().


basic _string <charT ,traits ,Allocator >&
assign ( size_type n , charT c );


Draft 


21.3 Class template basic_string Strings library 466 
9 Returns: assign(basic_string<charT,traits,Allocator>(n ,c )). 

template < class InputIterator >
basic_string& assign(InputIterator first , InputIterator last );


10 Returns: assign(basic_string<charT,traits,Allocator>(first ,last )). 

21.3.5.4 basic_string::insert [lib.string::insert] 
basic _string <charT ,traits ,Allocator >&
insert ( size_type pos1 ,
const basic_string <charT ,traits ,Allocator >& str );


1 Returns: insert(pos1 ,str ,0,npos ). 

basic _string <charT ,traits ,Allocator >& 

insert ( size_type pos1 ,
const basic_string <charT ,traits ,Allocator >& str ,
size_type pos2 , size_type n );


2 Requires: pos1 <= size() and pos2 <= str .size() 

3 Throws: out_of_range if pos1 > size() or pos2 > str .size(). 

4 Effects: Determines the effective length rlen of the string to insert as the smaller of n and str .size() 
pos2 . Then throws length_error if size() >= npos -rlen . 

Otherwise, the function replaces the string controlled by *this with a string of length size() + rlen whose 
first pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next 
rlen elementsareacopyofthe elementsofthestring controlledby str beginning at position pos2 , and whose 
remaining elements are a copyof the remaining elements of the original string controlled by *this. 

5 Returns: *this. 

basic _string <charT ,traits ,Allocator >&
insert ( size_type pos , const charT * s , size_type n );


6 Returns: insert(pos ,basic_string<charT,traits,Allocator>(s ,n )). 

basic _string <charT ,traits ,Allocator >&
insert ( size_type pos , const charT * s );


7 Returns: insert(pos ,basic_string<charT,traits,Allocator>(s )).
8 Remarks: Uses traits::length().


basic _string <charT ,traits ,Allocator >&
insert ( size_type pos , size_type n , charT c );


9 Returns: insert(pos ,basic_string<charT,traits,Allocator>(n ,c )). 

iterator insert ( iterator p , charT c ); 

Draft 


467 Strings library 21.3 Class template basic_string 
10 Requires: p is a valid iterator on *this. 
11 Effects: inserts a copyof c before the character referred to by p . 
12 Returns: an iterator which refers to the copyof the inserted character. 
v o i d i n s e r t ( i t e r a t o r p , s i z e _ t y p e n , c h a r T c ) ; 
13 Requires: p is a valid iterator on *this. 
14 Effects: inserts n copies of c before the character referred to by p . 
t e m p l a t e < c l a s s I n p u t I t e r a t o r > 
v o i d i n s e r t ( i t e r a t o r p , I n p u t I t e r a t o r first , I n p u t I t e r a t o r last ) ; 
15 Requires: p is a valid iterator on *this. [first ,last ) is a valid range. 
16 Effects: Equivalent to insert(p -begin(), basic_string(first, last)). 
21.3.5.5 basic_string::erase [lib.string::erase] 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
e r a s e ( s i z e _ t y p e pos = 0 , s i z e _ t y p e n = n p o s ) ; 
1 Requires: pos <= size() 
2 Throws: out_of_range if pos > size(). 
3 Effects: Determines the effective length xlen of the string to be removed as the smaller of n and size() -pos . 
4 The function then replaces the string controlled by *this with a string of length size() -xlen whose first 
pos elements are a copyof the initial elements of the original string controlled by *this, and whose remaining 
elements are acopyof the elements of the original string controlled by *this beginning at position pos + xlen . 
5 Returns: *this. 
i t e r a t o r e r a s e ( i t e r a t o r p ) ; 
6 Effects: removes the character referred to by p . 
7 Returns: an iterator which points to the element immediately following p prior to the element being erased. If no 
such element exists, end() is returned. 
i t e r a t o r e r a s e ( i t e r a t o r first , i t e r a t o r last ) ; 
8 Requires: first and last are valid iterators on *this, defining a range [first ,last ). 
9 Effects: removes the characters in the range [first ,last ). 
10 Returns: an iterator which points to the element pointed to by last prior to the other elements being erased. If 
no such element exists, end() is returned. 

Draft 


21.3 Class template basic_string Strings library 468 
21.3.5.6 basic_string::replace [lib.string::replace] 
basic _string <charT ,traits ,Allocator >&
replace ( size_type pos1 , size_type n1 ,
const basic_string <charT ,traits ,Allocator >& str );


1 Returns: replace(pos1 , n1 , str , 0, npos ). 

basic _string <charT ,traits ,Allocator >& 

replace ( size_type pos1 , size_type n1 ,
const basic_string <charT ,traits ,Allocator >& str ,
size_type pos2 , size_type n2 );


2 Requires: pos1 <= size() && pos2 <= str .size(). 

3 Throws: out_of_range if pos1 > size() or pos2 > str .size(), or length_error if the length of the 
resulting string would exceed max_size() (see below). 

4 Effects: Determines the effective length xlen of the string to be removed as the smaller of n1 and size() 
pos1 . Also determines the effectivelength rlen ofthestringtobe insertedasthesmallerof n2 and str .size() 
-pos2 . If size() -xlen >= max_size() -rlen , throws length_error. Otherwise, thefunction replaces the string controlled by *this with a string of length size() -xlen + rlen whose first pos1 elementsareacopyofthe initial elementsofthe originalstring controlledby *this, whose next rlen elements are 
a copyof the initial elements of the string controlled by str beginning at position pos2 , and whose remaining 
elements are a copy of the elements of the original string controlled by *this beginning at position pos1 + 
xlen . 

5 Returns: *this. 

basic _string <charT ,traits ,Allocator >&
replace ( size_type pos , size_type n1 , const charT * s , size_type n2 );


6 Returns: replace(pos ,n1 ,basic_string<charT,traits,Allocator>(s ,n2 )). 

basic _string <charT ,traits ,Allocator >&
replace(size_type pos, size_type n1, const charT* s );


7 Returns: replace(pos ,n1 ,basic_string<charT,traits,Allocator>(s )).
8 Remarks: Uses traits::length().


basic _string <charT ,traits ,Allocator >&
replace ( size_type pos , size_type n1 ,
size_type n2 , charT c );


9 Returns: replace(pos ,n1 ,basic_string<charT,traits,Allocator>(n2 ,c )). 

basic_string& replace(iterator i1 , iterator i2 , const basic_string& str ); 

10 Requires: The iterators i1 and i2 are valid iterators on *this, defining a range [i1 ,i2 ). 

11 Effects: Replaces the string controlledby *this with a string of length size() -(i2 -i1 )+ str .size() 
whose first begin() -i1 elementsarea copyof the initial elementsof the originalstring controlledby *this, 

Draft 


469 Strings library 21.3 Class template basic_string 

whose next str .size() elementsareacopyofthestring controlledby str , and whose remaining elements are 
a copyof the elements of the original string controlled by *this beginning at position i2 . 

12 Returns: *this. 

13 Remarks: After the call, the length ofthe string will be changed by: str .size() -(i2 -i1 ). 

basic_string &
replace ( iterator i1 , iterator i2 , const charT * s , size_type n );


14 Returns: replace(i1 ,i2 ,basic_string(s ,n )). 
15 Remarks: Length change: n -(i2 -i1 ). 

basic_string& replace(iterator i1 , iterator i2 , const charT * s ); 

16 Returns: replace(i1 ,i2 ,basic_string(s )). 
17 Remarks: Length change: traits::length(s )-(i2 -i1 ). 
Uses traits::length(). 

basic_string& replace(iterator i1 , iterator i2 , size_type n ,
charT c );


18 Returns: replace(i1 ,i2 ,basic_string(n ,c )). 
19 Remarks: Length change: n -(i2 -i1 ). 

template < class InputIterator >
basic_string& replace(iterator i1 , iterator i2 ,
InputIterator j1 , InputIterator j2 );


20 Returns: replace(i1 ,i2 ,basic_string(j1 ,j2 )). 
21 Remarks: Length change: j2 -j1 -(i2 -i1 ). 

21.3.5.7 basic_string::copy [lib.string::copy] 
size_type copy(charT* s , size_type n , size_type pos = 0) const ; 

1 Requires: pos <= size()
2 Throws: out_of_range if pos > size().
3 Effects: Determines the effective length rlen of the string to copy as the smaller of n and size() -pos . s


shall designate an array of at least rlen elements.


The function then replaces the string designated by s with a string of length rlen whose elements are a copyof
the string controlled by *this beginning at position pos .
The function does not append a null object to the string designated by s .


4 Returns: rlen . 

Draft 


21.3 Class template basic_string Strings library 470 
21.3.5.8 basic_string::swap [lib.string::swap] 
void swap(basic_ string <charT ,traits ,Allocator >& s ); 

1 Effects: Swaps the contents of the two strings.
2 Throws: Nothing.
3 Postcondition:*this contains the characters that were in s , s contains the characters that were in *this.
4 Complexity: constant time.


21.3.6 basic_string string operations [lib.string.ops] 
const charT * c_ str () const ; 

1 Returns: Apointer to the initial element of an array of lengthsize() + 1 whose first size() elements equal the 
corresponding elements of the string controlled by *this and whose last element is a null character specified by 
charT(). 

2 Requires: Theprogramshallnotalteranyofthevaluesstoredinthearray.Norshalltheprogramtreatthe returned 
valueasavalidpointervalueafteranysubsequentcalltoanon-constmember functionoftheclassbasic_string 
that designates the same object as this. 

const charT * data () const ; 

3 Returns: If size() is nonzero, the member returns a pointer to the initial element of an array whose first size() 
elements equal the corresponding elements of the string controlled by *this. If size() is zero, the member 
returns a non-null pointer that is copyable and can have zero added to it. 

4 Requires: The program shall not alter any of the values stored in the character array. Nor shall the program 
treat the returned value as a valid pointer value after anysubsequent call to a non-const member function of 
basic_string that designates the same object as this. 

allocator_type get_allocator() const; 

5 Returns: a copyof the Allocator object used to construct the string. 

21.3.6.1 basic_string::find [lib.string::find] 
size_type find(const basic_string <charT ,traits ,Allocator >& str ,
size_type pos = 0) const ;


1 Effects: Determines the lowest position xpos , if possible, such that bothof the following conditions obtain: 

— pos <= xpos and xpos + str .size() <= size(); 
— traits::eq(at(xpos +I ), str .at(I )) for all elements I of the string controlledby str . 
2 Returns: xpos if the function can determine such a value for xpos . Otherwise, returns npos. 
3 Remarks: Uses traits::eq(). 
Draft 


471 Strings library 21.3 Class template basic_string 

size_type find(const charT* s , size_type pos , size_type n ) const ; 
4 Returns: find(basic_string<charT,traits,Allocator>(s ,n ),pos ). 

size_type find(const charT* s , size_type pos = 0) const ; 
5 Returns: find(basic_string<charT,traits,Allocator>(s ),pos ). 
6 Remarks: Uses traits::length(). 

size_type find(charT c , size_type pos = 0) const ; 
7 Returns: find(basic_string<charT,traits,Allocator>(1,c ),pos ). 

21.3.6.2 basic_string::rfind [lib.string::rfind] 
size_type rfind(const basic_string <charT ,traits ,Allocator >& str ,
size _type pos = npos ) const ;


1 Effects: Determines the highest position xpos , if possible, such that both of the following conditions obtain: 

— xpos <= pos and xpos + str .size() <= size(); 
— traits::eq(at(xpos +I ), str .at(I )) for all elements I of the string controlledby str . 
2 Returns: xpos if the function can determine such a value for xpos . Otherwise, returns npos. 
3 Remarks: Uses traits::eq(). 
size_type rfind(const charT* s , size_type pos , size_type n ) const ; 
4 Returns: rfind(basic_string<charT,traits,Allocator>(s ,n ),pos ). 

size_type rfind(const charT* s , size_type pos = npos ) const ; 
5 Returns: rfind(basic_string<charT,traits,Allocator>(s ),pos ). 
6 Remarks: Uses traits::length(). 

size_type rfind(charT c , size_type pos = npos ) const ; 
7 Returns: rfind(basic_string<charT,traits,Allocator>(1,c ),pos ). 

21.3.6.3 basic_string::find_first_of [lib.string::find.first.of] 
size_type
find_first_of(const basic_string <charT ,traits ,Allocator >& str ,
size _type pos = 0) const ;


1 Effects: Determines the lowest position xpos , if possible, such that bothof the following conditions obtain: 

— pos <= xpos and xpos < size(); 
— traits::eq(at(xpos ), str .at(I )) for some element I of the string controlled by str . 
Draft 


21.3 Class template basic_string Strings library 472 
2 Returns: xpos if the function can determine such a value for xpos . Otherwise, returns npos. 
3 Remarks: Uses traits::eq(). 

size_type 
find_first_of(const charT* s , size_type pos , size_type n ) const ; 
4 Returns: find_first_of(basic_string<charT,traits,Allocator>(s ,n ),pos ). 
size_type find_first_of(const charT* s , size_type pos = 0) const ; 
5 Returns: find_first_of(basic_string<charT,traits,Allocator>(s ),pos ). 
6 Remarks: Uses traits::length(). 

size_type find_first_of(charT c , size_type pos = 0) const ; 
7 Returns: find_first_of(basic_string<charT,traits,Allocator>(1,c ),pos ). 

21.3.6.4 basic_string::find_last_of [lib.string::find.last.of] 
size_type
find_last_of(const basic_string <charT ,traits ,Allocator >& str ,
size_type pos = npos ) const ;


1 Effects: Determines the highest position xpos , if possible, such that both of the following conditions obtain: 

— xpos <= pos and xpos < size(); 
— traits::eq(at(xpos ), str .at(I )) for some element I of the string controlled by str . 
2 Returns: xpos if the function can determine such a value for xpos . Otherwise, returns npos. 
3 Remarks: Uses traits::eq(). 
size_type find_last_of(const charT* s , size_type pos , size_type n ) const ; 
4 Returns: find_last_of(basic_string<charT,traits,Allocator>(s ,n ),pos ). 

size_type find_last_of(const charT* s , size_type pos = npos ) const ; 
5 Returns: find_last_of(basic_string<charT,traits,Allocator>(s ),pos ). 
6 Remarks: Uses traits::length(). 

size_type find_last_of(charT c , size_type pos = npos ) const ; 
7 Returns: find_last_of(basic_string<charT,traits,Allocator>(1,c ),pos ). 

21.3.6.5 basic_string::find_first_not_of [lib.string::find.first.not.of] 
size_type
find_first_not_of(const basic_string <charT ,traits ,Allocator >& str ,
size_type pos = 0) const ;


Draft 


473 Strings library 21.3 Class template basic_string 

1 Effects: Determines the lowest position xpos , if possible, such that bothof the following conditions obtain: 

— pos <= xpos and xpos < size(); 
— traits::eq(at(xpos ), str .at(I )) for no element I of the string controlled by str . 
2 Returns: xpos if the function can determine such a value for xpos . Otherwise, returns npos. 
3 Remarks: Uses traits::eq(). 
size_type 
find_first_not_of(const charT* s , size_type pos , size_type n ) const ; 
4 Returns: find_first_not_of(basic_string<charT,traits,Allocator>(s ,n ),pos ). 
size_type find_first_not_of(const charT* s , size_type pos = 0) const ; 
5 Returns: find_first_not_of(basic_string<charT,traits,Allocator>(s ),pos ). 
6 Remarks: Uses traits::length(). 

size_type find_first_not_of(charT c , size_type pos = 0) const ; 
7 Returns: find_first_not_of(basic_string<charT,traits,Allocator>(1,c ),pos ). 

21.3.6.6 basic_string::find_last_not_of [lib.string::find.last.not.of] 
size_type
find_last_not_of(const basic_string <charT ,traits ,Allocator >& str ,
size_type pos = npos ) const ;


1 Effects: Determines the highest position xpos , if possible, such that both of the following conditions obtain: 

— xpos <= pos and xpos < size(); 
— traits::eq(at(xpos ), str .at(I )) for no element I of the string controlled by str . 
2 Returns: xpos if the function can determine such a value for xpos . Otherwise, returns npos. 
3 Remarks: Uses traits::eq(). 
size_type find_last_not_of(const charT* s , size_type pos , 
size_type n ) const ; 
4 Returns: find_last_not_of(basic_string<charT,traits,Allocator>(s ,n ),pos ). 
size_type find_last_not_of(const charT* s , size_type pos = npos ) const ; 
5 Returns: find_last_not_of(basic_string<charT,traits,Allocator>(s ),pos ). 
6 Remarks: Uses traits::length(). 

size_type find_last_not_of(charT c , size_type pos = npos ) const ; 
7 Returns: find_last_not_of(basic_string<charT,traits,Allocator>(1,c ),pos ). 

Draft 


21.3 Class template basic_string Strings library 474 
21.3.6.7 basic_string::substr [lib.string::substr] 
basic _string <charT ,traits ,Allocator >
substr ( size_type pos = 0 , size_type n = npos ) const ;


1 Requires: pos <= size()
2 Throws: out_of_range if pos > size().
3 Effects: Determines the effective length rlen of the string to copy as the smaller of n and size() -pos .
4 Returns: basic_string<charT,traits,Allocator>(data()+pos ,rlen ).


21.3.6.8 basic_string::compare [lib.string::compare] 
int compare(const basic_string <charT ,traits ,Allocator >& str ) const 

1 Effects: Determines the effectivelength rlen of the strings to compare as the smallest of size() and str.size(). 
The function then compares the two stringsby calling traits::compare(data(), str.data(), rlen). 

2 Returns: the nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as indicated in 
Table46. 

Table 46:compare() results 

Condition Return Value 
size() < str.size() 
size() == str.size() 
size() > str.size() 
< 0 
0 
> 0 

3 
i n t c o m p a r e ( s i z e _ t y p e pos1 , s i z e _ t y p e n1 , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
Returns: 
str ) c o n s t ; 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > ( * t h i s ,pos1 ,n1 ) . c o m p a r e (str ) . 
4 
i n t c o m p a r e ( s i z e _ t y p e pos1 , s i z e _ t y p e n1 , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
s i z e _ t y p e pos2 , s i z e _ t y p e n2 ) c o n s t ; 
Returns: 
str , 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > ( * t h i s ,pos1 ,n1 ) . c o m p a r e ( 
b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > ( str ,pos2 ,n2 ) ) . 
5 
i n t c o m p a r e ( c o n s t c h a r T * s ) c o n s t ; 
Returns: this->compare(basic_string<charT,traits,Allocator>(s )). 
i n t c o m p a r e ( s i z e _ t y p e pos , s i z e _ t y p e 
c o n s t c h a r T * s ) c o n s t ; 
n1 , 
Draft 


475 Strings library 21.3 Class template basic_string 

6 Returns: 

basic _string<charT,traits,Allocator >(*this,pos ,n1 ). compare (
basic_ string <charT ,traits ,Allocator >( s ))


int compare ( size_type pos , size_type n1 ,
const charT * s , size_type n2 ) const ;


7 Returns: 

basic _string<charT,traits,Allocator >(*this,pos ,n1 ). compare (
basic_ string <charT ,traits ,Allocator >( s ,n2 ))


21.3.7 basic_string non-member functions [lib.string.nonmembers] 
21.3.7.1 operator+ [lib.string::op+] 
template < class charT , class traits , class Allocator >
basic _string <charT ,traits ,Allocator >


operator +( const basic_string < charT , traits , Allocator >& lhs ,
const basic_string < charT , traits , Allocator >& rhs );
1 Returns: basic_string<charT,traits,Allocator>(lhs ).append(rhs ) 

template < class charT , class traits , class Allocator >
basic _string <charT ,traits ,Allocator >


operator +( const charT * lhs ,
const basic_string < charT , traits , Allocator >& rhs );
2 Returns: basic_string<charT,traits,Allocator>(lhs )+ rhs . 
3 Remarks: Uses traits::length(). 

template < class charT , class traits , class Allocator >
basic _string <charT ,traits ,Allocator >


operator +( charT lhs ,
const basic_string < charT , traits , Allocator >& rhs );
4 Returns: basic_string<charT,traits,Allocator>(1,lhs )+ rhs . 

template < class charT , class traits , class Allocator >
basic _string <charT ,traits ,Allocator >


operator +( const basic_string < charT , traits , Allocator >& lhs ,
const charT * rhs );
5 Returns: lhs + basic_string<charT,traits,Allocator>(rhs ). 
6 Remarks: Uses traits::length(). 

template < class charT , class traits , class Allocator >
basic _string <charT ,traits ,Allocator >


operator +( const basic_string < charT , traits , Allocator >& lhs ,
charT rhs );
Draft 


21.3 Class template basic_string Strings library 476 
7 Returns: lhs + basic_string<charT,traits,Allocator>(1,rhs ). 
21.3.7.2 operator== [lib.string::operator==] 
1 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
Returns: lhs .compare(rhs ) == 0. 
lhs , 
rhs ) ; 
2 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t c h a r T * lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
Returns: basic_string<charT,traits,Allocator>(lhs ) == rhs . 
rhs ) ; 
3 
4 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
c o n s t c h a r T * rhs ) ; 
Returns: lhs == basic_string<charT,traits,Allocator>(rhs ). 
Remarks: Uses traits::length(). 
lhs , 
21.3.7.3 operator!= [lib.string::op!=] 
1 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
Returns: !(lhs == rhs ). 
lhs , 
rhs ) ; 
2 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t c h a r T * lhs , 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
Returns: basic_string<charT,traits,Allocator>(lhs ) != rhs . 
rhs ) ; 
3 
4 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
c o n s t c h a r T * rhs ) ; 
Returns: lhs != basic_string<charT,traits,Allocator>(rhs ). 
Remarks: Uses traits::length(). 
lhs , 
21.3.7.4 operator< [lib.string::op<] 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
c o n s t b a s i c _ s t r i n g < c h a r T , t r a i t s , A l l o c a t o r > & 
lhs , 
rhs ) ; 
Draft 


477 Strings library 21.3 Class template basic_string 

1 Returns: lhs .compare(rhs )<0. 

template < class charT , class traits , class Allocator >
bool operator < ( const charT * lhs ,
const basic_string < charT , traits , Allocator >& rhs );


2 Returns: basic_string<charT,traits,Allocator>(lhs )< rhs . 

template < class charT , class traits , class Allocator >
bool operator < ( const basic_string < charT , traits , Allocator >& lhs ,
const charT * rhs );


3 Returns: lhs < basic_string<charT,traits,Allocator>(rhs ). 

21.3.7.5 operator> [lib.string::op>] 
template < class charT , class traits , class Allocator >
bool operator > ( const basic_string < charT , traits , Allocator >& lhs ,
const basic_string < charT , traits , Allocator >& rhs );


1 Returns: lhs .compare(rhs )>0. 

template < class charT , class traits , class Allocator >
bool operator > ( const charT * lhs ,
const basic_string < charT , traits , Allocator >& rhs );


2 Returns: basic_string<charT,traits,Allocator>(lhs )> rhs . 

template < class charT , class traits , class Allocator >
bool operator > ( const basic_string < charT , traits , Allocator >& lhs ,
const charT * rhs );


3 Returns: lhs > basic_string<charT,traits,Allocator>(rhs ). 

21.3.7.6 operator<= [lib.string::op<=] 
template < class charT , class traits , class Allocator >
bool operator < =( const basic_string < charT , traits , Allocator >& lhs ,
const basic_string < charT , traits , Allocator >& rhs );


1 Returns: lhs .compare(rhs ) <= 0. 

template < class charT , class traits , class Allocator >
bool operator < =( const charT * lhs ,
const basic_string < charT , traits , Allocator >& rhs );


2 Returns: basic_string<charT,traits,Allocator>(lhs ) <= rhs . 

template < class charT , class traits , class Allocator >
bool operator < =( const basic_string < charT , traits , Allocator >& lhs ,
const charT * rhs );


Draft 


21.3 Class template basic_string Strings library 478 
3 Returns: lhs <= basic_string<charT,traits,Allocator>(rhs ). 

21.3.7.7 operator>= [lib.string::op>=] 
template < class charT , class traits , class Allocator >
bool operator > =( const basic_string < charT , traits , Allocator >& lhs ,
const basic_string < charT , traits , Allocator >& rhs );


1 Returns: lhs .compare(rhs ) >= 0. 

template < class charT , class traits , class Allocator >
bool operator > =( const charT * lhs ,
const basic_string < charT , traits , Allocator >& rhs );


2 Returns: basic_string<charT,traits,Allocator>(lhs ) >= rhs . 

template < class charT , class traits , class Allocator >
bool operator > =( const basic_string < charT , traits , Allocator >& lhs ,
const charT * rhs );


3 Returns: lhs >= basic_string<charT,traits,Allocator>(rhs ). 

21.3.7.8 swap [lib.string.special] 
template < class charT , class traits , class Allocator >
void swap(basic_string <charT ,traits ,Allocator >& lhs ,
basic_string <charT ,traits ,Allocator >& rhs );


1 Effects: lhs .swap(rhs ); 

21.3.7.9 Inserters and extractors [lib.string.io] 
template < class charT , class traits , class Allocator >
basic_istream <charT ,traits >&


operator >>(basic_istream <charT ,traits >& is ,
basic_string <charT ,traits ,Allocator >& str );
1 Effects: Behaves as a formatted input function(27.6.1.2.1). After constructing a sentry object, if the sentry 
converts to true, calls str .erase() and thenextracts characters from is and appends them to str asifbycalling 
str .append(1,c ). If is .width() isgreater than zero, the maximum number n of characters appended is 
is .width();otherwisen is str .max_size(). Charactersareextractedandappendeduntilanyofthefollowing 
occurs: 

— n characters are stored; 
— end-of-file occurs on the input sequence; 
— isspace(c ,is.getloc()) is true for the next available input character c. 
Draft 


479 Strings library 21.3 Class template basic_string 

2 After the last character (if any) is extracted, is .width(0) is called and the sentry object k is destroyed.
3 If the function extracts no characters, it calls is.setstate(ios::failbit), which may throw ios_base::
failure (27.4.4.3).
4 Returns: is


template < class charT , class traits , class Allocator >
basic_ostream <charT , traits >&


operator <<(basic_ostream <charT , traits >& os ,
const basic_string < charT , traits , Allocator >& str );
5 Effects: Begins by constructing a sentry object k as if k were constructed by typename basic_ostream< 
charT, traits>::sentry k (os ). If bool(k) is true, determines padding as described in 22.2.2.2.2, then 
inserts the resulting sequence of characters seq as if by calling os.rdbuf()->sputn(seq , n), where n is the 
larger of os.width() and str.size();then callsos .width(0). If the call to sputn fails, callsos .setstate(ios_
base::failbit). 

6 Returns: os 

template < class charT , class traits , class Allocator >
basic_istream <charT ,traits >&


getline(basic_istream <charT ,traits >& is ,
basic_ string <charT ,traits ,Allocator >& str ,
charT delim );


7 Effects: Behavesasan unformattedinput function(27.6.1.3),exceptthatitdoesnotaffectthevalue returnedby
subsequent calls to basic_istream<>::gcount(). After constructing a sentry object, if the sentry converts
to true, calls str .erase() and then extracts characters from is and appends them to str as if by calling
str .append(1, c ) until anyof the following occurs:


— end-of-file occurs on the input sequence (in which case, the getline function calls is .setstate(ios_
base::eofbit)). 
— traits::eq(c , delim ) for the next available input character c (in which case, c is extracted but not 
appended)(27.4.4.3) 
— str .max_size() characters are stored (in which case, the function calls is .setstate(ios_base:: 
failbit)) (27.4.4.3) 
8 The conditions are tested in the order shown. In anycase, after the last character is extracted, the sentry object
k is destroyed.


9 Ifthe functionextractsno characters,it calls is .setstate(ios_base::failbit) which may throw ios_base
::failure (27.4.4.3).


10 Returns: is . 

template < class charT , class traits , class Allocator >
basic_istream <charT ,traits >&
getline(basic_istream <charT ,traits >& is ,
basic_ string <charT ,traits ,Allocator >& str )


Draft 


21.4 Null-terminated sequence utilities Strings library 480 
11 Returns: getline(is ,str ,is .widen(’\n’)) 

21.4 Null-terminated sequence utilities [lib.c.strings] 
1 Tables47, 48, 49, 50, and 51 describe headers <cctype>, <cwctype>, <cstring>, <cwchar>, and <cstdlib> (multibyte conversions), respectively. 

Table 47: Header<cctype> synopsis 


Type Name(s) 
Functions: 
isalnum isdigit isprint isupper tolower 
isalpha isgraph ispunct isxdigit toupper 
iscntrl islower isspace 


Table 48: Header<cwctype> synopsis 

Type Name(s) 
Macro: WEOF <cwctype> 
Types: wctrans_t wctype_t wint_t <cwctype> 
Functions: 
iswalnum 
iswalpha 
iswcntrl 
iswctype iswlower 
iswdigit iswprint 
iswgraph iswpunct 
iswspace towctrans 
iswupper towlower 
iswxdigit towupper 
wctrans 
wctype 

Table 49: Header<cstring> synopsis 

Type Name(s) 
Macro: NULL <cstring> 
Type: size_t <cstring> 
Functions: 
memchr 
memcmp 
memcpy 
memmove 
memset 
strcat strcspn strncpy 
strchr strerror strpbrk 
strcmp strlen strrchr 
strcoll strncat strspn 
strcpy strncmp strstr 
strtok 
strxfrm 

2 The contents of these headers are the same as the StandardClibrary headers <ctype.h>, <wctype.h>, <string.h>, 
<wchar.h> and <stdlib.h> respectively, with the following modifications: 

3 None of the headers shall define the type wchar_t (2.11). 

4 The function signature strchr(const char*, int) is replacedby the two declarations: 

const char * strchr ( const char * s , int c );
char * strchr ( char * s , int c );


Draft 


481 Strings library 21.4 Null-terminated sequence utilities 

Table 50: Header<cwchar> synopsis 

Type Name(s) 
Macros: NULL <cwchar> WCHAR_MAX WCHAR_MIN WEOF <cwchar> 
Types: mbstate_t wint_t <cwchar> size_t tm 
Functions: 
btowc 
fgetwc 
fgetws 
fputwc 
fputws 
fwide 
fwprintf 
fwscanf 
getwc 
getwchar 
mbrlen 
mbrtowc 
mbsinit 
mbsrtowcs 
putwc 
putwchar 
swprintf 
swscanf 
ungetwc wcscpy 
vfwprintf wcscspn 
vswprintf wcsftime 
vwprintf wcslen 
wcrtomb wcsncat 
wcscat wcsncmp 
wcschr wcsncpy 
wcscmp wcspbrk 
wcscoll wcsrchr 
wcsrtombs 
wcsspn 
wcsstr 
wcstod 
wcstok 
wcstol 
wcstoul 
wcsxfrm 
wctob 
wmemchr 
wmemcmp 
wmemcpy 
wmemmove 
wmemset 
wprintf 
wscanf 

Table 51: Header<cstdlib> synopsis 

Type Name(s) 
Macros: MB_CUR_MAX 
Functions: 
atol mblen 
atof mbstowcs 
atoi mbtowc 
strtod 
strtol 
strtoul 
wctomb 
wcstombs 

Draft 


21.4 Null-terminated sequence utilities Strings library 482 
both of which have the same behavior as the original declaration.
5 The function signature strpbrk(const char*, const char*) is replaced by the two declarations:


const char * strpbrk ( const char * s1 , const char * s2 );
char * strpbrk ( char * s1 , const char * s2 );


both of which have the same behavior as the original declaration.
6 The function signature strrchr(const char*, int) is replaced by the two declarations:


const char * strrchr ( const char * s , int c );
char * strrchr ( char * s , int c );


both of which have the same behavior as the original declaration.
7 The function signature strstr(const char*, const char*) is replacedby the two declarations:


const char * strstr ( const char * s1 , const char * s2 );
char * strstr ( char * s1 , const char * s2 );


both of which have the same behavior as the original declaration.
8 The function signature memchr(const void*, int, size_t) is replacedby the two declarations:


const void * memchr ( const void * s , int c , size_t n );
void * memchr ( void * s , int c , size_t n );


both of which have the same behavior as the original declaration.
9 The function signature wcschr(const wchar_t*, wchar_t) is replaced by the two declarations:


const wchar_t * wcschr ( const wchar_ t * s , wchar_t c );
wchar_t * wcschr ( wchar_ t * s , wchar_t c );


both of which have the same behavior as the original declaration. 
10 The function signature wcspbrk(const wchar_t*, const wchar_t*) is replaced by the two declarations: 

const wchar_t * wcspbrk ( const wchar _t * s1 , const wchar_t * s2 );
wchar_t * wcspbrk ( wchar _t * s1 , const wchar_t * s2 );


both of which have the same behavior as the original declaration. 
11 The function signature wcsrchr(const wchar_t*, wchar_t) is replacedby the two declarations: 

const wchar_t * wcsrchr ( const wchar _t * s , wchar_t c );
wchar_t * wcsrchr ( wchar _t * s , wchar_t c );


both of which have the same behavior as the original declaration. 
12 The function signature wcsstr(const wchar_t*, const wchar_t*) is replacedby the two declarations: 

const wchar_t * wcsstr ( const wchar_ t * s1 , const wchar_t * s2 );
wchar_t * wcsstr ( wchar_ t * s1 , const wchar_t * s2 );


Draft 


483 Strings library 21.4 Null-terminated sequence utilities 

both of which have the same behavior as the original declaration. 
13 The function signature wmemchr(const wwchar_t*, int, size_t) is replaced by the two declarations: 

const wchar_t * wmemchr ( const wchar _t * s , wchar_t c , size _t n );
wchar_t * wmemchr ( wchar _t * s , wchar_t c , size _t n );


both of which have the same behavior as the original declaration.
SEEALSO: ISOCsubclauses 7.3, 7.10.7, 7.10.8, and 7.11. Amendment1subclauses 4.4, 4.5, and 4.6.


Draft 


21.4 Null-terminated sequence utilities Strings library 484 
Draft 


Chapter 22 Localization library [lib.localization]


1 This clause describes components that C++ programs may use to encapsulate (and therefore be more portable when 
confronting) cultural differences. The localefacility includes internationalization support for character classification 
and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. 

2 The following subclauses describe components for locales themselves, the standardfacets, andfacilities from the ISO 
Clibrary,as summarizedinTable 52 

Table 52: Localization library summary 

Subclause Header(s) 
22.1 Locales 
22.2 Standard locale Categories 
<locale> 
22.3 Clibrary locales <clocale> 

22.1 Locales [lib.locales] 
1 Header <locale> synopsis 
n a m e s p a c e s t d { 
// 22.1.1, locale: 
c l a s s l o c a l e ; 
t e m p l a t e < c l a s s 
t e m p l a t e < c l a s s 
F a c e t > 
F a c e t > 
c o n s t 
b o o l 
F a c e t & u s e _ f a c e t ( c o n s t 
h a s _ f a c e t ( c o n s t 
l o c a l e & ) ; 
l o c a l e & ) t h r o w ( ) ; 
// 22.1.3, convenience interfaces: 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
t e m p l a t e < c l a s s c h a r T > 
b o o l i s s p a c e ( c h a r T 
b o o l i s p r i n t ( c h a r T 
b o o l i s c n t r l ( c h a r T 
b o o l i s u p p e r ( c h a r T 
b o o l i s l o w e r ( c h a r T 
b o o l i s a l p h a ( c h a r T 
b o o l i s d i g i t ( c h a r T 
b o o l i s p u n c t ( c h a r T 
b o o l i s x d i g i t ( c h a r T 
b o o l i s a l n u m ( c h a r T 
b o o l i s g r a p h ( c h a r T 
c h a r T t o u p p e r ( c h a r T 
c h a r T t o l o w e r ( c h a r T 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c , 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
c o n s t 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
l o c a l e & 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 
loc ) ; 


22.1 Locales Localization library 486 
// 22.2.1 and 22.2.1.3, ctype: 

class ctype_base;
template < class charT > class ctype ;
template <> class ctype <char >; // specialization
template <class charT > class ctype_byname;
template <> class ctype_ byname <char >; // specialization
class codecvt_base;
template < class internT , class externT , class stateT >


class codecvt ;
template < class internT , class externT , class stateT >
class codecvt_byname;


// 22.2.2 and 22.2.3, numeric: 

template < class charT , class InputIterator > class num_get ;
template < class charT , class OutputIterator > class num_put ;
template < class charT > class numpunct ;
template <class charT > class numpunct_byname;


// 22.2.4, collation: 

template < class charT > class collate ;
template <class charT > class collate_byname;


// 22.2.5, date and time: 

class time_base ;
template < class charT , class InputIterator > class time_get ;
template <class charT , class InputIterator > class time_get_byname;
template < class charT , class OutputIterator > class time_put ;
template <class charT , class OutputIterator > class time_put_byname;


// 22.2.6, money: 

class money_base;
template < class charT , class InputIterator > class money_get ;
template < class charT , class OutputIterator > class money_put ;
template <class charT , bool Intl > class moneypunct;
template <class charT , bool Intl > class moneypunct_byname;


// 22.2.7, message retrieval: 

class messages_base;
template < class charT > class messages ;
template <class charT > class messages_byname;


} 

The header <locale> defines classes and declares functions that encapsulate and manipulate the information peculiar 
to a locale.228) 

22.1.1 Class locale [lib.locale] 
namespace std { 

228) In this subclause, the type name struct tm is an incomplete type that is defined in <ctime>. 

Draft 


487 Localization library 22.1 Locales 

class locale {
public :


// types: 

class facet ;
class id;
typedef int category ;
static const category // values assigned here are for exposition only


none = 0,
collate = 0 x010 , ctype = 0 x020 ,
monetary = 0 x040 , numeric = 0 x080 ,
time = 0 x100 , messages = 0 x200 ,
all = collate | ctype | monetary | numeric | time | messages ;


// construct/copy/destroy: 

locale () throw ();
locale ( const locale & other ) throw ();
explicit locale ( const char * std_name );
locale ( const locale & other , const char * std_name , category );
template < class Facet > locale ( const locale & other , Facet * f );
locale ( const locale & other , const locale & one , category );


~ locale () throw (); // non-virtual 
const locale & operator = ( const locale & other ) throw (); 
template < class Facet > locale combine ( const locale & other ) const ; 

// locale operations: 

basic_string<char> name() const; 

bool operator ==( const locale & other ) const ;
bool operator !=( const locale & other ) const ;


template < class charT , class Traits , class Allocator > 
bool operator()(const basic _string<charT,Traits,Allocator>& s1, 
const basic _string <charT ,Traits ,Allocator >& s2) const; 

// global locale objects: 

static locale global ( const locale &);
static const locale & classic ();
};
}


1 Class locale implementsa type-safe polymorphic setoffacets, indexedbyfacet type. In otherwords,afacet hasa dual 
role:inonesense,it’sjustaclassinterface;atthesametime,it’sanindexintoa locale’ssetoffacets. 
2 Accesstothefacetsofa locale is via two function templates, use_facet<> and has_facet<>. 
3[Example: An iostream operator<< might be implemented as:229) 

template < class charT , class traits >
basic_ostream < charT , traits >&


229) Notice that, in the call to put, the stream is implicitly converted to an ostreambuf_iterator<charT,traits>. 

Draft 


22.1 Locales Localization library 488 
operator << (basic_ostream <charT ,traits >& s, Date d) 
{
typename basic _ostream <charT ,traits >::sentry cerberos(s);
if ( cerberos ) {


ios_base :: iostate err = 0;
tm tmbuf; d.extract(tmbuf);
use_ facet < time _put <charT ,ostreambuf_iterator <charT ,traits > > >(


s.getloc()).put(s, s, s.fill(), err, &tmbuf, ’x’); 
s. setstate ( err ); // might throw
}
return s;
} 

— end example ] 
4 In the call to use_facet<Facet>(loc),thetypeargument choosesafacet,makingavailableall membersofthenamed 
type. If Facet is not present in a locale, it throws the standard exception bad_cast.AC++ program can check if a 
locale implements a particular facet with the function template has_facet<Facet>().User-definedfacetsmay be 
installedina locale, and usedidentically as may standardfacets(22.2.8). 

5 [Note: All locale semantics are accessed via use_facet<> and has_facet<>, except that: 

— Amember operator templateoperator()(basic_string<C,T,A>&, basic_string<C,T,A>&) is provided 
so that a locale may be used as a predicate argument to the standard collections, to collate strings. 
— Convenient global interfaces are provided for traditional ctype functions such as isdigit() and isspace(), 
so that given a locale object loc aC++ program can call isspace(c ,loc ). (This eases upgrading existing 
extractors(27.6.1.2).) — end note ] 
6 Onceafacet referenceis obtained froma locale objectby calling use_facet<>, that reference remains usable, and the 
resultsfrommemberfunctionsofitmaybecachedand re-used,aslongassomelocaleobjectreferstothatfacet. 

7 In successive callstoa localefacet member functiononafacet object installedinthe same locale,thereturned result 
shall be identical. 

8 Alocale constructed froma name string (such as "POSIX"),orfrom partsoftwo named locales,hasa name;all others 
do not. Named locales may be compared for equality; an unnamed locale is equal only to (copies of) itself. For an 
unnamed locale, locale::name() returns the string "*". 

22.1.1.1 locale types [lib.locale.types] 
22.1.1.1.1 Typelocale::category [lib.locale.category] 
typedef int category ; 

1 Valid category values include the locale member bitmask elements collate, ctype, monetary, numeric, time, 
and messages, each of which represents a single locale category. In addition, locale member bitmask constant none 
is defined as zero and represents no category. And locale member bitmask constant all is defined such that the 
expression 

( collate | ctype | monetary | numeric | time | messages | all ) == all 

Draft 


489 Localization library 22.1 Locales 

is true, and represents the union of all categories. Further, the expression (X | Y), where X and Y each represent a 
single category, represents the union of the two categories. 

locale member functions expecting a category argument require one ofthe category values defined above, or the 
unionoftwo or more suchvalues. Sucha category value identifies a set of locale categories. Each locale category, in 
turn, identifiesasetof localefacets, includingat least thoseshowninTable 53: 

Table 53: Locale CategoryFacets 

Category Includes Facets 
collate collate<char>, collate<wchar_t> 
ctype ctype<char>, ctype<wchar_t> 
codecvt<char,char,mbstate_t> 
codecvt<wchar_t,char,mbstate_t> 
monetary moneypunct<char>, moneypunct<wchar_t> 
moneypunct<char,true>, moneypunct<wchar_t,true> 
money_get<char>, money_get<wchar_t> 
money_put<char>, money_put<wchar_t> 
numeric numpunct<char>, numpunct<wchar_t> 
num_get<char>, num_get<wchar_t> 
num_put<char>, num_put<wchar_t> 
time time_get<char>, time_get<wchar_t> 
time_put<char>, time_put<wchar_t> 
messages messages<char>, messages<wchar_t> 

3 For anylocaleloc either constructed, or returned by locale::classic(), and anyfacet Facet shown inTable 53, 
has_facet<Facet >(loc ) is true. Each locale member function which takes a locale::category argument operates on the corresponding setoffacets. 

4 An implementationis requiredtoprovidethose specializationsforfacet templatesidentifiedas membersofacategory, 
and for those showninTable 54: 

5 Theprovided implementationof membersoffacets num_get<charT> and num_put<charT> calls use_facet <F> (l) 
only forfacet F of types numpunct<charT> and ctype<charT>, and for locale l thevalue obtainedbycalling member 
getloc() on the ios_base& argument to these functions. 

6 In declarationsoffacets,a template formal parameter with name InputIterator or OutputIterator indicates the 
set of all possible specializations on parameters that satisfy the requirements of an Input Iterator or an Output Iterator, 
respectively(24.1).A template formal parameter with name C represents the set of all possible specializations on a 
parameter that satisfies the requirements for a character on which anyof the iostream components can be instantiated. 
A template formal parameter with name International represents the set of all possible specializations on a bool 
parameter. 

22.1.1.1.2 Class locale::facet [lib.locale.facet] 
namespace std {
class locale :: facet {
protected :


Draft 


22.1 Locales Localization library 490 
Table 54: Required Specializations 

Category Includes Facets 
collate collate_byname<char>, collate_byname<wchar_t> 
ctype ctype_byname<char>, ctype_byname<wchar_t> 
codecvt_byname<char,char,mbstate_t> 
codecvt_byname<wchar_t,char,mbstate_t> 
monetary moneypunct_byname<char,International> 
moneypunct_byname<wchar_t,International> 
money_get<C,InputIterator> 
money_put<C,OutputIterator> 
numeric numpunct_byname<char>, numpunct_byname<wchar_t> 
num_get<C,InputIterator>, num_put<C,OutputIterator> 
time time_get<char,InputIterator> 
time_get_byname<char,InputIterator> 
time_get<wchar_t,InputIterator> 
time_get_byname<wchar_t,InputIterator> 
time_put<char,OutputIterator> 
time_put_byname<char,OutputIterator> 
time_put<wchar_t,OutputIterator> 
time_put_byname<wchar_t,OutputIterator> 
messages messages_byname<char>, messages_byname<wchar_t> 

explicit facet ( size _t refs = 0); 

virtual ~ facet (); 

private :
facet ( const facet &); // not defined
void operator =( const facet &); // not defined


};
}


1 Templateparameters in this clause which are requiredto befacets are those namedFacet in declarations. Aprogram 
that passesa type thatis not afacet,oratypethat referstoavolatile-qualifiedfacet,asan(explicitor deduced) template 
parametertoa locale functionexpectingafacet,is ill-formed. Aconst-qualifiedfacetisavalid templateargumentto 
anylocale function thatexpectsaFacet template parameter. 

2 The refs argument to the constructor is used for lifetime management. 

— For refs == 0, the implementation performs delete static_cast<locale::facet*>(f) (where f is a 
pointer to the facet) when the last locale object containing the facet is destroyed; for refs == 1, the implementation never destroys thefacet. 
3 Constructors of all facets defined in this clause take such an argument and pass it along to their facet base class 
constructor. All one-argument constructors defined in this clause are explicit, preventing their participation in automatic 
conversions. 

4 For some standardfacetsa standard “..._byname” class, derived from it, implements the virtual function semantics 

Draft 


491 Localization library 22.1 Locales 

equivalent to that facet of the locale constructed by locale(const char*) with the same name. Each such facet 
provides a constructor that takes a const char* argument, which names the locale, and a refs argument, which is 
passed to the base class constructor. If there is no “..._byname”versionofafacet,the base class implements named 
locale semantics itselfby referenceto otherfacets. 

22.1.1.1.3 Class locale::id [lib.locale.id] 
namespace std {
class locale :: id {
public :


id (); 

private :
void operator =( const id &); // not defined
id(const id&); // not defined


};
}


1 The class locale::idprovides identificationofa localefacet interface, usedasan indexforlookupandto encapsulate 
initialization. 

2[Note: Becausefacets are usedby iostreams, potentially while static constructors are running, their initialization cannot 
depend on programmed static initialization. One initialization strategy is for locale to initialize eachfacet’s id member 
the first time an instanceof thefacetis installed intoa locale. This depends only on static storage being zero before 
constructors run(3.6.2). — end note ] 

22.1.1.2 locale constructors and destructor [lib.locale.cons] 
locale () throw (); 

1 Default constructor: a snapshot of the current global locale. 

2 Effects: Constructs a copy of the argument last passed to locale::global(locale&), if it has been called; 
else, the resulting facets have virtual function semantics identical to those of locale::classic().[Note: 
This constructor is commonly used as the default value for arguments of functions that take a const locale& 
argument. — end note ] 

locale ( const locale & other ) throw (); 

3 Effects: Constructs a locale which is a copyof other . 

const locale & operator = ( const locale & other ) throw (); 

4 Effects: Creates a copyof other , replacing the current value. 
5 Returns: *this 

explicit locale ( const char * std_name ); 

6 Effects: Constructs a locale using standard C locale names, e.g. "POSIX". The resulting locale implements 
semantics defined to be associated with that name. 

7 Throws: runtime_error if the argument is not valid, or is null. 

Draft 


22.1 Locales Localization library 492 
8 Remarks: The set of valid string argument values is "C", "", and anyimplementation-defined values. 

locale ( const locale & other , const char * std_name , category ); 

9 Effects: Constructs a locale as a copyof other except for thefacets identifiedby the category argument, which 
instead implement the same semantics as locale(std_name ). 
10 Throws: runtime_error if the argument is not valid, or is null. 
11 Remarks: The locale has a name if andonly if other has a name. 

template < class Facet > locale ( const locale & other , Facet * f ); 

12 Effects: Constructsa locale incorporatingallfacetsfromthefirstargumentexceptthatoftype Facet, and installs 
the second argument as the remainingfacet. If f is null, the resulting object is a copyof other . 

13 Remarks: The resulting locale has no name. 

locale ( const locale & other , const locale & one , category cats ); 

14 Effects: Constructsalocale incorporating allfacets from the first argumentexcept those that implement cats, 
which are instead incorporated from the second argument. 

15 Remarks: The resulting locale has a name if and only if the first two arguments have names. 

~ locale () throw (); 

16 Anon-virtual destructor that throws no exceptions. 

22.1.1.3 locale members [lib.locale.members] 
template < class Facet > locale combine ( const locale & other ) const ; 

1 Effects: Constructsalocale incorporating allfacets from *this exceptforthat onefacetofother that is identified 
by Facet. 
2 Returns: The newly created locale. 
3 Throws: runtime_error if has_facet<Facet>(other) isfalse. 
4 Remarks: The resulting locale has no name. 

basic _string < char > name () const ; 

5 Returns: The name of *this,if it hasone; otherwise, the string"*". If *this hasa name, then locale(name(). 
c_str()) is equivalent to *this. Details of the contents of the resulting string are otherwise implementation-
defined. 

22.1.1.4 locale operators [lib.locale.operators] 
bool operator == ( const locale & other ) const ; 

Draft 


493 Localization library 22.1 Locales 

1 Returns: true if both arguments are the same locale, or one is a copyof the other, or each has a name and the 
names are identical; false otherwise. 

bool operator != ( const locale & other ) const ; 

2 Returns: The result of the expression: !(*this == other ). 

template < class charT , class Traits , class Allocator >
bool operator ()( const basic_string < charT , Traits , Allocator >& s1 ,
const basic_string < charT , Traits , Allocator >& s2 ) const ;


3 Effects: Compares two strings according to the collate<charT> facet. 
4 Remarks: This member operator template (and therefore locale itself) satisfies requirements for a comparator 
predicate template argument (clause 25)applied to strings. 
5 Returns: The result of the following expression: 

use _facet < collate <charT > >(*this).compare 
(s1 . data () , s1 . data ()+ s1 . size () , s2 . data () , s2 . data ()+ s2 . size ()) < 0; 

6[Example: A vector of strings v can be collated according to collation rules in locale loc simply by(25.3.1, 
23.2.4): 

std::sort(v.begin(), v.end(), loc); 

— end example ] 
22.1.1.5 locale static members [lib.locale.statics] 
static locale global ( const locale & loc ); 

1 Sets the global locale toits argument. 

2 Effects: Causes future calls to the constructor locale() to returnacopyoftheargument.Iftheargumenthasa 
name, does 

std::setlocale(LC _ALL, loc.name().c _str()); 

otherwise,theeffectontheClocale,ifany,is implementation-defined.No library function otherthan locale:: 
global() shall affect the value returned by locale(). 

3 Returns: The previous value of locale(). 

static const locale & classic (); 

4 The "C" locale.
5 Returns: Alocale that implements the classic"C" locale semantics, equivalent to the value locale("C").
6 Remarks: This locale, itsfacets, andtheir member functions,do not change with time.


Draft 


22.1 Locales Localization library 494 
22.1.2 locale globals [lib.locale.global.templates] 
template < class Facet > const Facet & use_facet ( const locale & loc ); 

1 Requires: Facet isafacet class whose definition contains the public static member id as defined in 22.1.1.1.2.
2 Returns: a referencetothe correspondingfacetof loc , if present.
3 Throws: bad_cast if has_facet<Facet>(loc) is false.
4 Remarks: The reference returned remains valid at least as long as anycopyof loc exists.


template < class Facet > bool has_facet ( const locale & loc ) throw (); 

5 Returns: trueif thefacet requestedis presentin loc ;otherwisefalse. 

22.1.3 Convenience interfaces [lib.locale.convenience] 
22.1.3.1 Character classification [lib.classification] 
template < class charT > bool isspace ( charT c , const locale & loc );
template < class charT > bool isprint ( charT c , const locale & loc );
template < class charT > bool iscntrl ( charT c , const locale & loc );
template < class charT > bool isupper ( charT c , const locale & loc );
template < class charT > bool islower ( charT c , const locale & loc );
template < class charT > bool isalpha ( charT c , const locale & loc );
template < class charT > bool isdigit ( charT c , const locale & loc );
template < class charT > bool ispunct ( charT c , const locale & loc );
template < class charT > bool isxdigit ( charT c , const locale & loc );
template < class charT > bool isalnum ( charT c , const locale & loc );
template < class charT > bool isgraph ( charT c , const locale & loc );


1 Each of these functions isF returns the result of the expression: 

use_ facet < ctype < charT > >( loc ). is ( ctype_base ::F, c ) 

where Fis the ctype_base::mask value corresponding to that function(22.2.1).230) 

22.1.3.2 Character conversions [lib.conversions] 
template < class charT > charT toupper ( charT c , const locale & loc ); 

1 Returns: use_facet<ctype<charT> >(loc).toupper(c). 

template < class charT > charT tolower ( charT c , const locale & loc ); 

2 Returns: use_facet<ctype<charT> >(loc).tolower(c). 

230) Whenusedinaloop,itisfastertocachethe ctype<> facet and use it directly, or use the vector form ofctype<>::is. 

Draft 


495 Localization library 22.2 Standard locale categories 

22.2 Standard locale categories [lib.locale.categories] 
1 Eachof the standard categories includesafamilyoffacets. Someof these implement formatting or parsingofa datum, 
for use by standard or users’ iostream operators << and >>, as members put() and get(), respectively. Each such 
member function takes an ios_base& argument whose members flags(), precision(), and width(), specify the 
formatofthe corresponding datum.(27.4.2). Those functionswhichneedtouseotherfacetscallits member getloc() 
to retrieve the locale imbued there. Formattingfacets use the character argumentfill to fill out the specified width 
where necessary. 

2 The put() members make no provision for error reporting. (Any failures of the OutputIterator argument must be 
extracted from the returned iterator.) The get() members take an ios_base::iostate& argument whose value they 
ignore,but set to ios_base::failbit in case of a parse error. 

22.2.1 The ctype category [lib.category.ctype] 
namespace std {
class ctype_base {
public :


typedef T mask ; 

// numeric values are for exposition only. 

static const mask space = 1 < < 0;
static const mask print = 1 < < 1;
static const mask cntrl = 1 < < 2;
static const mask upper = 1 < < 3;
static const mask lower = 1 < < 4;
static const mask alpha = 1 < < 5;
static const mask digit = 1 < < 6;
static const mask punct = 1 < < 7;
static const mask xdigit = 1 < < 8;
static const mask alnum = alpha | digit ;
static const mask graph = alnum | punct ;


};
}


1 The type mask isa bitmask type(17.3.2.1.2). 

22.2.1.1 Class template ctype [lib.locale.ctype] 
namespace std {
template < class charT >
class ctype : public locale::facet , public ctype_base {
public :


typedef charT char_type ;
explicit ctype ( size _t refs = 0);


bool is(mask m , charT c ) const ;
const charT* is(const charT* low , const charT * high , mask * vec ) const ;
const charT * scan_is ( mask m ,


const charT * low , const charT * high ) const ; 
const charT * scan_not ( mask m , 

Draft 


22.2 Standard locale categories Localization library 496 
const charT * low , const charT * high ) const ; 
charT toupper ( charT c ) const ; 
const charT * toupper ( charT * low , const charT * high ) const ; 
charT tolower ( charT c ) const ; 
const charT * tolower ( charT * low , const charT * high ) const ; 

charT widen ( char c ) const ;
const char * widen ( const char * low , const char * high , charT * to ) const ;
char narrow ( charT c , char dfault ) const ;
const charT * narrow ( const charT * low , const charT * , char dfault ,


char * to ) const ; 

static locale::id id; 

protected : 

~ ctype (); // virtual 
virtual bool do _is ( mask m , charT c ) const ; 
virtual const charT * do _is ( const charT * low , const charT * high , 

mask * vec ) const ; 
virtual const charT* do_scan_is(mask m , 
const charT * low , const charT * high ) const ; 
virtual const charT* do_scan_not(mask m , 

const charT * low , const charT * high ) const ; 
virtual charT do_toupper(charT) const; 
virtual const charT* do_toupper(charT* low , const charT * high ) const ; 
virtual charT do_tolower(charT) const; 
virtual const charT* do_tolower(charT* low , const charT * high ) const ; 
virtual charT do _widen ( char ) const ; 
virtual const char * do _widen ( const char * low , const char * high , 

charT * dest ) const ; 
virtual char do_narrow(charT , char dfault ) const ; 
virtual const charT * do_narrow ( const charT * low , const charT * high , 

char dfault , char * dest ) const ;
};
}


1 Class ctype encapsulates theClibrary <cctype> features. istream members are required to use ctype<> for character 
classing during input parsing. 

2 The specializations requiredinTable 53(22.1.1.1.1),namelyctype<char> and ctype<wchar_t>,implement character 
classing appropriate to theimplementation’s native character set. 

22.2.1.1.1 ctype members [lib.locale.ctype.members] 
bool is(mask m , charT c ) const ;
const charT* is(const charT* low , const charT * high ,
mask * vec ) const ;


1 Returns: do_is(m ,c ) or do_is(low ,high ,vec ) 

const charT * scan _is ( mask m , 

Draft 


497 Localization library 22.2 Standard locale categories 

const charT * low , const charT * high ) const ; 
2 Returns: do_scan_is(m ,low ,high ) 
const charT * scan_not ( mask m , 
const charT * low , const charT * high ) const ; 
3 Returns: do_scan_not(m ,low ,high ) 

charT toupper ( charT ) const ; 

const charT * toupper ( charT * low , const charT * high ) const ; 

4 Returns: do_toupper(c ) or do_toupper(low ,high ) 

charT tolower ( charT c ) const ; 

const charT * tolower ( charT * low , const charT * high ) const ; 

5 Returns: do_tolower(c ) or do_tolower(low ,high ) 
charT widen ( char c ) const ; 
const char * widen ( const char * low , const char * high , charT * to ) const ; 
6 Returns: do_widen(c ) or do_widen(low ,high ,to ) 
char narrow ( charT c , char dfault ) const ; 
const charT * narrow ( const charT * low , const charT*, char dfault , 
char * to ) const ; 
7 Returns: do_narrow(c ,dfault ) or do_narrow(low ,high ,dfault ,to ) 

22.2.1.1.2 ctype virtual functions [lib.locale.ctype.virtuals] 
bool do _is ( mask m , charT c ) const ;
const charT * do _is ( const charT * low , const charT * high ,
mask * vec ) const ;


1 Effects: Classifies a character or sequence of characters. For each argument character, identifies a value M of 

type ctype_base::mask. The second form identifies a value M of type ctype_base::mask for each *p where 

(low <=p && p <high ), and places it into vec [p -low ]. 

2 Returns: The first form returns the result of the expression (M & m ) != 0; i.e.,true if the character has the 
characteristics specified. The second form returns high . 

const charT * do_scan_is ( mask m ,
const charT * low , const charT * high ) const ;


3 Effects: Locatesa characterinabuffer that conformstoa classification m . 

4 Returns: The smallest pointer p in the range [low , high ) such that is(m ,*p ) would return true;otherwise, 
returns high . 

const charT* do_scan_not(mask m ,
const charT * low , const charT * high ) const ;


Draft 


22.2 Standard locale categories Localization library 498 
5 Effects: Locatesa characterinabuffer thatfailsto conformtoa classification m. 

6 Returns: The smallest pointer p , if any, in the range [low ,high ) such that is(m ,*p ) would return false; 
otherwise, returns high . 

charT do_toupper ( charT c ) const ;
const charT * do_toupper ( charT * low , const charT * high ) const ;


7 Effects: Convertsa character or charactersto upper case. The second form replaces each character *p in the range 
[low ,high ) for which a corresponding upper-case character exists, with that character. 

8 Returns: The first form returns the corresponding upper-case character if it is known to exist, or its argument if 
not. The second form returns high . 

charT do_tolower ( charT c ) const ;
const charT * do_tolower ( charT * low , const charT * high ) const ;


9 Effects: Convertsa characteror characterstolower case. The second form replaces each character *p in the range 
[low ,high ) and for which a corresponding lower-case character exists, with that character. 

10 Returns: The first form returns the corresponding lower-case character if it is known to exist, or its argument if 
not. The second form returns high . 

charT do_widen ( char c ) const ;
const char * do_widen ( const char * low , const char * high ,
charT * dest ) const ;


11 Effects: Applies the simplest reasonable transformation from a char value or sequence of char values to the 
corresponding charT value or values.231) The only characters for which unique transformations are required are 
thosein the basic sourcecharacter set(2.2). 

For anynamedctype category with a ctype<charT> facetctc and valid ctype_base::mask value M , (ctc. 
is(M , c ) || !is(M , do_widen(c )) ) is true.232) 

The second form transforms each character *p in the range [low ,high ), placing the result in dest [p -low ]. 

12 Returns: The first form returns the transformed value. The second form returns high . 

char do_narrow ( charT c , char dfault ) const ;
const charT * do_narrow ( const charT * low , const charT * high ,
char dfault , char * dest ) const ;


13 Effects: Applies the simplest reasonable transformation from a charT value or sequence of charT values to the 
corresponding char value or values. 

For anycharacterc in the basic source character set(2.2)the transformationis suchthat 

do_widen ( do_narrow (c ,0)) == c 

For anynamedctype category with a ctype<char> facetctc however, and ctype_base::mask value M , 
(is(M ,c ) || ! ctc .is(M , do_narrow (c ,dfault )) ) 

231) The char argument of do_widen is intended to accept values derived from character literals for conversion to the locale’s encoding. 
232)Inotherwords,the transformed characterisnota memberofanycharacter classificationthat c is not also a member of. 

Draft 


499 Localization library 22.2 Standard locale categories 

is true (unless do_narrow returns dfault ). In addition, for anydigit character c , the expression (do_narrow(c , dfault ) -’0’) evaluates to the digit value of the character. The second form transforms each character *p in the range [low ,high ),placing the result (ordfault ifnosimpletransformationis readilyavailable) 
in dest [p -low ]. 

Returns: The first form returns the transformed value; or dfault if no mapping is readily available. The second 
form returns high . 

22.2.1.2 Class template ctype_byname [lib.locale.ctype.byname] 
namespace std {
template < class charT >
class ctype_byname : public ctype <charT > {
public :


typedef ctype < charT >:: mask mask ;
explicit ctype_byname(const char*, size_t refs = 0);
protected :
~ctype_byname (); // virtual
};
}


22.2.1.3 ctype specializations [lib.facet.ctype.special] 
namespace std {
template <> class ctype <char >
: public locale :: facet , public ctype_base {
public :
typedef char char_type ;


explicit ctype ( const mask * tab = 0 , bool del = false ,
size _t refs = 0);


bool is ( mask m , char c ) const ;
const char* is(const char* low , const char * high , mask * vec ) const ;
const char * scan_is ( mask m ,


const char * low , const char * high ) const ; 
const char * scan _not ( mask m , 
const char * low , const char * high ) const ; 

char toupper ( char c ) const ;
const char * toupper ( char * low , const char * high ) const ;
char tolower ( char c ) const ;
const char * tolower ( char * low , const char * high ) const ;


char widen ( char c ) const ;
const char * widen ( const char * low , const char * high , char * to ) const ;
char narrow ( char c , char dfault ) const ;
const char * narrow ( const char * low , const char * high , char dfault ,


char * to ) const ; 

Draft 


22.2 Standard locale categories Localization library 500 
static locale::id id;
static const size _t table_size = IMPLEMENTATION_DEFINED ;


protected :
const mask * table () const throw ();
static const mask* classic_table() throw();


~ ctype (); // virtual 
virtual char do_toupper(char c ) const ; 
virtual const char* do_toupper(char* low , const char * high ) const ; 
virtual char do_tolower(char c ) const ; 
virtual const char* do_tolower(char* low , const char * high ) const ; 

virtual char do_widen ( char c ) const ; 

virtual const char * do_widen ( const char * low ,
const char * high ,
char * to ) const ;


virtual char do_narrow ( char c , char dfault ) const ; 

virtual const char * do_narrow ( const char * low ,
const char * high ,
char dfault , char * to ) const ;


};
}


1 Aspecializationctype<char> is provided so that the member functions on type char can be implemented inline.233) 
The implementation-defined value of member table_size is at least 256. 

22.2.1.3.1 ctype<char> destructor [lib.facet.ctype.char.dtor] 
~ ctype (); 

1 Effects: If the constructor’s first argument was nonzero, and its second argument was true, does delete [] 
table(). 

22.2.1.3.2 ctype<char> members [lib.facet.ctype.char.members] 
1 In the following member descriptions, for unsigned char values v where (v >= table_size), table()[v ] is 
assumed to have an implementation-defined value (possibly different for each such value v )without performing the 
array lookup. 

explicit ctype ( const mask * tbl = 0 , bool del = false ,
size_t refs = 0);


2 Precondition: tbl either0 oran arrayofatleast table_size elements. 
3 Effects: Passes itsrefs argument to its base class constructor. 

233) Only the char (not unsigned char and signed char)form is provided. The specialization is specified in the standard, and not left as an 
implementation detail, because it affects the derivation interface for ctype<char>. 

Draft 


501 Localization library 22.2 Standard locale categories 

bool is(mask m , char c ) const ;
const char* is(const char* low , const char * high ,
mask * vec ) const ;


4 Effects: The second form, for all *p in the range [low ,high ), assigns into vec [p -low ] the value table()[ (unsigned char)*p ]. 

5 Returns: The first form returns table()[(unsigned char)c] & m;the second form returnshigh . 

const char * scan _is ( mask m ,
const char * low , const char * high ) const ;
6 Returns: The smallest p in the range [low ,high ) such that
table ()[( unsigned char ) * p ]& m


is true. 

const char * scan_not ( mask m ,
const char * low , const char * high ) const ;
7 Returns: The smallest p in the range [low ,high ) such that
table ()[( unsigned char ) * p ]& m


is false. 

char toupper ( char c ) const ; 

const char * toupper ( char * low , const char * high ) const ; 

8 Returns: do_toupper(c ) or do_toupper(low ,high ), respectively.
char tolower ( char c ) const ;
const char * tolower ( char * low , const char * high ) const ;


9 Returns: do_tolower(c ) or do_tolower(low ,high ), respectively. 
char widen ( char c ) const ; 
const char * widen ( const char * low , const char * high , 
char * to ) const ; 
10 Returns: do_widen(c ) or do_widen(low , high , to ), respectively. 
char narrow ( char c , char dfault ) const ; 
const char * narrow ( const char * low , const char * high , 
char dfault , char * to ) const ; 
11 Returns: do_narrow(c , dfault ) or do_narrow(low , high , dfault , to ), respectively. 

const mask * table () const throw (); 

12 Returns: The first constructor argument, if it was non-zero, otherwise classic_table(). 

Draft 


22.2 Standard locale categories Localization library 502 
22.2.1.3.3 ctype<char> static members [lib.facet.ctype.char.statics] 
static const mask* classic_table() throw(); 

Returns: Apointer to the initial element of an array of sizetable_size which represents the classifications of 
characters in the "C" locale. 

22.2.1.3.4 ctype<char> virtual functions [lib.facet.ctype.char.virtuals] 
char do_toupper ( char ) const ;
const char* do_toupper(char* low , const char* high) const;
char do_tolower ( char ) const ;
const char* do_tolower(char* low , const char* high) const;


virtual char do_widen ( char c ) const ; 

virtual const char * do_widen ( const char * low ,
const char * high ,
char * to ) const ;


virtual char do_narrow ( char c , char dfault ) const ; 

virtual const char * do_narrow ( const char * low ,
const char * high ,
char dfault , char * to ) const ;


These functions are describedidentically as those members of the same name in the ctype class template(22.2.1.1.1). 

22.2.1.4 Class template codecvt [lib.locale.codecvt] 
namespace std {
class codecvt_base {
public :


enum result { ok , partial , error , noconv };
};
template < class internT , class externT , class stateT >
class codecvt : public locale::facet , public codecvt_base {
public :


typedef internT intern_type ;
typedef externT extern_type ;
typedef stateT state_type;


explicit codecvt ( size _t refs = 0); 

result out ( stateT & state , 
const internT * from , const internT * from_end , const internT *& from_next , 
externT * to , externT * to_limit , externT *& to_next ) const ; 
result unshift ( stateT & state , 
externT * to , externT * to_limit , externT *& to_next ) const ; 
result in(stateT& state , 
const externT * from , const externT * from_end , const externT *& from_next , 
internT * to , internT * to_limit , internT *& to_next ) const ; 
int encoding () const throw (); 

Draft 


503 Localization library 22.2 Standard locale categories 

bool always_noconv() const throw();
int length(stateT&, const externT* from , const externT * end ,
size_t max ) const ;
int max_length() const throw();


static locale::id id; 

protected :
~ codecvt (); // virtual
virtual result do _out ( stateT & state ,


const internT * from , const internT * from_end , const internT *& from_next , 
externT * to , externT * to_limit , externT *& to_next ) const ; 
virtual result do_in ( stateT & state , 
const externT * from , const externT * from_end , const externT *& from_next , 
internT * to , internT * to_limit , internT *& to_next ) const ; 
virtual result do_unshift(stateT& state , 

externT * to , externT * to_limit , externT *& to_next ) const ; 
virtual int do_encoding() const throw(); 
virtual bool do_always_noconv () const throw (); 
virtual int do_length ( stateT & , const externT * from , 

const externT * end , size _t max ) const ;
virtual int do_max_length() const throw();
};
}


1 The class codecvt<internT,externT,stateT> isfor use when converting from one codeset to another, such as from 
wide characters to multibyte characters or between wide character encodings such as Unicode and EUC. 

2 The stateT argument selects the pair of codesets being mapped between. 

3 The specializations requiredinTable 53(22.1.1.1.1),namelycodecvt<wchar_t, char, mbstate_t> and codecvt< 
char, char, mbstate_t>, convert the implementation-defined native character set. codecvt<char, char, mbstate_t> implements a degenerate conversion; it does not convert at all. codecvt<wchar_t,char,mbstate_t> 
converts between the native character sets for tinyand wide characters. Specializations on mbstate_t perform conversion between encodings known to the library implementor. Other encodings can be converted by specializing on 
a user-defined stateT type. The stateT object can contain any state that is useful to communicate to or from the 
specialized do_in or do_out members. 

22.2.1.4.1 codecvt members [lib.locale.codecvt.members] 
result out ( stateT & state ,
const internT * from , const internT * from_end , const internT *& from_next ,
externT * to , externT * to_limit , externT *& to_next ) const ;


1 Returns: do_out(state , from , from_end , from_next , to ,to_limit , to_next ) 

result unshift ( stateT & state ,
externT * to , externT * to_limit , externT *& to_next ) const ;


2 Returns: do_unshift(state , to , to_limit , to_next ) 

Draft 


22.2 Standard locale categories Localization library 504 
result in(stateT& state ,
const externT * from , const externT * from_end , const externT *& from_next ,
internT * to , internT * to_limit , internT *& to_next ) const ;


3 Returns: do_in(state , from ,from_end ,from_next , to ,to_limit ,to_next ) 

int encoding () const throw (); 

4 Returns: do_encoding() 

bool always_noconv () const throw (); 

5 Returns: do_always_noconv() 

int length ( stateT & state , const externT * from , const externT * from_end ,
size_t max ) const ;


6 Returns: do_length(state , from ,from_end ,max ) 

int max_length () const throw (); 

7 Returns: do_max_length() 

22.2.1.4.2 codecvt virtual functions [lib.locale.codecvt.virtuals] 
result do_out ( stateT & state ,
const internT * from , const internT * from_end , const internT *& from_next ,
externT * to , externT * to_limit , externT *& to_next ) const ;


result do _in ( stateT & state ,
const externT * from , const externT * from_end , const externT *& from_next ,
internT * to , internT * to_limit , internT *& to_next ) const ;


1 Preconditions: (from <=from_end && to <=to_end ) well-defined and true;state initialized, if at the beginning of a sequence, or else equal to the result of converting the preceding characters in the sequence. 

2 Effects: Translates characters in the source range[from ,from_end ), placing the results in sequential positions 
starting at destination to . Converts no more than (from_end -from ) source elements, and stores no more than 
(to_limit -to ) destination elements. 

Stops if it encounters a character it cannot convert. It always leaves the from_next and to_next pointers 
pointing one beyond the last element successfully converted. If returns noconv, internT and externT are the 
same type and the convertedsequence is identical to the input sequence [from , from_next ). to_next is set 
equal to to , the value of state is unchanged, and there are no changes to the values in [to , to_limit ). 

3 Acodecvt facet that is used bybasic_filebuf (27.8)shall have the property that if 

do_out ( state , from , from _end , from_ next , to , to_ limit , to_next ) 

would return ok, where from != from_end, then 

do_out ( state , from , from + 1 , from_ next , to , to _end , to_next ) 

Draft 


505 Localization library 22.2 Standard locale categories 

shall also return ok, and that if 

do _in ( state , from , from _end , from_ next , to , to_ limit , to_next ) 

would return ok, where to != to_end, then 

do _in ( state , from , from _end , from_ next , to , to + 1 , to_next ) 

shall also return ok.234) 

4 Remarks: Its operations on state are unspecified.[ Note: This argument can be used, for example, to maintain 
shift state, to specify conversion options (such as count only), or to identify a cache ofseek offsets. — end note ] 

5 Returns: An enumerationvalue, as summarizedinTable 55: 

Table 55:do_in/do_out result values 

Value Meaning 

ok completed the conversion 

partial not all source characters converted 

error encountered a character in [from ,from_end) that it 
could not convert 

noconv internT and externT are the same type, and input 
sequence is identical to converted sequence 

A return value of partial, if (from_next ==from_end ), indicates that either the destination sequence has 
not absorbed all the available destination elements, or that additional source elements are needed before another 
destination element canbe produced. 

result do_unshift(stateT& state ,
externT * to , externT * to_limit , externT *& to_next ) const ;


6 Requires: (to <= to_end ) well defined and true; state initialized, if at the beginning of a sequence, or else 
equal to the result of converting the preceding characters in the sequence. 

7 Effects: Places characters starting at to that shouldbe appendedto terminatea sequencewhenthe current stateT 
is given by state .235) Stores no more than (to_limit -to ) destination elements, and leaves the to_next 
pointer pointing one beyond thelast element successfully stored. codecvt<char, char, mbstate_t> stores 
no characters. 

8 Returns: An enumerationvalue, as summarizedinTable 56: 

codecvt<char,char,mbstate_t>, returns noconv. 

int do_encoding () const throw (); 

234)Informally, this means that basic_filebuf assumesthatthe mappingsfrom internaltoexternal charactersis1 toN:a codecvt facet that is 
usedby basic_filebuf must be able to translate characters one internal character at a time. 
235)Typicallythesewillbe charactersto returnthe statetostateT() 

Draft 


22.2 Standard locale categories Localization library 506 
Table 56:do_unshift result values 

Value Meaning 
ok completed the sequence 
partial space for more than to_limit-to destination elements 
was needed to terminate a sequence given the value of 
state 
error an unspecified error has occurred 
noconv no termination is needed for this state_type 

9 Returns: -1 if the encoding of the externT sequence is state-dependent; else the constant number of externT 
characters neededtoproducean internal character;or0ifthis numberisnota constant236). 

bool do_always_noconv() const throw(); 

10 Returns: true if do_in() and do_out() return noconv for all valid argument values. codecvt<char, char, 
mbstate_t> returns true. 

int do_length ( stateT & state , const externT * from , const externT * from_end ,
size_t max ) const ;


11 Preconditions: (from <=from_end ) well-defined and true;state initialized,ifatthebeginningofa sequence, 
or else equal to the result of converting the preceding characters in the sequence. 

12 Effects: The effect on the state argumentis“asif”it called do_in(state , from , from_end , from , to , 
to+max , to ) for to pointingtoabufferofat least max elements. 

13 Returns: (from_next -from ) where from_next is the largest value in the range [from ,from_end ] such that 
the sequence of values in the range [from ,from_next ) represents max or fewer valid complete characters of 
type internT . The specialization codecvt<char, char, mbstate_t>,returns the lesser ofmax and (from_
end -from ). 

int do_max_length () const throw (); 

14 Returns: The maximum value that do_length(state , from , from_end , 1) can return for any valid range 
[from , from_end ) and stateT value state . The specialization codecvt<char, char, mbstate_t>:: 
do_max_length() returns 1. 

22.2.1.5 Class template codecvt_byname [lib.locale.codecvt.byname] 
namespace std {
template < class internT , class externT , class stateT >
class codecvt_byname : public codecvt < internT , externT , stateT > {
public :


explicit codecvt_byname(const char*, size_t refs = 0);
protected :
~codecvt_byname (); // virtual


};
}


236) If encoding() yields -1, then more than max_length() externT elements may be consumed when producing a single internT character, and 
additional externT elements may appear at the end of a sequence after those that yield the final internT character. 
Draft 


507 Localization library 22.2 Standard locale categories 

22.2.2 The numeric category [lib.category.numeric] 
1 The classes num_get<> and num_put<> handle numeric formatting and parsing. Virtual functions are provided for 
several numeric types. Implementations may (but are not required to) delegate extraction of smaller types to extractors 
for larger types.237) 

2 All specifications of member functions for num_put and num_get in the subclauses of 22.2.2 only apply to the specializations required inTables 53 and 54(22.1.1.1.1), namely num_get<char>, num_get<wchar_t>, num_get<C, InputIterator>, num_put<char>, num_put<wchar_t>, and num_put<C,OutputIterator>. These specializations 
refer to the ios_base& argument for formatting specifications(22.2), and to its imbued locale for the numpunct<> 
facet to identify all numeric punctuation preferences, and also for thectype<> facet to perform character classification. 

3 Extractor and inserter members of the standard iostreams use num_get<> and num_put<> member functions for formatting and parsing numericvalues(27.6.1.2.1, 27.6.2.5.1). 

22.2.2.1 Class template num_get [lib.locale.num.get] 
namespace std { 
template <class charT , class InputIterator = istreambuf_iterator <charT > > 
class num_get : public locale :: facet { 
public : 

typedef charT char_type;
typedef InputIterator iter_type;


explicit num_get ( size _t refs = 0); 

iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , bool & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base & , 
ios_base :: iostate & err , long & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , unsigned short & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , unsigned int & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , unsigned long & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , float & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , double & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , long double & v ) const ; 
iter_type get(iter_type in , iter_type end , ios_base &, 
ios_base :: iostate & err , void *& v ) const ; 

static locale::id id; 

protected :
~ num_get (); // virtual


237)Parsing"-1" correctly into (e.g.) an unsigned short requires that the corresponding member get() at leastextract the sign before delegating. 

Draft 


22.2 Standard locale categories Localization library 508 
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , bool & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , long & v ) const ;


virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , unsigned short & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,


ios_base :: iostate & err , unsigned int & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , unsigned long & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , float & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , double & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , long double & v ) const ;
virtual iter_type do_ get(iter _type , iter _type , ios_ base&,
ios_base :: iostate & err , void *& v ) const ;
};
}


1 Thefacet num_get is used to parse numeric values from an input sequence such as an istream. 

22.2.2.1.1 num_get members [lib.facet.num.get.members] 
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , bool & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , long & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , unsigned short & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , unsigned int & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , unsigned long & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , float & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , double & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , long double & val ) const ;
iter_type get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , void *& val ) const ;


1 Returns: do_get(in , end , str , err , val ). 

22.2.2.1.2 num_get virtual functions [lib.facet.num.get.virtuals] 
iter_type do_get(iter_type in , iter_type end , ios_base & str , 

Draft 


509 Localization library 22.2 Standard locale categories 

ios_base :: iostate & err , long & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , unsigned short & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , unsigned int & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , unsigned long & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , float & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , double & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , long double & val ) const ;
iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , void *& val ) const ;


1 Effects: Reads characters from in , interpreting them according to str .flags(), use_facet<ctype<charT> 
>(loc ), and use_facet< numpunct<charT> >(loc ), where loc is str .getloc(). If an error occurs, val 
is unchanged; otherwise it is set to the resulting value. 

2 The details of this operation occur in three stages 

— Stage 1: Determine a conversion specifier 
— Stage 2: Extract characters from in and determine a corresponding char value for the format expected by 
the conversion specification determined in stage 1. 
— Stage 3: Store results 
3 The details of the stages are presented below. 
Stage 1: The function initializeslocalvariables via 

fmtflags flags = str . flags ();
fmtflags basefield = ( flags & ios_base :: basefield );
fmtflags uppercase = ( flags & ios_base :: uppercase );
fmtflags boolalpha = ( flags & ios_base :: boolalpha );


For conversion to an integral type, the function determines the integral conversion specifier as indicated in 
Table57. The tableis ordered. Thatis,the first line whose conditionis true applies. 

Table 57: Integer Conversions 

State stdio equivalent 
basefield == oct %o 
basefield == hex %X 
basefield == 0 %i 
signed integral type %d 
unsigned integral type %u 

For conversions to a floating type the specifier is%g. 
Draft 


22.2 Standard locale categories Localization library 510 
For conversions tovoid* the specifier is %p.
Alength modifieris addedtothe conversion specification,if needed,as indicatedinTable58.


Table 58: Length Modifier 

type length modifier 
short h 
unsigned short h 
long l 
unsigned long l 
double l 
long double L 

Stage 2: If in ==end then stage2 terminates. Otherwise a charT is taken from in and local variables are 
initialized asifby 

char_type ct = * in ;
char c = src[find(atoms , atoms + sizeof(src) -1, ct) -atoms];
if ( ct == use _facet <numpunct <charT > >( loc ). decimal_point () )


c = ’.’; 
bool discard = 
( ct == use _facet <numpunct <charT > >( loc ). thousands_sep () 
&& 
use _facet <numpunct <charT > >( loc ).grouping().length() != 0 ); 

where the values src and atoms are defined as if by: 

static const char src[] = "0123456789abcdefxABCDEFX+-";
char_type atoms [ sizeof ( src )];
use _facet <ctype <charT > >(loc).widen(src , src + sizeof(src), atoms);


for this value of loc. 

If discard is true, then if ’.’ has not yet been accumulated, then the position of the character is remembered,butthe characteris otherwise ignored. Otherwise,if ’.’ has already been accumulated, the character 
is discarded and Stage2terminates. 

If the character is either discarded or accumulated then in is advanced by ++in and processing returns to 
the beginning of stage 2. 

Stage 3: The resultof stage2processing canbe oneof 

— Asequence ofcharshasbeenaccumulatedinstage2thatisconverted (accordingtotherulesofscanf) 
to a value of the type of val . This value is stored in val and ios_base::goodbit is stored in err . 
— The sequence of chars accumulated in stage 2 would have caused scanf to report an input failure. 
ios_base::failbit is assigned to err. 
Digit grouping is checked. That is, the positions of discarded separators is examined for consistencywith use_
facet<numpunct<charT> >(loc ).grouping(). If they are not consistent then ios_base::failbit is assigned to err . 

Draft 


511 Localization library 22.2 Standard locale categories 

5 In anycase,if stage2processingwas terminatedby the test for in ==end then err |=ios_base::eofbit is 
performed. 

iter_type do_get(iter_type in , iter_type end , ios_base & str ,
ios_base :: iostate & err , bool & val ) const ;


6 Effects: If (str .flags()&ios_base::boolalpha)==0 then input proceeds as it would for a long except that 
if a value is being stored into val ,thevalueis determined accordingtothe following:Ifthevaluetobe storedis 
0thenfalse is stored.Ifthevalueis1then true is stored. Otherwise err |=ios_base::failbit is performed 
and no value is stored. 

7 Otherwise target sequences are determined “as if” by calling the members falsename() and truename() of 
thefacet obtainedby use_facet<numpunct<charT> >(str .getloc()). Successive characters in the range 
[in ,end ) (see 23.1.1)are obtainedand matched against corresponding positions in the targetsequences only as 
necessary to identify a unique match. The input iterator in is compared to end only when necessary to obtain a 
character. If and only if a target sequence is uniquely matched, val is set to the corresponding value. 

8 The in iterator is alwaysleft pointing one position beyond the last character successfully matched. If val is 
set, then err is set to str.goodbit;or to str.eofbit if, when seeking another character to match, it is found 
that (in == end ). If val is not set, then err is set to str.failbit; or to (str.failbit|str.eofbit) 
if the reason for thefailurewas that (in == end ).[ Example: For targetstrue: "a" and false: "abb", the 
input sequence "a" yields val == true and err == str.eofbit;the input sequence "abc" yields err = 
str.failbit, with in ending at the ’c’ element. For targetstrue: "1" and false: "0", the input sequence 
"1" yields val == true and err == str.goodbit. For empty targets (""), anyinput sequence yields err 
== str.failbit. — end example ] 

9 Returns: in . 

22.2.2.2 Class template num_put [lib.locale.nm.put] 
namespace std { 
template <class charT , class OutputIterator = ostreambuf_iterator <charT > > 
class num_put : public locale :: facet { 
public : 

typedef charT char_type ;
typedef OutputIterator iter_type;


explicit num_put ( size _t refs = 0); 

iter_type put(iter_type s , ios_base & f , char_type fill , bool v ) const ; 
iter_type put(iter_type s , ios_base & f , char_type fill , long v ) const ; 
iter_type put(iter_type s , ios_base & f , char_type fill , 

unsigned long v ) const ;
iter_type put(iter_type s , ios_base & f , char_type fill ,
double v ) const ;
iter_type put(iter_type s , ios_base & f , char_type fill ,
long double v ) const ;
iter_type put(iter_type s , ios_base & f , char_type fill ,
const void * v ) const ;


Draft 


22.2 Standard locale categories Localization library 512 
static locale::id id; 

protected :
~ num_put (); // virtual
virtual iter_type do_ put(iter _type , ios_base&, char_type fill ,
bool v ) const ;
virtual iter_type do_ put(iter _type , ios_base&, char_type fill ,
long v ) const ;
virtual iter_type do_ put(iter _type , ios_base&, char_type fill ,
unsigned long ) const ;
virtual iter_type do_ put(iter _type , ios_base&, char_type fill ,
double v ) const ;
virtual iter_type do_ put(iter _type , ios_base&, char_type fill ,
long double v ) const ;
virtual iter_type do_ put(iter _type , ios_base&, char_type fill ,
const void * v ) const ;
};
}


1 Thefacet num_put is used to format numeric values to a character sequence such as an ostream. 

22.2.2.2.1 num_put members [lib.facet.num.put.members] 
iter_type put(iter_type out , ios_base & str , char_type fill ,
bool val ) const ;


iter_type put(iter_type out , ios_base & str , char_type fill ,
long val ) const ;


iter_type put(iter_type out , ios_base & str , char_type fill ,
unsigned long val ) const ;


iter_type put(iter_type out , ios_base & str , char_type fill ,
double val ) const ;


iter_type put(iter_type out , ios_base & str , char_type fill ,
long double val ) const ;


iter_type put(iter_type out , ios_base & str , char_type fill ,
const void * val ) const ;


1 Returns: do_put(out , str , fill , val ). 

22.2.2.2.2 num_put virtual functions [lib.facet.num.put.virtuals] 
iter_type do_put(iter_type out , ios_base & str , char_type fill ,
long val ) const ;


iter_type do_put(iter_type out , ios_base & str , char_type fill ,
unsigned long val ) const ;


iter_type do_put(iter_type out , ios_base & str , char_type fill ,
double val ) const ;


iter_type do_put(iter_type out , ios_base & str , char_type fill ,
long double val ) const ;


Draft 


513 Localization library 22.2 Standard locale categories 

iter_type do_put(iter_type out , ios_base & str , char_type fill ,
const void * val ) const ;


1 Effects: Writes characters to the sequence out , formatting val as desired. In the following description, a local 
variable initialized with 

locale loc = str . getloc (); 

2 The details of this operation occur in several stages: 

— Stage 1: Determine a printf conversion specifier spec and determining the characters that would be printed 
by printf(27.8.2)given this conversion specifier for 
printf (spec , val ) 

assuming that the current locale is the "C" locale. 

— Stage 2: Adjust the representation by converting each char determined by stage 1 to a charT using a 
conversion and values returned by members of use_facet< numpunct<charT> >(str.getloc() ) 
— Stage 3: Determine where padding is required. 
— Stage 4: Insert the sequence into the out . 
3 Detailed descriptions of each stage follow. 
4 Returns: out . 
Stage 1: The first actionof stage1isto determinea conversion specifier. The tablesthat describe this determination use the following local variables 

fmtflags flags = str . flags () ;
fmtflags basefield = ( flags & ( ios_base :: basefield ));
fmtflags uppercase = ( flags & ( ios_base :: uppercase ));
fmtflags floatfield = (flags & (ios_base::floatfield));
fmtflags showpos = ( flags & ( ios_base :: showpos ));
fmtflags showbase = ( flags & ( ios_base :: showbase ));


All tablesusedin describingstage1 are ordered. Thatis,thefirstlinewhose conditionistrue applies.A


line without a condition is the default behavior when none of the earlier lines apply.
For conversion from an integral type other than a character type, the function determines the integral con
version specifier as indicatedinTable 59.


For conversion from a floating-point type, the function determines the floating-point conversion specifier as


indicated inTable 60:
For conversions from an integral or floating type a length modifier is added to the conversion specifier as
indicated inTable 61


The conversion specifier has the following optional additional qualifiers prepended as indicatedinTable 62
For conversion from a floating-point type,str .precision() is specified in the conversion specification.


Draft 


22.2 Standard locale categories Localization library 514 
Table 59: Integer Conversions 

State stdio equivalent 
basefield == ios_base::oct %o 
(basefield == ios_base::hex) && !uppercase %x 
(basefield == ios_base::hex) %X 
for a signed integral type %d 
for an unsigned integral type %u 

Table 60: Floating-point Conversions 

State stdio equivalent 
floatfield == ios_base::fixed %f 
floatfield == ios_base::scientific && !uppercase %e 
floatfield == ios_base::scientific %E 
!uppercase %g 
otherwise %G 

Table 61: Length Modifier 

type length modifier 
long l 
unsigned long l 
long double L 
otherwise none 

Table 62: Numeric conversions 

Type(s) State stdio equivalent 
an integral type flags & showpos + 
flags & showbase # 
a floating-point type flags & showpos + 
flags & showpoint # 

Draft 


515 Localization library 22.2 Standard locale categories 

For conversion fromvoid* the specifier is %p.
Therepresentationsattheendofstage1consistsofthe char’sthatwouldbe printedbya callof printf(s ,
val ) where s is the conversion specifier determined above.


Stage 2: Anycharacter c other than a decimal point(.) is converted to a charT via use_facet<ctype<charT> 
>(loc ).widen( c ) 
Alocal variablepunct is initialized via 

numpunct < charT > punct = use_ facet < numpunct < charT > >( str.getloc() ) 

For arithmetic types,punct .thousands_sep() characters are inserted into the sequence as determinedby 
thevalue returnedby punct .do_grouping() using the method describedin 22.2.3.1.2 
Decimal point characters(.) are replaced by punct .decimal_point() 
Stage 3: Alocal variable is initialized as 

fmtflags adjustfield= (flags & (ios_base::adjustfield)); 

The locationofanypadding238)is determined accordingtoTable 63 

Table 63: Fill padding 

State Location 
adjustfield == ios_base::left pad after 
adjustfield == ios_base::right pad before 
adjustfield == internal and a sign occurs in the 
representation 
pad after the sign 
adjustfield == internal and representation after 
stage 1began with 0x of 0X 
pad after x or X 
otherwise pad before 

If str .width() is nonzero and the number of charT’s in the sequence after stage 2 is less than str . 
width(), then enough fill characters are addedto the sequence at the position indicated for paddingto 
bring the length of the sequence to str .width(). 

str .width(0) is called. 

Stage 4: The sequence of charT’sattheendofstage3 areoutputvia 

*out ++ = c 

iter_type do _put ( iter_type out , ios_base & str , char_type fill , 
bool val ) const ; 

6 Returns: If str .flags() & ios_base::boolalpha) == 0 returns do_put(out , str , fill , (int)val ), 
otherwise obtains a string s as if by 

238) The conversion specification #o generates a leading 0 which is not a padding character. 

Draft 


22.2 Standard locale categories Localization library 516 
string_type s = 
val ? use_ facet <ctype <charT > >(loc).truename() 
: use_ facet <ctype <charT > >(loc).falsename(); 

and then inserts each character c of s into out via *out++ = c and returns out. 

22.2.3 The numeric punctuation facet [lib.facet.numpunct] 
22.2.3.1 Class template numpunct [lib.locale.numpunct] 
namespace std {
template < class charT >
class numpunct : public locale :: facet {
public :


typedef charT char_type ;
typedef basic_string < charT > string_type ;


explicit numpunct ( size _t refs = 0); 

char_type decimal_point() const;
char_type thousands_sep() const;
string grouping () const ;
string_type truename() const;
string_type falsename() const;


static locale::id id; 

protected : 

~ numpunct (); // virtual
virtual char_type do_decimal_point() const;
virtual char_type do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_truename() const; // for bool
virtual string_type do_falsename() const; // for bool


};
}


1 numpunct<> specifies numeric punctuation. The specializationsrequiredinTable 53(22.1.1.1.1), namely numpunct< 
wchar_t> and numpunct<char>, provide classic "C" numeric formats, i.e. theycontain information equivalent to that 
contained in the "C" locale or their wide character counterparts as if obtained by a call to widen. 

2 The syntax for number formats is as follows, where digit represents the radix set specifiedby the fmtflags argument 
value, and thousands-sep and decimal-point are the results of corresponding numpunct<charT> members. Integer 
values have the format: 

integer ::= [ sign ] units
sign ::= plusminus
plusminus ::= ’+’ | ’-’
units ::= digits [ thousands -sep units ]
digits ::= digit [ digits ]


Draft 


517 Localization library 22.2 Standard locale categories 

and floating-point values have: 

floatval ::= [ sign ] units [ decimal -point [ digits ]] [ e [ sign ] digits ] | 
[sign] decimal -point digits [e [sign] digits] 

e ::= ’e’ | ’E’ 
where the number of digits between thousands-seps is as specified by do_grouping(). For parsing, if the digits 
portion contains no thousands-separators, no grouping constraint is applied. 

22.2.3.1.1 numpunct members [lib.facet.numpunct.members] 
char_type decimal_point() const; 

1 Returns: do_decimal_point() 

char_type thousands_sep() const; 

2 Returns: do_thousands_sep() 

string grouping () const ; 

3 Returns: do_grouping() 

string_type truename() const;
string_type falsename() const;


4 Returns: do_truename() or do_falsename(), respectively. 

22.2.3.1.2 numpunct virtual functions [lib.facet.numpunct.virtuals] 
char_type do_decimal_point() const; 

1 Returns: Acharacter for use as the decimal radix separator. The required specializations return’.’ or L’.’. 

char_type do_thousands_sep() const; 

2 Returns: Acharacter for use as the digitgroup separator. The required specializations return’,’ or L’,’. 

string do_grouping() const; 

3 Returns: Abasic_string<char>vec used as a vector of integer values, in which each element vec [i ] represents 
the number of digits239) in the group at position i ,startingwith position0as the rightmost group. Ifvec .size() 
<= i , the number is the same as group (i -1);if(i <0 || vec [i ]<=0 || vec [i ]==CHAR_MAX),the size of 
the digit group is unlimited. 

4 The required specializations return the empty string, indicating no grouping. 

string_type do_truename() const;
string_type do_falsename() const;


239) Thus, the string "\003" specifies groupsof3digits each, and "3" probably indicates groups of 51 (!) digits each, because 51 is the ASCII value 
of "3". 

Draft 


22.2 Standard locale categories Localization library 518 
5 Returns: Astring representing the name of the boolean valuetrue or false, respectively. 
6 In the base class implementation these names are "true" and "false", or L"true" and L"false". 

22.2.3.2 Class template numpunct_byname [lib.locale.numpunct.byname] 
namespace std {
template < class charT >
class numpunct_byname : public numpunct <charT > {


// this class is specialized for char and wchar_t. 

public :
typedef charT char_type ;
typedef basic_string <charT > string_type;
explicit numpunct_byname(const char*, size_t refs = 0);


protected :
~numpunct_byname (); // virtual
};
}


22.2.4 The collate category [lib.category.collate] 
22.2.4.1 Class template collate [lib.locale.collate] 
namespace std {
template < class charT >
class collate : public locale :: facet {
public :


typedef charT char_type ;
typedef basic_string < charT > string_type ;


explicit collate ( size _t refs = 0); 

int compare ( const charT * low1 , const charT * high1 , 

const charT * low2 , const charT * high2 ) const ; 
string_type transform(const charT* low , const charT * high ) const ; 
long hash ( const charT * low , const charT * high ) const ; 

static locale::id id; 

protected :
~ collate (); // virtual
virtual int do_compare ( const charT * low1 , const charT * high1 ,
const charT * low2 , const charT * high2 ) const ;
virtual string_type do_transform
( const charT * low , const charT * high ) const ;
virtual long do_hash ( const charT * low , const charT * high ) const ;
};
}


Draft 


519 Localization library 22.2 Standard locale categories 

1 The class collate<charT> provides features for use in the collation (comparison) and hashing of strings. A locale 
member function template, operator(), uses the collatefacet to allowa locale to act directly as the predicate argumentfor standard algorithms(clause 25)and containers operatingon strings. The specializations requiredinTable53 
(22.1.1.1.1), namely collate<char> and collate<wchar_t>, applylexicographic ordering(25.3.8). 

2 Each function compares a string of characters *p in the range [low ,high ). 

22.2.4.1.1 collate members [lib.locale.collate.members] 
int compare ( const charT * low1 , const charT * high1 ,
const charT * low2 , const charT * high2 ) const ;


1 Returns: do_compare(low 1, high1 , low2 , high2 ) 

string_type transform(const charT* low , const charT * high ) const ; 

2 Returns: do_transform(low , high ) 

long hash ( const charT * low , const charT * high ) const ; 

3 Returns: do_hash(low , high ) 

22.2.4.1.2 collate virtual functions [lib.locale.collate.virtuals] 
int do_compare(const charT* low1 , const charT * high1 ,
const charT * low2 , const charT * high2 ) const ;


1 Returns: 1 if the first string is greater than the second, -1 if less, zero otherwise. The specializations required in 
Table53(22.1.1.1.1), namely collate<char> and collate<wchar_t>, implement a lexicographical comparison(25.3.8). 

string_type do_transform(const charT* low , const charT * high ) const ; 

2 Returns: A basic_string<charT> value that, compared lexicographically with the result of calling transform() on another string, yields the same result as calling do_compare() on the same two strings.240) 

long do_hash ( const charT * low , const charT * high ) const ; 

3 Returns: An integer value equal to the result of calling hash() on any other string for which do_compare() 
returns 0 (equal) when passed the two strings. [Note: The probability that the result equals that for another 
string which does not compare equal should be very small, approaching (1.0/numeric_limits<unsigned 
long>::max()). — end note ] 

22.2.4.2 Class template collate_byname [lib.locale.collate.byname] 
namespace std {
template < class charT >
class collate_byname : public collate <charT > {
public :


240) This function is useful when one string is being compared to manyother strings. 

Draft 


22.2 Standard locale categories Localization library 520 
typedef basic_string < charT > string_type ;
explicit collate_byname(const char*, size_t refs = 0);
protected :
~ collate_byname (); // virtual
};
}


22.2.5 The time category [lib.category.time] 
Templatestime_get<charT,InputIterator> and time_put<charT,OutputIterator> provide date and time formatting and parsing. All specifications of member functions for time_put and time_get in the subclauses of 22.2.5 
onlyapplytothe specializations requiredinTables 53and54(22.1.1.1.1). Their membersusetheir ios_base&, ios_
base::iostate&, and fill arguments as describedin(22.2), and the ctype<> facet, to determine formatting details. 

22.2.5.1 Class template time_get [lib.locale.time.get] 
namespace std {
class time_base {
public :


enum dateorder { no _order , dmy , mdy , ymd , ydm };
};


template <class charT , class InputIterator = istreambuf_iterator <charT > >
class time_get : public locale :: facet , public time_base {
public :


typedef charT char_type;
typedef InputIterator iter_type;


explicit time_ get ( size _t refs = 0); 

dateorder date_order () const { return do_date_order (); } 
iter_type get_time(iter_type s , iter_type end , ios_base & f , 
ios _base :: iostate & err , tm* t ) const ; 
iter_type get_date(iter_type s , iter_type end , ios_base & f , 
ios _base :: iostate & err , tm* t ) const ; 
iter_type get_weekday(iter_type s , iter_type end , ios_base & f , 
ios_base :: iostate & err , tm* t ) const ; 
iter_type get_monthname(iter_type s , iter_type end , ios_base & f , 
ios_base :: iostate & err , tm* t ) const ; 
iter_type get_year(iter_type s , iter_type end , ios_base & f , 
ios _base :: iostate & err , tm* t ) const ; 

static locale::id id; 

protected : 

~ time_get (); // virtual 
virtual dateorder do_date_order() const; 
virtual iter_type do_get_time(iter_type s , iter_type end , ios_base&, 

ios_base :: iostate & err , tm* t ) const ; 
virtual iter_type do_get_date(iter_type s , iter_type end , ios_base&, 

Draft 


521 Localization library 22.2 Standard locale categories 

ios_base :: iostate & err , tm* t ) const ; 
virtual iter_type do_get_weekday ( iter_type s , iter_type end , ios_base&, 
ios_base :: iostate & err , tm* t ) const ; 
virtual iter_type do_get_monthname(iter_type s , iter_type end , ios_base&, 
ios_base :: iostate & err , tm* t ) const ; 
virtual iter_type do_get_year(iter_type s , iter_type end , ios_base&, 
ios_base :: iostate & err , tm* t ) const ; 
}; 
} 

1 time_get isusedto parsea charactersequence,extracting componentsofatimeordateintoa struct tm record. Each 
get member parses a format as produced by a corresponding format specifier to time_put<>::put. If the sequence 
being parsed matches the correct format, the corresponding members of the struct tm argument are set to the values 
used to produce the sequence; otherwise either an error is reported or unspecified values are assigned.241) 

2 If the end iterator is reached during parsing by anyof the get() member functions, the member sets ios_base::eofbit in err . 

22.2.5.1.1 time_get members [lib.locale.time.get.members] 
dateorder date_order() const; 

1 Returns: do_date_order() 

iter_type get_time(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


2 Returns: do_get_time(s , end , str , err , t ) 

iter_type get_date(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


3 Returns: do_get_date(s , end , str , err , t ) 

iter_type get_weekday(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;
iter_type get_monthname(iter_type s , iter_type end , ios_ base & str ,
ios_base :: iostate & err , tm* t ) const ;


4 Returns: do_get_weekday(s , end , str , err , t ) or do_get_monthname(s , end , str , err , t ) 

iter_type get_year(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


5 Returns: do_get_year(s , end , str , err , t ) 

22.2.5.1.2 time_get virtual functions [lib.locale.time.get.virtuals] 
dateorder do_date_order() const; 

241) In otherwords, user confirmation is required for reliable parsing of user-entered dates and times,but machine-generated formats can be parsed 
reliably. This allows parsers to be aggressive about interpreting user variations on standard formats. 

Draft 


22.2 Standard locale categories Localization library 522 
1 Returns: An enumerationvalueindicating the preferred orderof componentsfor those date formats that are composed of day, month, and year.242) Returns no_order if the date format specified by ’x’ contains other variable 
components (e.g. Julian day, week number, week day). 

iter_type do_get_time(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


2 Effects: Reads characters starting at s untilit hasextracted those struct tm members, and remaining format 
characters, usedby time_put<>::put to produce the format specifiedby ’X’"%H:%M:%S", or untilitencounters 
an error or end of sequence. 

3 Returns: An iterator pointing immediately beyond the last character recognized as possibly partof a valid time. 

iter_type do_get_date(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


4 Effects: Reads characters starting at s untilit hasextracted those struct tm members, and remaining format 
characters, used by time_put<>::put to produce the format specified by ’x’to produce one of the following 
formats, or until it encounters an error. The format depends on the value returned by date_order() as inTable 64: 

Table 64:do_get_date effects 

date_order() format 
no_order "%m%d%y" 
dmy "%d%m%y" 
mdy "%m%d%y" 
ymd "%y%m%d" 
ydm "%y%d%m" 

An implementation may also accept additional implementation-defined formats. 

Returns: An iterator pointing immediately beyond the last character recognized as possibly partof a valid date. 

iter_type do_get_weekday(iter_type s , iter_type end , ios_ base & str ,
ios_base :: iostate & err , tm* t ) const ;
iter_type do_get_monthname(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


5 Effects: Reads characters starting at s untilithasextractedthe (perhaps abbreviated) nameofaweekdayor month. 
If it finds an abbreviation that is followed by characters that could match a full name, it continues reading until it 
matches the full name orfails. It sets the appropriate struct tm member accordingly. 

6 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid name. 

iter_type do_get_year(iter_type s , iter_type end , ios_base & str ,
ios_base :: iostate & err , tm* t ) const ;


242) This function is intended as a convenience only, for common formats, and may return no_order in valid locales. 

Draft 


523 Localization library 22.2 Standard locale categories 

7 Effects: Reads characters starting at s untilit hasextracted an unambiguous year identifier.Itisimplementationdefined whether two-digit year numbers are accepted, and (if so) what century theyare assumed to lie in. Sets the 
t ->tm_year member accordingly. 

8 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid year identifier. 

22.2.5.2 Class template time_get_byname [lib.locale.time.get.byname] 
namespace std { 
template <class charT , class InputIterator = istreambuf_iterator <charT > > 
class time_get_byname : public time _get <charT , InputIterator > { 
public : 

typedef time_base :: dateorder dateorder ;
typedef InputIterator iter_type;


explicit time_get_byname(const char*, size_t refs = 0);
protected :
~time_get_byname (); // virtual
};
}


22.2.5.3 Class template time_put [lib.locale.time.put] 
namespace std { 
template <class charT , class OutputIterator = ostreambuf_iterator <charT > > 
class time_put : public locale :: facet { 
public : 

typedef charT char_type;
typedef OutputIterator iter_type;


explicit time_ put ( size _t refs = 0); 

// the following is implemented in terms of other member functions. 

iter_type put(iter_type s , ios_base & f , char_type fill , const tm * tmb , 
const charT * pattern , const charT * pat_end ) const ; 
iter_type put(iter_type s , ios_base & f , char_type fill , 
const tm * tmb , char format , char modifier = 0) const ; 

static locale::id id; 

protected : 
~ time_put (); // virtual 
virtual iter_type do_ put(iter_type s , ios_base&, char_ type , const tm* t , 
char format , char modifier ) const ; 
}; 
} 

22.2.5.3.1 time_put members [lib.locale.time.put.members] 
Draft 


22.2 Standard locale categories Localization library 524 
iter_type put(iter_type s , ios_base & str , char_type fill , const tm * t ,
const charT * pattern , const charT * pat_end ) const ;


iter_type put(iter_type s , ios_base & str , char_type fill , const tm * t ,
char format , char modifier = 0) const ;


1 Effects: The first form steps through the sequence from pattern to pat_end, identifying characters that are part 
ofa format sequence. Each character thatis not partofa format sequenceis writtento s immediately, and each 
format sequence, as it is identified, results in a call to do_put; thus, format elements and other charactersare 
interleaved in the output in the order in which they appear in the pattern. Format sequences are identified by 
converting each character c toa char value asifby ct.narrow(c,0), wherect isa reference to ctype<charT> 
obtained from str.getloc(). The first character of each sequence is equal to ’%’, followed by an optional 
modifier character mod243) and a format specifier character spec as defined for the function strftime. If no 
modifier character is present, mod is zero. For each valid format sequence identified, calls do_put(s, str, 
fill, t, spec, mod). 

2 The second form calls do_put(s, str, fill, t, format, modifier). 

3[Note: The fill argument may be used in the implementation-defined formats, or by derivations. A space 
characterisa reasonabledefault for this argument. — end note ] 

4 Returns: An iterator pointing immediately after the last character produced. 

22.2.5.3.2 time_put virtual functions [lib.locale.time.put.virtuals] 
iter_type do_put(iter_type s , ios_base&, char_ type fill , const tm * t ,
char format , char modifier ) const ;


1 Effects: Formats the contents of the parametert into characters placed on the output sequence s . Formatting is 
controlled by the parameters format and modifier , interpreted identically as the format specifiers in the string 
argument to the standard library function strftime().244) except that the sequence of characters produced for 
those specifiers that aredescribed as depending on theClocale are instead implementation-defined.245) 

2 Returns: An iterator pointing immediately after the last character produced.[ Note: The fill argument may be 
used in the implementation-defined formats, or by derivations. Aspace character is a reasonable default for this 
argument. — end note ] 

22.2.5.4 Class template time_put_byname [lib.locale.time.put.byname] 
namespace std { 
template <class charT , class OutputIterator = ostreambuf_iterator <charT > > 
class time_put_byname : public time _put <charT , OutputIterator > 
{ 
public : 

typedef charT char_type ;
typedef OutputIterator iter_type;


243) Although theCprogramming language defines no modifiers, mostvendors do.
244) Interpretation of the modifier argumentis implementation-defined,but should follow POSIX conventions.
245) Implementations are encouraged to refer to other standards (such as POSIX) for these definitions.


Draft 


525 Localization library 22.2 Standard locale categories 

explicit time_put_byname(const char*, size_t refs = 0);
protected :
~time_put_byname (); // virtual
};
}


22.2.6 The monetary category [lib.category.monetary] 
1 These templates handle monetary formats. A template parameter indicates whether local or international monetary 
formats are to be used. 

2 All specifications of member functions for money_put and money_get in the subclauses of 22.2.6 only apply to the 
specializations requiredinTables 53and54(22.1.1.1.1). Their members use theirios_base&,ios_base :: iostate&, 
and fill arguments as described in(22.2),and themoneypunct<> and ctype<> facets, to determine formatting details. 

22.2.6.1 Class template money_get [lib.locale.money.get] 
namespace std {
template < class charT ,


class InputIterator = istreambuf_iterator <charT > >
class money_get : public locale :: facet {
public :


typedef charT char_type ;
typedef InputIterator iter_type;
typedef basic_string < charT > string_type ;


explicit money_get(size _t refs = 0); 

iter_type get(iter_type s , iter_type end , bool intl ,
ios_base & f , ios_base :: iostate & err ,
long double & units ) const ;


iter_type get(iter_type s , iter_type end , bool intl ,
ios_base & f , ios_base :: iostate & err ,
string_type & digits ) const ;


static locale::id id; 

protected :
~ money_get (); // virtual
virtual iter_type do_ get(iter _type , iter _type , bool , ios _base&,
ios_base :: iostate & err , long double & units ) const ;
virtual iter_type do_ get(iter _type , iter _type , bool , ios _base&,
ios_base :: iostate & err , string_type& digits ) const ;
};
}


22.2.6.1.1 money_get members [lib.locale.money.get.members] 
iter_type get(iter_type s , iter_type end , bool intl ,
ios_base & f , ios_base :: iostate & err ,
long double & quant ) const ;


Draft 


22.2 Standard locale categories Localization library 526 
iter_type get(s , iter_type end , bool intl , ios _base &f ,
ios_base :: iostate & err , string_type& quant ) const ;


1 Returns: do_get(s , end , intl , f , err , quant ) 

22.2.6.1.2 money_get virtual functions [lib.locale.money.get.virtuals] 
iter_type do_get(iter_type s , iter_type end , bool intl ,
ios_base & str , ios_base :: iostate & err ,
long double & units ) const ;


iter_type do_get(iter_type s , iter_type end , bool intl ,
ios_base & str , ios_base :: iostate & err ,
string_type & digits ) const ;


1 Effects: Reads characters from s to parse and construct a monetary value accordingto the format specified by a 
moneypunct<charT,Intl> facet referencemp and the character mapping specifiedbya ctype<charT> facetreference ct obtained from the locale returned by str.getloc(), and str.flags(). If a valid sequence is recognized, does not change err ;otherwise, setserr to (err |str .failbit), or (err |str .failbit|str .eofbit) if no more characters are available, and does not change units or digits . Uses the pattern returned by 
mp.neg_format() to parseallvalues.The resultis returnedasanintegralvalue storedin units or asa sequence 
of digits possibly preceded by a minus sign (as produced by ct.widen(c) where c is ’-’ or in the range from 
’0’ through ’9’, inclusive) stored in digits.[ Example: The sequence $1,056.23 in a common United States 
locale would yield, for units, 105623, or, for digits, "105623". — end example ]Ifmp.grouping() indicates that no thousands separators are permitted, anysuch characters are not read, and parsing is terminated at 
the point where theyfirst appear. Otherwise, thousands separators are optional; if present, they are checked for 
correct placement only after all format components have been read. 

2 Where space or none appears in the format pattern, except at the end, optional white space (as recognized by 
ct.is)is consumed after anyrequired space. If(str.flags() & str.showbase) isfalse, the currencysymbol 
is optional and is consumed only if other characters are needed to complete the format; otherwise, the currency 
symbol is required. 

3 If the first character (if any) in the string pos returned by mp.positive_sign() or the string neg returned by 
mp.negative_sign() is recognized in the position indicated by sign in the format pattern, it is consumed and 
anyremaining charactersinthe string are required afterallthe other format components.[ Example: If showbase 
is off, then for a neg value of "()" and a currencysymbol of "L", in "(100 L)" the "L" is consumed;butif neg 
is "-", the "L" in "-100 L" is not consumed. — end example ]Ifpos or neg is empty, the sign component is 
optional, and if no sign is detected, the result is given the sign that corresponds to the source of the empty string. 
Otherwise, the character in the indicated position must match the first character of pos or neg, and the result is 
given the corresponding sign. If the first character of pos is equal to the first character of neg, or if both strings 
are empty, the result is given a positive sign. 

4 Digits in the numeric monetary component are extracted and placed in digits, or intoa characterbuffer buf1 
for conversionto produceavaluefor units, in the order in which theyappear, preceded by a minus sign if and 
only if the result is negative. The value units is produced as if by246) 

for (int i =0; i <n; ++i) 

246) The semantics here are different from ct.narrow. 

Draft 


527 Localization library 22.2 Standard locale categories 

buf2[i] = src[find(atoms , atoms+sizeof(src), buf1[i]) -atoms]; 
buf2[n] = 0; 
sscanf(buf2, "%Lf", &units); 

where n is the number of characters placed in buf1, buf2 isa characterbuffer, and thevalues src and atoms are 
defined as if by 

static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src , src + sizeof(src) -1, atoms);


Returns: An iterator pointing immediately beyond the last character recognized as part of a valid monetary quantity. 

22.2.6.2 Class template money_put [lib.locale.money.put] 
namespace std {
template < class charT ,


class OutputIterator = ostreambuf_iterator <charT > >
class money_put : public locale :: facet {
public :


typedef charT char_type ;
typedef OutputIterator iter_type;
typedef basic_string < charT > string_type ;


explicit money_put(size _t refs = 0); 

iter_type put(iter_type s , bool intl , ios _base & f ,
char_type fill , long double units ) const ;
iter_type put(iter_type s , bool intl , ios _base & f ,
char_type fill , const string_type & digits ) const ;


static locale::id id; 

protected :
~ money_put (); // virtual
virtual iter_type
do_put ( iter_ type , bool , ios_base & , char_type fill ,
long double units ) const ;
virtual iter_type
do_put ( iter_ type , bool , ios_base & , char_type fill ,
const string_type & digits ) const ;
};
}


22.2.6.2.1 money_put members [lib.locale.money.put.members] 
iter_type put(iter_type s , bool intl , ios_base & f , char_type fill ,
long double quant ) const ;


Draft 


22.2 Standard locale categories Localization library 528 
iter_type put(iter_type s , bool intl , ios_base & f , char_type fill ,
const string_type& quant ) const ;


1 Returns: do_put(s , intl , f , loc , quant ) 

22.2.6.2.2 money_put virtual functions [lib.locale.money.put.virtuals] 
iter_type do_put(iter_type s , bool intl , ios_base & str ,
char_type fill , long double units ) const ;


iter_type do_put(iter_type s , bool intl , ios_base & str ,
char_type fill , const string_type& digits ) const ;


1 Effects: Writes characters to s accordingtothe format specifiedbya moneypunct<charT,Intl> facet reference 
mp and the character mapping specifiedbya ctype<charT> facet referencect obtained from the locale returned 
by str.getloc(), and str.flags(). The argument units is transformed into a sequence of wide characters 
as if by 

ct.widen(buf1 , buf1 + sprintf(buf1 , "%.0Lf", units), buf2) 

for characterbuffers buf1 and buf2. If the first character in digits or buf2 is equal to ct.widen(’-’), then 
the pattern used for formatting is the result of mp.neg_format();otherwise the pattern is the result ofmp.pos_
format(). Digit characters are written, interspersed with anythousands separators and decimal point specified 
by the format, in the order theyappear (after the optional leading minus sign) in digits or buf2. In digits, 
only the optional leading minus sign and the immediately subsequent digit characters (as classified according to 
ct)are used; any trailing characters (including digits appearing after a non-digit character) are ignored. Calls 
str.width(0). 

2 Remarks: The currencysymbolisgeneratedif and onlyif (str.flags() & str.showbase) is nonzero. If the 
numberof characters generatedforthe specified formatislessthanthevalue returnedby str.width() on entry to 
the function, then copies of fill are insertedas necessarytopadtothe specified width.Forthevalue af equal to 
(str.flags() & str.adjustfield), if (af == str.internal) is true, the fill characters are placed where 
none or space appears in the formatting pattern; otherwise if (af == str.left) is true, they are placed after 
the other characters; otherwise, they are placed before the other characters. [Note: It is possible, with some 
combinationsofformatpatternsandflagvalues,toproduceoutputthat cannotbeparsedusing num_get<>::get. 

— end note ] 
3 Returns: An iterator pointing immediately after the last character produced. 
22.2.6.3 Class template moneypunct [lib.locale.moneypunct] 
namespace std {
class money_base {
public :


enum part { none , space , symbol , sign , value };
struct pattern { char field [4]; };
};


template <class charT , bool International = false >
class moneypunct : public locale::facet , public money_base {


Draft 


529 Localization library 22.2 Standard locale categories 

public :
typedef charT char_type ;
typedef basic_string < charT > string_type ;


explicit moneypunct(size _t refs = 0); 

charT decimal_point() const;
charT thousands_sep() const;
string grouping () const ;
string_type curr_symbol() const;
string_type positive_sign() const;
string_type negative_sign() const;
int frac_digits() const;
pattern pos_format() const;
pattern neg_format() const;


static locale::id id; 

static const bool intl = International; 

protected : 

~moneypunct (); // virtual
virtual charT do_decimal_point() const;
virtual charT do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_curr_symbol() const;
virtual string_type do_positive_sign() const;
virtual string_type do_negative_sign() const;
virtual int do_frac_digits () const ;
virtual pattern do_pos_format() const;
virtual pattern do_neg_format() const;


};
}


1 The moneypunct<> facet defines monetary formatting parameters used bymoney_get<> and money_put<>. A monetary format is a sequence of four components, specified by a pattern value p, such that the part value static_
cast<part>(p.field[i]) determines the ith component of the format247) In the field member ofa pattern object, 
each value symbol, sign, value, and either space or none appears exactly once. The value none, if present, is not 
first; the value space, if present, is neither first nor last. 

2 Where none or space appears, white space is permitted in the format, except where none appears at the end, in which 
case no white space is permitted. The value space indicates that at least one space is required at that position. Where 
symbol appears, the sequence of characters returned by curr_symbol() is permitted, and can be required. Where 
sign appears, the first (if any) of the sequence of characters returned by positive_sign() or negative_sign() 
(respectively as the monetary value is non-negative or negative) is required. Any remaining characters of the sign 
sequence are required after all other format components. Where value appears,the absolute numeric monetaryvalueis 
required. 

3 The format of the numeric monetary value is a decimal number: 

247) An array of char, rather than an array of part, is specified for pattern::field purely for efficiency. 

Draft 


22.2 Standard locale categories Localization library 530 
value ::= units [ decimal -point [ digits ]] |
decimal -point digits


if frac_digits() returns a positive value, or 

value ::= units 

otherwise. The symbol decimal-point indicates the character returnedby decimal_point(). The other symbols are 
defined as follows: 

units ::= digits [ thousands -sep units ]
digits ::= adigit [ digits ]


In the syntax specification, the symbol adigit is anyof the values ct.widen(c) for c in the range ’0’ through ’9’, 
inclusive, and ct isareferenceoftype const ctype<charT>& obtained as described in the definitions of money_get<> 
and money_put<>. The symbol thousands-sep is the character returned by thousands_sep(). The space character 
used is the value ct.widen(’ ’). White space characters are those characters c for which ci.is(space,c) returns 
true. The number of digits required after the decimal point (if any) is exactly the value returned by frac_digits(). 

4 The placement of thousands-separator characters (if any) is determined by the value returned by grouping(), defined 
identically as the member numpunct<>::do_grouping(). 

22.2.6.3.1 moneypunct members [lib.locale.moneypunct.members] 
charT decimal_point() const;
charT thousands_sep() const;
string grouping () const ;
string_type curr_symbol() const;
string_type positive_sign() const;
string_type negative_sign() const;
int frac_digits() const;
pattern pos_format() const;
pattern neg_format() const;


1 Each of these functions F returns the resultof callingthe corresponding virtual member function do_F(). 

22.2.6.3.2 moneypunct virtual functions [lib.locale.moneypunct.virtuals] 
charT do_decimal_point() const; 

1 Returns: The radix separator to use in case do_frac_digits() is greater than zero.248) 

charT do_thousands_sep() const; 

2 Returns: The digit group separator to use in case do_grouping() specifies a digit grouping pattern.249) 

string do_grouping() const; 

3 Returns: A pattern defined identically as,but not necessarily equal to, the result ofnumpunct<charT>::do_
grouping().250) 

248) In common U.S. locales this is ’.’.
249) In common U.S. locales this is ’,’.
250)To specify groupingby3s,thevalueis"\003" not "3").


Draft 


531 Localization library 22.2 Standard locale categories 

string_type do_curr_symbol() const; 

4 Returns: Astring to use as the currencyidentifier symbol.251) 

string_type do_positive_sign() const;
string_type do_negative_sign() const;


5 Returns: do_positive_sign() returns the string to use to indicate a positive monetary value;252) do_negative_sign() returnsthestringto usetoindicateanegativevalue. 

int do_frac_digits() const; 

6 Returns: The number of digits after the decimal radix separator, if any.253) 

pattern do_pos_format() const;
pattern do_neg_format() const;


7 Returns: The specializations requiredinTable 54(22.1.1.1.1),namelymoneypunct<char>,moneypunct<wchar_
t>, moneypunct<char,true>,and moneypunct<wchar_t,true>, return an object of type pattern initialized 
to { symbol, sign, none, value }.254) 

22.2.6.4 Class template moneypunct_byname [lib.locale.moneypunct.byname] 
namespace std {
template < class charT , bool Intl = false >
class moneypunct_byname : public moneypunct <charT , Intl > {
public :


typedef money_base::pattern pattern;
typedef basic_string < charT > string_type ;


explicit moneypunct_byname(const char*, size_t refs = 0);
protected :
~moneypunct_byname (); // virtual
};
}


22.2.7 The message retrieval category [lib.category.messages] 
1 Class messages<charT> implements retrieval of strings from message catalogs. 

22.2.7.1 Class template messages [lib.locale.messages] 
namespace std {
class messages_base {
public :


typedef int catalog ;
};


251)For international specializations (second template parametertrue)this is always four characters long, usually three letters and a space.
252) This is usually the empty string.
253) In common U.S. locales, this is 2.
254) Note that the international symbol returnedby do_curr_sym() usually contains a space, itself; for example, "USD ".


Draft 


22.2 Standard locale categories Localization library 532 
template < class charT >
class messages : public locale::facet , public messages_base {
public :


typedef charT char_type ;
typedef basic_string < charT > string_type ;


explicit messages ( size _t refs = 0); 

catalog open(const basic _string <char >& fn , const locale &) const ; 
string_type get(catalog c , int set , int msgid , 
const string_type & dfault ) const ; 
void close ( catalog c ) const ; 

static locale::id id; 

protected : 

~ messages (); // virtual 
virtual catalog do_open(const basic_string <char >&, const locale&) const; 
virtual string_type do_get(catalog , int set , int msgid , 

const string_type & dfault ) const ;
virtual void do_ close ( catalog ) const ;
};
}


1 Values of typemessages_base::catalog usable as arguments to members get and close can be obtained only by 
calling member open. 

22.2.7.1.1 messages members [lib.locale.messages.members] 
catalog open(const basic_string <char >& name , const locale & loc ) const ; 

1 Returns: do_open(name , loc ). 

string_type get(catalog cat , int set , int msgid ,
const string_type& dfault ) const ;


2 Returns: do_get(cat , set , msgid , dfault ). 

void close ( catalog cat ) const ; 

3 Effects: Calls do_close(cat ). 

22.2.7.1.2 messages virtual functions [lib.locale.messages.virtuals] 
catalog do_open(const basic_string <char >& name ,
const locale & loc ) const ;


1 Returns: A value that may be passed to get() to retrieve a message, from the message catalog identified by 
the string name according to an implementation-defined mapping. The result can be used until it is passed to 
close(). 

Draft 


533 Localization library 22.2 Standard locale categories 

2 Returnsavalue less than0if no such catalog canbe opened.
3 Remarks: The locale argument loc is used for character set code conversion when retrieving messages, if needed.


string_type do_get(catalog cat , int set , int msgid ,
const string_type& dfault ) const ;


4 Requires: Acatalogcat obtained from open() and not yet closed. 

5 Returns: Amessage identified by argumentsset , msgid , and dfault , according to an implementation-defined 
mapping. If no such message can be found, returns dfault . 

void do _close ( catalog cat ) const ; 

6 Requires: Acatalogcat obtained from open() and not yet closed. 
7 Effects: Releases unspecified resources associated with cat . 
8 Remarks: The limit on such resources, if any, is implementation-defined. 

22.2.7.2 Class template messages_byname [lib.locale.messages.byname] 
namespace std {
template < class charT >
class messages_byname : public messages <charT > {
public :


typedef messages_base::catalog catalog;
typedef basic_string <charT > string_type;


explicit messages_byname(const char*, size_t refs = 0);
protected :
~messages_byname (); // virtual
};
}


22.2.8 Program-defined facets [lib.facets.examples] 
1 AC++programmay definefacetstobe addedtoa localeand used identicallyasthebuilt-infacets.To createanewfacet 
interface,C++programs simply derive from locale::facet a class containinga static member: static locale::id 
id. 

2[Note: The locale member function templates verify its type and storage class. — end note ]
3[Note: This paragraph is intentionallyempty. — end note ]
4[Example: Traditional global localization is still easy:


# include < iostream >
# include < locale >
int main ( int argc , char ** argv )
{


using namespace std ;
locale :: global ( locale ("" )); // set the global locale


Draft 


22.2 Standard locale categories Localization library 534 
// imbue it on all the std streams 

cin . imbue ( locale ());
cout . imbue ( locale ());
cerr . imbue ( locale ());
wcin . imbue ( locale ());
wcout . imbue ( locale ());
wcerr . imbue ( locale ());


return MyObject(argc , argv).doit();
}


— end example ] 
5[Example: Greater flexibility is possible: 
# include < iostream >
# include < locale >
int main ()
{


using namespace std ;
cin . imbue ( locale ("" )); // the user’s preferred locale
cout . imbue ( locale :: classic ());
double f;
while (cin >> f) cout << f << endl;
return ( cin . fail () != 0);


} 

In a European locale, with input 3.456,78, output is 3456.78. — end example ] 

6 This can be important even for simple programs, which may need to write a data file in a fixed format, regardless of a 
user’s preference. 

7 [Example: Here is an example of the use of locales in a library interface. 

// file: Date.h
# include < iosfwd >
# include < string >
# include < locale >


...
class Date {
...


public :
Date ( unsigned day , unsigned month , unsigned year );
std :: string asString ( const std :: locale & = std :: locale ());


};
istream& operator >>(istream& s, Date& d);


ostream& operator <<(ostream& s, Date d);
...
8 This example illustrates two architectural uses of class locale. 

Draft 


535 Localization library 22.2 Standard locale categories 

9 The first is as a default argument in Date::asString(), where the default is the global (presumably user-preferred) 
locale. 

10 The second is in the operators << and >>, where a locale “hitchhikes” on another object, in this case a stream, to the 
point where it is needed. 

// file: Date.C
# include " Date " // includes <ctime>
# include < sstream >
std::string Date::asString(const std::locale& l)
{


using namespace std ; 

ostringstream s; s.imbue(l); 
s << *this; return s.str();
}


std::istream& operator >>(std::istream& s, Date& d) 

{
using namespace std ;
istream::sentry cerberos(s);
if ( cerberos ) {


ios_base :: iostate err = goodbit ;
struct tm t;
use_ facet< time _get<char> >(s.getloc()).get_date(s, 0, s, err, &t);
if (!err) d = Date(t.tm _day , t.tm_mon + 1, t.tm_year + 1900);


s. setstate ( err );
}
return s;
} 

— end example ] 
11 A locale object maybeextended witha newfacet simplyby constructingit with an instanceofa class derived from 
locale::facet. The only memberaC++ program must define is the static member id, which identifiesyour class 
interface asa newfacet. 

12 [Example: Classifying Japanese characters: 

// file: <jctype>
# include < locale >
namespace My {


using namespace std ;
class JCtype : public locale :: facet {
public :


static locale :: id id ; // required for use as a new locale facet
bool is_kanji (wchar_t c) const;
JCtype () {}


protected :
~ JCtype () {}
};
}


Draft 


22.2 Standard locale categories Localization library 536 
// file: filt.C
# include < iostream >
# include < locale >
# include " jctype " // above
std :: locale :: id My :: JCtype :: id ; // the static JCtype member declared above.


int main () 

{
using namespace std ;
typedef ctype < wchar _t > wctype ;
locale loc(locale(""), // the user’s preferred locale ...


new My :: JCtype ); // and a new feature ...
wchar_t c = use _facet <wctype >(loc).widen(’!’);
if (!use _facet <My::JCtype >(loc).is_kanji(c))


cout << "no it isn’t!" << endl;
return 0;
}


13 The newfacetis usedexactly like thebuilt-infacets. — end example ] 

14 [Example: Replacinganexistingfacetiseven easier. Herewedonot definea member id because we are reusing the 
numpunct<charT> facet interface: 

// file: my_bool.C
# include < iostream >
# include < locale >
# include < string >
namespace My {


using namespace std ;
typedef numpunct _byname <char > cnumpunct;
class BoolNames : public cnumpunct {


protected :
string do_truename() const { return "Oui Oui!"; }
string do_falsename() const { return "Mais Non!"; }


~ BoolNames () {}
public :
BoolNames ( const char * name ) : cnumpunct ( name ) {}
};
}


int main ( int argc , char ** argv )
{
using namespace std ;


// make the user’s preferred locale, except for... 

locale loc(locale(""), new My::BoolNames(""));
cout . imbue ( loc );
cout << boolalpha << "Any arguments today? " << (argc > 1) << endl;
return 0;


} 

Draft 


537 Localization library 22.3 CLibrary Locales 
1 
— end example ] 
22.3 CLibrary Locales 
Header <clocale> (Table 65): 
[lib.c.locales] 
Table 65: Header<clocale> synopsis 

Type Name(s) 
Macros: LC_ALL LC_COLLATE LC_CTYPE 
LC_MONETARY LC_NUMERIC LC_TIME 
NULL 
Struct: lconv 
Functions: localeconv setlocale 

The contents are the same as the StandardClibrary header <locale.h>. 
SEEALSO: ISOCclause 7.4. 

Draft 


22.3 CLibrary Locales Localization library 538 
Draft 


Chapter 23 Containers library [lib.containers]


1 
2 
This clause describes components that C++ programs may use to organize collections of information. 
The following subclauses describe container requirements, and components for sequences and associative containers, as 
summarized in Table 66: 
Table 66: Containers library summary 

Subclause Header(s) 
23.1 Requirements 
23.2 Sequences <deque> 
<list> 
<queue> 
<stack> 
<vector> 
23.3 Associative containers 
23.3.5 bitset 
<map> 
<set> 
<bitset> 

23.1 Container requirements [lib.container.requirements] 
1 Containers are objects that store other objects. They control allocation and deallocation ofthese objects through constructors, destructors, insert and erase operations. 

2 All of the complexity requirements in this clause are stated solely in terms of the number of operations on the contained 
objects. [Example: the copy constructor of type vector <vector<int> > has linear complexity, even though the 
complexity of copying each contained vector<int> is itself linear. — end example ] 

3 The type of objects stored in these components shall meet the requirements of CopyConstructible types(20.1.3). 

4 Table 67 defines the Assignable requirement. Some containers require this property of the types to be storedin the 
container. T is the type used to instantiate the container, t is a value of T, and u is a value of (possibly const)T. 

Table 67:Assignable requirements 

expression return type post-condition 

t=u T& t is equivalent to u 


23.1 Container requirements Containers library 540 
InTables 68 and69, X denotes a container class containing objects of type T, a and b denote values of type X, u denotes 
an identifier and r denotes a value of X&. 

Table 68: Container requirements 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
complexity 
X::value_T T is compile time 
type CopyConstructible 
X::reference lvalue of T compile time 
X::const_
reference 
const lvalue of T compile time 
X::iterator iterator type 
whose value 
type is T 
anyiterator category 
except output iterator. 
convertible to 
compile time 
X::const_iterator. 
X::const_constant iterator anyiterator category compile time 
iterator type whose except output iterator 
value type is T 
X::difsigned integral is identical to the compile time 
ference_type type difference type of 
X::iterator and 
X::const_iterator 
X::size_type unsigned 
integral type 
size_type can 
represent any 
non-negative value of 
compile time 
difference_type 
X u; post: u.size() == 0 constant 
X(); X().size() == 0 constant 
X(a); a == X(a). linear 
X u(a); post: u == a linear 
X u = a; Equivalent to: X u; u 
= a; 
(&a)->X(); void note: the destructor is 
applied to every 
linear 
element of a;all the 
memory is deallocated. 
a.begin(); iterator; constant 
const_
iterator for 
constant a 
a.end(); iterator; 
const_
iterator for 
constant 
constant a 

Draft 


541 Containers library 23.1 Container requirements 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
complexity 
a == b convertible to 
bool 
== is an equivalence 
relation. a.size() == 
linear 
b.size() && 
equal(a.begin(), 
a.end(), b.begin() 
a != b convertible to 
bool 
Equivalent to: !(a == 
b) 
linear 
a.swap(b); void swap(a,b) (Note A) 
r = a X& post: r == a. linear 
a.size() size_type a.end() -a.begin() 
(Note A) 
a.max_size() size_type size() of the largest 
possible container 
(Note A) 
a.empty() convertible to 
bool 
a.size() == 0 constant 
a < b convertible to 
bool 
lexicographical_
compare( 
a.begin(), 
pre: < is defined for 
values of T. < is a total 
ordering relationship. 
linear 
a.end(), 
b.begin(), 
b.end()) 
a > b convertible to 
bool 
b < a linear 
a <= b convertible to 
bool 
!(a > b) linear 
a >= b convertible to 
bool 
!(a < b) linear 

Notes: the algorithms swap(), equal() and lexicographical_compare() are defined in clause 25. Those entries 
marked “(Note A)” should have constant complexity. 

6 The member function size() returns the number of elements in the container. Its semantics is defined by the rules of 
constructors, inserts, and erases. 

7 begin() returns an iterator referring to the first element in the container. end() returns an iterator which is the past-
the-end value for the container. If the container is empty, then begin() == end(); 

8 In the expressions 

i == j
i != j
i<j
i <=j
i >=j
i>j


Draft 


23.1 Container requirements Containers library 542 
i -j 

where i and j denote objects of a container’s iterator type, either or both may be replaced by an object of the 
container’s const_iterator type referring to the same element with no change in semantics. 

9 Copy constructors for all container types defined in this clause copy an allocator argument from their respective first 
parameters. All other constructors for these container types take an Allocator& argument(20.1.6), an allocator whose 
value type is the same as the container’s value type. A copy of this argument is used for any memory allocation 
performed, by these constructors and by all member functions, during the lifetime of each container object. In all 
container types defined in this clause, the member get_allocator() returns a copyof the Allocator object used to 
construct the container.255) 

10 Ifthe iteratortypeofa container belongstothe bidirectionalor random access iterator categories(24.1),the container 
is called reversible and satisfies the additional requirementsinTable 69. 

Table 69: Reversible container requirements 

expression return type assertion/note 
pre/post-condition 
complexity 
X::reverse_
iterator 
iterator type pointing to T reverse_iterator<iterator> compile time 
X::const_
reverse_
iterator 
iterator type pointing to const T reverse_iterator<const_
iterator> 
compile time 
a.rbegin() reverse_iterator; 
const_reverse_iterator for 
constant a 
reverse_iterator(end()) constant 
a.rend() reverse_iterator; 
const_reverse_iterator for 
constant a 
reverse_iterator(begin()) constant 

11 Unless otherwise specified (see 23.2.1.3 and 23.2.4.4)all container types defined in this clause meet the following 
additional requirements: 

— if an exception is thrown by an insert() function while inserting a single element, that function has no effects. 
— if an exception is thrown by a push_back() or push_front() function, that function has no effects. 
— no erase(), pop_back() or pop_front() function throws an exception. 
— no copyconstructor or assignment operator of a returned iterator throws an exception. 
— no swap() function throws an exception unless that exception is thrown by the copyconstructor or assignment 
operatorofthe container’sCompare object(ifany; see 23.1.2). 
— no swap() function invalidates anyreferences, pointers, or iterators referring to the elements of the containers 
being swapped. 
255)As specified in 20.1.6, paragraphs 4-5, the semantics described in this clause applies only to the case where allocators compare equal. 

Draft 


543 Containers library 23.1 Container requirements 

12 Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container 
member function or passing a container as an argument to a library function shall not invalidate iterators to, or change 
the values of, objects within that container. 

23.1.1 Sequences [lib.sequence.reqmts] 
1 A sequence is a kind of container that organizes a finite set of objects, all of the same type, into a strictly linear arrangement. The library provides three basic kinds of sequence containers: vector, list, and deque. It also provides 
container adaptors that makeit easy to construct abstract data types, such as stacks orqueues, outofthe basic sequence 
kinds (or out of other kinds of sequences that the user might define). 

2 vector,list,anddeque offertheprogrammerdifferentcomplexitytrade-offsandshouldbeused accordingly. vector 
is the type of sequence that should be used by default. list should be used when there are frequent insertions and 
deletions from the middle of the sequence. deque is the data structure of choice when most insertions and deletions take 
place at the beginning or at the end of the sequence. 

3 In Tables 70 and 71, X denotes a sequence class, a denotes a value of X, i and j denote iterators satisfying input 
iterator requirements, [i, j) denotes a valid range, n denotes a value of X::size_type, p denotes a valid iterator 
to a, q denotes a valid dereferenceable iterator to a, [q1, q2) denotes a valid range in a, and t denotes a value of 
X::value_type. 

4 The complexities of the expressions are sequence dependent. 

Table 70: Sequence requirements (in addition to container) 

expression return type assertion/note 
pre/post-condition 
X(n, t) 
X a(n, t) 
post: size() == n 
constructs a sequence with n copies of t 
X(i, j) 
X a(i, j) 
post: size() == distance between i and j 
constructs a sequence equal to the range [i, j) 
a.insert(p,t) iterator inserts a copyof t before p 
a.insert (p,n,t) void inserts n copies of t before p 
a.insert (p,i,j) void pre: i and j are not iterators into a. 
inserts copies of elements in [i, j) before p 
a.erase(q) iterator erases the element pointed to by q 
a.erase(q1,q2) iterator erases the elements in the range [q1, q2). 
a.clear() void erase(begin(), end()) 
post: size() == 0 
a.assign(i,j) void pre: i, j are not iterators into a. 
Replaces elements in a with a copyof [i, j). 
a.assign(n,t) void pre: t is not a reference into a. 
Replaces elements in a with n copies of t. 

iterator and const_iterator types for sequences shall be atleast of the forward iterator category. 
Draft 


23.1 Container requirements Containers library 544 
6 The iterator returned from a.insert(p,t) points to the copyof t inserted into a. 
7 The iterator returned from a.erase(q) points to the element immediately following q prior to the element being erased. 
If no such element exists, a.end() is returned. 
8 The iterator returned by a.erase(q1,q2) points to the element pointed to by q2 prior to anyelements being erased. If 
no such element exists, a.end() is returned. 
9 For every sequence defined in this clause and in clause21: 

— If the constructor 
template < class InputIterator >
X(InputIterator first, InputIterator last,
const allocator_type & alloc = allocator_type ())


is called with a type InputIterator that does not qualify as an input iterator, then the constructor will behave 
as if the overloaded constructor: 

X(size_ type , const value_type& = value_type(),
const allocator_type & = allocator_type ())


were called instead, with the arguments static_cast<size_type>(first), last and alloc, respectively. 

— If the member functions of the forms: 
template < class InputIterator > // suchas insert() 
rt fx1(iterator p, InputIterator first , InputIterator last); 

template < class InputIterator > // suchas append(), assign()
rt fx2(InputIterator first , InputIterator last);


template < class InputIterator > // suchas replace()
rt fx3(iterator i1, iterator i2, InputIterator first, InputIterator last);


are called with a type InputIterator that does notqualify as an input iterator, then these functions will behave 
as if the overloaded member functions: 

rt fx1(iterator , size _type , const value_type&); 

rt fx2 ( size _type , const value_type &); 

rt fx3(iterator , iterator , size_ type , const value_type&); 

were called instead, with the same arguments. 

10 In the previous paragraph the alternative binding willfail if first is not implicitly convertible to X::size_type or if 
last is not implicitly convertible to X::value_type. 

11 The extent to which an implementation determines that a type cannot be an input iterator is unspecified, except that as a 
minimum integral types shall not qualify as input iterators. 

Draft 


545 Containers library 23.1 Container requirements 

12 Table71 lists sequence operations that are provided for some types of sequential containersbut not others. An implementation shall provide these operations for all container types shown in the “container” column, and shall implement 
them so as to take amortizedconstant time. 

Table 71: Optional sequence operations 

expression return type assertion/note 
pre/post-condition 
container 
a.front() reference; const_reference 
for constant a 
*a.begin() vector, list, 
deque 
a.back() reference; const_reference 
for constant a 
{ iterator tmp = a.end(); 
-tmp; 
return *tmp; } 
vector, list, 
deque 
a.push_
front(x) 
void a.insert(a.begin(),x) list, deque 
a.push_
back(x) 
void a.insert(a.end(),x) vector, list, 
deque 
a.pop_
front() 
void a.erase(a.begin()) list, deque 
a.pop_back() void { iterator tmp = a.end(); 
-tmp; 
a.erase(tmp); } 
vector, list, 
deque 
a[n] reference; const_reference 
for constant a 
*(a.begin() + n) vector, deque 
a.at(n) reference; const_reference 
for constant a 
*(a.begin() + n) vector, deque 

13 The member function at() provides bounds-checked access to container elements. at() throws out_of_range if n 
>= a.size(). 

23.1.2 Associative containers [lib.associative.reqmts] 
1 Associative containers provide an ability forfast retrieval of data based onkeys. The library provides four basic kinds 
of associative containers: set, multiset, map and multimap. 

2 Each associative containerisparameterizedon Key and an ordering relation Compare that inducesa strict weak ordering 
(25.3)on elements of Key. In addition, map and multimap associate an arbitrary type T with the Key. The object of 
type Compare is called the comparison object of a container. This comparison object may be a pointer to function or an 
object of a type with an appropriate function call operator. 

3 The phrase “equivalenceofkeys” means the equivalence relation imposedby the comparison and not the operator== 
onkeys. That is, twokeys k1 and k2 are considered to be equivalent if for the comparison object comp, comp(k1, k2) 
== false && comp(k2, k1) == false.For anytwokeys k1 and k2 in the same container, calling comp(k1, k2) 
shall always return the same value. 

Draft 


23.1 Container requirements Containers library 546 
4 An associative container supports uniquekeys ifitmay containatmostone elementforeachkey. Otherwise,itsupports 
equivalentkeys. The set and map classes support uniquekeys; the multiset and multimap classes support equivalent 
keys. 

5 Forset and multiset thevaluetypeisthe sameasthekeytype.For map and multimap it is equal to pair<const 
Key, T>.Keys in an associative container are immutable. 

6 iterator ofan associative containerisofthe bidirectional iterator category.For associativecontainers wherethevalue 
typeis the same as thekeytype, both iterator and const_iterator are constant iterators. It is unspecified whether 
or not iterator and const_iterator are the same type. 

7 In Table 72, X is an associative container class, a is a value of X, a_uniq is a value of X when X supports unique 
keys, anda_eq is a value of X when X supports multiplekeys, i and j satisfy input iterator requirements and refer to 
elements of value_type, [i,j) is a valid range, p is a valid iterator to a, q is a valid dereferenceable iterator to a, 
[q1, q2) is a valid range in a, t is a value of X::value_type, k is a value of X::key_type and c is a value of type 
X::key_compare. 

Table 72: Associative container requirements (in addition to container) 

expression return type assertion/note 
pre/post-condition 
complexity 
X::key_type Key Key is CopyConstructible and 
Assignable 
compile time 
X::key_
compare 
Compare defaults to less<key_type> compile time 
X::value_
compare 
a binary predicate 
type 
is the same as key_compare for 
set and multiset;is an ordering 
relation on pairs induced by the 
first component (i.e. Key)formap 
and multimap. 
compile time 
X(c) 
X a(c); 
constructs an empty container 
uses c as a comparison object 
constant 
X() 
X a; 
constructs an empty container 
uses Compare() as a comparison 
object 
constant 
X(i,j,c) 
X a(i,j,c); 
constructs an empty container and 
inserts elements from the range 
[i, j) into it; uses c as a 
comparison object. 
NlogNin general (Nis the 
distance from i to j); linear if 
[i, j) is sorted with 
value_comp() 
X(i,j) 
X a(i,j); 
same as above, but uses 
Compare() as a comparison 
object 
same as above 
a.key_
comp() 
X::key_
compare 
returns the comparison objectout 
of which a was constructed. 
constant 
a.value_
comp() 
X::value_
compare 
returns an object of 
value_compare constructed out 
of the comparison object 
constant 

Draft 


547 Containers library 23.1 Container requirements 

expression return type assertion/note 
pre/post-condition 
complexity 
a_uniq. 
insert(t) 
pair<iterator, 
bool> 
inserts t if and only if there is no 
element in the container withkey 
equivalent to the keyof t. The 
bool component of the returned 
pair is true if and only if the 
insertion takes place, and the 
iterator component of the pair 
points to the element with key 
equivalent to the keyof t. 
logarithmic 
a_eq. 
insert(t) 
iterator inserts t and returns the iterator 
pointing to the newly inserted 
element. 
logarithmic 
a.insert(p, 
t) 
iterator inserts t if and only if there is no 
element with keyequivalent to the 
keyoft in containers with unique 
keys; always insertst in 
containers with equivalent keys. 
always returns the iterator 
pointing to the element with key 
equivalent to the keyof t. iterator 
p is a hint pointing to where the 
insert should start to search. 
logarithmic in general, but 
amortized constant if t is 
inserted right after p. 
a.insert(i, 
j) 
void pre: i, j are not iterators into a. 
inserts each element from the 
range [i,j) if and only if there is 
no element with keyequivalentto 
the keyof that element in 
containers with unique keys; 
always inserts that elementin 
containers with equivalent keys. 
Nlog(size() + N) (Nis the 
distance from i to j) 
a.erase(k) size_type erases all elements in the 
container with keyequivalent to k. 
returns the number of erased 
elements. 
log(size()) + count(k) 
a.erase(q) iterator erases the element pointed to by q. 
Returns an iterator pointing to the 
element immediately following q 
prior to the element being erased. 
If no such element exists, returns 
a.end(). 
amortized constant 
a.erase(q1, 
q2) 
iterator erases all the elements in the 
range [q1,q2). Returns q2. 
log(size()) + Nwhere Nis the 
distance from q1 to q2. 

Draft 


23.2 Sequences Containers library 548 
expression return type assertion/note 
pre/post-condition 
complexity 
a.clear() void erase(a.begin(),a.end()) 
post: size() == 0 
linear in size(). 
a.find(k) iterator; 
const_
iterator for 
constant a. 
returns an iterator pointing to an 
element with the keyequivalent to 
k, or a.end() if such an element 
is not found 
logarithmic 
a.count(k) size_type returns the number of elements 
with keyequivalent to k 
log(size()) + count(k) 
a.lower_
bound(k) 
iterator; 
const_
iterator for 
constant a. 
returns an iterator pointing to the 
first element with keynot less 
than k, or a.end() if such an 
element is not found. 
logarithmic 
a.upper_
bound(k) 
iterator; 
const_
iterator for 
constant a. 
returns an iterator pointing to the 
first element with keygreater than 
k, or a.end() if such an element 
is not found. 
logarithmic 
a.equal_
range(k) 
pair<iterator, 
iterator>; 
pair<const_
iterator, 
const_iterator> for constant 
a. 
equivalent to make_
pair(a.lower_bound(k), 
a.upper_bound(k)). 
logarithmic 

8 The insert members shall not affect the validity of iterators and references to the container, and the erase members shall 
invalidate only iterators and references to the erased elements. 

9 The fundamental property of iterators of associative containers is that they iterate through the containers in the non-
descending orderofkeyswhere non-descendingis definedbythe comparisonthatwasusedto construct them.Forany 
two dereferenceable iterators i and j such that distance from i to j is positive, 

value_comp (*j , * i ) == false 

10 For associative containerswith uniquekeys the stronger condition holds, 

value_comp (*i , * j ) != false . 

11 When an associative container is constructed by passing a comparison object the container shall not store a pointer or 
referencetothepassedobject,evenifthatobjectispassedby reference.Whenan associative containeriscopied, either 
through a copyconstructor or an assignment operator, the target container shall then use the comparison object from the 
container being copied, as if that comparison object had been passed to the target container in its constructor. 

23.2 Sequences [lib.sequences] 
1 Headers <deque>, <list>, <queue>, <stack>, and <vector>. 

Draft 


549 Containers library 23.2 Sequences 

Header <deque> synopsis 
n a m e s p a c e s t d { 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r = a l l o c a t o r < T > > c l a s s d e q u e ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = 
( c o n s t d e q u e < T , A l l o c a t o r > & x , c o n s t d e q u e < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < 
( c o n s t d e q u e < T , A l l o c a t o r > & x , c o n s t d e q u e < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = 
( c o n s t d e q u e < T , A l l o c a t o r > & x , c o n s t d e q u e < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > 
( c o n s t d e q u e < T , A l l o c a t o r > & x , c o n s t d e q u e < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > = 
( c o n s t d e q u e < T , A l l o c a t o r > & x , c o n s t d e q u e < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < = 
( c o n s t d e q u e < T , A l l o c a t o r > & x , c o n s t d e q u e < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
v o i d s w a p ( d e q u e < T , A l l o c a t o r > & x , d e q u e < T , A l l o c a t o r > & y ) ; 
} 
Header <list> synopsis 
n a m e s p a c e s t d { 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r = a l l o c a t o r < T > > c l a s s l i s t ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t l i s t < T , A l l o c a t o r > & x , c o n s t l i s t < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t l i s t < T , A l l o c a t o r > & x , c o n s t l i s t < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t l i s t < T , A l l o c a t o r > & x , c o n s t l i s t < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > ( c o n s t l i s t < T , A l l o c a t o r > & x , c o n s t l i s t < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > = ( c o n s t l i s t < T , A l l o c a t o r > & x , c o n s t l i s t < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < = ( c o n s t l i s t < T , A l l o c a t o r > & x , c o n s t l i s t < T , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s A l l o c a t o r > 
v o i d s w a p ( l i s t < T , A l l o c a t o r > & x , l i s t < T , A l l o c a t o r > & y ) ; 
} 
Header <queue> synopsis 
n a m e s p a c e s t d { 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r = d e q u e < T > > c l a s s q u e u e ; 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
Draft 


23.2 Sequences Containers library 550 
bool operator==(const queue<T, Container>& x,
const queue <T, Container >& y);
template < class T , class Container >
bool operator < (const queue <T, Container >& x,
const queue <T, Container >& y);
template < class T , class Container >
bool operator!=(const queue<T, Container>& x,
const queue <T, Container >& y);
template < class T , class Container >
bool operator > (const queue <T, Container >& x,
const queue <T, Container >& y);
template < class T , class Container >
bool operator >=(const queue <T, Container >& x,
const queue <T, Container >& y);
template < class T , class Container >
bool operator <=(const queue <T, Container >& x,
const queue <T, Container >& y);


template <class T, class Container = vector <T>,
class Compare = less < typename Container :: value_type > >
class priority_queue;
}


Header <stack> synopsis 

namespace std { 

template <class T, class Container = deque <T> > class stack; 

template < class T , class Container > 

bool operator==(const stack<T, Container>& x, 

const stack <T, Container >& y); 

template < class T , class Container > 

bool operator < (const stack <T, Container >& x, 

const stack <T, Container >& y); 

template < class T , class Container > 

bool operator!=(const stack<T, Container>& x, 

const stack <T, Container >& y); 

template < class T , class Container > 

bool operator > (const stack <T, Container >& x, 

const stack <T, Container >& y); 

template < class T , class Container > 

bool operator >=(const stack <T, Container >& x, 

const stack <T, Container >& y); 

template < class T , class Container > 

bool operator <=(const stack <T, Container >& x, 

const stack <T, Container >& y); 

} 

Header <vector> synopsis 

namespace std { 
template <class T, class Allocator = allocator <T> > class vector; 

Draft 


551 Containers library 23.2 Sequences 

template < class T , class Allocator >
bool operator==(const vector<T,Allocator>& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator < (const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator!=(const vector<T,Allocator>& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator > (const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator >=(const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator <=(const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
void swap(vector <T,Allocator >& x, vector <T,Allocator >& y);


template <class Allocator > class vector <bool ,Allocator >;
template < class Allocator >
bool operator==(const vector<bool,Allocator>& x,
const vector<bool,Allocator>& y);
template < class Allocator >
bool operator< (const vector<bool,Allocator>& x,
const vector<bool,Allocator>& y);
template < class Allocator >
bool operator!=(const vector<bool,Allocator>& x,
const vector<bool,Allocator>& y);
template < class Allocator >
bool operator> (const vector<bool,Allocator>& x,
const vector<bool,Allocator>& y);
template < class Allocator >
bool operator>=(const vector<bool,Allocator>& x,
const vector<bool,Allocator>& y);
template < class Allocator >
bool operator<=(const vector<bool,Allocator>& x,
const vector<bool,Allocator>& y);
template < class Allocator >
void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);
}


23.2.1 Class template deque [lib.deque] 
Adeque is a kind of sequence that, like a vector (23.2.4), supports random access iterators. In addition, it supports 
constant time insert and erase operations at the beginning or the end; insert and erase in the middle take linear time. That 
is, a deque is especially optimized for pushing and popping elements at the beginning and end. As with vectors, storage 
management is handled automatically. 

Draft 


23.2 Sequences Containers library 552 
Adeque satisfies all of the requirements of a container and of a reversible container (given in tables in 23.1)and of a 
sequence, including the optional sequence requirements(23.1.1). In addition to the requirements on the stored object 
described in 23.1, the stored object shall meet the requirements of Assignable. Descriptions are provided here only for 
operations on deque that are not described in one of these tables or for operations where there is additional semantic 
information. 

namespace std {
template <class T, class Allocator = allocator <T> >
class deque {
public :


// types: 

typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator ; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef T value_type ; 
typedef Allocator allocator_type; 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

// 23.2.1.1 construct/copy/destroy: 

explicit deque(const Allocator& = Allocator());
explicit deque(size_type n, const T& value = T(),
const Allocator & = Allocator ());
template < class InputIterator >
deque(InputIterator first , InputIterator last ,
const Allocator & = Allocator ());
deque(const deque <T,Allocator >& x);


~ deque ();
deque<T,Allocator>& operator= (const deque<T,Allocator>& x);
template < class InputIterator >


void assign(InputIterator first , InputIterator last);
void assign(size_type n, const T& t);
allocator_type get_allocator() const;


// iterators: 

iterator begin ();
const_iterator begin () const ;
iterator end ();
const_iterator end () const ;
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
reverse_iterator rend();
const_reverse_iterator rend() const;


// 23.2.1.2 capacity: 

Draft 


553 Containers library 23.2 Sequences 

size_type size() const;
size_type max_size() const;
void resize(size_type sz, T c = T());
bool empty () const ;


// element access: 

reference operator []( size_type n);
const_reference operator[](size_type n) const;
reference at(size_type n);
const_reference at(size_type n) const;
reference front();
const_reference front() const;
reference back();
const_reference back() const;


// 23.2.1.3 modifiers: 

void push_front(const T& x);
void push_back(const T& x);


iterator insert(iterator position , const T& x); 
void insert(iterator position , size_type n, const T& x); 
template < class InputIterator > 

void insert ( iterator position ,
InputIterator first , InputIterator last);


void pop_front ();
void pop_back ();


iterator erase ( iterator position );
iterator erase ( iterator first , iterator last );
void swap(deque <T,Allocator >&);
void clear ();


}; 

template < class T , class Allocator > 
bool operator==(const deque<T,Allocator>& x, 
const deque <T,Allocator >& y); 
template < class T , class Allocator > 
bool operator < (const deque <T,Allocator >& x, 
const deque <T,Allocator >& y); 
template < class T , class Allocator > 
bool operator!=(const deque<T,Allocator>& x, 
const deque <T,Allocator >& y); 
template < class T , class Allocator > 
bool operator > (const deque <T,Allocator >& x, 
const deque <T,Allocator >& y); 
template < class T , class Allocator > 
bool operator >=(const deque <T,Allocator >& x, 
const deque <T,Allocator >& y); 
template < class T , class Allocator > 

Draft 


23.2 Sequences Containers library 554 
bool operator <=(const deque <T,Allocator >& x,
const deque <T,Allocator >& y);


// specialized algorithms: 

template < class T , class Allocator >
void swap(deque <T,Allocator >& x, deque <T,Allocator >& y);
}


23.2.1.1 deque constructors, copy,and assignment [lib.deque.cons] 
explicit deque(const Allocator& = Allocator()); 

1 Effects: Constructs an empty deque, using the specified allocator. 
2 Complexity: Constant. 

explicit deque ( size_type n , const T& value = T(),
const Allocator & = Allocator ());


3 Effects: Constructs a deque with n copies of value , using the specified allocator. 
4 Complexity: Linear in n . 

template < class InputIterator >
deque ( InputIterator first , InputIterator last ,
const Allocator & = Allocator ());


5 Effects: Constructs a deque equal to the the range [first ,last ), using the specified allocator. 
6 Complexity: Makes distance(first , last ) calls to the copyconstructor of T. 256) 

template < class InputIterator >
void assign(InputIterator first , InputIterator last);


7 Effects: 

erase ( begin () , end ());
insert ( begin () , first , last );


void assign(size_type n, const T& t); 

8 Effects: 

erase ( begin () , end ());
insert(begin(), n, t);


23.2.1.2 deque capacity [lib.deque.capacity] 
void resize ( size_type sz , T c = T ()); 

1 Effects: 
256) This footnote is intentionally empty. 

Draft 


555 Containers library 23.2 Sequences 

if (sz > size())
insert(end(), sz-size(), c);
else if ( sz < size ())
erase(begin()+sz, end());
else
; // do nothing


23.2.1.3 deque modifiers [lib.deque.modifiers] 
iterator insert(iterator position , const T& x);
void insert(iterator position , size_type n, const T& x);
template < class InputIterator >


void insert ( iterator position ,
InputIterator first , InputIterator last);


1 Effects: Aninsertinthemiddleofthedequeinvalidatesalltheiteratorsand referencesto elementsofthedeque. 
An insertat eitherendofthedequeinvalidatesallthe iteratorstothedeque,buthasnoeffectonthevalidityof 
references to elements of the deque. 

2 Remarks: If an exception is thrown other than by the copyconstructor or assignment operator of T there are no 
effects. 

3 Complexity: In the worst case, inserting a single element into a deque takes time linear in the minimum of the 
distance from the insertion point to the beginning of the deque and the distance from the insertion point to the end 
ofthedeque. Insertingasingle element eitheratthebeginningorendofadequealwaystakes constanttimeand 
causes a single call to the copyconstructor of T. 

iterator erase ( iterator position );
iterator erase ( iterator first , iterator last );


4 Effects: An erase in the middle of the deque invalidates all the iterators and references to elements of the deque. 
An erase at either end of the deque invalidates only the iterators and the references to the erased elements. 

5 Complexity: The numberof callstothe destructoristhe sameasthe numberof elements erased,butthe numberof 
thecallstotheassignmentoperatorisatmostequaltotheminimumofthenumberof elementsbeforetheerased 
elements and the number ofelements after the erased elements. 

6 Throws: Nothing unless an exception is thrown by the copyconstructor or assignment operator of T. 

23.2.1.4 deque specialized algorithms [lib.deque.special] 
template < class T , class Allocator >
void swap(deque <T,Allocator >& x, deque <T,Allocator >& y);


1 Effects: 

x. swap (y); 
Draft 


23.2 Sequences Containers library 556 
23.2.2 Class template list [lib.list] 
1Alist is a kind of sequence that supports bidirectional iterators and allows constant time insert and erase operations 
anywhere within the sequence, with storage management handled automatically. Unlikevectors(23.2.4)and deques 
(23.2.1),fast random accesstolist elementsisnot supported,butmanyalgorithmsonlyneed sequential accessanyway. 

2Alist satisfies all of the requirements of a container and of a reversible container (given in two tables in 23.1)and of 
a sequence, including most of the the optional sequence requirements(23.1.1). The exceptions are the operator[] and 
at member functions, which are not provided.257) list does not require the stored type T to be Assignable unless the 
following methods are instantiated:258) 

list<T,Allocator>& operator= (const list<T,Allocator>& x);
template < class InputIterator >
void assign(InputIterator first , InputIterator last);
void assign(size_type n, const T& t);


Descriptions are provided here only for operations on list that arenot describedin oneofthese tablesorfor operations 
where there is additional semantic information. 

namespace std {
template <class T, class Allocator = allocator <T> >
class list {
public :


// types: 

typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator ; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef T value_type ; 
typedef Allocator allocator_type; 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

// 23.2.2.1 construct/copy/destroy: 

explicit list(const Allocator& = Allocator());
explicit list ( size_type n , const T& value = T(),
const Allocator & = Allocator ());
template < class InputIterator >
list ( InputIterator first , InputIterator last ,
const Allocator & = Allocator ());
list(const list<T,Allocator >& x );


~ list ();
list <T , Allocator >& operator = ( const list <T , Allocator >& x );
template < class InputIterator >


257) These member functions are only provided by containers whose iterators are random access iterators.
258)Implementors are permittedbutnot requiredtotakeadvantageof T’s Assignable properties for these methods.


Draft 


557 Containers library 23.2 Sequences 

v o i d a s s i g n ( I n p u t I t e r a t o r f i r s t , I n p u t I t e r a t o r 
v o i d a s s i g n ( s i z e _ t y p e n , c o n s t T & t ) ; 
a l l o c a t o r _ t y p e g e t _ a l l o c a t o r ( ) c o n s t ; 
l a s t ) ; 
// iterators: 
i t e r a t o r 
c o n s t _ i t e r a t o r 
i t e r a t o r 
c o n s t _ i t e r a t o r 
r e v e r s e _ i t e r a t o r 
c o n s t _ r e v e r s e _ i t e r a t o r 
r e v e r s e _ i t e r a t o r 
c o n s t _ r e v e r s e _ i t e r a t o r 
b e g i n ( ) ; 
b e g i n ( ) c o n s t ; 
e n d ( ) ; 
e n d ( ) c o n s t ; 
r b e g i n ( ) ; 
r b e g i n ( ) c o n s t ; 
r e n d ( ) ; 
r e n d ( ) c o n s t ; 
// 23.2.2.2 capacity: 
b o o l e m p t y ( ) c o n s t ; 
s i z e _ t y p e s i z e ( ) c o n s t ; 
s i z e _ t y p e m a x _ s i z e ( ) c o n s t ; 
v o i d r e s i z e ( s i z e _ t y p e sz , T c = T ( ) ) ; 
// element access: 
r e f e r e n c e 
c o n s t _ r e f e r e n c e 
r e f e r e n c e 
c o n s t _ r e f e r e n c e 
f r o n t ( ) ; 
f r o n t ( ) c o n s t ; 
b a c k ( ) ; 
b a c k ( ) c o n s t ; 
// 23.2.2.3 modifiers: 
v o i d p u s h _ f r o n t ( c o n s t T & x ) ; 
v o i d p o p _ f r o n t ( ) ; 
v o i d p u s h _ b a c k ( c o n s t T & x ) ; 
v o i d p o p _ b a c k ( ) ; 
i t e r a t o r i n s e r t ( i t e r a t o r position , c o n s t T & x ) ; 
v o i d i n s e r t ( i t e r a t o r position , s i z e _ t y p e n , c o n s t 
t e m p l a t e < c l a s s I n p u t I t e r a t o r > 
v o i d i n s e r t ( i t e r a t o r position , I n p u t I t e r a t o r first , 
I n p u t I t e r a t o r last ) ; 
T & x ) ; 
i t e r a t o r 
i t e r a t o r 
v o i d 
v o i d 
e r a s e ( i t e r a t o r position ) ; 
e r a s e ( i t e r a t o r position , i t e r a t o r 
s w a p ( l i s t < T , A l l o c a t o r > & ) ; 
c l e a r ( ) ; 
last ) ; 
// 23.2.2.4 list operations: 
v o i d s p l i c e ( i t e r a t o r 
v o i d s p l i c e ( i t e r a t o r 
v o i d s p l i c e ( i t e r a t o r 
i t e r a t o r last ) ; 
position , 
position , 
position , 
l i s t < T , A l l o c a t o r > & 
l i s t < T , A l l o c a t o r > & 
l i s t < T , A l l o c a t o r > & 
x ) ; 
x , i t e r a t o r 
x , i t e r a t o r 
i ) ; 
first , 
v o i d r e m o v e ( c o n s t T & value ) ; 
Draft 


23.2 Sequences Containers library 558 
template < class Predicate > void remove_if ( Predicate pred ); 

void unique ();
template < class BinaryPredicate >
void unique(BinaryPredicate binary_pred );


void merge(list<T,Allocator >& x ); 

template <class Compare > void merge(list <T,Allocator >& x , Compare comp ); 

void sort (); 

template < class Compare > void sort ( Compare comp ); 

void reverse ();
};


template < class T , class Allocator > 
bool operator==(const list<T,Allocator >& x , const list<T,Allocator >& y ); 
template < class T , class Allocator > 
bool operator < (const list<T,Allocator >& x , const list<T,Allocator >& y ); 
template < class T , class Allocator > 
bool operator!=(const list<T,Allocator >& x , const list<T,Allocator >& y ); 
template < class T , class Allocator > 
bool operator > (const list<T,Allocator >& x , const list<T,Allocator >& y ); 
template < class T , class Allocator > 
bool operator >=(const list<T,Allocator >& x , const list<T,Allocator >& y ); 
template < class T , class Allocator > 
bool operator <=(const list<T,Allocator >& x , const list<T,Allocator >& y ); 

// specialized algorithms: 

template < class T , class Allocator >
void swap(list<T,Allocator>& x, list<T,Allocator>& y);
}


23.2.2.1 list constructors, copy, and assignment [lib.list.cons] 
explicit list(const Allocator& = Allocator()); 
1 Effects: Constructs an empty list, using the specified allocator. 
2 Complexity: Constant. 

explicit list ( size_type n , const T& value = T(),
const Allocator & = Allocator ());


3 Effects: Constructs a list with n copies of value, using the specified allocator. 
4 Complexity: Linear in n. 

template < class InputIterator > 

list ( InputIterator first , InputIterator last , 

const Allocator & = Allocator ()); 

Draft 


559 Containers library 23.2 Sequences 

5 Effects: Constructs a list equal to the range [first ,last ). 
6 Complexity: Linear in distance(first , last ). 

template < class InputIterator >
void assign(InputIterator first , InputIterator last);


7 Effects: Replaces the contentsof thelist with the range [first, last). 

void assign(size_type n, const T& t); 

8 Effects: Replaces the contentsof thelist with n copies of t . 

23.2.2.2 list capacity [lib.list.capacity] 
void resize ( size_type sz , T c = T ()); 

1 Effects: 

if (sz > size())
insert(end(), sz-size(), c);


else if (sz < size()) {
iterator i = begin ();
advance (i , sz );
erase (i , end ());


}
else
; // do nothing


23.2.2.3 list modifiers [lib.list.modifiers] 
iterator insert ( iterator position , const T& x );
void insert ( iterator position , size_type n , const T& x );
template < class InputIterator >


void insert ( iterator position , InputIterator first ,
InputIterator last );


void push_front(const T& x);
void push_back(const T& x);


1 Remarks: Does not affect the validityof iterators and references. If an exception is thrown there are no effects. 

2 Complexity: Insertionofasingle elementintoalisttakes constanttimeandexactlyonecalltothecopyconstructor 
of T. Insertionofmultiple elements intoa listis linearinthe numberof elements inserted,andthe numberof calls 
to the copyconstructor of T is exactly equal to the number of elements inserted. 

iterator erase ( iterator position );
iterator erase ( iterator first , iterator last );


void pop_front (); 

Draft 


23.2 Sequences Containers library 560 
void pop_back ();
void clear ();


3 Effects: Invalidates only the iterators and references to the erased elements. 

4 Throws: Nothing. 

5 Complexity: Erasing a single element is a constant time operation with a single call to the destructor of T. Erasing 
a range in a list is linear time in the size of the range and the number of calls to the destructor of type T is exactly 
equal to the size of the range. 

23.2.2.4 list operations [lib.list.ops] 
1 Since lists allowfast insertion and erasing from the middleofa list, certain operations are provided specifically for 
them.259) 

2 list provides three splice operations that destructively move elements from one list to another. 

void splice ( iterator position , list<T,Allocator >& x ); 

3 Requires: &x != this. 

4 Effects: Inserts the contents of x before position and x becomes empty. Pointers and references to the moved 
elements of x now refer to those same elements but as members of *this. Iterators referring to the moved 
elements will continue to refer to their elements,but theynow behave as iteratorsinto *this, not into x. 

5 Throws: Nothing 

6 Complexity: Constant time. 

void splice ( iterator position , list<T,Allocator >& x , iterator i ); 

7 Effects: Inserts an element pointed toby i from list x before position and removes the element from x. The 
result is unchanged if position == i or position == ++i. Pointers and references to *i continue to refer to 
this same elementbut asa memberof *this. Iterators to *i (including i itself) continue to refer to the same 
element,but now behave asiterators into *this, not into x. 

8 Throws: Nothing 

9 Requires: i is a valid dereferenceable iterator of x. 

10 Complexity: Constant time. 

void splice ( iterator position , list<T,Allocator >& x , iterator first ,
iterator last );


11 Effects: Inserts elements in the range [first,last) before position and removes the elementsfrom x. 

12 Requires: [first, last) is a valid range in x. The result is undefined if position is an iterator in the range 
[first,last). Pointers and references to the moved elements of x now refer to those same elementsbut as 
members of *this. Iterators referring to the moved elements will continue to refer to their elements,but they 
now behave as iterators into *this, not into x. 

259)As specified in 20.1.6, the requirements in this clause apply only to lists whose allocators compare equal. 

Draft 


561 Containers library 23.2 Sequences 
13 Throws: Nothing 
14 Complexity: Constant time if &x == this;otherwise, linear time. 
t e m p l a t e < c l a s s P r e d i c a t e > 
v o i d 
v o i d 
r e m o v e ( c o n s t T & value ) ; 
r e m o v e _ i f ( P r e d i c a t e pred ) ; 
15 Effects: Erases all the elements in the list referred by a list iterator i for which the following conditions hold: *i 
== value, pred(*i) != false. 
16 Throws: Nothing unless an exception is thrown by *i == value or pred (*i) != false. 
17 Remarks: Stable. 
18 Complexity: Exactly size() applications of the corresponding predicate. 
t e m p l a t e < c l a s s B i n a r y P r e d i c a t e > 
v o i d 
v o i d 
u n i q u e ( ) ; 
u n i q u e ( B i n a r y P r e d i c a t e binary_pred ) ; 
19 Effects: Eliminates all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first + 1,last ) for which *i == *(i-1) (for the version of unique with no arguments) 
or pred (*i, *(i -1)) (for the version of unique with a predicate argument) holds. 
20 Throws: Nothing unless an exception in thrown by *i == *(i-1) or pred (*i, *(i -1)) 
21 Complexity: If the range [first , last ) is not empty, exactly (last 
responding predicate, otherwise no applications of the predicate. 
-first ) -1 applications of the cor-
v o i d 
t e m p l a t e < c l a s s C o m p a r e > v o i d 
m e r g e ( l i s t < T , A l l o c a t o r > & 
m e r g e ( l i s t < T , A l l o c a t o r > & 
x ) ; 
x , C o m p a r e comp ) ; 
22 Requires: comp defines a strict weak ordering (25.3), and the list and the argument list are both sorted according 
to this ordering. 
23 Effects: If (&x == this) does nothing; otherwise, merges the two sorted ranges [begin(), end()) and [x. 
begin(), x.end()). The result is a range in which the elements will be sorted in non-decreasing order according to the ordering defined by comp; that is, for every iteratori, in the range other than the first, the condition 
comp(*i, *(i -1) will be false. 
24 Remarks: Stable. If (&x != this) the range [x.begin(), x.end()) is empty after the merge. 
25 Complexity: At most size() + x.size() -1 applications of comp if (&x != this);otherwise, no applications of comp are performed. If an exception is thrown other than by a comparison there are no effects. 
v o i d r e v e r s e ( ) ; 
26 Effects: Reverses the order of the elements in the list. 
27 Throws: Nothing. 
28 Complexity: Linear time. 
t e m p l a t e < c l a s s C o m p a r e > 
v o i d 
v o i d 
s o r t ( ) ; 
s o r t ( C o m p a r e comp ) ; 
Draft 


23.2 Sequences Containers library 562 
29 Requires: operator< (for the firstversion) or comp (for the secondversion) definesa strict weak ordering(25.3).
30 Effects: Sorts the list according to the operator< or a Compare function object.
31 Remarks: Stable.


32 Complexity: Approximately Nlog(N) comparisons, where N == size(). 

23.2.2.5 list specialized algorithms [lib.list.special] 
template < class T , class Allocator >
void swap(list<T,Allocator >& x, list<T,Allocator >& y);


1 Effects: 

x. swap (y); 
23.2.3 Container adaptors [lib.container.adaptors] 
1 The container adaptors each take a Container template parameter, and each constructor takes a Container reference 
argument. This container is copied into the Container member of each adaptor. 

23.2.3.1 Class template queue [lib.queue] 
1 Any sequence supporting operations front(), back(), push_back() and pop_front() can be used to instantiate 
queue. In particular, list (23.2.2)anddeque (23.2.1)can be used. 

23.2.3.1.1 queue definition [lib.queue.defn] 
namespace std {
template <class T, class Container = deque <T> >
class queue {
public :


typedef typename Container :: value_type value_type ; 
typedef typename Container::reference reference; 
typedef typename Container::const_reference const_reference; 
typedef typename Container::size_type size_type; 
typedef Container container_type; 

protected :
Container c;


public :
explicit queue(const Container& = Container());


bool empty() const { return c.empty(); }
size_type size() const { return c.size(); }
reference front() { return c.front(); }
const_reference front() const { return c.front(); }
reference back() { return c.back(); }
const_reference back() const { return c.back(); }
void push(const value_type& x) { c.push_back(x); }


Draft 


563 Containers library 23.2 Sequences 
v o i d 
} ; 
p o p ( ) { c . p o p _ f r o n t ( ) ; } 
} 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r = = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r < ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r ! = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r > ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r > = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & y ) ; 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r < = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & y ) ; 
x , 
x , 
x , 
x , 
x , 
x , 
23.2.3.1.2 queue operators [lib.queue.ops] 
t e m p l a t e 
b o o l 
< c l a s s T , c l a s s C o n t a i n e r > 
o p e r a t o r = = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & 
x , 
y ) ; 
1 Returns: x.c == y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , c l a s s C o n t a i n e r > 
o p e r a t o r ! = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & 
x , 
y ) ; 
2 Returns: x.c != y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , 
o p e r a t o r < 
c l a s s C o n t a i n e r > 
( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & 
x , 
y ) ; 
3 Returns: x.c < y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , c l a s s C o n t a i n e r > 
o p e r a t o r < = ( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & 
x , 
y ) ; 
4 Returns: x.c <= y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , 
o p e r a t o r > 
c l a s s C o n t a i n e r > 
( c o n s t q u e u e < T , C o n t a i n e r > & 
c o n s t q u e u e < T , C o n t a i n e r > & 
x , 
y ) ; 
Draft 


23.2 Sequences Containers library 564 
5 Returns: x.c > y.c. 

template < class T , class Container >
bool operator > =(const queue <T, Container >& x,
const queue <T , Container >& y );


6 Returns: x.c >= y.c. 

23.2.3.2 Class template priority_queue [lib.priority.queue] 
1 Any sequence with random access iterator and supporting operations front(), push_back() and pop_back() can 
be used to instantiate priority_queue. In particular, vector (23.2.4)anddeque (23.2.1)can be used. Instantiating 
priority_queue also involves supplying a function or function object for making priority comparisons; the library 
assumes that the function or function object definesa strict weak ordering(25.3). 

namespace std {
template <class T, class Container = vector <T>,


class Compare = less < typename Container :: value_type > >
class priority_queue {
public :


typedef typename Container :: value_type value_type ; 
typedef typename Container::reference reference; 
typedef typename Container::const_reference const_reference; 
typedef typename Container::size_type size_type; 
typedef Container container_type; 

protected :
Container c;
Compare comp ;


public :
explicit priority_queue(const Compare& x = Compare(),
const Container & = Container ());
template < class InputIterator >


priority_queue(InputIterator first, InputIterator last,
const Compare & x = Compare () ,
const Container & = Container ());


bool empty() const { return c.empty(); }
size_type size() const { return c.size(); }
const_reference top() const { return c.front(); }
void push ( const value_type & x );
void pop ();


}; 

// no equality is provided 

} 

23.2.3.2.1 priority_queue constructors [lib.priqueue.cons] 
priority_queue(const Compare& x = Compare(),
const Container & y = Container ());


Draft 


565 Containers library 23.2 Sequences 

1 Requires: x definesa strict weak ordering(25.3).
2 Effects: Initializes comp with x and c with y;callsmake_heap(c.begin(), c.end(), comp).


template < class InputIterator > 

priority_queue(InputIterator first , InputIterator last ,
const Compare& x = Compare(),
const Container & y = Container ());


3 Requires: x definesa strict weak ordering(25.3). 

4 Effects: Initializes c with y and comp with x; calls c.insert(c.end(), first, last); and finally calls 
make_heap(c.begin(), c.end(), comp). 

23.2.3.2.2 priority_queue members [lib.priqueue.members] 
void push(const value_type& x); 

1 Effects: 

c. push_back (x );
push_heap(c.begin(), c.end(), comp);
void pop (); 

2 Effects: 

pop_heap(c.begin(), c.end(), comp); 

c. pop _back (); 
23.2.3.3 Class template stack [lib.stack] 
1 Any sequence supporting operations back(), push_back() and pop_back() can be used to instantiate stack. In 
particular, vector (23.2.4), list (23.2.2)anddeque (23.2.1)can be used. 

23.2.3.3.1 stack definition [lib.stack.defn] 
namespace std {
template <class T, class Container = deque <T> >
class stack {
public :


typedef typename Container :: value_type value_type ; 
typedef typename Container::reference reference; 
typedef typename Container::const_reference const_reference; 
typedef typename Container::size_type size_type; 
typedef Container container_type; 

protected :
Container c;


public :
explicit stack(const Container& = Container());


Draft 


23.2 Sequences Containers library 566 
b o o l e m p t y ( ) c o n s t 
s i z e _ t y p e s i z e ( ) c o n s t 
r e f e r e n c e t o p ( ) 
c o n s t _ r e f e r e n c e t o p ( ) c o n s t 
v o i d p u s h ( c o n s t v a l u e _ t y p e & x ) 
v o i d p o p ( ) 
} ; 
{ 
{ 
{ 
{ 
{ 
{ 
r e t u r n c . e m p t y ( ) ; } 
r e t u r n c . s i z e ( ) ; } 
r e t u r n c . b a c k ( ) ; } 
r e t u r n c . b a c k ( ) ; } 
c . p u s h _ b a c k ( x ) ; } 
c . p o p _ b a c k ( ) ; } 
} 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r = = ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r < ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r ! = ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r > ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r > = ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
t e m p l a t e < c l a s s T , c l a s s C o n t a i n e r > 
b o o l o p e r a t o r < = ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
23.2.3.3.2 stack operators [lib.stack.ops] 
t e m p l a t e 
b o o l 
< c l a s s T , c l a s s C o n t a i n e r > 
o p e r a t o r = = ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
x , 
y ) ; 
1 Returns: x.c == y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , c l a s s C o n t a i n e r > 
o p e r a t o r ! = ( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
x , 
y ) ; 
2 Returns: x.c != y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , 
o p e r a t o r < 
c l a s s C o n t a i n e r > 
( c o n s t s t a c k < T , C o n t a i n e r > & 
c o n s t s t a c k < T , C o n t a i n e r > & 
x , 
y ) ; 
3 Returns: x.c < y.c. 
t e m p l a t e 
b o o l 
< c l a s s T , c l a s s C o n t a i n e r > 
o p e r a t o r < = ( c o n s t s t a c k < T , C o n t a i n e r > & x , 
Draft 


567 Containers library 23.2 Sequences 

const stack <T , Container >& y ); 

4 Returns: x.c <= y.c. 

template < class T , class Container >
bool operator > (const stack <T, Container >& x,
const stack <T , Container >& y );


5 Returns: x.c > y.c. 

template < class T , class Container >
bool operator > =(const stack <T, Container >& x,
const stack <T , Container >& y );


6 Returns: x.c >= y.c. 

23.2.4 Class template vector [lib.vector] 
1Avector isa kindof sequence that supports random access iterators.Inaddition,it supports (amortized) constant time 
insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled 
automatically, though hints can be given to improve efficiency. The elements of a vector are stored contiguously, 
meaning that if v is a vector<T, Allocator> where T is some type other than bool, then it obeys the identity &v[n] 
== &v[0] + n for all 0 <= n < v.size(). 

2Avector satisfies all of the requirements of a container and of a reversible container (given in two tables in 23.1)and 
ofa sequence,including mostof the optional sequence requirements(23.1.1). Theexceptions are the push_front and 
pop_front member functions, which are not provided. In additionto the requirements on the stored object described 
in 23.1, the stored object shall meet the requirementsofAssignable. Descriptions are provided here only for operations 
on vector that are not described in one of these tables or for operations where there is additional semantic information. 

namespace std {
template <class T, class Allocator = allocator <T> >
class vector {
public :


// types: 

typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef T value_type ; 
typedef Allocator allocator_type; 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

// 23.2.4.1 construct/copy/destroy: 

explicit vector ( const Allocator & = Allocator ());
explicit vector(size_type n, const T& value = T(),


Draft 


23.2 Sequences Containers library 568 
const Allocator & = Allocator ());
template < class InputIterator >
vector(InputIterator first , InputIterator last ,
const Allocator & = Allocator ());
vector(const vector <T,Allocator >& x);


~ vector (); 
vector<T,Allocator>& operator= (const vector<T,Allocator>& x); 
template < class InputIterator > 

void assign(InputIterator first , InputIterator last);
void assign(size_type n, const T& u);
allocator_type get_allocator() const;


// iterators: 

iterator begin ();
const_iterator begin () const ;
iterator end ();
const_iterator end () const ;
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
reverse_iterator rend();
const_reverse_iterator rend() const;


// 23.2.4.2 capacity: 

size_type size() const;
size_type max_size() const;
void resize(size_type sz, T c = T());
size_type capacity() const;
bool empty () const ;
void reserve ( size_type n );


// element access: 

reference operator []( size_type n);
const_reference operator[](size_type n) const;
const_reference at(size_type n) const;
reference at(size_type n);
reference front();
const_reference front() const;
reference back();
const_reference back() const;


// 23.2.4.3 data access
pointer data();
const_pointer data() const;


// 23.2.4.4 modifiers: 

void push_back(const T& x);
void pop_back ();
iterator insert(iterator position , const T& x);
void insert(iterator position , size_type n, const T& x);
template < class InputIterator >


Draft 


569 Containers library 23.2 Sequences 

void insert ( iterator position , 

InputIterator first , InputIterator last); 

iterator erase ( iterator position ); 

iterator erase ( iterator first , iterator last ); 

void swap(vector <T,Allocator >&); 

void clear (); 

}; 

template < class T , class Allocator >
bool operator==(const vector<T,Allocator>& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator < (const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator!=(const vector<T,Allocator>& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator > (const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator >=(const vector <T,Allocator >& x,
const vector <T,Allocator >& y);
template < class T , class Allocator >
bool operator <=(const vector <T,Allocator >& x,
const vector <T,Allocator >& y);


// specialized algorithms: 

template < class T , class Allocator >
void swap(vector <T,Allocator >& x, vector <T,Allocator >& y);
}


23.2.4.1 vector constructors, copy, and assignment [lib.vector.cons] 
vector ( const Allocator & = Allocator ());
explicit vector(size_type n, const T& value = T(),
const Allocator & = Allocator ());
template < class InputIterator >
vector(InputIterator first, InputIterator last,
const Allocator & = Allocator ());
vector(const vector <T,Allocator >& x);


Complexity: The constructor template <class InputIterator> vector(InputIterator first, Input-
Iterator last) makes only N calls to the copyconstructor of T (where N is the distance between first and 
last)and no reallocations if iterators first and last are of forward, bidirectional, or random access categories. It 
makes order N calls to the copyconstructor of T and order log(N) reallocationsif they are justinput iterators. 

template < class InputIterator >
void assign(InputIterator first , InputIterator last);


Draft 


23.2 Sequences Containers library 570 
2 Effects: 

erase ( begin () , end ());
insert ( begin () , first , last );


void assign(size_type n, const T& t); 

3 Effects: 

erase ( begin () , end ());
insert(begin(), n, t);


23.2.4.2 vector capacity [lib.vector.capacity] 
size_type capacity() const; 

1 Returns: The total number of elements that the vector can hold without requiring reallocation. 

void reserve(size_type n); 

2 Effects: Adirective that informsavector ofaplannedchangeinsize,sothatitcanmanagethestorage allocation 
accordingly. After reserve(), capacity() is greater or equal to the argument of reserve if reallocation 
happens;and equaltothepreviousvalueof capacity() otherwise. Reallocation happens at this point if and only 
if the current capacityisless than the argumentof reserve(). 

3 Complexity: It does not change the size ofthe sequence and takes at most linear time in the size of the sequence. 

4 Throws: length_error if n > max_size().260) 

5 Remarks: Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence.Itis guaranteed thatno reallocationtakes place during insertions that happen aftera callto reserve() 
until the time when an insertion would make the size of the vector greater than the value of capacity(). 

void swap(vector <T,Allocator >& x); 

6 Effects: Exchanges the contents and capacity() of *this with that of x. 
7 Complexity: Constant time. 

void resize ( size_type sz , T c = T ()); 

8 Effects: 

if (sz > size())
insert(end(), sz-size(), c);
else if ( sz < size ())
erase(begin()+sz, end());
else
; // do nothing


260) reserve() uses Allocator::allocate() which may throw an appropriate exception. 

Draft 


571 Containers library 23.2 Sequences 

23.2.4.3 vector data [lib.vector.data] 
pointer data();
const_pointer data() const;


1 Returns: Apointer such that [data(),data() + size()) isavalid range.Fora non-emptyvector, data() == 
&front(). 

2 Complexity: Constant time. 

3 Throws: Nothing. 

23.2.4.4 vector modifiers [lib.vector.modifiers] 
iterator insert(iterator position , const T& x);
void insert(iterator position , size_type n, const T& x);
template < class InputIterator >


void insert(iterator position , InputIterator first , InputIterator last); 

1 Remarks: Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the 
iterators and references before the insertion point remain valid. If an exception is thrown other than by the copy 
constructor or assignment operator of T or by any InputIterator operation there are no effects. 

2 Complexity: If first and last are forward iterators, bidirectional iterators, or random access iterators, the complexity is linear in the number of elements in the range [first,last) plus the distance to the end of the vector. 
If they are input iterators, the complexity is proportional to the number of elements in the range [first,last) 
times the distance to the end of the vector. 

iterator erase ( iterator position );
iterator erase ( iterator first , iterator last );


3 Effects: Invalidates iterators and references at or after the point of the erase. 

4 Complexity: The destructor of T is called the number of times equal to the number of the elements erased,but 
the assignmentoperator of T is called the number of times equal to the number of elements in the vector after the 
erased elements. 

5 Throws: Nothing unless anexceptionis thrownby the copyconstructor or assignment operatorof T. 

23.2.4.5 vector specialized algorithms [lib.vector.special] 
template < class T , class Allocator >
void swap(vector <T,Allocator >& x, vector <T,Allocator >& y);


1 Effects: 

x. swap (y); 
Draft 


23.2 Sequences Containers library 572 
23.2.5 Class vector<bool> [lib.vector.bool] 
To optimize space allocation, a specialization of vector forbool elements is provided: 

namespace std {
template <class Allocator > class vector <bool , Allocator > {
public :


// types: 

typedef bool const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef bool value_type ; 
typedef Allocator allocator_type; 
t y p e d e f implementation-defined p o i n t e r ; 
typedef implementation-defined const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

// bit reference: 

class reference {
friend class vector ;
reference ();


public :
~ reference ();


operator bool () const ;
reference& operator= (const bool x);
reference& operator= (const reference& x);
void flip (); // flips the bit
}; 

// construct/copy/destroy: 

explicit vector ( const Allocator & = Allocator ());
explicit vector(size_type n, const bool& value = bool(),
const Allocator & = Allocator ());
template < class InputIterator >
vector(InputIterator first , InputIterator last ,
const Allocator & = Allocator ());
vector(const vector<bool,Allocator>& x);


~ vector (); 
vector<bool,Allocator>& operator= (const vector<bool,Allocator>& x); 
template < class InputIterator > 

void assign(InputIterator first , InputIterator last);
void assign(size_type n, const Tbool & t);
allocator_type get_allocator() const;


// iterators: 

iterator begin ();
const_iterator begin () const ;


Draft 


573 Containers library 23.2 Sequences 

i t e r a t o r e n d ( ) ; 
c o n s t _ i t e r a t o r e n d ( ) c o n s t ; 
r e v e r s e _ i t e r a t o r r b e g i n ( ) ; 
c o n s t _ r e v e r s e _ i t e r a t o r r b e g i n ( ) c o n s t ; 
r e v e r s e _ i t e r a t o r r e n d ( ) ; 
c o n s t _ r e v e r s e _ i t e r a t o r r e n d ( ) c o n s t ; 
// capacity: 
s i z e _ t y p e s i z e ( ) c o n s t ; 
s i z e _ t y p e m a x _ s i z e ( ) c o n s t ; 
v o i d r e s i z e ( s i z e _ t y p e sz , b o o l c = f a l s e ) ; 
s i z e _ t y p e c a p a c i t y ( ) c o n s t ; 
b o o l e m p t y ( ) c o n s t ; 
v o i d r e s e r v e ( s i z e _ t y p e n ) ; 
// element access: 
r e f e r e n c e o p e r a t o r [ ] ( s i z e _ t y p e n ) ; 
c o n s t _ r e f e r e n c e o p e r a t o r [ ] ( s i z e _ t y p e n ) c o n s t ; 
c o n s t _ r e f e r e n c e a t ( s i z e _ t y p e n ) c o n s t ; 
r e f e r e n c e a t ( s i z e _ t y p e n ) ; 
r e f e r e n c e f r o n t ( ) ; 
c o n s t _ r e f e r e n c e f r o n t ( ) c o n s t ; 
r e f e r e n c e b a c k ( ) ; 
c o n s t _ r e f e r e n c e b a c k ( ) c o n s t ; 
// modifiers: 
v o i d p u s h _ b a c k ( c o n s t b o o l & x ) ; 
v o i d p o p _ b a c k ( ) ; 
i t e r a t o r i n s e r t ( i t e r a t o r p o s i t i o n , c o n s t b o o l & x ) ; 
v o i d i n s e r t ( i t e r a t o r p o s i t i o n , s i z e _ t y p e n , c o n s t b o o l & x ) ; 
t e m p l a t e < c l a s s I n p u t I t e r a t o r > 
v o i d i n s e r t ( i t e r a t o r p o s i t i o n , 
I n p u t I t e r a t o r f i r s t , I n p u t I t e r a t o r l a s t ) ; 
i t e r a t o r e r a s e ( i t e r a t o r p o s i t i o n ) ; 
i t e r a t o r e r a s e ( i t e r a t o r f i r s t , i t e r a t o r l a s t ) ; 
v o i d s w a p ( v e c t o r < b o o l , A l l o c a t o r > & ) ; 
s t a t i c v o i d s w a p ( r e f e r e n c e x , r e f e r e n c e y ) ; 
v o i d f l i p ( ) ; // flips all bits 
v o i d c l e a r ( ) ; 
} ; 
// specialized algorithms: 
t e m p l a t e < c l a s s A l l o c a t o r > 
v o i d s w a p ( v e c t o r < b o o l , A l l o c a t o r > & x , v e c t o r < b o o l , A l l o c a t o r > & y ) ; 
} 

Draft 


23.3 Associative containers Containers library 574 
2 reference is a class that simulates the behavior of references of a single bit in vector<bool>. 

23.3 Associative containers [lib.associative] 
1 Headers <map> and <set>: 
Header <map> synopsis 

namespace std {
template <class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T> > >
class map ;
template < class Key , class T , class Compare , class Allocator >
bool operator==(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator< (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator!=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator> (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator>=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator<=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
void swap(map<Key,T,Compare,Allocator>& x,
map<Key,T,Compare,Allocator>& y);


template <class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T> > >
class multimap ;
template < class Key , class T , class Compare , class Allocator >
bool operator==(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator< (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator> (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator>=(const multimap<Key,T,Compare,Allocator>& x,


Draft 


575 Containers library 23.3 Associative containers 

const multimap<Key,T,Compare,Allocator>& y); 
template < class Key , class T , class Compare , class Allocator > 
bool operator<=(const multimap<Key,T,Compare,Allocator>& x, 
const multimap<Key,T,Compare,Allocator>& y); 
template < class Key , class T , class Compare , class Allocator > 
void swap(multimap<Key,T,Compare,Allocator>& x, 
multimap<Key,T,Compare,Allocator>& y); 
} 

Header <set> synopsis 

namespace std {
template <class Key, class Compare = less<Key>,
class Allocator = allocator <Key > >
class set ;
template < class Key , class Compare , class Allocator >
bool operator==(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator< (const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator!=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator> (const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator>=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator<=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
void swap(set<Key,Compare,Allocator>& x,
set<Key,Compare,Allocator>& y);


template <class Key, class Compare = less<Key>, 
class Allocator = allocator <Key > > 
class multiset ; 
template < class Key , class Compare , class Allocator > 
bool operator==(const multiset<Key,Compare,Allocator>& x, 
const multiset<Key,Compare,Allocator>& y); 
template < class Key , class Compare , class Allocator > 
bool operator< (const multiset<Key,Compare,Allocator>& x, 
const multiset<Key,Compare,Allocator>& y); 
template < class Key , class Compare , class Allocator > 
bool operator!=(const multiset<Key,Compare,Allocator>& x, 
const multiset<Key,Compare,Allocator>& y); 
template < class Key , class Compare , class Allocator > 

Draft 


23.3 Associative containers Containers library 576 
bool operator> (const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator>=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
bool operator<=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);
template < class Key , class Compare , class Allocator >
void swap(multiset<Key,Compare,Allocator>& x,
multiset<Key,Compare,Allocator>& y);
}


23.3.1 Class template map [lib.map] 
1Amap isa kindof associative container that supports uniquekeys(containsat most oneof eachkeyvalue)andprovides 
forfast retrievalofvaluesof another type T based on thekeys. The map class supports bidirectional iterators. 

2Amap satisfies all of the requirements of a container and of a reversible container(23.1)and of an associative container 
(23.1.2).A map alsoprovidesmost operations describedin(23.1.2)foruniquekeys.This meansthatamap supports the 
a_uniq operations in(23.1.2)but not thea_eq operations. For a map<Key,T> the key_type is Key and the value_
type is pair<const Key,T>. Descriptions are provided here only for operations on map that are not described in one 
of those tables or for operations where there is additional semantic information. 

namespace std {
template <class Key, class T, class Compare = less<Key>,


class Allocator = allocator<pair<const Key, T> > >
class map {
public :


// types: 

typedef Key key_type ; 
typedef T mapped_type; 
typedef pair < const Key , T > value_type ; 
typedef Compare key_compare; 
typedef Allocator allocator_type; 
typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator ; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

class value_compare 

: public binary _function <value _type ,value_ type ,bool > {
friend class map ;
protected :


Draft 


577 Containers library 23.3 Associative containers 

Compare comp ;
value_compare(Compare c) : comp(c) {}
public :
bool operator()(const value_type& x, const value_type& y) const {
return comp(x.first , y.first);
}
};


// 23.3.1.1 construct/copy/destroy: 

explicit map(const Compare& comp = Compare(), 
const Allocator & = Allocator ()); 
template < class InputIterator > 
map(InputIterator first , InputIterator last , 
const Compare & comp = Compare () , const Allocator & = Allocator ()); 
map(const map<Key,T,Compare,Allocator>& x); 
~map (); 
map<Key,T,Compare,Allocator >& 

operator= (const map<Key,T,Compare,Allocator>& x);
allocator_type get_allocator() const;
// iterators: 

iterator begin ();
const_iterator begin () const ;
iterator end ();
const_iterator end () const ;
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
reverse_iterator rend();
const_reverse_iterator rend() const;


// capacity: 

bool empty () const ;
size_type size() const;
size_type max_size() const;


// 23.3.1.2 element access: 

T& operator[](const key_type& x); 

T& at(const key_type& x);
const T& at(const key_type& x) const;


// modifiers: 

pair <iterator , bool > insert(const value_type& x);
iterator insert(iterator position , const value_type& x);
template < class InputIterator >


void insert(InputIterator first , InputIterator last); 

iterator erase ( iterator position );
size_type erase(const key_type& x);
iterator erase ( iterator first , iterator last );
void swap(map<Key,T,Compare,Allocator>&);


Draft 


23.3 Associative containers Containers library 578 
void clear (); 

// observers: 

key_compare key_comp() const;
value_compare value_comp() const;


// 23.3.1.3 map operations: 

iterator find(const key_type& x);
const_iterator find(const key_type& x) const;
size_type count(const key_type& x) const;


iterator lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;
iterator upper_bound(const key_type& x);
const_iterator upper_bound(const key_type& x) const;


pair < iterator , iterator >
equal_range(const key_type& x);
pair < const_iterator , const_iterator >
equal_range(const key_type& x) const;
};


template < class Key , class T , class Compare , class Allocator >
bool operator==(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator< (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator!=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator> (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator>=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator<=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);


// specialized algorithms: 

template < class Key , class T , class Compare , class Allocator >
void swap(map<Key,T,Compare,Allocator>& x,
map<Key,T,Compare,Allocator>& y);
}


23.3.1.1 map constructors, copy,and assignment [lib.map.cons] 
explicit map(const Compare& comp = Compare(), 

Draft 


579 Containers library 23.3 Associative containers 

const Allocator & = Allocator ()); 

1 Effects: Constructs an empty map using the specified comparison object and allocator. 
2 Complexity: Constant. 

template < class InputIterator >
map ( InputIterator first , InputIterator last ,
const Compare & comp = Compare () , const Allocator & = Allocator ());


3 Effects: Constructs an empty map using the specified comparison object and allocator, and inserts elements from 
the range [first ,last ). 

4 Complexity: Linear in Nif the range [first ,last ) is already sorted using comp and otherwise NlogN, where 
Nis last -first . 

23.3.1.2 map element access [lib.map.access] 
T& operator[](const key_type& x); 

1 Effects: If thereisnokeyequivalentto x in the map, inserts value_type(x, T()) into the map.
2 Returns: Areference to themapped_type corresponding to x in *this.
3 Complexity: logarithmic.


T& at(const key_type& x);
const T& at(const key_type& x) const;


4 Returns: Areferencetotheelement whosekeyisequivalentto x. 
5 Throws: An exception object of type out_of_range if no such element is present. 

23.3.1.3 map operations [lib.map.ops] 
iterator find(const key_type& x);
const_iterator find(const key_type& x) const;


iterator lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;


iterator upper_bound(const key_type& x);
const_iterator upper_bound(const key_type &x) const;


pair < iterator , iterator >
equal_range(const key_type &x);
pair < const_iterator , const_iterator >
equal_range(const key_type& x) const;


1 The find, lower_bound, upper_bound and equal_range member functions eachhavetwoversions, one const 
and the other non-const. In each case the behavior of the two functions is identical except that the const version 
returns a const_iterator and the non-const version an iterator (23.1.2). 

Draft 


23.3 Associative containers Containers library 580 
23.3.1.4 map specialized algorithms [lib.map.special] 
template < class Key , class T , class Compare , class Allocator >
void swap(map<Key,T,Compare,Allocator>& x,
map<Key,T,Compare,Allocator>& y);


1 Effects: 

x. swap (y); 
23.3.2 Class template multimap [lib.multimap] 
1A multimap isa kindof associative container that supports equivalentkeys (possibly containing multiple copiesof 
the samekey value)andprovidesforfast retrievalofvaluesof anothertype T based on thekeys. The multimap class 
supports bidirectional iterators. 

2Amultimap satisfies allof the requirementsofa container andofa reversible container(23.1)andof an associative 
container(23.1.2). A multimap also provides most operations described in(23.1.2)for equalkeys. This means that 
a multimap supports the a_eq operationsin(23.1.2)butnot the a_uniq operations. For a multimap<Key,T> the 
key_type is Key and the value_type is pair<const Key,T>. Descriptions are provided here only for operations on 
multimap that are not described in one of those tables or for operations where there is additional semantic information. 

namespace std {
template <class Key, class T, class Compare = less<Key>,


class Allocator = allocator<pair<const Key, T> > >
class multimap {
public :


// types: 

typedef Key key_type ; 
typedef T mapped_type; 
typedef pair < const Key ,T > value_type ; 
typedef Compare key_compare; 
typedef Allocator allocator_type; 
typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator ; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

class value_compare 

: public binary _function <value _type ,value_ type ,bool > {
friend class multimap ;
protected :


Compare comp ;
value_compare(Compare c) : comp(c) {}


Draft 


581 Containers library 23.3 Associative containers 

public : 
bool operator()(const value_type& x, const value_type& y) const { 
return comp(x.first , y.first); 
} 
}; 

// construct/copy/destroy: 

explicit multimap(const Compare& comp = Compare(),
const Allocator & = Allocator ());
template < class InputIterator >


multimap(InputIterator first , InputIterator last ,
const Compare & comp = Compare () ,
const Allocator & = Allocator ());


multimap(const multimap<Key,T,Compare,Allocator>& x); 
~ multimap (); 
multimap<Key,T,Compare,Allocator >& 

operator= (const multimap<Key,T,Compare,Allocator>& x);
allocator_type get_allocator() const;
// iterators: 

iterator begin ();
const_iterator begin () const ;
iterator end ();
const_iterator end () const ;
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
reverse_iterator rend();
const_reverse_iterator rend() const;


// capacity: 

bool empty () const ;
size_type size() const;
size_type max_size() const;


// modifiers: 

iterator insert(const value_type& x);
iterator insert(iterator position , const value_type& x);
template < class InputIterator >


void insert(InputIterator first , InputIterator last); 

iterator erase ( iterator position );
size_type erase(const key_type& x);
iterator erase ( iterator first , iterator last );
void swap(multimap<Key,T,Compare,Allocator>&);
void clear ();


// observers: 

key_compare key_comp() const;
value_compare value_comp() const;


Draft 


23.3 Associative containers Containers library 582 
// map operations: 

iterator find(const key_type& x); 

const_iterator find(const key_type& x) const; 

size_type count(const key_type& x) const; 

iterator lower_bound(const key_type& x); 

const_iterator lower_bound(const key_type& x) const; 

iterator upper_bound(const key_type& x); 

const_iterator upper_bound(const key_type& x) const; 

pair < iterator , iterator >
equal_range(const key_type& x);
pair < const_iterator , const_iterator >
equal_range(const key_type& x) const;
};


template < class Key , class T , class Compare , class Allocator >
bool operator==(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator< (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator> (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template < class Key , class T , class Compare , class Allocator >
bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);


// specialized algorithms: 

template < class Key , class T , class Compare , class Allocator >
void swap(multimap<Key,T,Compare,Allocator>& x,
multimap<Key,T,Compare,Allocator>& y);
}


23.3.2.1 multimap constructors [lib.multimap.cons] 
explicit multimap ( const Compare & comp = Compare () ,
const Allocator & = Allocator ());


1 Effects: Constructs an empty multimap using the specified comparison object and allocator. 
2 Complexity: Constant. 

template < class InputIterator > 

Draft 


583 Containers library 23.3 Associative containers 

multimap ( InputIterator first , InputIterator last ,
const Compare& comp = Compare(),
const Allocator & = Allocator ());


3 Effects: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements 
from the range [first ,last ). 

4 Complexity: Linear in Nif the range [first ,last ) is already sorted using comp and otherwise NlogN, where 
Nis last -first . 

23.3.2.2 multimap operations [lib.multimap.ops] 
iterator find(const key_type &x);
const_iterator find(const key_type& x) const;


iterator lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;


pair < iterator , iterator >
equal_range(const key_type& x);
pair < const_iterator , const_iterator >
equal_range(const key_type& x) const;


1 The find,lower_bound,upper_bound,andequal_range member functions eachhavetwoversions, one const 
and one non-const. In each case the behavior of the two versions is identical except that the const version returns 
a const_iterator and the non-const version an iterator (23.1.2). 

23.3.2.3 multimap specialized algorithms [lib.multimap.special] 
template < class Key , class T , class Compare , class Allocator >
void swap(multimap<Key,T,Compare,Allocator>& x,
multimap<Key,T,Compare,Allocator>& y);


1 Effects: 

x. swap (y); 
23.3.3 Class template set [lib.set] 
1Aset isa kindof associative container that supports uniquekeys(containsat most oneof eachkeyvalue)andprovides 
forfast retrievalof thekeysthemselves. Class set supports bidirectional iterators. 

2Aset satisfiesalloftherequirementsofa containerandofareversible container(23.1),andofan associative container 
(23.1.2). A set alsoprovidesmost operations describedin(23.1.2)foruniquekeys. This meansthataset supports 
the a_uniq operations in(23.1.2)but not thea_eq operations. For a set<Key> both the key_type and value_type 
are Key. Descriptions are provided here only for operations on set that are not described in one of these tables and for 
operations where there is additional semantic information. 

Draft 


23.3 Associative containers Containers library 584 
namespace std { 
template <class Key, class Compare = less<Key>, 
class Allocator = allocator <Key > > 

class set { 

public : 

// types: 

typedef Key key_type ; 
typedef Key value_type ; 
typedef Compare key_compare; 
typedef Compare value_compare; 
typedef Allocator allocator_type; 
typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator ; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

// 23.3.3.1 construct/copy/destroy: 

explicit set(const Compare& comp = Compare(), 
const Allocator & = Allocator ()); 
template < class InputIterator > 
set(InputIterator first , InputIterator last , 
const Compare & comp = Compare () , const Allocator & = Allocator ()); 
set(const set<Key,Compare,Allocator>& x); 
~set (); 
set<Key,Compare,Allocator>& operator= 
(const set<Key,Compare,Allocator>& x); 
allocator_type get_allocator() const; 

// iterators: 

iterator begin (); 
const_iterator begin () const ; 
iterator end (); 
const_iterator end () const ; 
reverse_iterator rbegin(); 
const_reverse_iterator rbegin() const; 
reverse_iterator rend(); 
const_reverse_iterator rend() const; 

// capacity: 
b o o l e m p t y ( ) c o n s t ; 
s i z e _ t y p e s i z e ( ) c o n s t ; 
s i z e _ t y p e m a x _ s i z e ( ) c o n s t ; 

// modifiers: 

Draft 


585 Containers library 23.3 Associative containers 

p a i r < i t e r a t o r , b o o l > i n s e r t ( c o n s t v a l u e _ t y p e & x ) ; 
i t e r a t o r i n s e r t ( i t e r a t o r p o s i t i o n , c o n s t v a l u e _ t y p e & 
t e m p l a t e < c l a s s I n p u t I t e r a t o r > 
v o i d i n s e r t ( I n p u t I t e r a t o r f i r s t , I n p u t I t e r a t o r l a s t ) ; 
x ) ; 
i t e r a t o r e r a s e ( i t e r a t o r p o s i t i o n ) ; 
s i z e _ t y p e e r a s e ( c o n s t k e y _ t y p e & x ) ; 
i t e r a t o r e r a s e ( i t e r a t o r f i r s t , i t e r a t o r 
v o i d s w a p ( set < Key , C o m p a r e , A l l o c a t o r > & ) ; 
v o i d c l e a r ( ) ; 
l a s t ) ; 
// observers: 
k e y _ c o m p a r e 
v a l u e _ c o m p a r e 
k e y _ c o m p ( ) c o n s t ; 
v a l u e _ c o m p ( ) c o n s t ; 
// set operations: 
i t e r a t o r 
c o n s t _ i t e r a t o r 
f i n d ( c o n s t 
f i n d ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
s i z e _ t y p e c o u n t ( c o n s t k e y _ t y p e & x ) c o n s t ; 
i t e r a t o r 
c o n s t _ i t e r a t o r 
l o w e r _ b o u n d ( c o n s t 
l o w e r _ b o u n d ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
i t e r a t o r 
c o n s t _ i t e r a t o r 
u p p e r _ b o u n d ( c o n s t 
u p p e r _ b o u n d ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
p a i r < i t e r a t o r , i t e r a t o r > 
p a i r < c o n s t _ i t e r a t o r , c o n s t _ i t e r a t o r > 
} ; 
e q u a l _ r a n g e ( c o n s t 
e q u a l _ r a n g e ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > ( c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > = ( c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & y ) ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < = ( c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
c o n s t s e t < K e y , C o m p a r e , A l l o c a t o r > & y ) ; 
Draft 


23.3 Associative containers Containers library 586 
// specialized algorithms: 

template < class Key , class Compare , class Allocator >
void swap(set<Key,Compare,Allocator>& x,
set<Key,Compare,Allocator>& y);
}


23.3.3.1 set constructors, copy,and assignment [lib.set.cons] 
explicit set(const Compare& comp = Compare(),
const Allocator & = Allocator ());


1 Effects: Constructs an empty set using the specified comparison objects and allocator. 
2 Complexity: Constant. 

template < class InputIterator >
set ( InputIterator first , InputIterator last ,
const Compare & comp = Compare () , const Allocator & = Allocator ());


3 Effects: Constructs an empty set using the specified comparison object and allocator, and inserts elements from 
the range [first ,last ). 

4 Complexity: Linear in Nif the range [first ,last ) is already sorted using comp and otherwise NlogN, where 
Nis last -first . 

23.3.3.2 set specialized algorithms [lib.set.special] 
template < class Key , class Compare , class Allocator >
void swap(set<Key,Compare,Allocator>& x,
set<Key,Compare,Allocator>& y);


1 Effects: 

x. swap (y); 
23.3.4 Class template multiset [lib.multiset] 
1Amultiset isa kindof associative container that supports equivalentkeys (possibly contains multiple copiesof the 
samekey value) and providesforfast retrievalof thekeys themselves. Class multiset supports bidirectional iterators. 

2Amultiset satisfiesallof the requirementsofa container andofa reversible container(23.1), andof an associative 
container(23.1.2). multiset also provides most operations described in(23.1.2)for duplicatekeys. This means that 
a multiset supports the a_eq operations in(23.1.2)but not thea_uniq operations. For amultiset<Key> both the 
key_type and value_type are Key. Descriptions are provided here only for operations on multiset that are not 
described in one of these tables and for operations where there is additional semantic information. 

namespace std {
template <class Key, class Compare = less<Key>,
class Allocator = allocator <Key > >
class multiset {


Draft 


587 Containers library 23.3 Associative containers 

public : 

// types: 

typedef Key key_type ; 
typedef Key value_type ; 
typedef Compare key_compare; 
typedef Compare value_compare; 
typedef Allocator allocator_type; 
typedef typename Allocator :: reference reference ; 
typedef typename Allocator::const_reference const_reference; 
typedef implementation-defined iterator ; // See 23.1 
typedef implementation-defined const_iterator ; // See 23.1 
typedef implementation-defined size_type ; // See 23.1 
typedef implementation-defined difference_type; // See 23.1 
typedef typename Allocator :: pointer pointer ; 
typedef typename Allocator::const_pointer const_pointer; 
typedef std::reverse_iterator <iterator > reverse_iterator; 
typedef std::reverse_iterator <const _iterator > const_reverse_iterator; 

// construct/copy/destroy: 

explicit multiset(const Compare& comp = Compare(), 

const Allocator & = Allocator ()); 

template < class InputIterator > 

multiset(InputIterator first , InputIterator last , 

const Compare & comp = Compare () , 

const Allocator & = Allocator ()); 

multiset(const multiset<Key,Compare,Allocator>& x); 

~ multiset (); 

multiset<Key,Compare,Allocator >& 

operator= (const multiset<Key,Compare,Allocator>& x);
allocator_type get_allocator() const;
// iterators: 

iterator begin (); 

const_iterator begin () const ; 

iterator end (); 

const_iterator end () const ; 

reverse_iterator rbegin(); 

const_reverse_iterator rbegin() const; 

reverse_iterator rend(); 

const_reverse_iterator rend() const; 

// capacity: 

bool empty () const ; 

size_type size() const; 

size_type max_size() const; 

// modifiers: 

iterator insert(const value_type& x);
iterator insert(iterator position , const value_type& x);
template < class InputIterator >


Draft 


23.3 Associative containers Containers library 588 
v o i d i n s e r t ( I n p u t I t e r a t o r f i r s t , I n p u t I t e r a t o r l a s t ) ; 
i t e r a t o r e r a s e ( i t e r a t o r p o s i t i o n ) ; 
s i z e _ t y p e e r a s e ( c o n s t k e y _ t y p e & x ) ; 
i t e r a t o r e r a s e ( i t e r a t o r f i r s t , i t e r a t o r l a s t ) ; 
v o i d s w a p ( m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & ) ; 
v o i d c l e a r ( ) ; 
// observers: 
k e y _ c o m p a r e 
v a l u e _ c o m p a r e 
k e y _ c o m p ( ) c o n s t ; 
v a l u e _ c o m p ( ) c o n s t ; 
// set operations: 
i t e r a t o r 
c o n s t _ i t e r a t o r 
f i n d ( c o n s t 
f i n d ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
s i z e _ t y p e c o u n t ( c o n s t k e y _ t y p e & x ) c o n s t ; 
i t e r a t o r 
c o n s t _ i t e r a t o r 
l o w e r _ b o u n d ( c o n s t 
l o w e r _ b o u n d ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
i t e r a t o r 
c o n s t _ i t e r a t o r 
u p p e r _ b o u n d ( c o n s t 
u p p e r _ b o u n d ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
p a i r < i t e r a t o r , i t e r a t o r > 
p a i r < c o n s t _ i t e r a t o r , c o n s t _ i t e r a t o r > 
} ; 
e q u a l _ r a n g e ( c o n s t 
e q u a l _ r a n g e ( c o n s t 
k e y _ t y p e & 
k e y _ t y p e & 
x ) ; 
x ) c o n s t ; 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r = = ( c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < ( c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r ! = ( c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > ( c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r > = ( c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
b o o l o p e r a t o r < = ( c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
c o n s t m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
x , 
y ) ; 
// specialized algorithms: 
t e m p l a t e < c l a s s K ey , c l a s s C o m p a r e , c l a s s A l l o c a t o r > 
v o i d s w a p ( m u l t i s e t < K e y , C o m p a r e , A l l o c a t o r > & x , 
Draft 


589 Containers library 23.3 Associative containers 

multiset<Key,Compare,Allocator>& y);
}


23.3.4.1 multiset constructors [lib.multiset.cons] 
explicit multiset ( const Compare & comp = Compare(),
const Allocator & = Allocator ());


1 Effects: Constructs an empty set using the specified comparison object and allocator. 
2 Complexity: Constant. 

template < class InputIterator >
multiset ( InputIterator first , last ,
const Compare & comp = Compare () , const Allocator & = Allocator ());


3 Effects: Constructs an empty multiset using the specified comparison object and allocator, and inserts elements 
from the range [first ,last ). 

4 Complexity: Linear in Nif the range [first ,last ) is already sorted using comp and otherwise NlogN, where 
Nis last -first . 

23.3.4.2 multiset specialized algorithms [lib.multiset.special] 
template < class Key , class Compare , class Allocator >
void swap(multiset<Key,Compare,Allocator>& x,
multiset<Key,Compare,Allocator>& y);


1 Effects: 

x. swap (y); 
23.3.5 Class template bitset [lib.template.bitset] 
Header <bitset> synopsis 

# include < cstddef > // for size_t 

# include < string > 

# include < stdexcept > // for invalid_argument, 

// out_of_range, overflow_error 

# include < iosfwd > // for istream, ostream 

namespace std { 

template < size_t N > class bitset ; 

// 23.3.5.3 bitset operations: 

template <size_t N>
bitset <N > operator &( const bitset <N >& , const bitset <N >&);
template <size_t N>
bitset <N > operator |( const bitset <N >& , const bitset <N >&);
template <size_t N>


Draft 


23.3 Associative containers Containers library 590 
bitset <N > operator ^( const bitset <N >& , const bitset <N >&);
template <class charT , class traits , size_t N>
basic_istream < charT , traits >&


operator >>(basic_istream <charT , traits >& is , bitset <N >& x ); 
template <class charT , class traits , size_t N>
basic_ostream < charT , traits >&


operator <<(basic_ostream <charT , traits >& os , const bitset <N >& x );
}
The header <bitset> definesa class template and several related functions for representing and manipulating fixed-size 
sequences of bits. 

namespace std {
template < size_t N > class bitset {
public :


// bit reference: 

class reference {
friend class bitset ;
reference ();


public : 

~ reference ();
reference & operator = ( bool x ); // for b[i] = x;
reference & operator = ( const reference &); // for b[i] = b[j];
bool operator ~() const ; // flips the bit


operator bool () const ; // for x = b[i]; 
reference & flip (); // for b[i].flip();
};


// 23.3.5.1 constructors: 

bitset ();
bitset ( unsigned long val );
template < class charT , class traits , class Allocator >


explicit bitset ( 
const basic_string < charT , traits , Allocator >& str , 
typename basic_string<charT,traits,Allocator>::size_type pos = 0, 
typename basic_string<charT,traits,Allocator>::size_type n = 

basic_string < charT , traits , Allocator >:: npos ); 

// 23.3.5.2 bitset operations: 

bitset <N >& operator &=( const bitset <N >& rhs );
bitset <N >& operator |=( const bitset <N >& rhs );
bitset <N >& operator ^=( const bitset <N >& rhs );
bitset <N >& operator < < =( size_ t pos );
bitset <N >& operator > > =( size_ t pos );
bitset <N >& set ();
bitset <N >& set ( size _t pos , bool val = true );
bitset <N >& reset ();
bitset <N >& reset ( size _t pos );
bitset <N > operator ~() const ;
bitset <N >& flip ();


Draft 


591 Containers library 23.3 Associative containers 

bitset <N >& flip ( size _t pos ); 

// element access:
bool operator []( size _t pos ) const ; // for b[i];
reference operator []( size _t pos ); // for b[i];


unsigned long to_ulong () const ; 
template < class charT , class traits , class Allocator > 
basic_string < charT , traits , Allocator > to_string () const ; 
template < class charT , class traits > 
basic_string<charT, traits, allocator<charT> > to_string() const; 
template < class charT > 

basic_string<charT, char_traits<charT>, allocator<charT> > to_string() const; 
basic_string<char, char_traits<char>, allocator<char> > to_string() const; 
size_t count () const ; 
size_t size () const ; 
bool operator ==( const bitset <N >& rhs ) const ; 
bool operator !=( const bitset <N >& rhs ) const ; 
bool test ( size_t pos ) const ; 
bool any () const ; 
bool none () const ; 
bitset <N> operator <<(size _t pos ) const ; 
bitset <N> operator >>(size _t pos ) const ; 

};
}


2 The template class bitset<N> describes an object that can store a sequence consisting of a fixed number of bits, N . 

3 Each bit represents either thevalue zero (reset)orone (set).To toggle abitistochangethevaluezeroto one,orthevalue 
one to zero. Each bit has a non-negative position pos . When converting between an object of class bitset<N> and a 
value of some integral type, bit position pos corresponds to the bit value 1 << pos . The integral value corresponding 
to two or more bits is the sum of their bit values. 

4 The functions described in this subclause can report three kinds of errors, each associated with a distinct exception: 

— an invalid-argument error is associated with exceptions of type invalid_argument (19.1.3); 
— an out-of-range error is associated with exceptions of type out_of_range (19.1.5); 
— an overflow error is associated with exceptions of type overflow_error (19.1.8). 
23.3.5.1 bitset constructors [lib.bitset.cons] 
bitset (); 

1 Effects: Constructs an object of class bitset<N>, initializing all bits to zero. 

bitset ( unsigned long val ); 

2 Effects: Constructs an object of class bitset<N>, initializing the first M bit positions to the corresponding bit 
values in val . M is the smaller of N and the numberof bitsin thevalue representation(section 3.9)ofunsigned 

Draft 


23.3 Associative containers Containers library 592 
long. If M <N , the remaining bit positions are initialized to zero. 

template < class charT , class traits , class Allocator >
explicit
bitset(const basic_string <charT , traits , Allocator >& str ,


typename basic_string<charT, traits, Allocator>::size_type pos = 0, 
typename basic_string <charT , traits , Allocator >:: size_type n = 
basic_ string <charT , traits , Allocator >::npos); 

3 Requires: pos <= str .size().
4 Throws: out_of_range if pos > str .size().
5 Effects: Determines the effective length rlen of the initializing string as the smaller of n and str .size() 

pos . 

The function then throws invalid_argument if anyof the rlen characters in str beginning at position pos is 
other than 0 or 1. 
Otherwise, the function constructs an object of class bitset<N>, initializing the first M bit positions to values 

determined from the corresponding characters in the string str . M is the smaller of N and rlen . 
6 An element of the constructed string has value zero if the corresponding character in str , beginning at position 
pos , is 0. Otherwise, the element has thevalue one. Character position pos + M -1 corresponds to bit position 
zero. Subsequent decreasingcharacter positions correspond to increasing bit positions. 
7 If M<N , remaining bit positions are initialized to zero. 

23.3.5.2 bitset members [lib.bitset.members] 
bitset <N >& operator & =( const bitset <N >& rhs ); 

1 Effects: Clears each bit in *this for which the corresponding bit in rhs is clear, and leaves all other bits unchanged. 

2 Returns: *this. 

bitset <N >& operator | =( const bitset <N >& rhs ); 

3 Effects: Sets each bit in *this for which the corresponding bit in rhs is set, and leaves all other bits unchanged. 
4 Returns: *this. 

bitset <N >& operator ^ =( const bitset <N >& rhs ); 

5 Effects: Toggles each bit in *this for which the corresponding bit in rhs is set, and leaves all other bits unchanged. 

6 Returns: *this. 

bitset <N >& operator < < =( size_t pos ); 

7 Effects: Replaces each bit at position I in *this with a value determined as follows: 

Draft 


593 Containers library 23.3 Associative containers 

— If I < pos, the new value is zero; 
— If I >= pos, the new value is the previous value of the bit at position I -pos.
8 Returns: *this.
bitset <N >& operator > > =( size_t pos ); 

9 Effects: Replaces each bit at position I in *this with a value determined as follows: 

— If pos >= N -I, the new value is zero; 
— If pos <N-I, the new value is the previous value of the bit at position I + pos . 
10 Returns: *this. 
bitset <N >& set (); 

11 Effects: Sets all bits in *this. 
12 Returns: *this. 

bitset <N>& set(size_t pos , bool val = true ); 

13 Requires: pos is valid
14 Throws: out_of_range if pos does not correspond to a validbit position.
15 Effects: Stores a new value in the bit at position pos in *this. If val is nonzero, the stored value is one,


otherwise it is zero. 
16 Returns: *this. 

bitset <N >& reset (); 

17 Effects: Resets all bits in *this. 
18 Returns: *this. 

bitset <N >& reset ( size_t pos ); 

19 Requires: pos is valid
20 Throws: out_of_range if pos does not correspond to a validbit position.
21 Effects: Resets the bit at position pos in *this.
22 Returns: *this.


bitset <N > operator ~() const ; 

23 Effects: Constructs an object x of class bitset<N> and initializes it with *this. 
24 Returns: x .flip(). 

bitset <N >& flip (); 

Draft 


23.3 Associative containers Containers library 594 
25 Effects: Toggles all bits in*this. 
26 Returns: *this. 

bitset <N >& flip ( size_t pos ); 

27 Requires: pos is valid
28 Throws: out_of_range if pos does not correspond to a validbit position.
29 Effects: Toggles the bit at positionpos in *this.
30 Returns: *this.


unsigned long to_ulong () const ; 

31 Throws: overflow_error if the integral value x corresponding to the bits in *this cannot be represented as 
type unsigned long. 

32 Returns: x . 

template < class charT , class traits , class Allocator >
basic _string < charT , traits , Allocator > to_string () const ;


33 Effects: Constructs a string object of the appropriate type and initializes it to a string of length N characters. 
Each character is determined by the value of its corresponding bit position in *this. Character position N-1 
corresponds to bit position zero. Subsequent decreasing character positions correspond to increasing bit positions. 
Bit value zero becomes the character 0, bit value one becomes the character 1. 

34 Returns: The created object. 

template < class charT , class traits >
basic _string<charT, traits, allocator<charT> > to_string() const;


35 Returns: to_string<charT, traits, allocator<charT> >(). 

template < class charT > 
basic _string<charT, char_ traits<charT>, allocator<charT> > to_string() const; 

36 Returns: to_string<charT, char_traits<charT>, allocator<charT> >(). 

basic _string<char, char _traits<char>, allocator<char> > to_string() const; 

37 Returns: to_string<char, char_traits<char>, allocator<char> >(). 

size _t count () const ; 

38 Returns: Acount of the number of bits set in*this. 

size _t size () const ; 

39 Returns: N. 

bool operator == ( const bitset <N >& rhs ) const ; 

40 Returns: Anonzero value if the value of each bit in *this equals the value of the corresponding bit in rhs . 

Draft 


595 Containers library 23.3 Associative containers 

b o o l o p e r a t o r ! = ( c o n s t b i t s e t < N > & rhs ) c o n s t ; 
41 Returns: Anonzero value if !(*this == rhs ). 
b o o l t e s t ( s i z e _ t pos ) c o n s t ; 
42 Requires: pos is valid 
43 Throws: out_of_range if pos does not correspond to a validbit position. 
44 Returns: true if the bit at position pos in *this has the value one. 
b o o l a n y ( ) c o n s t ; 
45 Returns: true if anybit in *this is one. 
b o o l n o n e ( ) c o n s t ; 
46 Returns: true if no bit in *this is one. 
b i t s e t < N > o p e r a t o r < < ( s i z e _ t pos ) c o n s t ; 
47 Returns: bitset<N>(*this) <<= pos . 
b i t s e t < N > o p e r a t o r > > ( s i z e _ t pos ) c o n s t ; 
48 Returns: bitset<N>(*this) >>= pos . 
b o o l o p e r a t o r [ ] ( s i z e _ t pos ) c o n s t ; 
49 Requires: pos is valid. 
50 Throws: nothing. 
51 Returns: test(pos ). 
b i t s e t < N > : : r e f e r e n c e o p e r a t o r [ ] ( s i z e _ t pos ) ; 
52 Requires: pos is valid. 
53 Throws: nothing. 
54 Returns: An object of type bitset<N>::reference such that (*this)[pos ] == this->test(pos ), and 
such that (*this)[pos ] = val is equivalent to this->set(pos , val ). 
23.3.5.3 bitset operators [lib.bitset.operators] 
b i t s e t < N > o p e r a t o r & ( c o n s t b i t s e t < N > & lhs , c o n s t b i t s e t < N > & rhs ) ; 
1 Returns: bitset<N>(lhs ) &= rhs . 
b i t s e t < N > o p e r a t o r | ( c o n s t b i t s e t < N > & lhs , c o n s t b i t s e t < N > & rhs ) ; 
2 Returns: bitset<N>(lhs ) |= rhs . 
b i t s e t < N > o p e r a t o r ^ ( c o n s t b i t s e t < N > & lhs , c o n s t b i t s e t < N > & rhs ) ; 
Draft 


23.3 Associative containers Containers library 596 
3 Returns: bitset<N>(lhs ) ^= rhs . 

template <class charT , class traits , size _t N>
basic_istream <charT , traits >&


operator >>(basic_istream <charT , traits >& is , bitset <N >& x ); 
4 Aformatted input function(27.6.1.2). 

5 Effects: Extracts up to N characters from is . Stores these characters in a temporary object str of type basic_
string<charT, traits>, then evaluates the expression x = bitset<N>(str ). Characters are extracted and 
stored until anyof the following occurs: 

— N characters have been extractedand stored; 
— end-of-file occurs on the input sequence; 
— the next input character is neither is.widen(’0’) nor is.widen(’1’) (in which case the input character 
is not extracted). 
6 If no characters are storedin str ,callsis .setstate(ios::failbit) (which may throw ios_base::failure 
(27.4.4.3)). 

7 Returns: is . 

template <class charT , class traits , size _t N>
basic_ostream <charT , traits >&


operator <<(basic_ostream <charT , traits >& os , const bitset <N >& x ); 
8 Returns: os <<x .template to_string<charT,traits,allocator<charT> >() (27.6.2.5). 

Draft 


Chapter 24 Iterators library [lib.iterators]


1 This clausedescribes components thatC++programs may use to perform iterations over containers (clause 23), streams 
(27.6), and streambuffers(27.5). 

2 The following subclauses describe iterator requirements, and components for iterator primitives, predefined iterators, 
and stream iterators, as summarizedinTable 73. 

Table 73: Iterators library summary 

Subclause Header(s) 
24.1 Requirements 
24.3 Iterator primitives <iterator> 
24.4 Predefined iterators 
24.5 Stream iterators 

24.1 Iteratorrequirements [lib.iterator.requirements] 
1 Iterators area generalization of pointers that allowaC++ program to work with different data structures (containers) 
in a uniform manner. To be able to construct template algorithms that work correctly and efficiently on different types 
of data structures, the library formalizes not just the interfacesbut also the semantics and complexity assumptions of 
iterators. All input iterators i support the expression *i, resultinginavalueof some class, enumeration,orbuilt-intype 
T, called the value type of the iterator. All output iterators support the expression *i = o where o is a value of some 
type that is in the set of types that are writable to the particular iterator type of i. All iterators i for which theexpression 
(*i).m is well-defined, support the expression i->m with the same semantics as (*i).m. For every iterator type X for 
which equality is defined, there is a corresponding signed integral type called the difference type of the iterator. 

2 Since iterators are an abstraction of pointers, their semantics is a generalization of most of the semantics of pointers in 
C++. This ensures thatevery function template that takes iteratorsworks as wellwith regular pointers. This International 
Standard defines fivecategories of iterators, according to the operations defined on them: input iterators,output iterators, 
forwarditerators, bidirectional iterators and random access iterators, as showninTable 74. 

Table 74: Relations among iterator categories 

Random Access Bidirectional Forward Input

. !. 

Output

. 

Forward iterators satisfy all the requirements of the input and output iterators and can be used whenever either kind is 
specified; Bidirectional iterators also satisfy all the requirements of the forward iterators and can be used whenever a 


24.1 Iteratorrequirements Iterators library 598 
forward iterator is specified; Random access iterators also satisfy all the requirements of bidirectional iterators and can 
be used whenever a bidirectional iterator is specified. 

4 Besides its category, a forward, bidirectional, or random access iterator can also be mutable or constant depending on 
whether the result of the expression *i behaves as a reference or as a reference to a constant. Constant iterators do not 
satisfy the requirements for output iterators, and the result of the expression *i (for constant iterator i)cannot be used 
in an expression where an lvalue is required. 

5 Justasaregularpointertoanarray guaranteesthatthereisapointervaluepointingpastthelastelementofthearray,so 
foranyiteratortypethereisaniteratorvaluethatpointspastthelastelementofa correspondingcontainer.Thesevalues 
are called past-the-end values.Valuesof an iterator i for whichthe expression *i is defined are called dereferenceable. 
The library never assumes that past-the-end values are dereferenceable. Iterators can also have singular values that are 
not associated with anycontainer.[ Example: After the declaration of an uninitialized pointer x (as with int* x;), x 
mustalwaysbe assumedtohaveasingularvalueofapointer. — endexample ]Resultsof mostexpressions are undefined 
for singular values; the only exceptions are destroying an iterator that holds a singular value and the assignment of a 
non-singular value to an iterator that holds a singular value. In this case the singular value is overwritten the same way 
as anyother value. Dereferenceable values are always non-singular. 

6 An iterator j is called reachablefrom an iterator i ifandonlyif thereisafinite sequenceof applicationsoftheexpression 
++i that makes i == j. If j is reachable from i, theyrefer to the same container. 

7 Most of the library’s algorithmic templates that operate on data structures have interfaces that use ranges. A range is a 
pairof iterators that designatethebeginningandendofthe computation.Arange [i,i) isan empty range;in general,a 
range [i,j) referstotheelementsinthedatastructure startingwiththeonepointedtoby i anduptobutnot including 
the one pointed to by j. Range [i,j) is valid if and only if j is reachable from i. The result of the application of 
functions in the library to invalid ranges is undefined. 

8 All the categories of iterators require only those functions that are realizable for a given category in constant time 
(amortized). Therefore, requirement tables for the iterators do not have a complexity column. 

9 Destruction of an iterator may invalidate pointers and references previously obtained from that iterator. 

10 An invalid iterator is an iterator that may be singular.261) 

11 In the following sections, a and b denote values of type const X, n denotesavalueof the difference type Distance, u, 
tmp, and m denote identifiers, r denotes a value of X&, t denotes a value of value type T, o denotes a value of some type 
that is writable to the outputiterator. 

24.1.1 Input iterators [lib.input.iterators] 
1Aclassorabuilt-intypeX satisfies the requirements of an input iterator for the value type T if the following expressions 
are valid, where U is the type of anyspecified member of type T, as showninTable 75. 

2 InTable 75, the term the domain of == isusedintheordinary mathematicalsensetodenotethesetofvaluesoverwhich 
== is (required to be) defined. This set can change over time. Each algorithm places additional requirements on the 
domain of == for the iterator values it uses. These requirements can be inferred from the uses that algorithm makes of 
== and !=.[ Example:the call find(a,b,x) is defined only if the value of a has the property pdefined as follows: b 
has property pand a value i has property pif (*i==x) or if (*i!=x and ++i has property p). — end example ] 

261)This definitionappliestopointers,sincepointersare iterators.Theeffectof dereferencingan iteratorthathasbeeninvalidatedis undefined. 

Draft 


599 Iterators library 24.1 Iterator requirements 

Table 75: Input iterator requirements 

operation type semantics, pre/post-conditions 
X u(a); X post: u is a copyof a 
Adestructor is assumed to be present and 
accessible. 
u = a; X& result: u 
post: u is a copyof a 
a == b convertible to bool == is an equivalence relation over its domain. 
a != b convertible to bool bool(a == b) != bool(a != b) over the 
domain of == 
*a convertible to T pre: a is dereferenceable. 
If a == b and (a,b) is in the domain of == then 
*a is equivalent to *b. 
a->m pre: (*a).m is well-defined. 
Equivalent to (*a).m. 
++r X& pre: r is dereferenceable. 
post: r is dereferenceable or r is past-the-end. 
post: anycopies of the previous value of r are no 
longer required either to be dereferenceable or to 
be in the domain of ==. 
(void)r++ equivalent to (void)++r 
*r++ convertible to T { T tmp = *r; ++r; return tmp; } 

3[Note: For input iterators,a == b does not imply ++a == ++b. (Equality does not guarantee the substitutionproperty 
or referential transparency.) Algorithms on input iterators should never attempt to pass through the same iterator twice. 
Theyshould be single pass algorithms. ValuetypeTisnotrequiredtobean Assignabletype(23.1). These algorithms 
can be used with istreams as the source of the input data through the istream_iterator class. — end note ] 

24.1.2 Output iterators [lib.output.iterators] 
1 A class or a built-in type X satisfies the requirements of an output iterator if X is a CopyConstructible(20.1.3)and 
Assignable type(23.1)and also the followingexpressions arevalid, as showninTable76. 

Table 76: Output iterator requirements 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
X(a) a = t is equivalent to X(a) = 
t. 
note: a destructor is assumed. 
X u(a); 
X u = a; 
*r = o result is not used 
++r X& &r == &++r. 

Draft 


24.1 Iteratorrequirements Iterators library 600 
expression return type operational assertion/note 
semantics pre/post-condition 
r++ convertible to { X tmp = r; 
const X& ++r; 
return tmp; } 
*r++ = o result is not used 

2[Note: The only valid use of an operator* is on the left side of the assignment statement. Assignment through the 
same value of the iterator happens only once. Algorithms on output iterators should never attempt to pass through the 
same iterator twice. Theyshould be singlepass algorithms. Equality and inequality might notbe defined. Algorithms 
that take output iterators canbe used with ostreams asthe destination forplacing data throughthe ostream_iterator 
class as well as with insertiterators and insert pointers. — end note ] 

24.1.3 Forward iterators [lib.forward.iterators] 
1 Aclass orabuilt-in typeX satisfiesthe requirementsofaforward iteratorifthefollowingexpressionsarevalid,asshown 
inTable 77. 

Table 77:Forward iterator requirements 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
X u; note: u might have a singular 
value. 
note: a destructor is assumed. 
X() note: X() might be singular. 
X(a) a == X(a) 
X u(a); 
X u = a; 
X u; u = a; post: u == a. 
a == b convertible to 
bool 
== is an equivalence relation. 
a != b convertible to 
bool 
!(a == b) 
r = a X& post: r == a 
*a T if X is mutable, 
otherwise const 
T& 
pre: a is dereferenceable. 
a == b implies *a == *b. 
If X is mutable, *a = t is valid. 
a->m U& if X is 
mutable, 
otherwise const 
U& 
(*a).m pre: (*a).m is well-defined. 
r->m U& (*r).m pre: (*r).m is well-defined. 

Draft 


601 Iterators library 24.1 Iterator requirements 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
++r X& pre: r is dereferenceable. 
post: r is dereferenceable or r 
is past-the-end. 
r == s and r is 
dereferenceable implies ++r 
== ++s. 
&r == &++r. 
r++ convertible to 
const X& 
{ X tmp = r; 
++r; 
return tmp; } 
*r++ T& if X is 
mutable, 
otherwise const 
T& 

— If a and b are equal, then either a and b are both dereferenceable or else neither is dereferenceable. 
— If a and b are both dereferenceable, then a == b if and only if *a and *b are the same object. 
2 [Note: The condition that a == b implies ++a == ++b (which is not true for input and output iterators) and the removal 
of the restrictions on the number of the assignments through the iterator (which applies to outputiterators) allows the 
use of multi-pass one-directional algorithms with forward iterators. — end note ] 

24.1.4 Bidirectional iterators [lib.bidirectional.iterators] 
1 Aclass orabuilt-in typeX satisfies the requirements of a bidirectional iterator if, in addition to satisfying the requirements for forward iterators, the followingexpressions arevalid as showninTable 78. 

Table 78: Bidirectional iterator requirements (in addition to forward iterator) 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
--r X& pre: there exists s such that r 
== ++s. 
post: r is dereferenceable. 
--(++r) == r. 
--r == --s implies r == s. 
&r == &--r. 
r-convertible to 
const X& 
{ X tmp = r; 
--r; 
return tmp; } 
*r-convertible to T 

Draft 


24.2 Header <iterator> synopsis Iterators library 602 
2 [Note: Bidirectional iterators allow algorithms to move iterators backward as well as forward. — end note ] 

24.1.5 Random access iterators [lib.random.access.iterators] 
1 Aclass orabuilt-in typeX satisfies the requirements of a random access iterator if, in addition to satisfying the requirements for bidirectional iterators, the followingexpressions arevalid as showninTable 79. 

Table 79: Random access iterator requirements (in addition to bidirectional iterator) 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
r += n X& { Distance m = n; 
if (m >= 0) 
while (m--) 
++r; 
else 
while (m++) 
--r; 
return r; } 
a + n 
n + a 
X { X tmp = a; 
return tmp += n; } 
a + n == n + a. 
r -= n X& return r += -n; 
a -n X { X tmp = a; 
return tmp -= n; } 
b -a Distance (a < b) ? distance(a,b) : 
-distance(b,a) 
pre: there exists a value n of 
Distance such that a + n == 
b. 
b == a + (b -a). 
a[n] convertible to 
const T & 
*(a + n) 
a < b convertible to 
bool 
b -a > 0 < is a total ordering relation 
a > b convertible to 
bool 
b < a > is a total ordering relation 
opposite to <. 
a >= b convertible to 
bool 
!(a < b) 
a <= b convertible to 
bool 
!(a > b) 

24.2 Header <iterator> synopsis [lib.iterator.synopsis] 
n a m e s p a c e s t d { 
// 24.3, primitives: 
t e m p l a t e < c l a s s I t e r a t o r > s t r u c t i t e r a t o r _ t r a i t s ; 
t e m p l a t e < c l a s s T > s t r u c t i t e r a t o r _ t r a i t s < T * > ; 
Draft 


603 Iterators library 24.2 Header <iterator> synopsis 

template < class Category , class T , class Distance = ptrdiff _t , 
class Pointer = T*, class Reference = T&> struct iterator; 

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


// 24.3.4, iterator operations: 

template < class InputIterator , class Distance > 
void advance(InputIterator& i, Distance n); 

template < class InputIterator > 
typename iterator _traits <InputIterator >::difference_type 
distance(InputIterator first , InputIterator last); 

// 24.4, predefined iterators: 

template <class Iterator > class reverse_iterator; 

template < class Iterator > 

bool operator ==(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

bool operator <(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

bool operator !=(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

bool operator >(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

bool operator >=(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

bool operator <=(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

typename reverse_iterator<Iterator>::difference_type operator -(
const reverse_iterator < Iterator >& x ,
const reverse_iterator <Iterator >& y);


template < class Iterator > 

Draft 


24.2 Header <iterator> synopsis Iterators library 604 
reverse_iterator < Iterator > 

operator +(
typename reverse_iterator <Iterator >::difference_type n,
const reverse_iterator <Iterator >& x);
template <class Container > class back_insert_iterator;
template < class Container >
back_insert_iterator <Container > back_inserter(Container& x);


template <class Container > class front_insert_iterator;
template < class Container >
front_insert_iterator <Container > front_inserter(Container& x);


template <class Container > class insert_iterator;
template < class Container , class Iterator >
insert_iterator <Container > inserter(Container& x, Iterator i);


// 24.5, stream iterators: 

template < class T , class charT = char , class traits = char_traits < charT >, 

class Distance = ptrdiff_ t >
class istream_iterator;
template < class T , class charT , class traits , class Distance >


bool operator==(const istream_iterator<T,charT,traits,Distance>& x, 
const istream_iterator <T,charT ,traits ,Distance >& y); 
template < class T , class charT , class traits , class Distance > 
bool operator!=(const istream_iterator<T,charT,traits,Distance>& x, 
const istream_iterator <T,charT ,traits ,Distance >& y); 

template < class T , class charT = char , class traits = char_traits < charT > > 
class ostream_iterator; 

template <class charT , class traits = char _traits <charT > >
class istreambuf_iterator;
template < class charT , class traits >
bool operator==(const istreambuf_iterator<charT,traits>& a ,
const istreambuf_iterator <charT ,traits >& b );
template < class charT , class traits >
bool operator!=(const istreambuf_iterator<charT,traits>& a ,
const istreambuf_iterator <charT ,traits >& b );


template < class charT , class traits = char _traits < charT > > 
class ostreambuf_iterator; 
} 

Draft 


605 Iterators library 24.3 Iterator primitives 

24.3 Iterator primitives [lib.iterator.primitives] 
1 To simplify the task of defining iterators, the library provides several classes and functions: 

24.3.1 Iterator traits [lib.iterator.traits] 
1To implement algorithmsonlyin termsof iterators,itisoftennecessaryto determinethevalueanddifferencetypesthat 
correspond to a particular iterator type. Accordingly, it is required that if Iterator is the type of an iterator, the types 

iterator_traits <Iterator >::difference_type
iterator_traits <Iterator >::value_type
iterator_traits <Iterator >::iterator_category


be defined as the iterator’s difference type, value type and iterator category, respectively. In addition, the types 

iterator_traits < Iterator >:: reference
iterator_traits < Iterator >:: pointer


shallbedefinedasthe iterator’s referenceand pointer types,thatis,foran iteratorobject a, the same type as the type of 
*a and a->, respectively. In the case of an output iterator, the types 

iterator_traits <Iterator >::difference_type
iterator_traits <Iterator >::value_type
iterator_traits < Iterator >:: reference
iterator_traits < Iterator >:: pointer


may be defined as void. 
2 The template iterator_traits<Iterator> is defined as 

namespace std { 

template <class Iterator > struct iterator_traits {
typedef typename Iterator::difference_type difference_type;
typedef typename Iterator :: value_type value_type ;
typedef typename Iterator :: pointer pointer ;
typedef typename Iterator :: reference reference ;
typedef typename Iterator::iterator_category iterator_category;


};
}


3 It is specialized for pointers as 

namespace std { 

template <class T> struct iterator_traits <T*> {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef T* pointer;
typedef T& reference;
typedef random_access_iterator_tag iterator_category;


};
}


and for pointers to const as 

Draft 


24.3 Iterator primitives Iterators library 606 
namespace std { 

template <class T> struct iterator_traits <const T*> {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T* pointer;
typedef const T& reference;
typedef random_access_iterator_tag iterator_category;


};
}


4[Note: If there is an additional pointer type _ _ far such that the difference oftwo _ _ far is of type long, an implementation may define 

template<class T> struct iterator_traits<T __far*> {
typedef long difference_type;
typedef T value_type;
typedef T _ _ far* pointer ;
typedef T __far& reference;
typedef random_access_iterator_tag iterator_category;


}; 

— end note ] 
5[Example: To implement a genericreverse function, aC++ program can do the following: 
template <class BidirectionalIterator >
void reverse(BidirectionalIterator first , BidirectionalIterator last) {
typename iterator _traits <BidirectionalIterator >::difference_type n =


distance(first , last);
--n;
while(n > 0) {


typename iterator_traits <BidirectionalIterator >::value_type 
tmp = *first; 

*first++ = *--last; 
* last = tmp ;
n -= 2;
}
}


— end example ] 
24.3.2 Basic iterator [lib.iterator.basic] 
1 The iterator template may be used as a base class to ease the definition of required types for new iterators. 

namespace std {
template < class Category , class T , class Distance = ptrdiff _t ,
class Pointer = T*, class Reference = T&>


struct iterator {
typedef T value_type;
typedef Distance difference_type;
typedef Pointer pointer ;


Draft 


607 Iterators library 24.3 Iterator primitives 

typedef Reference reference ;
typedef Category iterator_category;
};
}


24.3.3 Standard iterator tags [lib.std.iterator.tags] 
1 It is often desirable for a function template specialization to find out what is the most specific category of its iterator 
argument, so that the function can select the most efficient algorithm at compile time. Tofacilitate this, the library 
introduces category tag classes which are used as compile time tags for algorithm selection. Theyare: input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag and random_access_iterator_tag. For every iterator of type Iterator, iterator_traits<Iterator>::iterator_category 
shall be defined to be the mostspecific category tag that describes the iterator’s behavior. 

namespace std {
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


} 

2[Example: For a program-defined iterator BinaryTreeIterator, it could be included into the bidirectional iterator 
categoryby specializing the iterator_traits template: 

template < class T > struct iterator_traits < BinaryTreeIterator <T > > {
typedef std::ptrdiff_t difference_type;
typedef T value_type;
typedef T* pointer;
typedef T& reference;
typedef bidirectional_iterator_tag iterator_category;


}; 

Typically, however, it would be easier to deriveBinaryTreeIterator<T> from iterator<bidirectional_iterator_tag,T,ptrdiff_t,T*,T&>. — end example ] 

3[Example: If evolve() is well definedfor bidirectional iterators,but canbeimplemented moreefficientlyfor random 
access iterators, then the implementation is as follows: 

template <class BidirectionalIterator > 
inline void 
evolve(BidirectionalIterator first , BidirectionalIterator last) { 
evolve(first, last, 
typename iterator_traits <BidirectionalIterator >::iterator_category()); 
} 

template <class BidirectionalIterator >
void evolve(BidirectionalIterator first, BidirectionalIterator last,
bidirectional_iterator_tag ) {


// ... moregeneric,but lessefficient algorithm 

} 

Draft 


24.4 Predefined iterators Iterators library 608 
template <class RandomAccessIterator >
void evolve(RandomAccessIterator first, RandomAccessIterator last,
random_access_iterator_tag ) {


// ... moreefficient,but lessgeneric algorithm 

} 

— end example ] 
4 [Example: If aC++program wants to define a bidirectional iterator for some data structure containing double and such 
that it works on a large memory model of the implementation, it can do so with: 

class MyIterator : 
public iterator <bidirectional_iterator_tag , double , long , T*, T&> { 
// code implementing ++, etc. 
}; 

5 Then there is no need to specialize the iterator_traits template. — end example ] 

24.3.4 Iterator operations [lib.iterator.operations] 
1 Since only random access iterators provide + and -operators, the library provides twofunction templates advance 
and distance. These function templates use + and -for random access iterators (and are, therefore, constant time for 
them); for input, forward andbidirectional iterators theyuse ++ to provide linear time implementations. 

template < class InputIterator , class Distance >
void advance(InputIterator& i, Distance n);


2 Requires: n may be negative only for random access and bidirectional iterators. 
3 Effects: Increments (or decrements for negative n)iterator referencei by n. 

template < class InputIterator >
typename iterator_traits <InputIterator >::difference_type
distance(InputIterator first , InputIterator last);


4 Effects: Returns the number of increments or decrements needed to get from first to last. 
5 Requires: last shall be reachable from first. 

24.4 Predefined iterators [lib.predef.iterators] 
24.4.1 Reverse iterators [lib.reverse.iterators] 
1 Bidirectional and random access iterators havecorresponding reverse iterator adaptors that iterate through the data structure in the opposite direction. Theyhave the same signatures as the correspondingiterators. The fundamental relation 
between a reverse iterator and its corresponding iterator i is established by the identity: &*(reverse_iterator(i)) 
== &*(i -1). 

2 This mappingisdictatedbythefactthat while thereisalwaysa pointerpasttheendofan array, theremightnotbea 
valid pointer before the beginning of an array. 

24.4.1.1 Class template reverse_iterator [lib.reverse.iterator] 
Draft 


609 Iterators library 24.4 Predefined iterators 

namespace std { 

template < class Iterator > 

class reverse_iterator : public 

iterator < typename iterator_traits < Iterator >:: iterator_category , 

typename iterator_traits < Iterator >:: value _type , 

typename iterator_traits < Iterator >:: difference_type , 

typename iterator_traits < Iterator >:: pointer , 

typename iterator_traits < Iterator >:: reference > { 

protected : 

Iterator current ; 

public : 

typedef Iterator 

iterator_type ; 

typedef typename iterator_traits<Iterator>::difference_type 

difference_type ; 

typedef typename iterator_traits < Iterator >:: reference 

reference ; 

typedef typename iterator_traits < Iterator >:: pointer 

pointer ; 

reverse_iterator (); 

explicit reverse_iterator(Iterator x); 

template <class U> reverse_iterator(const reverse_iterator <U>& u); 

template <class U> reverse_iterator operator=(const reverse_iterator<U>& u); 

Iterator base () const ; // explicit 

reference operator*() const; 

pointer operator ->() const ; 

reverse_iterator& operator++(); 

reverse_iterator operator++(int); 

reverse_iterator& operator --(); 

reverse_iterator operator --(int); 

reverse_iterator operator+ (difference_type n) const; 

reverse_iterator& operator+=(difference_type n); 

reverse_iterator operator -(difference_type n) const; 

reverse_iterator& operator -=(difference_type n); 

unspecified operator[](difference_type n) const; 

}; 

template < class Iterator 1, class Iterator2 > 

bool operator ==( 

const reverse_iterator <Iterator 1>& x, 

const reverse_iterator <Iterator 2>& y); 

template < class Iterator 1, class Iterator2 > 

bool operator <( 

const reverse_iterator <Iterator 1>& x, 

const reverse_iterator <Iterator 2>& y); 

Draft 


24.4 Predefined iterators Iterators library 610 
template < class Iterator 1, class Iterator2 > 

bool operator !=(
const reverse_iterator <Iterator 1>& x,
const reverse_iterator <Iterator 2>& y);


template < class Iterator 1, class Iterator2 > 

bool operator >(
const reverse_iterator <Iterator 1>& x,
const reverse_iterator <Iterator 2>& y);


template < class Iterator 1, class Iterator2 > 

bool operator >=(
const reverse_iterator <Iterator 1>& x,
const reverse_iterator <Iterator 2>& y);


template < class Iterator 1, class Iterator2 > 

bool operator <=(
const reverse_iterator <Iterator 1>& x,
const reverse_iterator <Iterator 2>& y);


template < class Iterator 1, class Iterator2 > 

typename reverse_iterator <Iterator >::difference_type operator -( 
const reverse_iterator <Iterator 1>& x, 
const reverse_iterator <Iterator 2>& y); 

template < class Iterator > 

reverse_iterator < Iterator > operator +(
typename reverse_iterator <Iterator >::difference_type n,
const reverse_iterator <Iterator >& x);


} 

24.4.1.2 reverse_iterator requirements [lib.reverse.iter.requirements] 
1 The template parameter Iterator shall meet all the requirementsofa Bidirectional Iterator(24.1.4). 

2 Additionally, Iterator shallmeetthe requirementsofaRandom Access Iterator(24.1.5)ifanyofthemembersoperator+ (24.4.1.3.8), operator-(24.4.1.3.10), operator+= (24.4.1.3.9), operator-= (24.4.1.3.11), operator [] 
(24.4.1.3.12), or the global operators operator< (24.4.1.3.14), operator> (24.4.1.3.16), operator <= (24.4.1.3.18), 
operator>= (24.4.1.3.17), operator-(24.4.1.3.19)or operator+ (24.4.1.3.20). is referenced in a way that requires 
instantiation(14.7.1). 

24.4.1.3 reverse_iterator operations [lib.reverse.iter.ops] 
24.4.1.3.1 reverse_iterator constructor [lib.reverse.iter.cons] 
reverse_iterator (); 

1 Effects: Default initializes current. Iterator operations applied to the resulting iterator have defined behavior if 
and only if the corresponding operations are defined on a default constructed iterator of type Iterator. 

Draft 


611 Iterators library 24.4 Predefined iterators 

explicit reverse_iterator(Iterator x); 

2 Effects: Initializes current with x . 

template <class U> reverse_iterator(const reverse_ iterator <U> &u); 

3 Effects: Initializes current with u .current. 

24.4.1.3.2 reverse_iterator::operator= [lib.reverse.iter.op=] 
template <class U>
reverse_iterator&
operator=(const reverse_iterator<U>& u);


1 Effects: Assigns u.base() to current. 
2 Returns: *this. 

24.4.1.3.3 Conversion [lib.reverse.iter.conv] 
Iterator base () const ; // explicit 
1 Returns: current. 

24.4.1.3.4 operator* [lib.reverse.iter.op.star] 
reference operator*() const; 

1 Effects: 

this->tmp = current;
--this ->tmp;
return *this->tmp;


2[Note: Thisoperationmustuseanauxiliarymembervariable,ratherthana temporaryvariable,toavoidreturning 
a reference that persists beyond the lifetime of its associated iterator. (See 24.1.) The name of this member 
variable is shown for exposition only. — end note ] 

24.4.1.3.5 operator-> [lib.reverse.iter.opref] 
pointer operator ->() const ; 

1 Effects: 

return &( operator *()); 

Draft 


24.4 Predefined iterators Iterators library 612 
24.4.1.3.6 operator++ [lib.reverse.iter.op++] 
reverse_iterator & operator ++(); 

1 Effects: --current; 
2 Returns: *this. 

reverse_iterator operator++(int); 

3 Effects: 

reverse_iterator tmp = *this;
--current ;
return tmp ;


24.4.1.3.7 operator--[lib.reverse.iter.op--] 
reverse_iterator& operator --(); 

1 Effects: ++current 
2 Returns: *this. 

reverse_iterator operator --(int); 

3 Effects: 

reverse_iterator tmp = *this;
++ current ;
return tmp ;


24.4.1.3.8 operator+ [lib.reverse.iter.op+] 
reverse_iterator 

operator+(typename reverse_iterator <Iterator >::difference_type n) const; 
1 Returns: reverse_iterator(current-n). 

24.4.1.3.9 operator+= [lib.reverse.iter.op+=] 
reverse_iterator & 

operator+=(typename reverse_iterator <Iterator >::difference_type n); 
1 Effects: current -= n; 
2 Returns: *this. 

Draft 


613 Iterators library 24.4 Predefined iterators 

24.4.1.3.10 operator-[lib.reverse.iter.op-] 
reverse_iterator 

operator -(typename reverse_iterator<Iterator>::difference_type n) const; 
1 Returns: reverse_iterator(current+n). 

24.4.1.3.11 operator-= [lib.reverse.iter.op-=] 
reverse_iterator & 

operator -=(typename reverse_iterator <Iterator >::difference_type n); 
1 Effects: current += n; 

2 Returns: *this. 

24.4.1.3.12 operator[] [lib.reverse.iter.opindex] 
\ textit { unspecified } 

operator[](typename reverse_iterator <Iterator >::difference_type n) const; 
1 Returns: current[-n-1]. 

24.4.1.3.13 operator== [lib.reverse.iter.op==] 
template < class Iterator 1, class Iterator2 > 

bool operator = =( 

const reverse_iterator <Iterator 1>& x, 

const reverse_iterator <Iterator 2>& y); 

1 Returns: x.current == y.current. 

24.4.1.3.14 operator< [lib.reverse.iter.op<] 
template < class Iterator 1, class Iterator2 > 

bool operator <( 

const reverse_iterator <Iterator 1>& x, 

const reverse_iterator <Iterator 2>& y); 

1 Returns: x.current > y.current. 

24.4.1.3.15 operator!= [lib.reverse.iter.op!=] 
template < class Iterator 1, class Iterator2 > 

bool operator ! =( 

const reverse_iterator <Iterator 1>& x, 

const reverse_iterator <Iterator 2>& y); 

Draft 


24.4 Predefined iterators Iterators library 614 
1 Returns: x.current != y.current. 
24.4.1.3.16 operator> [lib.reverse.iter.op>] 
1 
t e m p l a t e < c l a s s I t e r a t o r 1, class Iterator2 > 
b o o l o p e r a t o r > ( 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 1 >& x , 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 2 >& y ) ; 
Returns: x.current < y.current. 
24.4.1.3.17 operator>= [lib.reverse.iter.op>=] 
1 
t e m p l a t e < c l a s s I t e r a t o r 1, class Iterator2 > 
b o o l o p e r a t o r > = ( 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 1 >& x , 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 2 >& y ) ; 
Returns: x.current <= y.current. 
24.4.1.3.18 operator<= [lib.reverse.iter.op<=] 
1 
t e m p l a t e < c l a s s I t e r a t o r 1, class Iterator2 > 
b o o l o p e r a t o r < = ( 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 1 >& x , 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 2 >& y ) ; 
Returns: x.current >= y.current. 
24.4.1.3.19 operator[lib.reverse.iter.opdiff] 
1 
t e m p l a t e < c l a s s I t e r a t o r 1, class Iterator2 > 
t y p e n a m e r e v e r s e _ i t e r a t o r < I t e r a t o r > : : d i f f e r e n c e _ t y p e 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 1 >& x , 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r 2 >& y ) ; 
Returns: y.current -x.current. 
o p e r a t o r -( 
24.4.1.3.20 operator+ [lib.reverse.iter.opsum] 
1 
t e m p l a t e < c l a s s I t e r a t o r > 
r e v e r s e _ i t e r a t o r < I t e r a t o r > o p e r a t o r + ( 
t y p e n a m e r e v e r s e _ i t e r a t o r < I t e r a t o r > : : d i f f e r e n c e _ t y p e 
c o n s t r e v e r s e _ i t e r a t o r < I t e r a t o r > & x ) ; 
Returns: reverse_iterator<Iterator> (x.current -n). 
n , 
Draft 


615 Iterators library 24.4 Predefined iterators 

24.4.2 Insert iterators [lib.insert.iterators] 
1 To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator adaptors, 
called insert iterators, areprovidedinthe library.Withregular iterator classes, 

while ( first != last ) * result ++ = * first ++; 

causesa range [first,last) tobe copied intoa range starting with result. The same code with result being an insert 
iterator will insert corresponding elements into the container. Thisdevice allows all of the copying algorithms in the 
library to work in the insert mode instead of the regular overwrite mode. 

2 An insert iterator is constructedfrom a container and possibly one of its iterators pointing to where insertion takes place 
if it is neither at the beginning nor at the end of the container. Insert iterators satisfy the requirements of output iterators. 
operator* returns the insert iterator itself. The assignment operator=(const T& x) is defined on insert iterators to 
allow writing into them, it inserts x right before where the insert iterator is pointing. In other words, an insert iterator is 
likeacursor pointing into the container where the insertiontakes place. back_insert_iterator inserts elements at the 
end of a container, front_insert_iterator inserts elements at the beginningof a container, and insert_iterator 
inserts elements where the iterator points to in a container. back_inserter, front_inserter, and inserter are 
three functions making the insert iterators out of a container. 

24.4.2.1 Class template back_insert_iterator [lib.back.insert.iterator] 
namespace std {
template < class Container >
class back_insert_iterator :


public iterator<output_iterator_tag,void,void,void,void> {
protected :
Container* container;


public :
typedef Container container_type ;
explicit back_insert_iterator(Container& x);
back_insert_iterator <Container >&


operator= (typename Container::const_reference value); 
back_insert_iterator <Container >& operator*();
back_insert_iterator <Container >& operator++();
back_insert_iterator <Container > operator++(int);


}; 

template < class Container >
back_insert_iterator <Container > back_inserter(Container& x);
}


24.4.2.2 back_insert_iterator operations [lib.back.insert.iter.ops] 
24.4.2.2.1 back_insert_iterator constructor [lib.back.insert.iter.cons] 
explicit back_insert_iterator(Container& x); 

1 Effects: Initializes container with &x . 

Draft 


24.4 Predefined iterators Iterators library 616 
24.4.2.2.2 back_insert_iterator::operator= [lib.back.insert.iter.op=] 
back_insert_iterator <Container >& 

operator= (typename Container::const_reference value); 
1 Effects: container->push_back(value); 

2 Returns: *this. 

24.4.2.2.3 back_insert_iterator::operator* [lib.back.insert.iter.op*] 
back_insert_iterator <Container >& operator*(); 

1 Returns: *this. 

24.4.2.2.4 back_insert_iterator::operator++ [lib.back.insert.iter.op++] 
back_insert_iterator <Container >& operator++();
back_insert_iterator <Container > operator++(int);


1 Returns: *this. 

24.4.2.2.5 back_inserter [lib.back.inserter] 
template < class Container >
back_insert_iterator <Container > back_inserter(Container& x);


1 Returns: back_insert_iterator<Container>(x). 

24.4.2.3 Class template front_insert_iterator [lib.front.insert.iterator] 
namespace std { 

template < class Container > 

class front_insert_iterator : 

public iterator<output_iterator_tag,void,void,void,void> { 

protected : 

Container* container; 

public :
typedef Container container_type ;
explicit front_insert_iterator(Container& x);
front_insert_iterator <Container >&


operator= (typename Container::const_reference value); 
front_insert_iterator <Container >& operator*(); 

front_insert_iterator <Container >& operator++(); 

front_insert_iterator <Container > operator++(int); 

}; 

Draft 


617 Iterators library 24.4 Predefined iterators 

template < class Container >
front_insert_iterator <Container > front_inserter(Container& x);
}


24.4.2.4 front_insert_iterator operations [lib.front.insert.iter.ops] 
24.4.2.4.1 front_insert_iterator constructor [lib.front.insert.iter.cons] 
explicit front_insert_iterator(Container& x); 

1 Effects: Initializes container with &x . 

24.4.2.4.2 front_insert_iterator::operator= [lib.front.insert.iter.op=] 
front_insert_iterator <Container >& 

operator= (typename Container::const_reference value); 
1 Effects: container->push_front(value); 
2 Returns: *this. 

24.4.2.4.3 front_insert_iterator::operator* [lib.front.insert.iter.op*] 
front_insert_iterator <Container >& operator*(); 

1 Returns: *this. 

24.4.2.4.4 front_insert_iterator::operator++ [lib.front.insert.iter.op++] 
front_insert_iterator <Container >& operator++();
front_insert_iterator <Container > operator++(int);


1 Returns: *this. 

24.4.2.4.5 front_inserter [lib.front.inserter] 
template < class Container >
front_insert_iterator <Container > front_inserter(Container& x);


1 Returns: front_insert_iterator<Container>(x). 

24.4.2.5 Class template insert_iterator [lib.insert.iterator] 
namespace std { 

template < class Container > 

class insert_iterator : 

public iterator<output_iterator_tag,void,void,void,void> { 

Draft 


24.4 Predefined iterators Iterators library 618 
p r o t e c t e d : 
C o n t a i n e r * c o n t a i n e r ; 
t y p e n a m e C o n t a i n e r : : i t e r a t o r i t e r ; 
p u b l i c : 
t y p e d e f C o n t a i n e r c o n t a i n e r _ t y p e ; 
i n s e r t _ i t e r a t o r ( C o n t a i n e r & x , t y p e n a m e C o n t a i n e r : : i t e r a t o r 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
o p e r a t o r = ( t y p e n a m e C o n t a i n e r : : c o n s t _ r e f e r e n c e v a l u e ) ; 
i ) ; 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
} ; 
o p e r a t o r * ( ) ; 
o p e r a t o r + + ( ) ; 
o p e r a t o r + + ( i n t ) ; 
} 
t e m p l a t e < c l a s s C o n t a i n e r , c l a s s I t e r a t o r > 
i n s e r t _ i t e r a t o r < C o n t a i n e r > i n s e r t e r ( C o n t a i n e r & x , I t e r a t o r i ) ; 
24.4.2.6 insert_iterator operations 
24.4.2.6.1 insert_iterator constructor 
[lib.insert.iter.ops] 
[lib.insert.iter.cons] 
1 
i n s e r t _ i t e r a t o r ( C o n t a i n e r & x , t y p e n a m e C o n t a i n e r : : i t e r a t o r 
Effects: Initializes container with &x and iter with i . 
i ) ; 
24.4.2.6.2 insert_iterator::operator= [lib.insert.iter.op=] 
1 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
o p e r a t o r = ( t y p e n a m e C o n t a i n e r : : c o n s t _ r e f e r e n c e 
Effects: 
v a l u e ) ; 
i t e r = c o n t a i n e r -> i n s e r t ( i t e r , 
+ + i t e r ; 
v a l u e ) ; 
2 Returns: *this. 
24.4.2.6.3 insert_iterator::operator* [lib.insert.iter.op*] 
1 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
Returns: *this. 
o p e r a t o r * ( ) ; 
24.4.2.6.4 insert_iterator::operator++ [lib.insert.iter.op++] 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
i n s e r t _ i t e r a t o r < C o n t a i n e r > & 
o p e r a t o r + + ( ) ; 
o p e r a t o r + + ( i n t ) ; 
Draft 


619 Iterators library 24.5 Stream iterators 

1 Returns: *this. 

24.4.2.6.5 inserter [lib.inserter] 
template < class Container , class Inserter >
insert_iterator<Container> inserter(Container& x, Inserter i);


1 Returns: insert_iterator<Container>(x,typename Container::iterator(i)). 

24.5 Stream iterators [lib.stream.iterators] 
1 To make it possible for algorithmic templates to work directly with input/output streams, appropriate iterator-like class 
templates are provided. 

[Example: 

partial_sum_copy(istream_iterator <double , char >(cin),
istream_iterator < double , char >() ,


ostream_iterator <double , char >(cout , "\n")); 
reads a file containing floating point numbers from cin, and prints the partial sums onto cout. — end example ] 

24.5.1 Class template istream_iterator [lib.istream.iterator] 
1 istream_iterator reads (using operator>>)successive elementsfromtheinput streamforwhichitwas constructed. 
Afteritis constructed,andeverytime ++ isused,the iterator readsand storesavalueof T. If the end of stream is reached 
(operator void*() on the stream returns false), the iterator becomes equal to the end-of-stream iterator value. The 
constructor with no arguments istream_iterator() always constructs an end of stream input iterator object, which 
is the only legitimate iterator to be used for the end condition. The result of operator* on an end of stream is not 
defined. For any other iterator value a const T& is returned. The result of operator-> on an end of stream is not 
defined. For anyother iterator value a const T* is returned. It is impossible to store things into istream iterators. The 
main peculiarityofthe istream iteratorsisthefact that ++ operators are not equality preserving, that is, i == j does not 
guarantee at all that ++i == ++j. Every time ++ is used a new value is read. 

2 The practical consequenceof thisfactis that istream iterators canbe used onlyfor one-pass algorithms, which actually 
makes perfect sense, sincefor multi-pass algorithmsitisalways more appropriateto use in-memory data structures. 

3 Two end-of-stream iterators are always equal. An end-of-stream iterator is not equal to a non-end-of-stream iterator. 
Two non-end-of-stream iterators are equal when theyare constructed from the same stream. 

namespace std { 
template < class T , class charT = char , class traits = char_traits < charT >, 
class Distance = ptrdiff_ t > 
class istream_iterator: 
public iterator <input_iterator_tag , T, Distance , const T*, const T&> { 

public :
typedef charT char_type ;
typedef traits traits_type;
typedef basic _istream <charT ,traits > istream_type;
istream_iterator ();


Draft 


24.5 Stream iterators Iterators library 620 
istream_iterator(istream_type& s); 
istream_iterator(const istream_iterator <T,charT ,traits ,Distance >& x); 
~istream_iterator (); 

const T& operator*() const; 

const T* operator ->() const; 

istream_iterator<T,charT,traits,Distance>& operator++(); 

istream_iterator<T,charT,traits,Distance> operator++(int); 

private : 

// basic_istream<charT,traits>* in_stream; exposition only 

// Tvalue; exposition only 

}; 

template < class T , class charT , class traits , class Distance >
bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
const istream_iterator <T,charT ,traits ,Distance >& y);
template < class T , class charT , class traits , class Distance >
bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
const istream_iterator <T,charT ,traits ,Distance >& y);
}


24.5.1.1 istream_iterator constructors and destructor [lib.istream.iterator.cons] 
istream_iterator (); 

1 Effects: Constructs the end-of-stream iterator. 

istream_iterator ( istream_type & s ); 

2 Effects: Initializes in_stream with s . value may be initialized during construction or the first time it is referenced. 

istream_iterator(const istream_iterator <T,charT ,traits ,Distance >& x); 

3 Effects: Constructs a copyof x . 

~istream_iterator (); 

4 Effects: The iterator is destroyed. 

24.5.1.2 istream_iterator operations [lib.istream.iterator.ops] 
const T& operator*() const; 

1 Returns: value. 

const T* operator ->() const; 

2 Returns: &(operator*()). 

istream_iterator<T,charT,traits,Distance>& operator++(); 

3 Effects: *in_stream >> value . 

Draft 


621 Iterators library 24.5 Stream iterators 

4 Returns: *this. 

istream_iterator <T,charT ,traits ,Distance > operator++(int); 

5 Effects: 

istream_iterator<T,charT,traits,Distance> tmp = *this;
*in_stream >> value ;
return ( tmp );


template < class T , class charT , class traits , class Distance >
bool operator= =(const istream_iterator<T,charT,traits,Distance> & x ,
const istream_iterator <T,charT ,traits ,Distance > & y );


6 Returns: (x .in_stream == y .in_stream ). 

template < class T , class charT , class traits , class Distance >
bool operator! =(const istream_iterator<T,charT,traits,Distance> & x ,
const istream_iterator <T,charT ,traits ,Distance > & y );


7 Returns: !(x == y) 

24.5.2 Class template ostream_iterator [lib.ostream.iterator] 
1 ostream_iterator writes (using operator<<)successive elements onto the output stream from which it was constructed. If it was constructed with char* as a constructor argument, this string, called a delimiter string,is written to 
the stream after every T is written. It is not possible to get a value out of the output iterator. Its only use is as an output 
iterator in situations like 

while ( first != last ) * result ++ = * first ++; 

2 ostream_iterator is defined as: 

namespace std { 
template < class T , class charT = char , class traits = char_traits < charT > > 
class ostream_iterator: 

public iterator < output_iterator_tag , void , void , void , void > { 

public :
typedef charT char_type ;
typedef traits traits_type;
typedef basic _ostream <charT ,traits > ostream_type;


ostream_iterator(ostream_type& s); 
ostream_iterator(ostream_type& s, const charT* delimiter); 
ostream_iterator(const ostream_iterator <T,charT ,traits >& x);
~ostream_iterator ();
ostream_iterator <T,charT ,traits >& operator= (const T& value); 
ostream_iterator<T,charT,traits>& operator*(); 
ostream_iterator<T,charT,traits>& operator++(); 
ostream_iterator<T,charT,traits>& operator++(int);
private :
Draft 


24.5 Stream iterators Iterators library 622 
} 
// 
// 
} ; 
basic_ostream<charT,traits>* out_stream; 
const charT* delim; 
exposition only 
exposition only 
24.5.2.1 ostream_iterator constructors and destructor [lib.ostream.iterator.cons.des] 
1 
o s t r e a m _ i t e r a t o r ( o s t r e a m _ t y p e & s ) ; 
Effects: Initializes out_stream with s and delim with null. 
2 
o s t r e a m _ i t e r a t o r ( o s t r e a m _ t y p e & s , c o n s t c h a r T * delimiter ) ; 
Effects: Initializes out_stream with s and delim with delimiter . 
3 
o s t r e a m _ i t e r a t o r ( c o n s t o s t r e a m _ i t e r a t o r & 
Effects: Constructs a copyof x . 
x ) ; 
4 
~ o s t r e a m _ i t e r a t o r ( ) ; 
Effects: The iterator is destroyed. 
24.5.2.2 ostream_iterator operations [lib.ostream.iterator.ops] 
1 
o s t r e a m _ i t e r a t o r & 
Effects: 
o p e r a t o r = ( c o n s t T & value ) ; 
*out_stream < < value ; 
i f ( d e l i m ! = 0 ) * out_stream 
r e t u r n ( * t h i s ) ; 
< < delim ; 
2 
o s t r e a m _ i t e r a t o r & 
Returns: *this. 
o p e r a t o r * ( ) ; 
3 
o s t r e a m _ i t e r a t o r & 
o s t r e a m _ i t e r a t o r & 
Returns: *this. 
o p e r a t o r + + ( ) ; 
o p e r a t o r + + ( i n t ) ; 
24.5.3 Class template istreambuf_iterator 
n a m e s p a c e s t d { 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s = c h a r _ t r a i t s < c h a r T > 
c l a s s i s t r e a m b u f _ i t e r a t o r 
: p u b l i c i t e r a t o r < i n p u t _ i t e r a t o r _ t a g , c h a r T , 
t y p e n a m e t r a i t s : : o f f _ t y p e , c h a r T * , 
p u b l i c : 
t y p e d e f c h a r T c h a r _ t y p e ; 
t y p e d e f t r a i t s t r a i t s _ t y p e ; 
[lib.istreambuf.iterator] 
> 
c h a r T > { 
Draft 


623 Iterators library 24.5 Stream iterators 

typedef typename traits :: int_type int_type ;
typedef basic_streambuf <charT ,traits > streambuf_type;
typedef basic _istream <charT ,traits > istream_type;


class proxy ; // exposition only 

public :
istreambuf_iterator() throw();
istreambuf_iterator(istream_type & s ) throw ();
istreambuf_iterator(streambuf_type * s ) throw ();
istreambuf_iterator(const proxy& p ) throw ();
charT operator *() const ;
istreambuf_iterator < charT , traits >& operator ++();
proxy operator ++( int );
bool equal(istreambuf_iterator& b ) const ;


private : 
streambuf_type * sbuf_; // exposition only 
}; 

template < class charT , class traits >
bool operator==(const istreambuf_iterator<charT,traits>& a ,
const istreambuf_iterator <charT ,traits >& b );


template < class charT , class traits >
bool operator!=(const istreambuf_iterator<charT,traits>& a ,
const istreambuf_iterator <charT ,traits >& b );
}


1 The class template istreambuf_iterator reads successive characters from the streambuf for which it was constructed. operator* provides access to the current input character, if any. Each time operator++ is evaluated, 
the iterator advances to the next input character. If the end of stream is reached (streambuf_type::sgetc() returns 
traits::eof()),the iterator becomes equal to theend of stream iteratorvalue. Thedefault constructor istreambuf_
iterator() and the constructor istreambuf_iterator(0) both construct an end of stream iterator object suitable 
for use as an end-of-range. 

2 The result of operator*() onanendof streamis undefined.Foranyother iteratorvaluea char_type value is returned. 
It is impossible to assign a character via an input iterator. 

3 Note that in the input iterators, ++ operators are not equality preserving, that is, i == j does not guarantee at all that 
++i == ++j. Every time ++ is evaluated a new value is used. 

4 The practical consequence of thisfact is that an istreambuf_iterator object can be used only for one-pass algorithms. Two end of stream iterators are always equal. An end of stream iterator is not equal to a non-end of stream 
iterator. 

24.5.3.1 Class template istreambuf_iterator::proxy [lib.istreambuf.iterator::proxy] 
namespace std {
template < class charT , class traits = char _traits < charT > >
class istreambuf_iterator <charT , traits >::proxy {


charT keep_; 

Draft 


24.5 Stream iterators Iterators library 624 
basic_streambuf < charT , traits >* sbuf_;
proxy ( charT c ,
basic_streambuf < charT , traits >* sbuf );
: keep_(c ), sbuf_( sbuf ) {}
public :
charT operator *() { return keep_ ;}
};
}


1 Class istreambuf_iterator<charT,traits>::proxy is for exposition only. An implementation is permitted to 
provide equivalent functionality without providing a class with this name. Class istreambuf_iterator<charT, 
traits>::proxy providesa temporary placeholderasthe returnvalueofthe post-increment operator(operator++). 
Itkeepsthe characterpointedtobythepreviousvalueoftheiteratorforsomepossiblefuture accesstogetthe character. 

24.5.3.2 istreambuf_iterator constructors [lib.istreambuf.iterator.cons] 
istreambuf_iterator () throw (); 

1 Effects: Constructs the end-of-stream iterator. 

istreambuf_iterator(basic _istream <charT ,traits >& s ) throw ();
istreambuf_iterator(basic_streambuf <charT ,traits >* s ) throw ();


2 Effects: Constructs an istreambuf_iterator<> that uses the basic_streambuf<> object *(s .rdbuf()), or 
*s , respectively. Constructs an end-of-stream iterator if s .rdbuf() is null. 

istreambuf_iterator(const proxy& p ) throw (); 

3 Effects: Constructs a istreambuf_iterator<> that uses the basic_streambuf<> object pointed to by the 
proxy object’s constructor argument p . 

24.5.3.3 istreambuf_iterator::operator* [lib.istreambuf.iterator::op*] 
charT operator *() const 

1 Returns: The character obtained via the streambuf member sbuf_->sgetc(). 

24.5.3.4 istreambuf_iterator::operator++ [lib.istreambuf.iterator::op++] 
istreambuf_iterator <charT ,traits >&
istreambuf_iterator <charT,traits >::operator++();


1 Effects: sbuf_->sbumpc(). 
2 Returns: *this. 

proxy istreambuf_iterator<charT,traits>::operator++(int); 

3 Returns: proxy(sbuf_->sbumpc(), sbuf_). 

Draft 


625 Iterators library 24.5 Stream iterators 

24.5.3.5 istreambuf_iterator::equal [lib.istreambuf.iterator::equal] 
bool equal(istreambuf_iterator <charT ,traits >& b ) const ; 

1 Returns: true if and only if bothiterators are at end-of-stream, or neither is at end-of-stream, regardless of what 
streambuf object they use. 

24.5.3.6 operator== [lib.istreambuf.iterator::op==] 
template < class charT , class traits >
bool operator= =(const istreambuf_iterator<charT,traits>& a ,
const istreambuf_iterator <charT ,traits >& b );


1 Returns: a .equal(b ). 

24.5.3.7 operator!= [lib.istreambuf.iterator::op!=] 
template < class charT , class traits >
bool operator! =(const istreambuf_iterator<charT,traits>& a ,
const istreambuf_iterator <charT ,traits >& b );


1 Returns: !a .equal(b ). 

24.5.4 Class template ostreambuf_iterator [lib.ostreambuf.iterator] 
namespace std { 

template < class charT , class traits = char _traits < charT > > 

class ostreambuf_iterator: 

public iterator < output_iterator_tag , void , void , void , void > { 

public : 

typedef charT char_type ; 

typedef traits traits_type; 

typedef basic_streambuf <charT ,traits > streambuf_type; 

typedef basic _ostream <charT ,traits > ostream_type; 

public : 

ostreambuf_iterator(ostream_type & s ) throw (); 
ostreambuf_iterator(streambuf_type * s ) throw (); 
ostreambuf_iterator& operator= (charT c ); 
ostreambuf_iterator& operator*(); 
ostreambuf_iterator& operator++(); 
ostreambuf_iterator& operator++(int);
bool failed () const throw ();
private : 

// streambuf_type* sbuf_; exposition only 

Draft 


24.5 Stream iterators Iterators library 626 
};
}


1 The class template ostreambuf_iterator writes successive characters onto the output stream from which it was 
constructed. It is not possible to get a character value out of the output iterator. 

24.5.4.1 ostreambuf_iterator constructors [lib.ostreambuf.iter.cons] 
ostreambuf_iterator ( ostream_type & s ) throw (); 
1 Requires: s .rdbuf() is not null. 
2 Effects: :sbuf_(s .rdbuf()) {}. 

ostreambuf_iterator ( streambuf_type * s ) throw (); 
3 Requires: s is not null. 
4 Effects: : sbuf_(s ) {}. 
24.5.4.2 ostreambuf_iterator operations [lib.ostreambuf.iter.ops] 
ostreambuf_iterator <charT ,traits >& 
operator = ( charT c ); 
1 Effects: If failed() yields false, calls sbuf_->sputc(c );otherwise has no effect. 
2 Returns: *this. 

ostreambuf_iterator<charT,traits>& operator*(); 
3 Returns: *this. 

ostreambuf_iterator<charT,traits>& operator++(); 
ostreambuf_iterator<charT,traits>& operator++(int); 
4 Returns: *this. 

bool failed () const throw (); 

5 Returns: true if in anyprior use of member operator=, the call tosbuf_->sputc() returned traits::eof(); 
or false otherwise. 

Draft 


Chapter 25 Algorithms library [lib.algorithms]


1 This clause describes components thatC++ programs may use to perform algorithmic operations on containers (clause 
23)and other sequences. 

2 The following subclauses describe components for non-modifying sequence operation, modifying sequence operations, 
sorting and related operations, and algorithms from the ISOClibrary, as summarizedinTable 80. 

Table 80: Algorithms library summary 

Subclause Header(s) 
25.1 Non-modifying sequence operations 
25.2 Mutating sequence operations 
25.3 Sorting and related operations 
<algorithm> 
25.4 Clibrary algorithms <cstdlib> 

Header <algorithm> synopsis 

namespace std { 

// 25.1, non-modifying sequence operations: 

template < class InputIterator , class Function > 
Function for_each(InputIterator first , InputIterator last , Function f ); 
template <class InputIterator , class T> 
InputIterator find(InputIterator first , InputIterator last , 
const T& value ); 
template < class InputIterator , class Predicate > 
InputIterator find_if(InputIterator first , InputIterator last , 
Predicate pred ); 
template < class ForwardIterator1 , class ForwardIterator2 > 
ForwardIterator1 
find_end ( ForwardIterator1 first1 , ForwardIterator1 last1 , 
ForwardIterator2 first2 , ForwardIterator2 last2 ); 
template < class ForwardIterator1 , class ForwardIterator2 , 
class BinaryPredicate > 
ForwardIterator1 

find_end ( ForwardIterator1 first1 , ForwardIterator1 last1 , 
ForwardIterator2 first2 , ForwardIterator2 last2 , 
BinaryPredicate pred ); 

template < class ForwardIterator1 , class ForwardIterator2 >
ForwardIterator1



Algorithms library 628 

find_first_of ( ForwardIterator1 first1 , ForwardIterator1 last1 , 
ForwardIterator2 first2 , ForwardIterator2 last2 ); 
template < class ForwardIterator1 , class ForwardIterator2 , 
class BinaryPredicate > 
ForwardIterator1 

find_first_of ( ForwardIterator1 first1 , ForwardIterator1 last1 , 
ForwardIterator2 first2 , ForwardIterator2 last2 , 
BinaryPredicate pred ); 

template < class ForwardIterator > 
ForwardIterator adjacent_find(ForwardIterator first , 
ForwardIterator last ); 
template < class ForwardIterator , class BinaryPredicate > 
ForwardIterator adjacent_find(ForwardIterator first , 
ForwardIterator last , BinaryPredicate pred ); 

template <class InputIterator , class T> 
typename iterator _traits <InputIterator >::difference_type 
count ( InputIterator first , InputIterator last , const T& value ); 
template < class InputIterator , class Predicate > 
typename iterator _traits <InputIterator >::difference_type 
count_ if ( InputIterator first , InputIterator last , Predicate pred ); 

template < class InputIterator1 , class InputIterator2 > 
pair < InputIterator1 , InputIterator2 > 
mismatch ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 ); 
template 
<class InputIterator1 , class InputIterator2 , class BinaryPredicate > 
pair < InputIterator1 , InputIterator2 > 
mismatch ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , BinaryPredicate pred ); 

template < class InputIterator1 , class InputIterator2 > 
bool equal(InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 ); 
template 
<class InputIterator1 , class InputIterator2 , class BinaryPredicate > 
bool equal(InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , BinaryPredicate pred ); 

template < class ForwardIterator1 , class ForwardIterator2 > 
ForwardIterator1 search 
( ForwardIterator1 first1 , ForwardIterator1 last1 , 
ForwardIterator2 first2 , ForwardIterator2 last2 ); 
template < class ForwardIterator1 , class ForwardIterator2 , 
class BinaryPredicate > 
ForwardIterator1 search 
( ForwardIterator1 first1 , ForwardIterator1 last1 , 
ForwardIterator2 first2 , ForwardIterator2 last2 , 

Draft 


629 Algorithms library 

BinaryPredicate pred ); 
template <class ForwardIterator , class Size , class T> 
ForwardIterator search_n(ForwardIterator first , ForwardIterator last , 
Size count , const T & value ); 
template 
<class ForwardIterator , class Size , class T , class BinaryPredicate > 

ForwardIterator1 search_n(ForwardIterator first , ForwardIterator last ,
Size count , const T & value ,
BinaryPredicate pred );


// 25.2, modifying sequence operations: 
// 25.2.1, copy: 

template < class InputIterator , class OutputIterator > 
OutputIterator copy(InputIterator first , InputIterator last , 
OutputIterator result ); 
template <class BidirectionalIterator1 , class BidirectionalIterator2 > 
BidirectionalIterator2 
copy_backward 
( BidirectionalIterator1 first , BidirectionalIterator1 last , 
BidirectionalIterator2 result ); 

// 25.2.2, swap: 

template <class T> void swap(T& a, T& b); 
template < class ForwardIterator1 , class ForwardIterator2 > 
ForwardIterator2 swap_ranges(ForwardIterator1 first1 , 
ForwardIterator1 last1 , ForwardIterator2 first2 ); 
template < class ForwardIterator1 , class ForwardIterator2 > 
void iter_swap(ForwardIterator1 a , ForwardIterator2 b ); 

template < class InputIterator , class OutputIterator , class UnaryOperation > 
OutputIterator transform(InputIterator first , InputIterator last , 
OutputIterator result , UnaryOperation op ); 
template < class InputIterator1 , class InputIterator2 , class OutputIterator , 
class BinaryOperation > 

OutputIterator transform(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , OutputIterator result ,
BinaryOperation binary_op );


template <class ForwardIterator , class T> 
void replace(ForwardIterator first , ForwardIterator last , 
const T& old_value , const T& new_value ); 
template <class ForwardIterator , class Predicate , class T> 
void replace_if(ForwardIterator first , ForwardIterator last , 
Predicate pred , const T& new_value ); 
template <class InputIterator , class OutputIterator , class T> 

OutputIterator replace_copy(InputIterator first , InputIterator last ,
OutputIterator result ,
const T& old_value , const T& new_value );


template < class InputIterator , class OutputIterator , class Predicate , class T > 
OutputIterator replace_copy_if(InputIterator first , InputIterator last , 

Draft 


Algorithms library 630 

OutputIterator result ,
Predicate pred , const T& new_value );


template <class ForwardIterator , class T> 
void fill(ForwardIterator first , ForwardIterator last , const T & value ); 
template <class OutputIterator , class Size , class T> 
void fill_n(OutputIterator first , Size n , const T& value ); 

template < class ForwardIterator , class Generator > 
void generate(ForwardIterator first , ForwardIterator last , 
Generator gen ); 
template < class OutputIterator , class Size , class Generator > 
void generate_n ( OutputIterator first , Size n , Generator gen ); 

template <class ForwardIterator , class T> 
ForwardIterator remove(ForwardIterator first , ForwardIterator last , 
const T & value ); 
template < class ForwardIterator , class Predicate > 
ForwardIterator remove_if(ForwardIterator first , ForwardIterator last , 
Predicate pred ); 
template <class InputIterator , class OutputIterator , class T> 
OutputIterator remove_copy(InputIterator first , InputIterator last , 
OutputIterator result , const T& value ); 
template < class InputIterator , class OutputIterator , class Predicate > 
OutputIterator remove_copy_if(InputIterator first , InputIterator last , 
OutputIterator result , Predicate pred ); 

template < class ForwardIterator > 
ForwardIterator unique(ForwardIterator first , ForwardIterator last ); 
template < class ForwardIterator , class BinaryPredicate > 
ForwardIterator unique(ForwardIterator first , ForwardIterator last , 
BinaryPredicate pred ); 
template < class InputIterator , class OutputIterator > 
OutputIterator unique_copy(InputIterator first , InputIterator last , 
OutputIterator result ); 
template < class InputIterator , class OutputIterator , class BinaryPredicate > 
OutputIterator unique_copy(InputIterator first , InputIterator last , 
OutputIterator result , BinaryPredicate pred ); 

template <class BidirectionalIterator > 
void reverse(BidirectionalIterator first , BidirectionalIterator last ); 
template <class BidirectionalIterator , class OutputIterator > 

OutputIterator reverse_copy(BidirectionalIterator first ,
BidirectionalIterator last ,
OutputIterator result );


template < class ForwardIterator > 
void rotate(ForwardIterator first , ForwardIterator middle , 
ForwardIterator last ); 
template < class ForwardIterator , class OutputIterator > 

Draft 


631 Algorithms library 

OutputIterator rotate_copy
( ForwardIterator first , ForwardIterator middle ,
ForwardIterator last , OutputIterator result );


template <class RandomAccessIterator > 
void random_shuffle(RandomAccessIterator first , 
RandomAccessIterator last ); 
template <class RandomAccessIterator , class RandomNumberGenerator > 

void random_shuffle(RandomAccessIterator first ,
RandomAccessIterator last ,
RandomNumberGenerator & rand );


// 25.2.12, partitions: 

template <class BidirectionalIterator , class Predicate > 

BidirectionalIterator partition(BidirectionalIterator first ,
BidirectionalIterator last ,
Predicate pred );


template <class BidirectionalIterator , class Predicate > 

BidirectionalIterator stable_partition(BidirectionalIterator first ,
BidirectionalIterator last ,
Predicate pred );


// 25.3, sorting and related operations: 
// 25.3.1, sorting: 

template <class RandomAccessIterator > 
void sort(RandomAccessIterator first , RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void sort(RandomAccessIterator first , RandomAccessIterator last , 
Compare comp ); 

template <class RandomAccessIterator > 
void stable_sort(RandomAccessIterator first , RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void stable_sort(RandomAccessIterator first , RandomAccessIterator last , 
Compare comp ); 

template <class RandomAccessIterator > 

void partial_sort(RandomAccessIterator first ,
RandomAccessIterator middle ,
RandomAccessIterator last );


template <class RandomAccessIterator , class Compare > 

void partial_sort(RandomAccessIterator first ,
RandomAccessIterator middle ,
RandomAccessIterator last , Compare comp );


template <class InputIterator , class RandomAccessIterator > 
RandomAccessIterator 

partial_sort_copy ( InputIterator first , InputIterator last ,
RandomAccessIterator result_first ,
RandomAccessIterator result_last );


template <class InputIterator , class RandomAccessIterator , class Compare > 

Draft 


Algorithms library 632 

RandomAccessIterator 

partial_sort_copy ( InputIterator first , InputIterator last ,
RandomAccessIterator result_first ,
RandomAccessIterator result_last ,
Compare comp );


template <class RandomAccessIterator > 
void nth_element(RandomAccessIterator first , RandomAccessIterator nth , 
RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void nth_element(RandomAccessIterator first , RandomAccessIterator nth , 
RandomAccessIterator last , Compare comp ); 

// 25.3.3, binary search: 

template <class ForwardIterator , class T> 
ForwardIterator lower_bound(ForwardIterator first , ForwardIterator last , 
const T& value ); 
template < class ForwardIterator , class T , class Compare > 
ForwardIterator lower_bound(ForwardIterator first , ForwardIterator last , 
const T& value , Compare comp ); 

template <class ForwardIterator , class T> 
ForwardIterator upper_bound(ForwardIterator first , ForwardIterator last , 
const T& value ); 
template < class ForwardIterator , class T , class Compare > 
ForwardIterator upper_bound(ForwardIterator first , ForwardIterator last , 
const T& value , Compare comp ); 

template <class ForwardIterator , class T> 
pair < ForwardIterator , ForwardIterator > 
equal_range ( ForwardIterator first , ForwardIterator last , 
const T& value ); 
template < class ForwardIterator , class T , class Compare > 
pair < ForwardIterator , ForwardIterator > 
equal_range ( ForwardIterator first , ForwardIterator last , 
const T& value , Compare comp ); 

template <class ForwardIterator , class T> 
bool binary_search(ForwardIterator first , ForwardIterator last , 
const T& value ); 
template < class ForwardIterator , class T , class Compare > 
bool binary_search(ForwardIterator first , ForwardIterator last , 
const T& value , Compare comp ); 

// 25.3.4, merge: 

template < class InputIterator1 , class InputIterator2 , class OutputIterator > 

OutputIterator merge(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 , class OutputIterator , 

Draft 


633 Algorithms library 

class Compare > 

OutputIterator merge(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


template <class BidirectionalIterator > 

void inplace_merge(BidirectionalIterator first ,
BidirectionalIterator middle ,
BidirectionalIterator last );


template <class BidirectionalIterator , class Compare > 

void inplace_merge(BidirectionalIterator first ,
BidirectionalIterator middle ,
BidirectionalIterator last , Compare comp );


// 25.3.5, set operations: 

template < class InputIterator1 , class InputIterator2 > 
bool includes(InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 ); 
template < class InputIterator1 , class InputIterator2 , class Compare > 
bool includes 
( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 , Compare comp ); 

template < class InputIterator1 , class InputIterator2 , class OutputIterator > 

OutputIterator set_union(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 , class OutputIterator , 
class Compare > 

OutputIterator set_union(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


template < class InputIterator1 , class InputIterator2 , class OutputIterator > 
OutputIterator set_intersection 

( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 , class OutputIterator , 
class Compare > 
OutputIterator set_intersection 

( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


template < class InputIterator1 , class InputIterator2 , class OutputIterator > 
OutputIterator set_difference 

( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


Draft 


Algorithms library 634 

template < class InputIterator1 , class InputIterator2 , class OutputIterator , 
class Compare > 
OutputIterator set_difference 

( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


template < class InputIterator1 , class InputIterator2 , class OutputIterator > 
OutputIterator 

set_symmetric_difference ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 , 
OutputIterator result ); 

template < class InputIterator1 , class InputIterator2 , class OutputIterator , 
class Compare > 
OutputIterator 

set_symmetric_difference ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 , 
OutputIterator result , Compare comp ); 

// 25.3.6, heap operations: 

template <class RandomAccessIterator > 
void push_heap(RandomAccessIterator first , RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void push_heap(RandomAccessIterator first , RandomAccessIterator last , 
Compare comp ); 

template <class RandomAccessIterator > 
void pop_heap(RandomAccessIterator first , RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void pop_heap(RandomAccessIterator first , RandomAccessIterator last , 
Compare comp ); 

template <class RandomAccessIterator > 
void make_heap(RandomAccessIterator first , RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void make_heap(RandomAccessIterator first , RandomAccessIterator last , 
Compare comp ); 

template <class RandomAccessIterator > 
void sort_heap(RandomAccessIterator first , RandomAccessIterator last ); 
template <class RandomAccessIterator , class Compare > 
void sort_heap(RandomAccessIterator first , RandomAccessIterator last , 
Compare comp ); 

// 25.3.7, minimum and maximum: 

template <class T> const T& min(const T& a , const T& b ); 
template < class T , class Compare > 

const T& min(const T& a , const T& b , Compare comp ); 
template <class T> const T& max(const T& a , const T& b ); 
template < class T , class Compare > 

Draft 


635 Algorithms library 

const T& max(const T& a , const T& b , Compare comp ); 

template < class ForwardIterator > 
ForwardIterator min_element 
( ForwardIterator first , ForwardIterator last ); 
template < class ForwardIterator , class Compare > 
ForwardIterator min_element(ForwardIterator first , ForwardIterator last , 
Compare comp ); 
template < class ForwardIterator > 
ForwardIterator max_element 
( ForwardIterator first , ForwardIterator last ); 
template < class ForwardIterator , class Compare > 
ForwardIterator max_element(ForwardIterator first , ForwardIterator last , 
Compare comp ); 

template < class InputIterator1 , class InputIterator2 >
bool lexicographical_compare
( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 );
template < class InputIterator1 , class InputIterator2 , class Compare >
bool lexicographical_compare


( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
Compare comp );


// 25.3.9, permutations: 

template <class BidirectionalIterator >
bool next_permutation(BidirectionalIterator first ,
BidirectionalIterator last );
template <class BidirectionalIterator , class Compare >
bool next_permutation(BidirectionalIterator first ,
BidirectionalIterator last , Compare comp );
template <class BidirectionalIterator >
bool prev_permutation(BidirectionalIterator first ,
BidirectionalIterator last );
template <class BidirectionalIterator , class Compare >
bool prev_permutation(BidirectionalIterator first ,
BidirectionalIterator last , Compare comp );
}


3 All of the algorithms are separated from the particular implementations of data structures and are parameterized by 
iterator types. Because of this, theycan work with program-defined data structures, as long as these data structures have 
iterator types satisfying the assumptions on the algorithms. 

4 Throughout this clause, the names of template parameters are used to express type requirements. If an algorithm’s 
template parameter is InputIterator, InputIterator1, or InputIterator2, the actual template argument shall 
satisfy the requirements of an input iterator(24.1.1). If an algorithm’s template parameter is OutputIterator, OutputIterator1, or OutputIterator2, the actual template argument shall satisfy the requirements of an output iterator 
(24.1.2). If an algorithm’s template parameter is ForwardIterator, ForwardIterator1, or ForwardIterator2, 

Draft 


Algorithms library 636 

the actual template argument shall satisfy the requirementsofa forward iterator(24.1.3). If an algorithm’s template 
parameter is BidirectionalIterator, BidirectionalIterator1, or BidirectionalIterator2, the actual template argument shall satisfy the requirementsofa bidirectional iterator(24.1.4). If an algorithm’s template parameter 
is RandomAccessIterator, RandomAccessIterator1, or RandomAccessIterator2, the actual template argument 
shall satisfy the requirementsofa random-access iterator(24.1.5). 

5 If an algorithm’s Effects section says that a value pointed to by anyiterator passed as an argument is modified, then 
that algorithm has an additional type requirement: The type of that argument shall satisfy the requirements of a mutable 
iterator(24.1).[Note: thisrequirementdoesnotaffectargumentsthatare declaredas OutputIterator, OutputIterator1, or OutputIterator2, because output iterators must always be mutable. — end note ] 

6 Both in-place and copyingversions are provided for certain algorithms.262) When suchaversionis provided for algorithm it is called algorithm_copy. Algorithms that take predicates end with the suffix _if (which follows the suffix 
_copy). 

7 The Predicate parameter is used whenever an algorithm expects a function object that when applied to the result 
of dereferencing the corresponding iterator returns a value testable as true. In other words, if an algorithm takes 
Predicate pred as its argument and first as its iterator argument, it should work correctly in the construct if 
(pred (*first )){...}. The functionobject pred shall not apply anynon-constant function through the dereferenced 
iterator. This function object may be a pointer to function, or an object of a type with an appropriate function call 
operator. 

8 The BinaryPredicate parameter is used whenever an algorithm expects a function object that when applied to the 
result of dereferencing two corresponding iterators or to dereferencing an iterator and type T when T is part of the 
signature returns a value testable as true. In other words, if an algorithm takes BinaryPredicate binary_pred as 
its argument and first1 and first2 asits iteratorarguments,it shouldwork correctlyinthe construct if (binary_
pred (*first1 ,*first2 )){...}. BinaryPredicate always takes the first iterator type as its first argument, that 
is, in those cases when T value is part of the signature, it should work correctly in the context of if (binary_
pred (*first1 , value )){...}. binary_pred shall not apply anynon-constant function through the dereferenced 
iterators. 

9[Note: Unless otherwise specified, algorithms that take function objects as arguments are permitted to copythose functionobjectsfreely. Programmersforwhomobjectidentityisimportantshould considerusingawrapperclassthatpoints 
to a noncopied implementation object, or some equivalent solution. — end note ] 

10 When the description of an algorithm gives an expression such as *first == value for a condition, the expression 
shallevaluateto either trueorfalsein boolean contexts. 

11 In the description of the algorithms operators + and -are used for someof theiterator categoriesfor which theydo not 
have to be defined. In these cases the semantics of a+n is the same as that of 

{X tmp = a;
advance(tmp , n);
return tmp ;


} 

and that of b-a is the same as of 

262) The decision whether to include a copying version was usually based on complexity considerations. When the cost of doing the operation 

dominates the cost of copy, the copying version is not included. For example, sort_copy is not included because the cost of sorting is much more 

significant, and users might as well do copy followed by sort. 

Draft 


637 Algorithms library 25.1 Non-modifying sequence operations 

return distance(a, b); 

25.1 Non-modifying sequence operations [lib.alg.nonmodifying] 
25.1.1 For each [lib.alg.foreach] 
template < class InputIterator , class Function >
Function for_each(InputIterator first , InputIterator last , Function f );


1 Effects: Applies f to the resultofdereferencingevery iteratorinthe range [first ,last ), starting from first 
and proceeding to last -1. 
2 Returns: f . 
3 Complexity: Applies f exactly last -first times. 
4 Remarks: If f returnsa result, the resultis ignored. 

25.1.2 Find [lib.alg.find] 
template <class InputIterator , class T>
InputIterator find(InputIterator first , InputIterator last ,
const T& value );


template < class InputIterator , class Predicate >
InputIterator find _if(InputIterator first , InputIterator last ,
Predicate pred );


1 Returns: The first iterator i in the range [first ,last ) for which the following corresponding conditions hold: 
*i == value , pred (*i) != false. Returns last if no such iterator is found. 

2 Complexity: At most last -first applications of the corresponding predicate. 

25.1.3 Find End [lib.alg.find.end] 
template < class ForwardIterator1 , class ForwardIterator2 >
ForwardIterator1
find_end ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 , ForwardIterator2 last2 );


template < class ForwardIterator1 , class ForwardIterator2 ,
class BinaryPredicate >
ForwardIterator1


find_end ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 , ForwardIterator2 last2 ,
BinaryPredicate pred );


1 Effects: Finds a subsequence of equal values in a sequence. 

Draft 


25.1 Non-modifying sequence operations Algorithms library 638 
2 Returns: The last iterator i in the range [first1 ,last1 -(last2 -first2 )) such that for any nonnegative integer n<(last2 -first2 ), the following corresponding conditions hold: *(i + n) == *( 
first2 + n), pred (*(i + n), *(first2 + n)) != false. Returns last1 if no such iterator is found. 

3 Complexity: At most (last2 -first2 )*(last1 -first1 -(last2 -first2 ) + 1) applications 
of the corresponding predicate. 

25.1.4 Find First [lib.alg.find.first.of] 
template < class ForwardIterator1 , class ForwardIterator2 >
ForwardIterator1
find_first_of ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 , ForwardIterator2 last2 );


template < class ForwardIterator1 , class ForwardIterator2 ,
class BinaryPredicate >
ForwardIterator1


find_first_of ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 , ForwardIterator2 last2 ,
BinaryPredicate pred );


1 Effects: Finds an element that matches one of a set of values. 

2 Returns: The first iterator i in the range [first1 ,last1 ) such that for some iterator j in the range [first2 , 
last2 ) the following conditions hold: *i == *j, pred (*i,*j) != false. Returns last1 if no such iterator is found. 

3 Complexity: At most (last1 -first1 )*(last2 -first2 ) applications of the corresponding predicate. 

25.1.5 Adjacent find [lib.alg.adjacent.find] 
template < class ForwardIterator >
ForwardIterator adjacent_find(ForwardIterator first , ForwardIterator last );


template < class ForwardIterator , class BinaryPredicate >
ForwardIterator adjacent_find(ForwardIterator first , ForwardIterator last ,
BinaryPredicate pred );


1 Returns: The first iterator i such that both i and i+1 are in the range [first ,last ) for which the following 
corresponding conditions hold: *i == *(i + 1), pred (*i, *(i + 1)) != false. Returns last if no 
such iterator is found. 

2 Complexity: For a nonemptyrange, exactlymin((i -first ) + 1, (last -first ) -1) applications of 
the corresponding predicate, where i is adjacent_find’s return value. 

25.1.6 Count [lib.alg.count] 
Draft 


639 Algorithms library 25.1 Non-modifying sequence operations 

template <class InputIterator , class T>
typename iterator_traits <InputIterator >::difference_type
count ( InputIterator first , InputIterator last , const T& value );


template < class InputIterator , class Predicate >
typename iterator_traits <InputIterator >::difference_type
count_if ( InputIterator first , InputIterator last , Predicate pred );


1 Effects: Returns the number of iterators i in the range [first ,last ) for which the following corresponding 
conditions hold: *i == value , pred (*i) != false. 

2 Complexity: Exactly last -first applications of the corresponding predicate. 

25.1.7 Mismatch [lib.mismatch] 
template < class InputIterator1 , class InputIterator2 >
pair < InputIterator1 , InputIterator2 >
mismatch ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 );


template < class InputIterator1 , class InputIterator2 ,
class BinaryPredicate >
pair < InputIterator1 , InputIterator2 >
mismatch ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , BinaryPredicate pred );


1 Returns: Apair of iteratorsi and j such that j == first2 + (i -first1 ) and i is the first iterator in the 
range [first1 ,last1 ) for which the following corresponding conditions hold: 

!(*i == *( first2 +(i -first1 )))
pred (*i, *( first2 +(i -first1 ))) == false


Returns the pair last1 and first2 +(last1 -first1 ) if such an iterator i is not found. 
2 Complexity: At most last1 -first1 applications of the corresponding predicate. 

25.1.8 Equal [lib.alg.equal] 
template < class InputIterator1 , class InputIterator2 >
bool equal(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 );


template < class InputIterator1 , class InputIterator2 ,
class BinaryPredicate >
bool equal(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , BinaryPredicate pred );


1 Returns: true if forevery iterator i in the range [first1 ,last1 ) the following corresponding conditions hold: 

*i == *(first2 + (i -first1 )), pred (*i, *(first2 + (i -first1 ))) != false. Otherwise, 

returns false. 

Draft 


25.2 Mutating sequence operations Algorithms library 640 
2 Complexity: At most last1 -first1 applications of the corresponding predicate. 

25.1.9 Search [lib.alg.search] 
template < class ForwardIterator1 , class ForwardIterator2 >
ForwardIterator1
search ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 , ForwardIterator2 last2 );


template < class ForwardIterator1 , class ForwardIterator2 ,
class BinaryPredicate >
ForwardIterator1


search ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 , ForwardIterator2 last2 ,
BinaryPredicate pred );


1 Effects: Finds a subsequence of equal values in a sequence. 

2 Returns: The first iterator i in the range [first1 ,last1 -(last2 -first2 )) such that for anynon-negative 
integer n less than last2 -first2 the following corresponding conditions hold: *(i + n) == *(first2 + 
n), pred (*(i + n), *(first2 + n)) != false. Returns last1 if no such iterator is found. 

3 Complexity: At most (last1 -first1 )*(last2 -first2 ) applications of the corresponding predicate. 

template <class ForwardIterator , class Size , class T>
ForwardIterator
search_n ( ForwardIterator first , ForwardIterator last , Size count ,
const T& value );


template <class ForwardIterator , class Size , class T,
class BinaryPredicate >
ForwardIterator
search_n ( ForwardIterator first , ForwardIterator last , Size count ,
const T& value , BinaryPredicate pred );


4 Requires: The type Size is convertible to integral type(4.7, 12.3). 

5 Effects: Finds a subsequence of equal values in a sequence. 

6 Returns: The first iterator i in the range [first ,last -count ) such that for any non-negative integer n less 
than count the following corresponding conditions hold: *(i + n) == value , pred (*(i + n),value ) 
!= false. Returns last if no such iterator is found. 

7 Complexity: At most (last -first )* count applications of the corresponding predicate if count is positive, or0otherwise. 

25.2 Mutating sequence operations [lib.alg.modifying.operations] 
25.2.1 Copy [lib.alg.copy] 
Draft 


641 Algorithms library 25.2 Mutating sequence operations 

template < class InputIterator , class OutputIterator >
OutputIterator copy(InputIterator first , InputIterator last ,
OutputIterator result );


1 Effects: Copies elements in the range [first ,last ) into the range [result ,result +(last -first )) 
starting from first and proceeding to last . For each non-negative integer n<(last -first ), performs 
*(result + n) = *(first + n). 

2 Returns: result +(last -first ). 
3 Requires: result shall not be in the range [first ,last ). 
4 Complexity: Exactly last -first assignments. 

template <class BidirectionalIterator1 , class BidirectionalIterator2 >
BidirectionalIterator2


copy_backward ( BidirectionalIterator1 first ,
BidirectionalIterator1 last ,
BidirectionalIterator2 result );


5 Effects: Copies elements in the range [first ,last ) into the range [result -(last -first ),result ) 
starting from last -1 and proceeding to first .263) For each positive integern <= (last -first ), performs *(result -n) = *(last -n). 

6 Requires: result shall not be in the range [first ,last ). 
7 Returns: result -(last -first ). 
8 Complexity: Exactly last -first assignments. 

25.2.2 Swap [lib.alg.swap] 
template <class T> void swap(T& a , T& b ); 

1 Requires: TypeT is CopyConstructible (20.1.3)andAssignable (23.1). 
2 Effects: Exchanges values stored in two locations. 

template < class ForwardIterator1 , class ForwardIterator2 >
ForwardIterator2
swap_ranges ( ForwardIterator1 first1 , ForwardIterator1 last1 ,
ForwardIterator2 first2 );


3 Effects: For each non-negativeintegern<(last1 -first1 ) performs: swap(*(first1 + n), *(first2 

+ n)). 
4 Requires: The two ranges [first1 ,last1 ) and [first2 ,first2 +(last1 -first1 )) shall not overlap. The type of *first1 shall be the same as the type of *first2 and that type shall satisfy the Swappable 
requirements(20.1.4). 

5 Returns: first2 +(last1 -first1 ). 

263) copy_backward should be used instead of copywhen last is in the range [result -(last -first ),result ). 

Draft 


25.2 Mutating sequence operations Algorithms library 642 
6 Complexity: Exactly last1 -first1 swaps. 

template < class ForwardIterator1 , class ForwardIterator2 >
void iter_swap(ForwardIterator1 a , ForwardIterator2 b );


7 Effects: swap(*a ,*b ). 

8 Requires: The type of *a shall be the same as the type of *b and that type shall satisfy the Swappable requirements 
(20.1.4). 

25.2.3 Transform [lib.alg.transform] 
template < class InputIterator , class OutputIterator ,
class UnaryOperation >
OutputIterator
transform ( InputIterator first , InputIterator last ,
OutputIterator result , UnaryOperation op );


template < class InputIterator1 , class InputIterator2 ,
class OutputIterator , class BinaryOperation >
OutputIterator


transform ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , OutputIterator result ,
BinaryOperation binary_op );


1 Effects: Assigns through every iterator i in the range [result ,result +(last1 -first1 )) a new corresponding value equal to op (*(first1 + (i -result )) or binary_op (*(first1 + (i -result ), 
*(first2 + (i -result ))). 

2 Requires: op and binary_op shall not invalidate iterators or subranges, or modify elements in the ranges [ 

first1 ,last1 ],[first2 ,first2 +(last1 -first1 )],and[result ,result +(last1 -first1 ) 
].264) 

3 Returns: result +(last1 -first1 ). 

4 Complexity: Exactly last1 -first1 applications of op or binary_op . 

5 Remarks: result may be equal to first in case of unary transform, or to first1 or first2 in case of binary 
transform. 

25.2.4 Replace [lib.alg.replace] 
template <class ForwardIterator , class T>
void replace(ForwardIterator first , ForwardIterator last ,
const T& old_value , const T & new_value );


template < class ForwardIterator , class Predicate , class T >
void replace_if(ForwardIterator first , ForwardIterator last ,
Predicate pred , const T& new_value );


264)The useof fully closed rangesis intentional. 

Draft 


643 Algorithms library 25.2 Mutating sequence operations 

1 Requires: The expression *first = new_value must be valid. 
2 Effects: Substitutes elements referred by the iterator i in the range [first ,last ) with new_value , when the 
following corresponding conditions hold: *i == old_value , pred (*i) != false. 
3 Complexity: Exactly last -first applications of the corresponding predicate. 

template < class InputIterator , class OutputIterator , class T >
OutputIterator


replace_copy ( InputIterator first , InputIterator last ,
OutputIterator result ,
const T& old_value , const T & new_value );


template <class InputIterator , class OutputIterator , class Predicate , class T>
OutputIterator


replace_copy_if ( InputIterator first , InputIterator last ,
OutputIterator result ,
Predicate pred , const T& new_value );


4 Requires: The resultsoftheexpressions *first and new_value shall be writable to the result output iterator. 
The ranges [first ,last ) and [result ,result +(last -first )) shall not overlap. 

5 Effects: Assigns to every iterator i in the range [result ,result +(last -first )) either new_value or 
*(first + (i -result )) depending on whether the following corresponding conditions hold: 

*( first +(i -result )) == old_value
pred (*( first +(i -result ))) != false
6 Returns: result +(last -first ).
7 Complexity: Exactly last -first applications of the corresponding predicate.


25.2.5 Fill [lib.alg.fill] 
template <class ForwardIterator , class T>
void fill(ForwardIterator first , ForwardIterator last , const T& value );


template <class OutputIterator , class Size , class T>
void fill_ n(OutputIterator first , Size n , const T& value );


1 Requires: The expression value shallbe writabletothe output iterator.Thetype Size shall be convertible to an 
integral type(4.7, 12.3). 

2 Effects: The first algorithm assigns value through all the iterators in the range [first ,last ). The second 
algorithm assigns value through all the iterators in the range [first ,first + n ) if n is positive, otherwise 
it does nothing. 

3 Complexity: Exactly last -first , n , or0assignments, respectively. 

25.2.6 Generate [lib.alg.generate] 
Draft 


25.2 Mutating sequence operations Algorithms library 644 
template < class ForwardIterator , class Generator >
void generate(ForwardIterator first , ForwardIterator last ,
Generator gen );


template < class OutputIterator , class Size , class Generator >
void generate_n(OutputIterator first , Size n , Generator gen );


1 Effects: The first algorithm invokes the function object gen and assigns the return value of gen through all the 
iterators in the range [first ,last ). The second algorithm invokes the function object gen and assigns the 
returnvalue of gen through all the iterators in the range [first ,first + n ) if n is positive, otherwiseitdoes 
nothing. 

2 Requires: gen takes no arguments, Size is convertible to an integraltype(4.7, 12.3). 

3 Complexity: Exactly last -first , n , or0invocationsof gen and assignments, respectively. 

25.2.7 Remove [lib.alg.remove] 
template <class ForwardIterator , class T>
ForwardIterator remove(ForwardIterator first , ForwardIterator last ,
const T& value );


template < class ForwardIterator , class Predicate >
ForwardIterator remove_if(ForwardIterator first , ForwardIterator last ,
Predicate pred );


1 Requires: The type of *first shall satisfy the Assignable requirements(23.1). 
2 Effects: Eliminates all the elements referred toby iterator i in the range [first ,last ) for which the following 
corresponding conditions hold: *i == value , pred (*i) != false. 
3 Returns: The end of the resulting range. 

4 Remarks: Stable.
5 Complexity: Exactly last -first applications of the corresponding predicate.


template < class InputIterator , class OutputIterator , class T >
OutputIterator
remove_copy ( InputIterator first , InputIterator last ,
OutputIterator result , const T& value );


template < class InputIterator , class OutputIterator , class Predicate >
OutputIterator
remove_copy_if ( InputIterator first , InputIterator last ,
OutputIterator result , Predicate pred );


6 Requires: Type T is EqualityComparable (20.1.1). The ranges [first ,last ) and [result ,result + 
(last -first )) shall not overlap. 

7 Effects: Copies all the elements referred to by the iterator i in the range [first ,last ) for which the following 
corresponding conditions do not hold: *i == value , pred (*i) != false. 

Draft 


645 Algorithms library 25.2 Mutating sequence operations 

8 Returns: The end of the resulting range. 
9 Complexity: Exactly last -first applications of the corresponding predicate. 
10 Remarks: Stable. 

25.2.8 Unique [lib.alg.unique] 
template < class ForwardIterator >
ForwardIterator unique(ForwardIterator first , ForwardIterator last );


template < class ForwardIterator , class BinaryPredicate >
ForwardIterator unique(ForwardIterator first , ForwardIterator last ,
BinaryPredicate pred );


1 Effects: Fora nonempty range, eliminates allbut the first element fromevery consecutive groupof equivalent 
elements referred to by the iterator i in the range [first + 1,last ) for whichthe following conditions hold: 
*(i -1) == *i or pred (*(i -1), *i) != false. 

2 Requires: The comparison function shall be an equivalence relation.
3 Returns: The end of the resulting range.
4 Complexity: For nonempty ranges, exactly(last -first )-1 applications of the corresponding predicate.


template < class InputIterator , class OutputIterator >
OutputIterator
unique_copy ( InputIterator first , InputIterator last ,
OutputIterator result );


template < class InputIterator , class OutputIterator ,
class BinaryPredicate >
OutputIterator
unique_copy ( InputIterator first , InputIterator last ,
OutputIterator result , BinaryPredicate pred );


5 Requires: The ranges [first ,last ) and [result ,result +(last -first )) shall not overlap. The expression *result =*first shall be valid. If neither InputIterator nor OutputIterator meets the requirements of forward iterator then the value type of InputIterator shallbeCopyConstructible(20.1.3). Otherwise 
CopyConstructible is not required. 

6 Effects: Copies only the first element from every consecutive group of equal elements referred to by the iterator 
i in the range [first ,last ) for which the following corresponding conditions hold: *i == *(i -1) or 
pred (*i, *(i -1)) != false. 

7 Returns: The end of the resulting range. 

8 Complexity: For nonempty ranges, exactlylast -first -1 applications of the corresponding predicate. 

25.2.9 Reverse [lib.alg.reverse] 
Draft 


25.2 Mutating sequence operations Algorithms library 646 
template < class BidirectionalIterator >
void reverse(BidirectionalIterator first , BidirectionalIterator last );


1 Effects: For each non-negative integer i <= (last -first )/2, applies iter_swap to all pairs of iterators 
first + i, (last -i) -1. 
2 Requires: The type of *first shall satisfy the Swappable requirements(20.1.4). 
3 Complexity: Exactly (last -first )/2 swaps. 

template < class BidirectionalIterator , class OutputIterator >
OutputIterator
reverse_copy ( BidirectionalIterator first ,
BidirectionalIterator last , OutputIterator result );


4 Effects: Copies the range [first ,last ) to the range [result ,result +(last -first )) such that for any 
non-negative integer i<(last -first ) the following assignment takes place: *(result +(last 
first ) -i) = *(first + i). 

5 Requires: The ranges [first ,last ) and [result ,result +(last -first )) shall not overlap.
6 Returns: result +(last -first ).
7 Complexity: Exactly last -first assignments.


25.2.10 Rotate [lib.alg.rotate] 
template < class ForwardIterator >
void rotate(ForwardIterator first , ForwardIterator middle ,
ForwardIterator last );


1 Effects: For each non-negative integeri<(last -first ), places the element from the position first +i 
into position first + (i + (last -middle )) % (last -first ). 
2 Remarks: This is a left rotate. 
3 Requires: [first ,middle ) and [middle ,last ) are valid ranges. The type of *first shall satisfy the Swappable requirements(20.1.4). 
4 Complexity: At most last -first swaps. 

template < class ForwardIterator , class OutputIterator >
OutputIterator
rotate_copy ( ForwardIterator first , ForwardIterator middle ,
ForwardIterator last , OutputIterator result );


5 Effects: Copies the range [first ,last ) to the range [result ,result +(last -first )) such that for 
each non-negative integer i<(last -first ) the following assignment takes place: *(result + i) = 
*(first + (i + (middle -first )) % (last -first )). 

6 Returns: result +(last -first ). 

7 Requires: The ranges [first ,last ) and [result ,result +(last -first )) shall not overlap. 

Draft 


647 Algorithms library 25.2 Mutating sequence operations 

8 Complexity: Exactly last -first assignments. 

25.2.11 Random shuffle [lib.alg.random.shuffle] 
template <class RandomAccessIterator >
void random_shuffle(RandomAccessIterator first ,
RandomAccessIterator last );


template <class RandomAccessIterator , class RandomNumberGenerator > 

void random_shuffle(RandomAccessIterator first ,
RandomAccessIterator last ,
RandomNumberGenerator & rand );


1 Effects: Shuffles the elements in the range [first ,last ) with uniform distribution. 

2 Requires: The type of *first shall satisfy the Swappable requirements(20.1.4). 

3 Complexity: Exactly (last -first )-1 swaps. 

4 Remarks: The underlying source of random numbers for the first form of the function is implementation-defined. 
An implementation may use the rand function from the standard C library. The second form of the function 
takes a random number generating function object rand such that if n is an argument for rand , with a positive 
value, that has typeiterator_traits<RandomAccessIterator>::difference_type,thenrand (n) returns 
a randomly chosenvalue, whichliesinthe interval[0,n),and whichhasatypethatisconvertibletoiterator_
traits<RandomAccessIterator>::difference_type. 

25.2.12 Partitions [lib.alg.partitions] 
template < class BidirectionalIterator , class Predicate >
BidirectionalIterator
partition ( BidirectionalIterator first ,
BidirectionalIterator last , Predicate pred );


1 Effects: Places all the elements in the range [first ,last ) that satisfy pred before all the elements that do not 
satisfy it. 

2 Returns: An iterator i such that for anyiterator j in the range [first ,i) pred (*j) != false, and for any 
iterator k in the range [i,last ), pred (*k) == false. 

3 Requires: The type of *first shall satisfy the Swappable requirements(20.1.4). 

4 Complexity: At most (last -first )/2 swaps. Exactly last -first applications of the predicate are 
done. 

template < class BidirectionalIterator , class Predicate >
BidirectionalIterator
stable_partition ( BidirectionalIterator first ,
BidirectionalIterator last , Predicate pred );


Draft 


25.3 Sorting and related operations Algorithms library 648 
5 Effects: Places all the elements in the range [first ,last ) that satisfy pred before all the elements that do not 
satisfy it. 

6 Returns: An iterator i such that for anyiterator j in the range [first ,i), pred (*j) != false, and for any 
iterator k in the range [i,last ), pred (*k) == false. The relative order of the elements in both groups is 
preserved. 

7 Requires: The type of *first shall satisfy the Swappable requirements(20.1.4). 

8 Complexity: At most (last -first ) * log(last -first ) swaps, but only linear number of swaps if 
there is enough extra memory. Exactly last -first applications of the predicate. 

25.3 Sorting and related operations [lib.alg.sorting] 
1 All the operations in 25.3 have two versions: one that takes a function object of type Compare and one that uses an 
operator<. 

2 Compare is used as a function object which returns true if the first argument is less than the second, and false 
otherwise. Compare comp is used throughout for algorithms assuming an ordering relation. It is assumed that comp 
will not apply anynon-constantfunction through the dereferenced iterator. 

3 For all algorithms that take Compare, there is a version that uses operator< instead. That is, comp (*i, *j) != 
false defaults to *i < *j != false.For algorithms otherthanthose describedin 25.3.3towork correctly, comp has 
to induce a strict weak ordering on the values. 

4 The term strict refers to the requirement of an irreflexive relation(!comp (x, x) for all x), and the term weak to 
requirements that are not as strong as those fora total ordering,but stronger than those fora partial ordering. If we 
define equiv(a, b) as !comp (a, b) && !comp (b, a), then the requirements are that comp and equiv both be 
transitive relations: 

— comp (a, b) && comp (b, c) implies comp (a, c) 
— equiv(a, b) && equiv(b, c) implies equiv(a, c) [Note: Under these conditions, it can be shown that 
— equiv is an equivalence relation 
— comp induces a well-defined relation on the equivalence classes determined by equiv 
— The induced relation is a stricttotal ordering. — end note ] 
5 A sequence is sorted with respect to a comparator comp if for anyiterator i pointing to the sequence and any nonnegative integer n such that i+n is a valid iterator pointing to an element of the sequence, comp (*(i + n), *i) 
== false. 

6 Asequence[start, finish) is partitioned with respect to an expression f(e) if there exists an integer n such that 
for all 0 <= i < distance(start, finish), f(*(begin + i)) is true if and only if i<n. 

7 In the descriptions of the functions that deal with ordering relationships we frequently use a notion of equivalence 
to describe concepts such as stability. The equivalence to which we refer is not necessarily an operator==, but an 
equivalence relation induced by the strict weak ordering. That is, two elements a and b are considered equivalent if and 
only if !(a < b) && !(b < a). 

Draft 


649 Algorithms library 25.3 Sorting and related operations 

25.3.1 Sorting [lib.alg.sort] 
25.3.1.1 sort [lib.sort] 
template <class RandomAccessIterator >
void sort(RandomAccessIterator first , RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void sort(RandomAccessIterator first , RandomAccessIterator last ,
Compare comp );


1 Effects: Sorts the elements in the range [first ,last ).
2 Requires: The type of *first shall satisfy the Swappable requirements(20.1.4).
3 Complexity: Approximately Nlog(N) (where N == last -first )comparisons on the average.265)


25.3.1.2 stable_sort [lib.stable.sort] 
template <class RandomAccessIterator >
void stable_sort(RandomAccessIterator first , RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void stable_sort(RandomAccessIterator first , RandomAccessIterator last ,
Compare comp );


1 Effects: Sorts the elements in the range [first ,last ).
2 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4).
3 Complexity: It does at most Nlog2(N) (where N == last -first )comparisons;if enoughextra memoryis


available, it is Nlog(N). 
4 Remarks: Stable. 

25.3.1.3 partial_sort [lib.partial.sort] 
template <class RandomAccessIterator > 

void partial_sort(RandomAccessIterator first ,
RandomAccessIterator middle ,
RandomAccessIterator last );


template <class RandomAccessIterator , class Compare > 

void partial_sort(RandomAccessIterator first ,
RandomAccessIterator middle ,
RandomAccessIterator last ,
Compare comp );


265) If the worst case behavior is important stable_sort() (25.3.1.2)orpartial_sort() (25.3.1.3)should be used. 

Draft 


25.3 Sorting and related operations Algorithms library 650 
1 Effects: Places the first middle -first sorted elements from the range [first ,last ) into the range [ 
first ,middle ). The rest of the elements in the range [middle ,last ) are placed in an unspecified order. 

2 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4). 
3 Complexity: It takes approximately (last -first ) * log(middle -first ) comparisons. 

25.3.1.4 partial_sort_copy [lib.partial.sort.copy] 
template <class InputIterator , class RandomAccessIterator >
RandomAccessIterator


partial_sort_copy ( InputIterator first , InputIterator last ,
RandomAccessIterator result_first ,
RandomAccessIterator result_last );


template <class InputIterator , class RandomAccessIterator ,
class Compare >
RandomAccessIterator


partial_sort_copy ( InputIterator first , InputIterator last ,
RandomAccessIterator result_first ,
RandomAccessIterator result_last ,
Compare comp );


1 Effects: Places the first min(last -first , result_last -result_first ) sorted elements into the range 
[result_first ,result_first + min(last -first , result_last -result_first )). 
2 Returns: The smaller of: result_last or result_first +(last -first ). 
3 Requires: The type of *result_first shall satisfy theSwappable requirements(20.1.4). 
4 Complexity: Approximately (last -first ) * log(min(last -first , result_last -result_first )) 
comparisons. 

25.3.2 Nth element [lib.alg.nth.element] 
template <class RandomAccessIterator >
void nth_element(RandomAccessIterator first , RandomAccessIterator nth ,
RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void nth_element(RandomAccessIterator first , RandomAccessIterator nth ,
RandomAccessIterator last , Compare comp );


1 After nth_element the element in the position pointed to by nth is the element that would be in that position if 
the whole range were sorted. Also for anyiterator i in the range [first ,nth ) and anyiterator j in the range 
[nth ,last ) it holds that: !(*i > *j) or comp (*j, *i) == false. 

2 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4). 

3 Complexity: Linear on average. 

Draft 


651 Algorithms library 25.3 Sorting and related operations 

25.3.3 Binary search [lib.alg.binary.search] 
1 All of the algorithms in this section are versions of binary search and assume that the sequence being searched is 
partitioned with respecttoanexpression formedby bindingthe searchkey toanargumentofthe impliedorexplicit 
comparison function. They work on non-random access iterators minimizing the number of comparisons, which will 
be logarithmic for all types of iterators. They are especially appropriate for random access iterators, because these 
algorithmsdoalogarithmicnumberofstepsthroughthedata structure.For non-random access iteratorsthey executea 
linear number of steps. 

25.3.3.1 lower_bound [lib.lower.bound] 
template <class ForwardIterator , class T>
ForwardIterator
lower_bound ( ForwardIterator first , ForwardIterator last ,
const T& value );


template < class ForwardIterator , class T , class Compare >
ForwardIterator
lower_bound ( ForwardIterator first , ForwardIterator last ,
const T& value , Compare comp );


1 Requires: The elements e of [first ,last ) are partitioned with respecttotheexpression e < value or comp (e, 
value). 

2 Returns: The furthermost iterator i in the range [first ,last ] such that for anyiterator j in the range [first , 
i) the following corresponding conditions hold: *j < value or comp (*j, value ) != false. 

3 Complexity: At most log(last -first )+1 comparisons. 

25.3.3.2 upper_bound [lib.upper.bound] 
template <class ForwardIterator , class T>
ForwardIterator
upper_bound ( ForwardIterator first , ForwardIterator last ,
const T& value );


template < class ForwardIterator , class T , class Compare >
ForwardIterator
upper_bound ( ForwardIterator first , ForwardIterator last ,
const T& value , Compare comp );


1 Requires: The elements e of [first ,last ) are partitioned with respect to the expression !(value < e) or 
!comp (value, e). 

2 Returns: The furthermost iterator i in the range [first ,last ) such that for anyiterator j in the range [first , 
i) the following corresponding conditions hold: !(value < *j) or comp (value , *j) == false. 

3 Complexity: At most log(last -first )+1 comparisons. 

Draft 


25.3 Sorting and related operations Algorithms library 652 
25.3.3.3 equal_range [lib.equal.range] 
template <class ForwardIterator , class T>
pair < ForwardIterator , ForwardIterator >
equal_range ( ForwardIterator first ,
ForwardIterator last , const T& value );


template < class ForwardIterator , class T , class Compare >
pair < ForwardIterator , ForwardIterator >


equal_range ( ForwardIterator first ,
ForwardIterator last , const T& value ,
Compare comp );


1 Requires: The elements e of [first ,last ) are partitioned with respect to the expressions e < value and 
!(value < e) or comp (e, value) and !comp (value, e). Also, for all elements e of [first , last ), e 
< value implies !(value < e) or comp (e, value) implies !comp (value, e). 

2 Returns: 

make_pair ( lower_bound (first , last , value ),
upper_bound (first , last , value ))


or 

make_pair ( lower_bound (first , last , value , comp ),
upper_bound (first , last , value , comp ))


3 Complexity: At most 2 * log(last -first )+1 comparisons. 

25.3.3.4 binary_search [lib.binary.search] 
template <class ForwardIterator , class T>
bool binary_search(ForwardIterator first , ForwardIterator last ,
const T& value );


template < class ForwardIterator , class T , class Compare >
bool binary_search(ForwardIterator first , ForwardIterator last ,
const T& value , Compare comp );


1 Requires: The elements e of [first ,last ) are partitioned with respect to the expressions e < value and 
!(value < e) or comp (e, value) and !comp (value, e). Also, for all elements e of [first , last ), e 
< value implies !(value < e) or comp (e, value) implies !comp (value, e). 

2 Returns: true if there is an iterator i in the range [first ,last ) that satisfies the corresponding conditions: !(*i < value ) && !(value < *i) or comp (*i, value ) == false && comp (value , *i) == 
false. 

3 Complexity: At most log(last -first )+2 comparisons. 

Draft 


653 Algorithms library 25.3 Sorting and related operations 

25.3.4 Merge [lib.alg.merge] 
template < class InputIterator1 , class InputIterator2 ,
class OutputIterator >
OutputIterator


merge ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 ,
class OutputIterator , class Compare >
OutputIterator


merge ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


1 Effects: Merges two sorted ranges [first1 ,last1 ) and [first2 ,last2 ) into the range [result ,result 

+(last1 -first1 )+(last2 -first2 )). 
2 The resulting range shall not overlap with either of the original ranges. The list will be sorted in non-decreasing 
order accordingtothe ordering definedby comp ;thatis,forevery iteratori in [first ,last ) other than first , 
the condition *i < *(i -1) or comp (*i, *(i -1)) will befalse. 
3 Returns: result +(last1 -first1 )+(last2 -first2 ). 
4 Complexity: At most (last1 -first1 )+(last2 -first2 )-1 comparisons. 
5 Remarks: Stable. 

template <class BidirectionalIterator > 

void inplace_merge(BidirectionalIterator first ,
BidirectionalIterator middle ,
BidirectionalIterator last );


template <class BidirectionalIterator , class Compare > 

void inplace_merge(BidirectionalIterator first ,
BidirectionalIterator middle ,
BidirectionalIterator last , Compare comp );


6 Effects: Merges two sorted consecutive ranges [first ,middle ) and [middle ,last ), putting the result of the 
merge into the range [first ,last ). The resulting range will be in non-decreasing order; that is, for every 
iterator i in [first ,last ) other than first , the condition *i < *(i -1) or, respectively, comp (*i, *(i 
-1)) will befalse. 

7 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4). 

8 Complexity: When enough additional memoryisavailable, (last -first )-1 comparisons. If no additional 
memory is available, an algorithm with complexity Nlog(N) (where N is equal to last -first )may be used. 

9 Remarks: Stable. 

Draft 


25.3 Sorting and related operations Algorithms library 654 
25.3.5 Set operations on sorted structures [lib.alg.set.operations] 
1 This section defines all the basic set operations on sortedstructures. Theyalsowork with multisets(23.3.4)containing 
multiple copies of equivalent elements. The semantics of the set operations are generalized to multisets in a standard 
way by defining set_union() to contain the maximum number of occurrences of every element, set_intersection() to contain the minimum, and so on. 

25.3.5.1 includes [lib.includes] 
template < class InputIterator1 , class InputIterator2 >
bool includes ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 );


template < class InputIterator1 , class InputIterator2 , class Compare > 

bool includes ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
Compare comp );


1 Returns: true if every element in the range [first2 ,last2 ) is contained in the range [first1 ,last1 ). 
Returns false otherwise. 

2 Complexity: At most 2 * ((last1 -first1 )+(last2 -first2 )) -1 comparisons. 

25.3.5.2 set_union [lib.set.union] 
template < class InputIterator1 , class InputIterator2 ,
class OutputIterator >
OutputIterator


set_union ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 ,
class OutputIterator , class Compare >
OutputIterator


set_union ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


1 Effects: Constructs a sorted union of the elements from the two ranges; that is, the set of elements that are present 
in one or both of the ranges. 

2 Requires: The resulting range shall not overlap with either of the original ranges. 

3 Returns: The end of the constructed range. 

4 Complexity: At most 2 * ((last1 -first1 )+(last2 -first2 )) -1 comparisons. 

5 Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,last2) contains n elements that are equivalent to them, then all m elementsfromthe first range shallbe copiedtothe output 

Draft 


655 Algorithms library 25.3 Sorting and related operations 

range, in order, and then max(n- m,0) elements from the second range shall be copied to the output range, in 
order. 

25.3.5.3 set_intersection [lib.set.intersection] 
template < class InputIterator1 , class InputIterator2 ,
class OutputIterator >
OutputIterator


set_intersection ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 ,
class OutputIterator , class Compare >
OutputIterator


set_intersection ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


1 Effects: Constructs a sorted intersection of the elements from the two ranges; that is, the set of elements that are 
present in both of the ranges. 

2 Requires: The resulting range shall not overlap with either of the original ranges. 

3 Returns: The end of the constructed range. 

4 Complexity: At most 2 * ((last1 -first1 )+(last2 -first2 )) -1 comparisons. 

5 Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,last2) contains n elements that are equivalent to them, the first min(m,n) elements shall be copied from the first range to the 
output range, in order. 

25.3.5.4 set_difference [lib.set.difference] 
template < class InputIterator1 , class InputIterator2 ,
class OutputIterator >
OutputIterator


set_difference ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result );


template < class InputIterator1 , class InputIterator2 ,
class OutputIterator , class Compare >
OutputIterator


set_difference ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 ,
OutputIterator result , Compare comp );


1 Effects: Copies the elements of the range [first1 ,last1 ) which are not present in the range [first2 ,last2 
) to the range beginning at result. The elements in the constructed range are sorted. 

Draft 


25.3 Sorting and related operations Algorithms library 656 
2 Requires: The resulting range shall not overlap with either of the original ranges.
3 Returns: The end of the constructed range.
4 Complexity: At most 2 * ((last1 -first1 )+(last2 -first2 )) -1 comparisons.
5 Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,last2) con


tains n elements that are equivalent to them, the last max(m- n,0) elements from [first1,last1) shall be 
copied to the output range. 

25.3.5.5 set_symmetric_difference [lib.set.symmetric.difference] 
template < class InputIterator1 , class InputIterator2 ,
class OutputIterator >
OutputIterator


set_symmetric_difference ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 , 
OutputIterator result ); 

template < class InputIterator1 , class InputIterator2 ,
class OutputIterator , class Compare >
OutputIterator


set_symmetric_difference ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 , 
OutputIterator result , Compare comp ); 

1 Effects: Copies the elements of the range [first1 ,last1 ) which are not present in the range [first2 ,last2 
), and the elements of the range [first2 ,last2 ) which are not present in the range [first1 ,last1 ) to the 
range beginning at result. The elements in the constructed range are sorted. 

2 Requires: The resulting range shall not overlap with either of the original ranges. 

3 Returns: The end of the constructed range. 

4 Complexity: At most 2 * ((last1 -first1 )+(last2 -first2 )) -1 comparisons. 

5 Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,last2) contains n elements that are equivalent to them, then |m- n| of those elements shall be copied to the output range: 
the last m- n of these elements from [first1,last1) if m > n, and the last n- m of these elements from 
[first2,last2) if m < n. 

25.3.6 Heap operations [lib.alg.heap.operations] 
1A heap is a particular organization of elements in a range between two random access iterators [a,b). Its twokey 
properties are: 

(1) There is no element greater than *a in the range and 
(2) *a maybe removedby pop_heap(), or a new element added by push_heap(), in O(log(N)) time. 
Draft 


657 Algorithms library 25.3 Sorting and related operations 

2 These properties make heaps useful as priority queues.
3 make_heap() converts a range into a heap and sort_heap() turns a heap into a sorted sequence.


25.3.6.1 push_heap [lib.push.heap] 
template <class RandomAccessIterator >
void push_heap(RandomAccessIterator first , RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void push_heap(RandomAccessIterator first , RandomAccessIterator last ,
Compare comp );


1 Effects: Places the value in the location last -1 into the resulting heap [first ,last ).
2 Requires: The range [first ,last -1) shall be a valid heap.
3 Complexity: At most log(last -first ) comparisons.


25.3.6.2 pop_heap [lib.pop.heap] 
template <class RandomAccessIterator >
void pop_heap(RandomAccessIterator first , RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void pop_heap(RandomAccessIterator first , RandomAccessIterator last ,
Compare comp );


1 Effects: Swapsthevalueinthe location first withthevalueinthe location last -1 andmakes [first ,last 
-1) into a heap. 

2 Requires: The range [first ,last ) shall be a valid heap. The type of *first shall satisfy the Swappable 
requirements(20.1.4). 

3 Complexity: At most 2 * log(last -first ) comparisons. 

25.3.6.3 make_heap [lib.make.heap] 
template <class RandomAccessIterator >
void make_heap(RandomAccessIterator first , RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void make_heap(RandomAccessIterator first , RandomAccessIterator last ,
Compare comp );


1 Effects: Constructs a heap out of the range [first ,last ). 
2 Complexity: At most 3*(last -first ) comparisons. 

Draft 


25.3 Sorting and related operations Algorithms library 658 
25.3.6.4 sort_heap [lib.sort.heap] 
template <class RandomAccessIterator >
void sort_heap(RandomAccessIterator first , RandomAccessIterator last );


template <class RandomAccessIterator , class Compare >
void sort_heap(RandomAccessIterator first , RandomAccessIterator last ,
Compare comp );


1 Effects: Sorts elements in the heap [first ,last ).
2 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4).
3 Complexity: At most Nlog(N) comparisons (where N == last -first ).


25.3.7 Minimum and maximum [lib.alg.min.max] 
template <class T> const T& min(const T& a , const T& b );
template < class T , class Compare >
const T& min(const T& a , const T& b , Compare comp );


1 Requires: TypeT is LessThanComparable (20.1.2).
2 Returns: The smaller value.
3 Remarks: Returns the first argument when the arguments are equivalent.


template <class T> const T& max(const T& a , const T& b );
template < class T , class Compare >
const T& max(const T& a , const T& b , Compare comp );


4 Requires: TypeT is LessThanComparable (20.1.2).
5 Returns: The larger value.
6 Remarks: Returns the first argument when the arguments are equivalent.


template < class ForwardIterator >
ForwardIterator min_element(ForwardIterator first , ForwardIterator last );


template < class ForwardIterator , class Compare >
ForwardIterator min_element(ForwardIterator first , ForwardIterator last ,
Compare comp );


7 Returns: The first iterator i in the range [first ,last ) such that for anyiterator j in the range [first ,last 
) the following corresponding conditions hold: !(*j < *i) or comp (*j, *i) == false. Returns last if 
first == last . 

8 Complexity: Exactly max((last -first ) -1, 0) applications of the corresponding comparisons. 

template < class ForwardIterator >
ForwardIterator max_element(ForwardIterator first , ForwardIterator last );
template < class ForwardIterator , class Compare >


Draft 


659 Algorithms library 25.3 Sorting and related operations 

ForwardIterator max_element(ForwardIterator first , ForwardIterator last ,
Compare comp );


9 Returns: The first iterator i in the range [first ,last ) such that for anyiterator j in the range [first ,last 
) the following corresponding conditions hold: !(*i < *j) or comp (*i, *j) == false. Returns last if 
first == last . 

10 Complexity: Exactly max((last -first ) -1, 0) applications of the corresponding comparisons. 

25.3.8 Lexicographical comparison [lib.alg.lex.comparison] 
template < class InputIterator1 , class InputIterator2 >
bool
lexicographical_compare ( InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 , InputIterator2 last2 );


template < class InputIterator1 , class InputIterator2 , class Compare >
bool


lexicographical_compare ( InputIterator1 first1 , InputIterator1 last1 , 
InputIterator2 first2 , InputIterator2 last2 , 
Compare comp ); 

1 Returns: true if the sequence of elements defined by the range [first1 ,last1 ) is lexicographically less than 
the sequenceof elementsdefinedby the range [first2 ,last2 ). 

Returns false otherwise. 

2 Complexity: At most 2*min((last1 -first1 ), (last2 -first2 )) applications of the corresponding 
comparison. 

3 Remarks: If two sequences have the same number of elements and their corresponding elements are equivalent, 
then neither sequence is lexicographically less than the other. If one sequence is a prefix of the other, then the 
shorter sequence is lexicographically less than the longer sequence. Otherwise, the lexicographicalcomparison 
ofthe sequencesyieldsthesameresultasthe comparisonofthefirst correspondingpairof elementsthatarenot 
equivalent. 

for (; first1 != last1 && first2 != last2 ; ++first1 , ++first2 ){ 
if (* first1 <* first2 ) return true ; 
if (* first2 <* first1 ) return false ; 

}
return first1 == last1 && first2 != last2 ;


25.3.9 Permutation generators [lib.alg.permutation.generators] 
template < class BidirectionalIterator >
bool next_permutation(BidirectionalIterator first ,
BidirectionalIterator last );


template < class BidirectionalIterator , class Compare > 

Draft 


25.4 Clibrary algorithms Algorithms library 660 
bool next_permutation(BidirectionalIterator first ,
BidirectionalIterator last , Compare comp );


1 Effects: Takesa sequence definedbythe range[first ,last ) and transforms it into the nextpermutation. The 
next permutation is found by assuming that the set of all permutations is lexicographically sorted with respect to 
operator< or comp . If such a permutation exists, it returns true. Otherwise, it transforms the sequence into the 
smallest permutation, that is, the ascendingly sorted one, and returns false. 

2 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4). 

3 Complexity: At most (last -first )/2 swaps. 

template < class BidirectionalIterator >
bool prev_permutation(BidirectionalIterator first ,
BidirectionalIterator last );


template < class BidirectionalIterator , class Compare >
bool prev_permutation(BidirectionalIterator first ,
BidirectionalIterator last , Compare comp );


4 Effects: Takes a sequence defined by the range[first ,last ) and transforms it into the previous permutation. 
The previous permutation is found by assuming that the set of all permutations is lexicographically sorted with 
respect to operator< or comp . 

5 Returns: true if such a permutation exists. Otherwise, it transforms the sequence into the largest permutation, 
that is, the descendingly sorted one, and returns false. 

6 Requires: The type of *first shall satisfy theSwappablerequirements(20.1.4). 

7 Complexity: At most (last -first )/2 swaps. 

25.4 Clibrary algorithms [lib.alg.c.library] 
1 Header <cstdlib> (partial,Table 81). 

Table 81: Header<cstdlib> synopsis 

Type Name(s) 
Type: size_t 
Functions: bsearch qsort 

2 The contents are the same as the StandardClibrary header <stdlib.h> with the following exceptions: 
3 The function signature: 

bsearch ( const void * , const void * , size _t , size _t ,
int (*)( const void * , const void *));


is replaced by the two declarations: 

extern "C" void *bsearch(const void * key , const void * base ,
size _t nmemb , size _t size ,


Draft 


661 Algorithms library 25.4 Clibrary algorithms 

int (* compar )( const void * , const void *)); 

extern "C++" void *bsearch(const void * key , const void * base ,
size _t nmemb , size _t size ,
int (* compar )( const void * , const void *));


both of which have the same behavior as the original declaration.
The function signature:


qsort ( void * , size _t , size _t ,
int (*)( const void * , const void *));


is replaced by the two declarations: 

extern "C" void qsort(void* base , size_t nmemb , size_t size ,
int (* compar )( const void * , const void *));
extern "C++" void qsort(void* base , size _t nmemb , size_t size ,
int (* compar )( const void * , const void *));


both of which have the same behavior as the original declaration. The behavior is undefined unless the objects in the 
array pointed toby base are of POD type. 

[Note: Because the function argument compar() may throw an exception, bsearch() and qsort() are allowed to 
propagate theexception(17.4.4.8). — end note ] 

SEEALSO: ISOCsubclause 7.10.5. 

Draft 


25.4 Clibrary algorithms Algorithms library 662 
Draft 


Chapter 26 Numerics library [lib.numerics]


1 This clause describes components thatC++ programs may use to perform seminumerical operations. 

2 The following subclauses describe components for complex number types, numeric(n-at-a-time) arrays, generalized 
numeric algorithms, andfacilities included from the ISOClibrary, as summarizedinTable 82. 

Table 82: Numerics library summary 

Subclause Header(s) 
26.1 Requirements 
26.2 Complex Numbers <complex> 
26.3 Numeric arrays <valarray> 
26.4 Generalized numeric operations <numeric> 
26.5 Clibrary <cmath> 
<cstdlib> 

26.1 Numeric type requirements [lib.numeric.requirements] 
1 The complex and valarray components are parameterizedby the typeof information theycontain and manipulate.A 
C++ program shall instantiate these components only with a type T that satisfies the following requirements:266) 

— T is not an abstract class (it has no pure virtual member functions); 
— T is not a reference type; 
— T is not cv-qualified; 
— If T is a class, it has a public default constructor; 
— If T is a class, it has a public copyconstructor with the signature T ::T (const T &) 
— If T is a class, it has a public destructor; 
— If T isa class,ithasa public assignmentoperator whose signatureis either T & T ::operator=(const T &) or 
T & T ::operator=(T ) 
— If T is a class, its assignment operator, copy and default constructors, and destructor shall correspond to each 
other in the following sense: Initialization of raw storage using the default constructor, followed by assignment, 
266) In otherwords,value types. These includebuilt-in arithmetic types, pointers, the library class complex, and instantiations of valarray for 
value types. 


26.2 Complex numbers Numerics library 664 
is semantically equivalent to initialization of raw storage using the copy constructor. Destruction of an object, 
followed by initialization of its raw storage using the copyconstructor, is semantically equivalent to assignment 
to the original object. 

[Note: This rule states that there shall not be any subtle differences in the semantics of initialization versus 
assignment. This gives an implementation considerable flexibility in how arrays are initialized. 

[Example: An implementation is allowedto initialize a valarray by allocating storage using the new operator 
(which impliesa call to the default constructor for each element) and then assigning each element itsvalue. Or the 
implementation can allocate raw storage and use the copyconstructor to initialize each element. — end example ] 

Ifthe distinction between initializationand assignmentis importantfora class,orifitfailsto satisfyanyofthe 
other conditions listed above, the programmer should use vector (23.2.4)instead ofvalarray for that class; 

— end note ] 
— If T is a class, it does not overloadunary operator&. 
2 If anyoperation on T throws an exception the effects are undefined. 
3 In addition, manymember and related functionsof valarray<T > canbe successfully instantiatedandwillexhibit well-
defined behavior if and only if T satisfies additional requirements specified for each such member or related function. 
4[Example: It is valid to instantiate valarray<complex >,but operator>() will not be successfully instantiated for 
valarray<complex > operands, since complex does not have anyordering operators. — end example ] 

26.2 Complex numbers [lib.complex.numbers] 
1 The header <complex> defines a class template, and numerous functions for representing and manipulating complex 
numbers. 

2 Theeffectof instantiatingthe template complex for anytype other than float, double or long double is unspecified. 

3 If the result of a function is not mathematically defined or not in the range of representable values for its type, the 
behavior is undefined. 

26.2.1 Header <complex> synopsis [lib.complex.synopsis] 
namespace std {
template < class T > class complex ;
template <> class complex <float >;
template <> class complex <double >;
template <> class complex <long double >;


// 26.2.6 operators: 

template <class T> 

complex <T > operator +( const complex <T >& , const complex <T >&);
template < class T > complex <T > operator +( const complex <T >& , const T &);
template <class T> complex <T> operator+(const T&, const complex <T>&);


template < class T > complex <T > operator 
( const complex <T >& , const complex <T >&);
template < class T > complex <T > operator -( const complex <T >& , const T &);


Draft 


665 Numerics library 26.2 Complex numbers 

template <class T> complex <T> operator -(const T&, const complex <T>&); 

template < class T > complex <T > operator * 

( const complex <T >& , const complex <T >&); 
template < class T > complex <T > operator *( const complex <T >& , const T &); 
template <class T> complex <T> operator*(const T&, const complex <T>&); 

template < class T > complex <T > operator / 

( const complex <T >& , const complex <T >&); 
template < class T > complex <T > operator /( const complex <T >& , const T &); 
template <class T> complex <T> operator/(const T&, const complex <T>&); 

template < class T > complex <T > operator +( const complex <T >&); 
template < class T > complex <T > operator -( const complex <T >&); 

template < class T > bool operator = = 

( const complex <T >& , const complex <T >&); 
template < class T > bool operator == ( const complex <T >& , const T &); 
template<class T> bool operator== (const T&, const complex<T>&); 

template < class T > bool operator != ( const complex <T >& , const complex <T >&); 
template < class T > bool operator != ( const complex <T >& , const T &); 
template<class T> bool operator!= (const T&, const complex<T>&); 

template < class T , class charT , class traits > 
basic_istream <charT , traits >& 

operator >>(basic_ istream <charT , traits >&, complex <T>&); 
template < class T , class charT , class traits > 
basic_ostream <charT , traits >& 

operator <<(basic_ ostream <charT , traits >&, const complex <T>&); 
// 26.2.7 values: 

template < class T > T real ( const complex <T >&);
template < class T > T imag ( const complex <T >&);


template < class T > T abs ( const complex <T >&);
template < class T > T arg ( const complex <T >&);
template < class T > T norm ( const complex <T >&);


template < class T > complex <T > conj ( const complex <T >&);
template <class T> complex <T> polar(const T& rho , const T & theta = 0);


// 26.2.8 transcendentals: 

template < class T > complex <T > cos ( const complex <T >&); 
template < class T > complex <T > cosh ( const complex <T >&); 
template < class T > complex <T > exp ( const complex <T >&); 
template < class T > complex <T > log ( const complex <T >&); 
template < class T > complex <T > log10 ( const complex <T >&); 

Draft 


26.2 Complex numbers Numerics library 666 
template <class T> complex <T> pow(const complex <T>&, int);
template <class T> complex <T> pow(const complex <T>&, const T&);
template <class T> complex <T> pow(const complex <T>&, const complex <T>&);
template <class T> complex <T> pow(const T&, const complex <T>&);


template < class T > complex <T > sin ( const complex <T >&);
template < class T > complex <T > sinh ( const complex <T >&);
template < class T > complex <T > sqrt ( const complex <T >&);
template < class T > complex <T > tan ( const complex <T >&);
template < class T > complex <T > tanh ( const complex <T >&);


} 

26.2.2 Class template complex [lib.complex] 
namespace std {
template <class T>
class complex {
public :


typedef T value_type; 

complex(const T& re = T(), const T& im = T ());
complex ( const complex &);
template < class X > complex ( const complex <X >&);


T real () const ;
T imag () const ;


complex <T >& operator = ( const T &);
complex <T >& operator +=( const T &);
complex <T >& operator -=( const T &);
complex <T >& operator *=( const T &);
complex <T >& operator /=( const T &);


complex & operator =( const complex &);
template < class X > complex <T >& operator = ( const complex <X >&);
template < class X > complex <T >& operator +=( const complex <X >&);
template < class X > complex <T >& operator -=( const complex <X >&);
template < class X > complex <T >& operator *=( const complex <X >&);
template < class X > complex <T >& operator /=( const complex <X >&);


}; 

} 

The class complex describes an object that can store the Cartesian components, real() and imag(), of a complex 
number. 

26.2.3 complex specializations [lib.complex.special] 
template <> class complex <float > {
public :
typedef float value_type;


Draft 


667 Numerics library 26.2 Complex numbers 

complex(float re = 0.0f, float im = 0.0f);
explicit complex(const complex <double >&);
explicit complex ( const complex < long double >&);


float real () const ;
float imag () const ;


complex<float>& operator= (float);
complex<float>& operator+=(float);
complex<float>& operator -=(float);
complex<float>& operator*=(float);
complex<float>& operator/=(float);


complex <float >& operator= (const complex <float >&);
template < class X > complex < float >& operator = ( const complex <X >&);
template < class X > complex < float >& operator +=( const complex <X >&);
template < class X > complex < float >& operator -=( const complex <X >&);
template < class X > complex < float >& operator *=( const complex <X >&);
template < class X > complex < float >& operator /=( const complex <X >&);


}; 

template <> class complex <double > { 
public : 
typedef double value_type ; 

complex ( double re = 0.0 , double im = 0.0);
complex ( const complex < float >&);
explicit complex ( const complex < long double >&);


double real () const ;
double imag () const ;


complex < double >& operator = ( double );
complex < double >& operator +=( double );
complex < double >& operator -=( double );
complex < double >& operator *=( double );
complex < double >& operator /=( double );


complex < double >& operator = ( const complex < double >&);
template < class X > complex < double >& operator = ( const complex <X >&);
template < class X > complex < double >& operator +=( const complex <X >&);
template < class X > complex < double >& operator -=( const complex <X >&);
template < class X > complex < double >& operator *=( const complex <X >&);
template < class X > complex < double >& operator /=( const complex <X >&);


}; 

template <> class complex <long double > { 
public : 
typedef long double value_type; 

Draft 


26.2 Complex numbers Numerics library 668 
complex(long double re = 0.0L, long double im = 0.0L);
complex ( const complex < float >&);
complex ( const complex < double >&);


long double real () const ;
long double imag () const ;


complex < long double >& operator = ( const complex < long double >&);
complex < long double >& operator = ( long double );
complex < long double >& operator += ( long double );
complex < long double >& operator -= ( long double );
complex < long double >& operator *= ( long double );
complex < long double >& operator /= ( long double );


template < class X > complex < long double >& operator = ( const complex <X >&); 
template < class X > complex < long double >& operator +=( const complex <X >&); 
template < class X > complex < long double >& operator -=( const complex <X >&); 
template < class X > complex < long double >& operator *=( const complex <X >&); 
template < class X > complex < long double >& operator /=( const complex <X >&); 

}; 

26.2.4 complex member functions [lib.complex.members] 
template <class T> complex(const T& re = T(), const T& im = T ()); 

1 Effects: Constructs an object of class complex. 
2 Postcondition:real() == re && imag() == im . 

26.2.5 complex member operators [lib.complex.member.ops] 
template <class T> complex<T>& operator+=(const T& rhs ); 

1 Effects: Adds the scalarvalue rhs tothe realpartofthe complexvalue *this and stores the result in the real part 
of *this, leaving the imaginary part unchanged. 

2 Returns: *this. 

template <class T> complex<T>& operator -=(const T& rhs ); 

3 Effects: Subtracts the scalar value rhs from the real part of the complex value *this and stores the result in the 
real part of *this, leaving the imaginary part unchanged. 

4 Returns: *this. 

template <class T> complex<T>& operator*=(const T& rhs ); 

5 Effects: Multiplies the scalar value rhs by the complex value *this and stores the result in *this. 
6 Returns: *this. 

Draft 


669 Numerics library 26.2 Complex numbers 

template <class T> complex<T>& operator/=(const T& rhs ); 

7 Effects: Divides the scalar value rhs into the complex value *this and stores the result in *this.
8 Returns: *this.


template < class T > complex <T >& operator +=( const complex <T >& rhs ); 

9 Effects: Adds the complex value rhs to the complex value *this and stores the sum in *this. 
10 Returns: *this. 

template < class T > complex <T >& operator -=( const complex <T >& rhs ); 

11 Effects: Subtracts the complex value rhs from the complex value *this and stores the differencein *this. 
12 Returns: *this. 

template < class T > complex <T >& operator *=( const complex <T >& rhs ); 

13 Effects: Multiplies the complex value rhs by the complex value *this and stores the product in *this. 
Returns: *this. 

template < class T > complex <T >& operator /=( const complex <T >& rhs ); 

14 Effects: Divides the complex value rhs into the complex value *this and stores the quotient in *this. 
15 Returns: *this. 

26.2.6 complex non-member operations [lib.complex.ops] 
template < class T > complex <T > operator +( const complex <T >& lhs ); 

1 Remarks: unary operator.
2 Returns: complex<T>(lhs ).


template <class T> 

complex <T > operator +( const complex <T >& lhs , const complex <T >& rhs ); 
template < class T > complex <T > operator +( const complex <T >& lhs , const T& rhs ); 
template <class T> complex <T> operator+(const T& lhs , const complex <T >& rhs ); 

3 Returns: complex<T>(lhs ) += rhs .
template < class T > complex <T > operator -( const complex <T >& lhs );


4 Remarks: unary operator.
5 Returns: complex<T>(-lhs .real(),-lhs .imag()).


template <class T> 

complex <T > operator -( const complex <T >& lhs , const complex <T >& rhs );
template < class T > complex <T > operator -( const complex <T >& lhs , const T & rhs );
template < class T > complex <T > operator -( const T & lhs , const complex <T >& rhs );


Draft 


26.2 Complex numbers Numerics library 670 
6 Returns: complex<T>(lhs ) -= rhs . 

template <class T> 

complex <T > operator *( const complex <T >& lhs , const complex <T >& rhs );
template < class T > complex <T > operator *( const complex <T >& lhs , const T & rhs );
template < class T > complex <T > operator *( const T & lhs , const complex <T >& rhs );


7 Returns: complex<T>(lhs ) *= rhs . 

template <class T> 

complex <T > operator /( const complex <T >& lhs , const complex <T >& rhs );
template < class T > complex <T > operator /( const complex <T >& lhs , const T & rhs );
template < class T > complex <T > operator /( const T & lhs , const complex <T >& rhs );


8 Returns: complex<T>(lhs ) /= rhs . 

template <class T> 

bool operator = =( const complex <T >& lhs , const complex <T >& rhs );
template < class T > bool operator ==( const complex <T >& lhs , const T& rhs );
template<class T> bool operator==(const T& lhs , const complex <T >& rhs );


9 Returns: lhs .real() == rhs .real() && lhs .imag() == rhs .imag(). 
10 Remarks: The imaginary part is assumed to be T(), or 0.0, for the T arguments. 

template <class T> 

bool operator ! =( const complex <T >& lhs , const complex <T >& rhs );
template < class T > bool operator !=( const complex <T >& lhs , const T& rhs );
template<class T> bool operator!=(const T& lhs , const complex <T >& rhs );


11 Returns: rhs .real() != lhs .real() || rhs .imag() != lhs .imag(). 

template < class T , class charT , class traits >
basic_istream <charT , traits >&


operator >>(basic_istream <charT , traits >& is , complex <T >& x ); 
12 Effects: Extractsacomplexnumber x of the form: u,(u),or(u,v),whereu is the real part and v is the imaginary 
part(27.6.1.2). 
13 Requires: The input values be convertible to T. 
If bad input is encountered, calls is .setstate(ios::failbit) (which may throw ios::failure (27.4.4.3). 

14 Returns: is . 

15 Remarks: This extraction is performed as a series of simpler extractions. Therefore, the skippingof whitespace is 
specified to be the same for each of the simpler extractions. 

template < class T , class charT , class traits >
basic_ostream <charT , traits >&


operator <<(basic_ostream <charT , traits >& o , const complex <T >& x ); 
16 Effects: inserts the complex number x onto the stream o as if it were implemented as follows: 

template < class T , class charT , class traits > 

Draft 


671 Numerics library 26.2 Complex numbers 

basic_ostream < charT , traits >& 

operator <<(basic_ostream <charT , traits >& o, const complex <T>& x) 
{
basic_ostringstream <charT , traits > s;


s. flags (o. flags ());
s. imbue (o. getloc ());
s.precision(o.precision ());
s << ’(’ << x.real() << "," << x.imag() << ’)’;
return o << s.str();
} 

26.2.7 complex value operations [lib.complex.value.ops] 
template < class T > T real ( const complex <T >& x ); 

1 Returns: x .real(). 

template < class T > T imag ( const complex <T >& x ); 

2 Returns: x .imag(). 

template < class T > T abs ( const complex <T >& x ); 
3 Returns: the magnitude of x . 

template < class T > T arg ( const complex <T >& x ); 

4 Returns: the phase angle of x , or atan2(imag(x ), real(x )). 

template < class T > T norm ( const complex <T >& x ); 
5 Returns: the squared magnitude of x . 

template < class T > complex <T > conj ( const complex <T >& x ); 
6 Returns: the complex conjugate of x . 

template <class T> complex <T> polar(const T& rho , const T& theta = 0); 

7 Returns: the complex value correspondingtoa complex number whose magnitudeis rho and whose phase angle 
is theta . 

26.2.8 complex transcendentals [lib.complex.transcendentals] 
template < class T > complex <T > cos ( const complex <T >& x ); 
1 Returns: the complex cosine of x . 

template < class T > complex <T > cosh ( const complex <T >& x ); 
2 Returns: the complexhyperbolic cosineof x . 

Draft 


26.3 Numeric arrays Numerics library 672 
template < class T > complex <T > exp ( const complex <T >& x );
3 Returns: the complex base e exponential of x .
template < class T > complex <T > log ( const complex <T >& x );


4 Remarks: the branch cuts are along the negative real axis. 

5 Returns: the complex natural (base e) logarithm of x , in the range of a strip mathematically unbounded along the 
real axis and in the interval [-i times pi,i times pi] along the imaginary axis. When x is a negative real 
number, imag(log(x )) is pi. 

template < class T > complex <T > log10 ( const complex <T >& x ); 

6 Remarks: the branch cuts are along the negative real axis.
7 Returns: the complex common (base 10) logarithm of x , defined as log(x )/log(10).


template < class T > complex <T > pow ( const complex <T >& x , int y );
template <class T>


complex <T> pow(const complex <T>& x , const complex <T >& y );
template < class T > complex <T > pow ( const complex <T >& x , const T& y );
template <class T> complex <T> pow (const T& x , const complex <T >& y );


8 Remarks: the branch cuts are along the negative real axis. 

9 Returns: the complex power of base x raised to the y -th power, defined as exp(y *log(x )). The value returned 
for pow(0,0) is implementation-defined. 

template < class T > complex <T > sin ( const complex <T >& x ); 
10 Returns: the complex sine of x . 
template < class T > complex <T > sinh ( const complex <T >& x ); 
11 Returns: the complexhyperbolic sineof x . 
template < class T > complex <T > sqrt ( const complex <T >& x ); 

12 Remarks: the branch cuts are along the negative real axis. 

13 Returns: the complex square root of x , in the range of the right half-plane. If the argument is a negative real 
number, thevalue returnedlies on the positive imaginary axis. 

template < class T > complex <T > tan ( const complex <T >& x ); 
14 Returns: the complex tangent of x . 
template < class T > complex <T > tanh ( const complex <T >& x ); 
15 Returns: the complexhyperbolic tangentof x . 

26.3 Numeric arrays [lib.numarray] 
26.3.1 Header <valarray> synopsis [lib.valarray.synopsis] 
Draft 


673 Numerics library 26.3 Numeric arrays 

namespace std { 
template < class T > class valarray ; // An array of type T 
class slice ; // a BLAS-like slice out of an array 
template <class T> class slice_array; 
class gslice ; // ageneralized slice outof an array 
template <class T> class gslice_array; 
template<class T> class mask_array; // a masked array 
template<class T> class indirect_array; // an indirected array 

template < class T > valarray <T > operator * 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator* (const valarray <T>&, const T&); 
template <class T> valarray <T> operator* (const T&, const valarray <T>&); 

template < class T > valarray <T > operator / 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator/ (const valarray <T>&, const T&); 
template <class T> valarray <T> operator/ (const T&, const valarray <T>&); 

template < class T > valarray <T > operator % 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator% (const valarray <T>&, const T&); 
template <class T> valarray <T> operator% (const T&, const valarray <T>&); 

template < class T > valarray <T > operator + 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator+ (const valarray <T>&, const T&); 
template <class T> valarray <T> operator+ (const T&, const valarray <T>&); 

template < class T > valarray <T > operator 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator -(const valarray <T>&, const T&); 
template <class T> valarray <T> operator -(const T&, const valarray <T>&); 

template < class T > valarray <T > operator ^ 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator^ (const valarray <T>&, const T&); 
template <class T> valarray <T> operator^ (const T&, const valarray <T>&); 

template < class T > valarray <T > operator & 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator& (const valarray <T>&, const T&); 
template <class T> valarray <T> operator& (const T&, const valarray <T>&); 

template < class T > valarray <T > operator | 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator| (const valarray <T>&, const T&); 
template <class T> valarray <T> operator| (const T&, const valarray <T>&); 

template < class T > valarray <T > operator << 

Draft 


26.3 Numeric arrays Numerics library 674 
( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator <<(const valarray <T>&, const T&); 
template <class T> valarray <T> operator <<(const T&, const valarray <T>&); 

template < class T > valarray <T > operator >> 

( const valarray <T >& , const valarray <T >&); 
template <class T> valarray <T> operator >>(const valarray <T>&, const T&); 
template <class T> valarray <T> operator >>(const T&, const valarray <T>&); 

template <class T> valarray <bool > operator&& 

( const valarray <T >& , const valarray <T >&); 
template<class T> valarray<bool> operator&&(const valarray<T>&, const T&); 
template<class T> valarray<bool> operator&&(const T&, const valarray<T>&); 

template <class T> valarray <bool > operator|| 

( const valarray <T >& , const valarray <T >&); 
template<class T> valarray<bool> operator||(const valarray<T>&, const T&); 
template<class T> valarray<bool> operator||(const T&, const valarray<T>&); 

template <class T> 

valarray<bool> operator==(const valarray<T>&, const valarray<T>&); 
template<class T> valarray<bool> operator==(const valarray<T>&, const T&); 
template<class T> valarray<bool> operator==(const T&, const valarray<T>&); 
template <class T> 

valarray<bool> operator!=(const valarray<T>&, const valarray<T>&); 
template<class T> valarray<bool> operator!=(const valarray<T>&, const T&); 
template<class T> valarray<bool> operator!=(const T&, const valarray<T>&); 

template <class T> 

valarray<bool> operator< (const valarray<T>&, const valarray<T>&); 
template <class T> valarray <bool > operator < (const valarray <T>&, const T&); 
template <class T> valarray <bool > operator < (const T&, const valarray <T>&); 
template <class T> 

valarray<bool> operator> (const valarray<T>&, const valarray<T>&); 
template <class T> valarray <bool > operator > (const valarray <T>&, const T&); 
template <class T> valarray <bool > operator > (const T&, const valarray <T>&); 
template <class T> 

valarray<bool> operator<=(const valarray<T>&, const valarray<T>&); 
template <class T> valarray <bool > operator <=(const valarray <T>&, const T&); 
template <class T> valarray <bool > operator <=(const T&, const valarray <T>&); 
template <class T> 

valarray<bool> operator>=(const valarray<T>&, const valarray<T>&); 
template <class T> valarray <bool > operator >=(const valarray <T>&, const T&); 
template <class T> valarray <bool > operator >=(const T&, const valarray <T>&); 

template < class T > valarray <T > abs ( const valarray <T >&); 
template < class T > valarray <T > acos ( const valarray <T >&); 
template < class T > valarray <T > asin ( const valarray <T >&); 
template < class T > valarray <T > atan ( const valarray <T >&); 

Draft 


675 Numerics library 26.3 Numeric arrays 

template < class T > valarray <T > atan2 

( const valarray <T >& , const valarray <T >&);
template < class T > valarray <T > atan2 ( const valarray <T >& , const T &);
template <class T> valarray <T> atan2(const T&, const valarray <T>&);


template < class T > valarray <T > cos ( const valarray <T >&);
template < class T > valarray <T > cosh ( const valarray <T >&);
template < class T > valarray <T > exp ( const valarray <T >&);
template < class T > valarray <T > log ( const valarray <T >&);
template < class T > valarray <T > log10 ( const valarray <T >&);


template <class T> valarray <T> pow(const valarray <T>&, const valarray <T>&);
template <class T> valarray <T> pow(const valarray <T>&, const T&);
template <class T> valarray <T> pow(const T&, const valarray <T>&);


template < class T > valarray <T > sin ( const valarray <T >&);
template < class T > valarray <T > sinh ( const valarray <T >&);
template < class T > valarray <T > sqrt ( const valarray <T >&);
template < class T > valarray <T > tan ( const valarray <T >&);
template < class T > valarray <T > tanh ( const valarray <T >&);


} 

1 The header <valarray> defines five class templates(valarray, slice_array, gslice_array, mask_array, and 
indirect_array), two classes(slice and gslice), and a series of related function templates for representing and 
manipulating arrays of values. 

2 The valarray array classes are defined to be free of certain forms of aliasing, thus allowing operations on these classes 
to be optimized. 

3 Anyfunction returning a valarray<T> is permitted to return an object of another type, provided all the const member 
functions of valarray<T> are also applicable to this type. This return type shall not add more than two levels of 
template nesting over the most deeply nested argument type.267) 

4 Implementations introducingsuch replacement types shall provide additional functions and operators as follows: 

— for every function taking a const valarray<T>&, identical functions taking the replacement types shall be 
added; 
— for every function taking two const valarray<T>& arguments, identical functions taking every combination of 
const valarray<T>& and replacement types shallbe added. 
5 In particular, an implementation shall allow a valarray<T> to be constructed from such replacement types and shall 
allow assignments and computed assignments of such types to valarray<T>, slice_array<T>, gslice_array<T>, 
mask_array<T> and indirect_array<T> objects. 

6 These library functions are permitted to throw a bad_alloc (18.4.2.1)exception if there are not sufficient resources 
available to carry out the operation. Note that the exception is not mandated. 

267) ClauseBrecommends a minimum number of recursively nested template instantiations. This requirement thus indirectly suggests a minimum 
allowable complexity for valarray expressions. 

Draft 


26.3 Numeric arrays Numerics library 676 
26.3.2 Class template valarray [lib.template.valarray] 
namespace std { 

template < class T > class valarray { 

public : 

typedef T value_type; 

// 26.3.2.1 construct/destroy: 

valarray (); 

explicit valarray ( size _t ); 

valarray(const T&, size _t); 

valarray(const T*, size _t); 

valarray ( const valarray &); 

valarray ( const slice_ array <T >&); 

valarray ( const gslice_array <T >&); 

valarray ( const mask _array <T >&); 

valarray ( const indirect_array <T >&); 

~ valarray (); 

// 26.3.2.2 assignment: 

valarray <T >& operator = ( const valarray <T >&);
valarray <T>& operator= (const T&);
valarray <T >& operator = ( const slice_array <T >&);
valarray <T >& operator = ( const gslice_ array <T >&);
valarray <T >& operator = ( const mask_ array <T >&);
valarray <T >& operator = ( const indirect_array <T >&);


// 26.3.2.3 element access: 

const T& operator[](size_t) const;
T& operator []( size_t );


// 26.3.2.4 subset operations: 

valarray <T > operator []( slice ) const ;
slice _array <T > operator []( slice );
valarray <T > operator []( const gslice &) const ;
gslice_array <T > operator []( const gslice &);
valarray<T> operator[](const valarray<bool>&) const;
mask_array<T> operator[](const valarray<bool>&);
valarray <T > operator []( const valarray < size _t >&) const ;
indirect_array <T > operator []( const valarray < size _t >&);


// 26.3.2.5 unary operators: 

valarray <T > operator +() const ;
valarray <T > operator -() const ;
valarray <T > operator ~() const ;
valarray<bool> operator!() const;


// 26.3.2.6 computed assignment: 

valarray<T>& operator*= (const T&); 

valarray<T>& operator/= (const T&); 

Draft 


677 Numerics library 26.3 Numeric arrays 

valarray<T>& operator%= (const T&);
valarray<T>& operator+= (const T&);
valarray<T>& operator -= (const T&);
valarray<T>& operator^= (const T&);
valarray<T>& operator&= (const T&);
valarray<T>& operator|= (const T&);
valarray <T>& operator << =(const T&);
valarray <T>& operator >> =(const T&);


valarray <T >& operator *= ( const valarray <T >&);
valarray <T >& operator /= ( const valarray <T >&);
valarray <T >& operator %= ( const valarray <T >&);
valarray <T >& operator += ( const valarray <T >&);
valarray <T >& operator -= ( const valarray <T >&);
valarray <T >& operator ^= ( const valarray <T >&);
valarray <T >& operator |= ( const valarray <T >&);
valarray <T >& operator &= ( const valarray <T >&);
valarray <T >& operator < < =( const valarray <T >&);
valarray <T >& operator > > =( const valarray <T >&);


// 26.3.2.7 member functions: 

size_t size () const ; 

T sum () const ;
T min () const ;
T max () const ;


valarray <T > shift ( int ) const ;
valarray <T > cshift ( int ) const ;
valarray <T> apply(T func(T)) const;
valarray <T> apply(T func(const T&)) const;
void resize ( size _t sz , T c = T ());


};
}


1 The class template valarray<T > isa one-dimensionalsmart array, with elements numbered sequentiallyfrom zero.It 
is a representation of the mathematical concept of an ordered set of values. The illusion of higher dimensionality may 
beproducedbythefamiliar idiomof computedindices, together withthepowerful subsetting capabilitiesprovidedby 
the generalized subscript operators.268) 

2 An implementation is permitted to qualify anyof the functions declared in <valarray> as inline. 

26.3.2.1 valarray constructors [lib.valarray.cons] 
valarray (); 

268) The intent is to specify an array template that has the minimum functionalitynecessary to address aliasing ambiguities and the proliferation of 

temporaries. Thus, the valarray templateis neithera matrix class nora field class.However,itisavery usefulbuilding blockfor designing such 

classes. 

Draft 


26.3 Numeric arrays Numerics library 678 
1 Effects: Constructs an object of class valarray<T >,269) which has zero length until it is passed into a library 
function as a modifiable lvalue or through a non-constant this pointer.270) 

explicit valarray ( size_t ); 

2 The array created by this constructor has a length equal to the value of the argument. The elements of the array 
are constructed using thedefault constructor for the instantiating type T . 

valarray(const T&, size_t); 

3 The array created by this constructor has a length equal to the second argument. The elements of the array are 
initialized with the value of the first argument. 

valarray(const T*, size_t); 

4 The array created by this constructor has a length equal to the second argument n. The values of the elements 

of the array are initialized with the first n values pointed to by the first argument.271) If the value of the second 

argument is greater than the number of values pointed to by the first argument, the behavior is undefined. 

valarray ( const valarray <T >&); 

5 The array createdby this constructor has the same length as the argument array. The elementsare initialized with 
the values of the corresponding elements of the argument array.272) 

valarray ( const slice _array <T >&);
valarray ( const gslice_array <T >&);
valarray ( const mask_array <T >&);
valarray ( const indirect_array <T >&);


6 These conversion constructors convert one of the four reference templates to a valarray. 

~ valarray (); 

7 The destructoris appliedtoevery elementof *this;an implementation may return all allocated memory. 

26.3.2.2 valarray assignment [lib.valarray.assign] 
valarray <T >& operator = ( const valarray <T >&); 

1 Each element of the *this array is assigned the value of the corresponding element of the argument array. The 
resulting behavior is undefined if the length of the argument array is not equal to the length of the *this array. 

valarray <T >& operator = ( const T &); 

2 The scalar assignment operator causes each element of the *this array to be assigned the value of the argument. 

269)Forconvenience,suchobjectsarereferredtoas“arrays”throughoutthe remainderof26.3. 

270) This default constructor is essential, since arrays of valarray are likely to prove useful. There shall also be a way to change the size of an array 

after initialization; thisis suppliedby the semanticsof the resize member function. 

271) This constructoristhe preferred methodfor convertingaCarraytoa valarray object. 

272) This copyconstructor createsa distinct array rather than an alias. Implementationsin which arrays share storage are permitted,but theyshall 

implement a copy-on-reference mechanism to ensure that arrays are conceptually distinct. 

Draft 


679 Numerics library 26.3 Numeric arrays 

valarray <T >& operator = ( const slice_ array <T >&);
valarray <T >& operator = ( const gslice_array <T >&);
valarray <T >& operator = ( const mask _array <T >&);
valarray <T >& operator = ( const indirect_array <T >&);


3 These operators allow the results of a generalized subscripting operation to be assigned directly to a valarray. 

4 If the value of an element in the left-hand side of a valarray assignment operator depends on the value of another 
element in that left-hand side, the resulting behavior is undefined. 

26.3.2.3 valarray element access [lib.valarray.access] 
const T& operator[](size_t) const;
T& operator []( size_t );


1 When appliedtoaconstant array,the subscript operator returnsthevalueofthe corresponding elementofthe array. 
When applied to a non-constant array, the subscript operator returns a reference to the corresponding element of 
the array. 

2 Thus, the expression (a[i] = q, a[i]) == q evaluates as true for anynon-constant valarray<T> a, any T 
q, and for any size_t i such that the value of i is less than the length of a. 

3 The expression &a[i+j] == &a[i] + j evaluates as true for all size_t i and size_t j such that i+j is less 
than the length of the non-constant array a. 

4 Likewise, theexpression &a[i] != &b[j] evaluates as true for anytwo non-constant arrays a and b and for any 
size_t i and size_t j such that i is less than the length of a and j is lessthan the lengthof b. This property 
indicates an absence of aliasing and may be used to advantage by optimizing compilers.273) 

5 The reference returnedbythe subscriptoperatorforanon-constant arrayis guaranteedtobevalid untilthe member 
function resize(size_t, T) (26.3.2.7)is called for that array or until the lifetime of that array ends, whichever 
happens first. 

6 If the subscript operator is invoked with a size_t argument whose value is not less than the length of the array, 
the behavior is undefined. 

26.3.2.4 valarray subset operations [lib.valarray.sub] 
valarray <T > operator []( slice ) const ;
slice_array <T > operator []( slice );
valarray <T > operator []( const gslice &) const ;
gslice _array <T > operator []( const gslice &);
valarray <T > operator []( const valarray < bool >&) const ;
mask _array<T> operator[](const valarray<bool>&);
valarray <T > operator []( const valarray < size _t >&) const ;
indirect_array <T > operator []( const valarray < size _t >&);


273) Compilers may take advantage of inlining, constant propagation, loop fusion, tracking of pointers obtained from operator new, and other 
techniques to generate efficient valarrays. 

Draft 


26.3 Numeric arrays Numerics library 680 
1 Each of these operations returns a subset of the array. The const-qualified versions return this subset as a new 
valarray. The non-const versions return a class template object which has reference semantics to the original 
array. 

26.3.2.5 valarray unary operators [lib.valarray.unary] 
valarray <T > operator +() const ;
valarray <T > operator -() const ;
valarray <T > operator ~() const ;
valarray < bool > operator !() const ;


1 Each of these operators may only be instantiated for a type T to which the indicated operator can be applied and 
for which the indicated operator returns a value which is of type T (bool for operator! ) or which may be 
unambiguously converted totype T (bool for operator! ). 

2 Each of these operators returns an array whose length is equal to the length of the array. Each element of the 
returned array is initialized with the result of applying the indicated operator to the corresponding element of the 
array. 

26.3.2.6 valarray computed assignment [lib.valarray.cassign] 
valarray <T >& operator *= ( const valarray <T >&);
valarray <T >& operator /= ( const valarray <T >&);
valarray <T >& operator %= ( const valarray <T >&);
valarray <T >& operator += ( const valarray <T >&);
valarray <T >& operator -= ( const valarray <T >&);
valarray <T >& operator ^= ( const valarray <T >&);
valarray <T >& operator &= ( const valarray <T >&);
valarray <T >& operator |= ( const valarray <T >&);
valarray <T >& operator < < =( const valarray <T >&);
valarray <T >& operator > > =( const valarray <T >&);


1 Eachof these operatorsmayonlybe instantiatedforatype T to which the indicated operator can be applied. Each 
of these operators performs the indicated operation on each of its elements and the correspondingelementof the 
argument array. 

2 The arrayis then returnedbyreference. 

3 If the array and the argument array do not have the same length, the behavior is undefined. The appearance of an 
array on the left-hand side of a computed assignment does not invalidate references or pointers. 

4 If the value of an element in the left-hand side of a valarray computed assignment operator depends on the value 
of another element in that left hand side, the resulting behavior is undefined. 

valarray <T >& operator *= ( const T &);
valarray <T >& operator /= ( const T &);
valarray <T >& operator %= ( const T &);
valarray <T >& operator += ( const T &);
valarray <T >& operator -= ( const T &);


Draft 


681 Numerics library 26.3 Numeric arrays 

valarray <T >& operator ^= ( const T &);
valarray <T >& operator &= ( const T &);
valarray <T >& operator |= ( const T &);
valarray <T >& operator < < =( const T &);
valarray <T >& operator > > =( const T &);


5 Each of these operators mayonly be instantiated for a type T to which the indicated operator can be applied.
6 Each of these operators applies the indicated operation to each element of the array and the non-array argument.
7 The arrayis then returnedbyreference.
8 The appearance of an array on the left-hand side of a computed assignment does not invalidate references or


pointers to the elements ofthe array. 

26.3.2.7 valarray member functions [lib.valarray.members] 
size _t size () const ; 

1 This function returns the number of elements in the array. 

T sum () const ; 

This function may only be instantiated for a type T to which operator+= can be applied. This function returns 
the sum of all the elements of the array. 

2 If the array has length 0, the behavior is undefined. If the array has length 1, sum() returns the value of element 

0. Otherwise, the returned value is calculated by applying operator+= to a copyof an element of the array and 
all other elements of the array in an unspecified order. 
T min () const ; 

3 This function returns the minimum value contained in *this. The value returned for an array of length 0 is 
undefined.Foranarrayoflength1,thevalueof element0is returned.Forallotherarraylengths,the determination 
is made using operator<. 

T max () const ; 

4 This function returns the maximum value contained in *this. The value returned for an array of length 0 is 
undefined.Foranarrayoflength1,thevalueof element0is returned.Forallotherarraylengths,the determination 
is made using operator<. 

valarray <T> shift(int n ) const ; 

5 This function returns an object of class valarray<T> of length size(), each of whose elements Iis (*this)[I 

+ n ] if I + n is non-negativeand less than size(),otherwiseT(). Thus if element zero is taken as the leftmost 
element, a positive value of n shifts the elements left n places, with zero fill. 
6 [Example: If the argument has the value -2, the first two elements of the result will be constructed using the 
default constructor; the third element of the result will be assigned the value of the first element of the argument; 
etc. — end example ] 

valarray <T > cshift ( int n ) const ; 

Draft 


26.3 Numeric arrays Numerics library 682 
7 This function returns an object of class valarray<T>,of lengthsize(),each of whose elementsIis (*this)[(I 

+ n ) % size()]. Thus,if element zeroistakenastheleftmost element,apositivevalueof n shifts the elements 
circularly left n places. 
valarray <T> apply(T func(T)) const;
valarray <T > apply (T func ( const T &)) const ;


8 These functions return an array whose length is equal to the array. Each element of the returned array is assigned 
thevalue returnedbyapplyingtheargument functiontothe corresponding elementofthe array. 

void resize ( size _t sz , T c = T ()); 

9 This member function changes the length of the *this array to sz and then assigns to each element the value of 
the second argument. Resizing invalidates all pointers and references to elements in the array. 

26.3.3 valarray non-member operations [lib.valarray.nonmembers] 
26.3.3.1 valarray binary operators [lib.valarray.binary] 
template < class T > valarray <T > operator * 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator / 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator % 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator + 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator ^ 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator & 

( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > operator | 

( const valarray <T >& , const valarray <T >&); 

template <class T> valarray <T> operator << 

( const valarray <T >& , const valarray <T >&); 

template <class T> valarray <T> operator >> 

( const valarray <T >& , const valarray <T >&); 

1 Each of these operators may only be instantiated for a type T to which the indicated operator can be applied and 

for which the indicated operator returns a value which is of type T or which can be unambiguously converted to 

type T . 

2 Eachofthese operators returnsanarraywhoselengthisequaltothelengthsoftheargumentarrays.Each element 

of the returned array is initialized with the result of applying the indicated operator to the corresponding elements 

of the argument arrays. 

3 If the argument arrays do not have the same length, the behavior is undefined. 

template < class T > valarray <T > operator * ( const valarray <T >& , const T &); 

Draft 


683 Numerics library 26.3 Numeric arrays 

template<class T> valarray<T> operator* (const T&, const valarray<T>&);
template < class T > valarray <T > operator / ( const valarray <T >& , const T &);
template<class T> valarray<T> operator/ (const T&, const valarray<T>&);
template < class T > valarray <T > operator % ( const valarray <T >& , const T &);
template<class T> valarray<T> operator% (const T&, const valarray<T>&);
template < class T > valarray <T > operator + ( const valarray <T >& , const T &);
template<class T> valarray<T> operator+ (const T&, const valarray<T>&);
template < class T > valarray <T > operator -( const valarray <T >& , const T &);
template<class T> valarray<T> operator -(const T&, const valarray<T>&);
template < class T > valarray <T > operator ^ ( const valarray <T >& , const T &);
template<class T> valarray<T> operator^ (const T&, const valarray<T>&);
template < class T > valarray <T > operator & ( const valarray <T >& , const T &);
template<class T> valarray<T> operator& (const T&, const valarray<T>&);
template < class T > valarray <T > operator | ( const valarray <T >& , const T &);
template<class T> valarray<T> operator| (const T&, const valarray<T>&);
template <class T> valarray <T> operator <<(const valarray <T>&, const T&);
template <class T> valarray <T> operator <<(const T&, const valarray <T>&);
template <class T> valarray <T> operator >>(const valarray <T>&, const T&);
template <class T> valarray <T> operator >>(const T&, const valarray <T>&);


4 Each of these operators may only be instantiated for a type T to which the indicated operator can be applied and 
for which the indicated operator returns a value which is of type T or which can be unambiguously converted to 
type T . 

5 Each of these operators returns an array whose length is equal to the length of the array argument. Each element 
ofthe returned arrayis initializedwiththe resultof applyingthe indicated operatortothe corresponding element 
of the array argument and the non-array argument. 

26.3.3.2 valarray logical operators [lib.valarray.comparison] 
template <class T> valarray <bool > operator= =
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator! =
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator <
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator >
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator < =
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator > =
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator&&
( const valarray <T >& , const valarray <T >&);
template <class T> valarray <bool > operator||
( const valarray <T >& , const valarray <T >&);


1 Each of these operators may only be instantiated for a type T to which the indicated operator can be applied and 
for which the indicated operator returns a value which is of type bool or which can be unambiguously converted 

Draft 


26.3 Numeric arrays Numerics library 684 
to type bool . 

2 Each of these operators returns a bool array whose length is equal to the length of the array arguments. Each 
element of the returned array is initialized with the result of applying the indicated operator to the corresponding 
elements of the argument arrays. 

3 If the two array arguments do not have the same length, the behavior is undefined. 

template<class T> valarray<bool> operator==(const valarray<T>&, const T&);
template<class T> valarray<bool> operator==(const T&, const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator!=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&, const T&);
template<class T> valarray<bool> operator< (const T&, const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&, const T&);
template<class T> valarray<bool> operator> (const T&, const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator<=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator>=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const T&);
template<class T> valarray<bool> operator&&(const T&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const T&);
template<class T> valarray<bool> operator||(const T&, const valarray<T>&);


4 Each of these operators may only be instantiated for a type T to which the indicated operator can be applied and 
for which the indicated operator returns a value which is of type bool or which can be unambiguously converted 
to type bool . 

5 Each of these operators returns a bool array whose length is equal to the length of the array argument. Each 
element of the returned array is initialized with the result of applying the indicated operator to the corresponding 
element of the array and the non-array argument. 

26.3.3.3 valarray transcendentals [lib.valarray.transcend] 
template < class T > valarray <T > abs ( const valarray <T >&);
template < class T > valarray <T > acos ( const valarray <T >&);
template < class T > valarray <T > asin ( const valarray <T >&);
template < class T > valarray <T > atan ( const valarray <T >&);
template < class T > valarray <T > atan2


( const valarray <T >& , const valarray <T >&); 

template < class T > valarray <T > atan2 ( const valarray <T >& , const T &); 

template <class T> valarray <T> atan2(const T&, const valarray <T>&); 

template < class T > valarray <T > cos ( const valarray <T >&); 

template < class T > valarray <T > cosh ( const valarray <T >&); 

template < class T > valarray <T > exp ( const valarray <T >&); 

template < class T > valarray <T > log ( const valarray <T >&); 

template < class T > valarray <T > log10 ( const valarray <T >&); 

template < class T > valarray <T > pow 

( const valarray <T >& , const valarray <T >&); 

Draft 


685 Numerics library 26.3 Numeric arrays 

template < class T > valarray <T > pow ( const valarray <T >& , const T &);
template <class T> valarray <T> pow (const T&, const valarray <T>&);
template < class T > valarray <T > sin ( const valarray <T >&);
template < class T > valarray <T > sinh ( const valarray <T >&);
template < class T > valarray <T > sqrt ( const valarray <T >&);
template < class T > valarray <T > tan ( const valarray <T >&);
template < class T > valarray <T > tanh ( const valarray <T >&);


1 Each ofthese functions may only be instantiated for a type T to which a unique function with the indicated name 
canbeapplied (unqualified). This function shall returnavalue whichisof type T or which can be unambiguously 
converted to type T . 

26.3.4 Class slice [lib.class.slice] 
namespace std {
class slice {
public :


slice ();
slice ( size _t , size _t , size _t );


size_t start () const ;
size_t size () const ;
size_t stride () const ;


};
}


1 The slice class represents a BLAS-like slice from an array. Such a slice is specified by a starting index, a length, and 
a stride.274) 

26.3.4.1 slice constructors [lib.cons.slice] 
slice ();
slice ( size _t start , size _t length , size_t stride );
slice ( const slice &);


1 The default constructor for slice creates a slice which specifiesno elements.Adefault constructorisprovided 
only to permit the declaration of arrays of slices. The constructor with arguments for a slice takes a start, length, 
and stride parameter. 

2[Example: slice(3, 8, 2) constructs a slice which selects elements 3, 5, 7, ... 17 from an array. — end 
example] 

26.3.4.2 slice access functions [lib.slice.access] 
size _t start () const ;
size _t size () const ;


274) BLAS stands for Basic Linear Algebra Subprograms. C++ programs may instantiate this class. See, for example, Dongarra, Du Croz, Duff, 
and Hammerling: A set of Level 3 Basic Linear Algebra Subprograms; Technical Report MCS-P1-0888, Argonne National Laboratory (USA), 
Mathematics and Computer Science Division, August, 1988. 

Draft 


26.3 Numeric arrays Numerics library 686 
size _t stride () const ; 

1 These functions return the start, length, or stride specified by a slice object. 

26.3.5 Class template slice_array [lib.template.slice.array] 
namespace std {
template <class T> class slice_array {
public :


typedef T value_type; 

void operator = ( const valarray <T >&) const ;
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < < =( const valarray <T >&) const ;
void operator > > =( const valarray <T >&) const ;


slice_array(const slice_array&);
~slice_array ();
slice_array& operator= (const slice_array&);
void operator =( const T &) const ;
private :
slice_array ();
};
}


1 The slice_array templateisa helper template usedby the slice subscript operator 

slice _array <T > valarray <T >:: operator []( slice ); 

It has reference semantics to a subset of an array specified by a slice object. 

2[Example: The expression a[slice(1, 5, 3)] = b; has the effect of assigning the elements of b to a slice of the 
elements in a.For the slice shown, the elements selected from a are 1, 4, ..., 13. — end example ] 

26.3.5.1 slice_array constructors [lib.cons.slice.arr] 
slice_array (); 

1 This constructor is declared to be private. This constructor need not be defined. 

26.3.5.2 slice_array assignment [lib.slice.arr.assign] 
Draft 


687 Numerics library 26.3 Numeric arrays 

void operator = ( const valarray <T >&) const ;
slice_array& operator= (const slice_array&);


1 These assignment operators have reference semantics, assigning the values of the argument array elements to 
selected elements of the valarray<T> object to which the slice_array object refers. 

26.3.5.3 slice_array computed assignment [lib.slice.arr.comp.assign] 
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < <= ( const valarray <T >&) const ;
void operator > >= ( const valarray <T >&) const ;


1 These computed assignments have reference semantics, applying the indicated operation to the elements of the 
argument array and selectedelements of the valarray<T> object to which the slice_array object refers. 

26.3.5.4 slice_array fill function [lib.slice.arr.fill] 
void operator = ( const T &) const ; 

1 This function has reference semantics, assigning the value of its argument to the elements of the valarray<T> 
object to which the slice_array object refers. 

26.3.6 The gslice class [lib.class.gslice] 
namespace std {
class gslice {
public :


gslice ();
gslice(size_t s, const valarray <size _t >& l, const valarray <size _t >& d);


size_t start () const ;
valarray < size _t > size () const ;
valarray < size _t > stride () const ;


};
}


1 This class representsa generalized slice outof an array.A gslice is definedbya startingoffset(s), a set of lengths(lj), 
anda setof strides(dj). The number of lengths shall equal the number of strides. 

2 Agslice representsa mapping froma setof indices(ij), equal in number to the number of strides, to a single index 

k.Itis useful forbuilding multidimensional array classes using the valarray template, which is one-dimensional. The 
Draft 


26.3 Numeric arrays Numerics library 688 
set of one-dimensional index values specified by a gslice are 

k= s+ åijdj 

j 

where the multidimensional indices ij rangeinvalue from0to lij- 1. 
3[Example: The gslice specification 

start = 3
length = {2, 4, 3}
stride = {19, 4, 1}


yields the sequence of one-dimensional indices 

k= 3+(0,1) × 19+(0,1,2, 3) × 4+(0,1, 2) × 1 

which are ordered as shown in the following table: 

(i0, i1, i2, k)=
(0, 0, 0, 3),
(0, 0, 1, 4),
(0, 0, 2, 5),
(0, 1, 0, 7),
(0, 1, 1, 8),
(0, 1, 2, 9),
(0, 2, 0, 11),
(0, 2, 1, 12),
(0, 2, 2, 13),
(0, 3, 0, 15),
(0, 3, 1, 16),
(0, 3, 2, 17),
(1, 0, 0, 22),
(1, 0, 1, 23),
...
(1, 3, 2, 36)


That is, the highest-orderedindex turnsfastest. — end example ] 

4 It is possible to have degenerate generalized slices in which an address is repeated. 

5[Example: If the stride parameters in the previous example are changed to {1, 1, 1}, the first few elements of the 
resulting sequence of indices will be 

(0, 0, 0, 3),
(0, 0, 1, 4),
(0, 0, 2, 5),
(0, 1, 0, 4),
(0, 1, 1, 5),
(0, 1, 2, 6),
...


Draft 


689 Numerics library 26.3 Numeric arrays 

— end example ] 
6 Ifadegeneratesliceisusedastheargumenttothe non-const version of operator[](const gslice&), the resulting 
behavior is undefined. 

26.3.6.1 gslice constructors [lib.gslice.cons] 
gslice ();
gslice ( size_ t start , const valarray <size _t >& lengths ,
const valarray < size _t >& strides );
gslice ( const gslice &);


1 The default constructor creates a gslice which specifies no elements. The constructor with argumentsbuildsa 
gslice based on a specification of start, lengths, and strides, as explained in the previous section. 

26.3.6.2 gslice access functions [lib.gslice.access] 
size _t start () const ;
valarray < size _t > size () const ;
valarray < size _t > stride () const ;


1 These access functions return the representation of the start, lengths, or strides specified for the gslice. 

26.3.7 Class template gslice_array [lib.template.gslice.array] 
namespace std {
template <class T> class gslice_array {
public :


typedef T value_type; 

void operator = ( const valarray <T >&) const ;
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < < =( const valarray <T >&) const ;
void operator > > =( const valarray <T >&) const ;


gslice_array(const gslice_array&); 

~gslice_array ();
gslice_array& operator= (const gslice_array&);
void operator =( const T &) const ;


private :
gslice_array ();


Draft 


26.3 Numeric arrays Numerics library 690 
};
}


1 This template is a helper template used by the slice subscript operator 

gslice _array <T > valarray <T >:: operator []( const gslice &); 

2 It has reference semantics to a subset of an array specified by a gslice object. 

3 Thus, the expression a[gslice(1, length, stride)] = b has the effect of assigning the elements of b to a 
generalized slice of the elements in a. 

26.3.7.1 gslice_array constructors [lib.gslice.array.cons] 
gslice_array (); 

1 This constructor is declared to be private. This constructor need not be defined. 

26.3.7.2 gslice_array assignment [lib.gslice.array.assign] 
void operator = ( const valarray <T >&) const ;
gslice_array& operator= (const gslice_array&);


1 These assignment operators have reference semantics, assigning the values of the argument array elements to 
selected elements of the valarray<T> object to which the gslice_array refers. 

26.3.7.3 gslice_array [lib.gslice.array.comp.assign] 
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < <= ( const valarray <T >&) const ;
void operator > >= ( const valarray <T >&) const ;


1 These computed assignments have reference semantics, applying the indicated operation to the elements of the 
argument array and selectedelements of the valarray<T> object to which the gslice_array object refers. 

26.3.7.4 gslice_array fill function [lib.gslice.array.fill] 
void operator = ( const T &) const ; 

1 This function has reference semantics, assigning the value of its argument to the elements of the valarray<T> 
object to which the gslice_array object refers. 

Draft 


691 Numerics library 26.3 Numeric arrays 

26.3.8 Class template mask_array [lib.template.mask.array] 
namespace std {
template <class T> class mask_array {
public :


typedef T value_type; 

void operator = ( const valarray <T >&) const ;
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < < =( const valarray <T >&) const ;
void operator > > =( const valarray <T >&) const ;


mask_array(const mask_array&); 

~mask_array ();
mask_array& operator= (const mask_array&);
void operator =( const T &) const ;


private :
mask_array ();
};
}


1 This template is a helper template used by the mask subscript operator: 

mask _array<T> valarray<T>::operator[](const valarray<bool>&). 

2 Ithas reference semanticstoa subsetofan arrayspecifiedbyaboolean mask.Thus,theexpression a[mask] = 
b; has the effect of assigning the elements of b to the masked elements in a (those for which the corresponding 
element in mask is true.) 

26.3.8.1 mask_array constructors [lib.mask.array.cons] 
mask_array (); 

1 This constructor is declared to be private. This constructor need not be defined. 

26.3.8.2 mask_array assignment [lib.mask.array.assign] 
void operator = ( const valarray <T >&) const ;
mask_array& operator= (const mask_array&);


1 These assignment operators have reference semantics, assigning the values of the argument array elements to 
selected elements of the valarray<T> object to which it refers. 

Draft 


26.3 Numeric arrays Numerics library 692 
26.3.8.3 mask_array computed assignment [lib.mask.array.comp.assign] 
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < <= ( const valarray <T >&) const ;
void operator > >= ( const valarray <T >&) const ;


1 These computed assignments have reference semantics, applying the indicated operation to the elements of the 
argument array and selectedelements of the valarray<T> object to which the mask objectrefers. 

26.3.8.4 mask_array fill function [lib.mask.array.fill] 
void operator = ( const T &) const ; 

1 This function has reference semantics, assigning the value of its argument to the elements of the valarray<T> 
object to which the mask_array object refers. 

26.3.9 Class template indirect_array [lib.template.indirect.array] 
namespace std {
template <class T> class indirect_array {
public :


typedef T value_type; 

void operator = ( const valarray <T >&) const ;
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < < =( const valarray <T >&) const ;
void operator > > =( const valarray <T >&) const ;


indirect_array(const indirect_array&); 

~ indirect_array ();
indirect_array& operator= (const indirect_array&);
void operator =( const T &) const ;


private :
indirect_array ();
};


Draft 


693 Numerics library 26.3 Numeric arrays 

} 

1 This template is a helper template used by the indirect subscript operator 

indirect_array <T > valarray <T >:: operator []( const valarray < size _t >&). 

2 It has reference semantics to a subset of an array specified by an indirect_array. Thus the expression a[ 
indirect] = b; has the effect of assigning the elements of b to the elements in a whose indices appear in 
indirect. 

26.3.9.1 indirect_array constructors [lib.indirect.array.cons] 
indirect_array (); 

1 This constructor is declared to be private. This constructor need not be defined. 

26.3.9.2 indirect_array assignment [lib.indirect.array.assign] 
void operator = ( const valarray <T >&) const ;
indirect_array& operator= (const indirect_array&);


1 These assignment operators have reference semantics, assigning the values of the argument array elements to 
selected elements of the valarray<T> object to which it refers. 

2 If the indirect_array specifies an element in the valarray<T> object to which it refers more than once, the 
behavior is undefined. 

3 [Example: 

int addr[] = {2, 3, 1, 4, 4}; 

valarray <size _t > indirect(addr , 5); 

valarray<double> a(0., 10), b(1., 5); 

a[ indirect ] = b; 

resultsin undefined behavior since element4is specified twicein the indirection. — end example ] 

26.3.9.3 indirect_array computed assignment [lib.indirect.array.comp.assign] 
void operator *= ( const valarray <T >&) const ;
void operator /= ( const valarray <T >&) const ;
void operator %= ( const valarray <T >&) const ;
void operator += ( const valarray <T >&) const ;
void operator -= ( const valarray <T >&) const ;
void operator ^= ( const valarray <T >&) const ;
void operator &= ( const valarray <T >&) const ;
void operator |= ( const valarray <T >&) const ;
void operator < <= ( const valarray <T >&) const ;
void operator > >= ( const valarray <T >&) const ;


Draft 


26.4 Generalized numeric operations Numerics library 694 
1 These computed assignments have reference semantics, applying the indicated operation to the elements of the 
argument array and selectedelements of the valarray<T> object to which the indirect_array object refers. 

2 If the indirect_array specifies an element in the valarray<T> object to which it refers more than once, the 
behavior is undefined. 

26.3.9.4 indirect_array fill function [lib.indirect.array.fill] 
void operator = ( const T &) const ; 

1 This function has reference semantics, assigning the value of its argument to the elements of the valarray<T> 
object to which the indirect_array object refers. 

26.4 Generalized numeric operations [lib.numeric.ops] 
Header <numeric> synopsis 

namespace std {
template <class InputIterator , class T>
T accumulate(InputIterator first , InputIterator last ,T init );
template < class InputIterator , class T , class BinaryOperation >
T accumulate(InputIterator first , InputIterator last ,T init ,
BinaryOperation binary_op );


template <class InputIterator1 , class InputIterator2 , class T>
T inner_product(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 ,T init );
template <class InputIterator1 , class InputIterator2 , class T,
class BinaryOperation1 , class BinaryOperation2 >


T inner_product(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 ,T init ,
BinaryOperation1 binary_op1 ,
BinaryOperation2 binary_op2 );


template < class InputIterator , class OutputIterator > 

OutputIterator partial_sum(InputIterator first ,
InputIterator last ,
OutputIterator result );


template < class InputIterator , class OutputIterator ,
class BinaryOperation >


OutputIterator partial_sum(InputIterator first ,
InputIterator last ,
OutputIterator result ,
BinaryOperation binary_op );


template < class InputIterator , class OutputIterator > 

OutputIterator adjacent_difference(InputIterator first ,
InputIterator last ,
OutputIterator result );


Draft 


695 Numerics library 26.4 Generalized numeric operations 

template < class InputIterator , class OutputIterator ,
class BinaryOperation >


OutputIterator adjacent_difference(InputIterator first ,
InputIterator last ,
OutputIterator result ,
BinaryOperation binary_op );


} 

1 The requirements on the types of algorithms’ arguments that are described in the introduction to clause 25 also apply to 
the following algorithms. 

26.4.1 Accumulate [lib.accumulate] 
template <class InputIterator , class T>
T accumulate(InputIterator first , InputIterator last ,T init );
template < class InputIterator , class T , class BinaryOperation >
T accumulate(InputIterator first , InputIterator last ,T init ,
BinaryOperation binary_op );


1 Effects: Computes its result by initializing the accumulator acc with theinitialvalue init and then modifies 
it with acc = acc + *i or acc = binary_op(acc, *i) for every iterator i in the range [first,last) in 
order.275) 

2 Requires: Tshall meetthe requirementsofCopyConstructible(20.1.3)and Assignable(23.1)types.Inthe range 
[first,last], binary_op shall neither modify elements nor invalidate iterators or subranges.276) 

26.4.2 Inner product [lib.inner.product] 
template <class InputIterator1 , class InputIterator2 , class T>
T inner_product(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 ,T init );
template <class InputIterator1 , class InputIterator2 , class T,
class BinaryOperation1 , class BinaryOperation2 >


T inner_product(InputIterator1 first1 , InputIterator1 last1 ,
InputIterator2 first2 ,T init ,
BinaryOperation1 binary_op1 ,
BinaryOperation2 binary_op2 );


1 Effects: Computes its result by initializing the accumulator acc with the initial value init and then modifying 
it with acc = acc + (*i1) * (*i2) or acc = binary_op1(acc, binary_op2(*i1, *i2)) for every iterator i1 in the range [first,last) and iterator i2 in the range [first2,first2 + (last -first)) in 
order. 

2 Requires: Tshall meet the requirements of CopyConstructible(20.1.3)and Assignable(23.1)types. In the ranges 
[first,last] and [first2,first2 + (last -first)] binary_op1 and binary_op2 shall neither modify elements nor invalidate iterators or subranges.277) 

275) accumulate is similar to the APL reduction operator and Common Lisp reduce function,but it avoids the difficulty of defining the result of 

reduction on an empty sequencebyalways requiring an initialvalue.
276)The useof fully closed rangesis intentional
277)The useof fully closed rangesis intentional


Draft 


26.4 Generalized numeric operations Numerics library 696 
26.4.3 Partial sum [lib.partial.sum] 
template < class InputIterator , class OutputIterator >
OutputIterator
partial_sum ( InputIterator first , InputIterator last ,
OutputIterator result );
template
<class InputIterator , class OutputIterator , class BinaryOperation >
OutputIterator
partial_sum ( InputIterator first , InputIterator last ,
OutputIterator result , BinaryOperation binary_op );


1 Effects: Assigns to every element referred to by iterator i in the range [result,result + (last -first)) 
a value correspondingly equal to 

((...(*first + *(first + 1)) + ...) + *(first + (i -result))) 

or 

binary_op ( binary_op (... , 
binary_op (* first , *( first + 1)) ,...) , *( first + ( i -result ))) 

2 Returns: result + (last -first).
3 Complexity: Exactly (last -first) -1 applications of binary_op.
4 Requires: In the ranges [first,last] and [result,result + (last -first)] binary_op shall neither


modify elements nor invalidate iterators or subranges.278) 
5 Remarks: result may be equal to first. 

26.4.4 Adjacent difference [lib.adjacent.difference] 
template < class InputIterator , class OutputIterator >
OutputIterator
adjacent_difference ( InputIterator first , InputIterator last ,
OutputIterator result );
template
<class InputIterator , class OutputIterator , class BinaryOperation >
OutputIterator


adjacent_difference ( InputIterator first , InputIterator last ,
OutputIterator result ,
BinaryOperation binary_op );


1 Effects: Assigns to every element referred to by iterator i in the range [result + 1,result + (last 
first)) avalue correspondingly equalto 

*(first + (i -result)) -*(first + (i -result) -1) 
or
278)The useof fully closed rangesis intentional.


Draft 


697 Numerics library 26.5 CLibrary 

binary_op (*( first + ( i -result )) , *( first + ( i -result ) -1)). 

result gets the value of *first. 
2 Requires: In the ranges [first,last] and [result,result + (last -first)], binary_op shall neither 

modify elements nor invalidate iterators or subranges.279) 

3 Remarks: result may be equal to first. 

4 Returns: result + (last -first). 

5 Complexity: Exactly (last -first) -1 applications of binary_op. 

26.5 CLibrary [lib.c.math] 
1 Tables83 and 84 describe headers <cmath> and <cstdlib>, respectively. 

Table 83: Header<cmath> synopsis 

Type Name(s) 
Macro: HUGE_VAL 
Functions: 
abs ceil floor log10 sqrt 
acos cos fmod modf tan 
asin cosh frexp pow tanh 
atan exp ldexp sin 
atan2 fabs log sinh 

Table 84: Header<cstdlib> synopsis 

Type Name(s) 
Macro: RAND_MAX 
Types: div_t ldiv_t 
Functions: 
abs labs srand 
div ldiv rand 

2 The contentsof these headers are the same as the StandardClibrary headers <math.h> and <stdlib.h> respectively, 
with the following changes: 

3 The rand function has the semantics specified in the C standard, except that the implementation may specify that 
particular library functions may call rand. 

4 In addition to the int versions of certain math functions in <cstdlib>,C++ adds long overloaded versions of these 
functions, with the same semantics. 

5 The added signatures are: 

279)The useof fully closed rangsis intentional. 

Draft 


26.5 CLibrary Numerics library 698 
long abs ( long ); // labs()
ldiv_t div(long , long); // ldiv()


6 In addition to the double versions of the math functions in <cmath>,C++ adds float and long double overloaded 
versions of these functions, with the same semantics. 

7 The added signatures are: 

float abs ( float );
float acos ( float );
float asin ( float );
float atan ( float );
float atan2(float , float);
float ceil ( float );
float cos ( float );
float cosh ( float );
float exp ( float );
float fabs ( float );
float floor ( float );
float fmod ( float , float );
float frexp(float , int*);
float ldexp(float , int);
float log ( float );
float log10 ( float );
float modf ( float , float *);
float pow (float , float);
float pow (float , int);
float sin ( float );
float sinh ( float );
float sqrt ( float );
float tan ( float );
float tanh ( float );


double abs ( double ); // fabs()
double pow ( double , int );


long double abs ( long double );
long double acos ( long double );
long double asin ( long double );
long double atan ( long double );
long double atan2 ( long double , long double );
long double ceil ( long double );
long double cos ( long double );
long double cosh ( long double );
long double exp ( long double );
long double fabs ( long double );
long double floor ( long double );
long double fmod ( long double , long double );
long double frexp ( long double , int *);
long double ldexp ( long double , int );


Draft 


699 Numerics library 26.5 CLibrary 

long double log ( long double );
long double log10 ( long double );
long double modf ( long double , long double *);
long double pow ( long double , long double );
long double pow ( long double , int );
long double sin ( long double );
long double sinh ( long double );
long double sqrt ( long double );
long double tan ( long double );
long double tanh ( long double );


SEEALSO: ISOCsubclauses 7.5, 7.10.2, 7.10.6. 

Draft 


26.5 CLibrary Numerics library 700 
Draft 


Chapter 27 Input/output library [lib.input.output]


1 This clause describes components thatC++ programs may use to perform input/output operations. 

2 The following subclauses describe requirements for stream parameters, and components for forward declarations of 
iostreams, predefined iostreams objects, base iostreams classes, streambuffering, stream formatting and manipulators, 
string streams, and file streams, as summarizedinTable 85. 

Table 85: Input/output library summary 

Subclause Header(s) 
27.1 Requirements 
27.2 Forward declarations <iosfwd> 
27.3 Standard iostream objects <iostream> 
27.4 Iostreams base classes <ios> 
27.5 Stream buffers <streambuf> 
27.6 Formatting and manipulators <istream> 
<ostream> 
<iomanip> 
27.7 String streams <sstream> 
27.8 File streams <fstream> 
<cstdio> 

27.1 Iostreams requirements [lib.iostreams.requirements] 
27.1.1 Imbue Limitations [lib.iostream.limits.imbue] 
1 No function described in clause 27 except for ios_base::imbue causes anyinstance of basic_ios::imbue or basic_streambuf::imbue to be called. If any user function called from a function declared in clause 27 or as an 
overriding virtual function of anyclass declared in clause 27 calls imbue, the behavior is undefined. 

27.1.2 PositioningType Limitations [lib.iostreams.limits.pos] 
1 The classes of clause 27 with template arguments charT and traits behave as described if traits::pos_type and 
traits::off_type are streampos and streamoff respectively. Except as noted explicitly below, their behavior 
when traits::pos_type and traits::off_type are other types is implementation-defined. 

27.2 Forward declarations [lib.iostream.forward] 
Header <iosfwd> synopsis 

27.2 Forward declarations Input/output library 702 
namespace std { 
template <class charT > class char_traits; 
template <> class char_traits <char >; 
template <> class char_traits <wchar _t >; 

template < class T > class allocator ; 

template < class charT , class traits = char _traits < charT > > 
class basic_ios ; 

template < class charT , class traits = char _traits < charT > > 
class basic_streambuf; 

template < class charT , class traits = char _traits < charT > > 
class basic_istream; 

template < class charT , class traits = char _traits < charT > > 
class basic_ostream; 

template < class charT , class traits = char _traits < charT > > 
class basic_iostream; 

template <class charT , class traits = char _traits <charT >, 
class Allocator = allocator <charT > > 
class basic_stringbuf; 

template <class charT , class traits = char _traits <charT >, 
class Allocator = allocator <charT > > 
class basic_istringstream; 

template <class charT , class traits = char _traits <charT >, 
class Allocator = allocator <charT > > 
class basic_ostringstream; 

template <class charT , class traits = char _traits <charT >, 
class Allocator = allocator <charT > > 
class basic_stringstream; 

template < class charT , class traits = char _traits < charT > > 
class basic_filebuf; 

template < class charT , class traits = char _traits < charT > > 
class basic_ifstream; 

template < class charT , class traits = char _traits < charT > > 
class basic_ofstream; 

template < class charT , class traits = char _traits < charT > > 
class basic_fstream; 

Draft 


703 Input/output library 27.2 Forward declarations 

template 
class 

template 
class 

typedef 
typedef 

typedef 
typedef 
typedef 
typedef 

typedef 
typedef 
typedef 
typedef 

typedef 
typedef 
typedef 
typedef 

typedef 
typedef 
typedef 
typedef 

typedef 
typedef 
typedef 
typedef 

typedef 
typedef 
typedef 
typedef 

template 
typedef 
typedef 

} 

< class charT , class 
istreambuf_iterator ; 

< class charT , class 

ostreambuf_iterator ; 
basic _ios <char > 
basic _ios < wchar _t > 

basic_streambuf <char > 
basic _istream <char > 
basic _ostream <char > 
basic_iostream <char > 

traits = char _traits < charT > > 

traits = char _traits < charT > > 

ios;
wios ;


streambuf ;
istream ;


ostream ;
iostream ;
basic_stringbuf <char > 
basic_istringstream <char > 
basic_ostringstream <char > 
basic_stringstream <char > 

stringbuf ; 
istringstream ; 

ostringstream ; 
stringstream ; 
basic _filebuf <char > filebuf; 
basic_ifstream <char > ifstream; 
basic_ofstream <char > ofstream; 
basic _fstream <char > fstream; 

basic_streambuf < wchar _t > 
basic _istream < wchar _t > 
basic _ostream < wchar _t > 
basic_iostream < wchar _t > 

basic_stringbuf < wchar _t > 
basic_istringstream <wchar 
basic_ostringstream <wchar 

wstreambuf ; 
wistream ; 
wostream ; 
wiostream ; 

wstringbuf ; 
_t > wistringstream ; 
_t > wostringstream ; 

basic_stringstream <wchar _t > wstringstream; 

basic _filebuf < wchar _t > wfilebuf ; 
basic_ifstream < wchar _t > wifstream ; 
basic_ofstream < wchar _t > wofstream ; 
basic _fstream < wchar _t > wfstream ; 

< class state > class fpos ; 
fpos<char_traits<char>::state _type> streampos; 
fpos <char_traits <wchar _t >::state_ type > wstreampos; 

Default template arguments are described as appearing both in <iosfwd> andinthe synopsisof other headersbutitis 
well-formed to include both <iosfwd> and one or more of the other headers.280) 

280) It is the implementation’s responsibility to implement headers so that including <iosfwd> and other headers does not violate the rules about 
multiple occurences of default arguments. 

Draft 


27.3 Standard iostream objects Input/output library 704 
2[Note: The class template specialization basic_ios<charT,traits> serves as a virtual base class for the class templates basic_istream, basic_ostream, and class templates derived from them. basic_iostream isa class template 
derived from both basic_istream<charT,traits> and basic_ostream<charT,traits>. 

3 The class template specialization basic_streambuf<charT,traits> serves as a base class for template classes basic_stringbuf and basic_filebuf. 
4 The class template specialization basic_istream<charT,traits> serves asabase class for template classes basic_
istringstream and basic_ifstream. 
5 The class template specialization basic_ostream<charT,traits> serves asabase class for template classes basic_
ostringstream and basic_ofstream. 
6 The class template specialization basic_iostream<charT,traits> serves as a base class for template classes basic_stringstream and basic_fstream. 
7 Other typedefs define instances of class templates specialized for char or wchar_t types. 
8 Specializations of the class template fpos are used for specifying file position information. 
9 The types streampos and wstreampos are used for positioning streams specialized on char and wchar_t respectively. 
10 This synopsis suggests a circularity between streampos and char_traits<char>. An implementation can avoid this 
circularity by substituting equivalent types. One way to do this might be 

template < class stateT > class fpos { ... }; // depends on nothing
typedef ... _STATE ; // implementation private declaration ofstateT
typedef fpos < _ STATE > streampos ;


template <> struct char_traits <char > {
typedef streampos
pos_type ;


// ... 

} 

— end note ] 
27.3 Standard iostream objects [lib.iostream.objects] 
Header <iostream> synopsis 

namespace std {
extern istream cin ;
extern ostream cout ;
extern ostream cerr ;
extern ostream clog ;


extern wistream wcin ;
extern wostream wcout ;
extern wostream wcerr ;
extern wostream wclog ;


} 

Draft 


705 Input/output library 27.3 Standard iostream objects 

1 Theheader <iostream> declares objects that associate objects with the standardCstreams provided forbythe functions 
declared in <cstdio> (27.8.2). 

2 Mixing operations on corresponding wide-and narrow-character streams follows the same semantics as mixing such 
operations on FILEs, as specified in Amendment1of the ISOCstandard. The objects are constructed, and the associations are established at some time prior to or during first time an object of class ios_base::Init is constructed, and 
in any case before the body of main begins execution.281) The objects are not destroyed during program execution.282) 

27.3.1 Narrow stream objects [lib.narrow.stream.objects] 
istream cin ; 

1 The object cin controls input froma streambuffer associated with the object stdin, declared in <cstdio>. 

2 After the object cin is initialized, cin.tie() returns &cout. Its state is otherwise the same as required for 
basic_ios<char>::init (27.4.4.1). 

ostream cout ; 
3 The object cout controls output to a stream buffer associated with the object stdout, declared in <cstdio> 
(27.8.2). 

ostream cerr ; 
4 The object cerr controls output to a stream buffer associated with the object stderr, declared in <cstdio> 
(27.8.2). 

5 After the object cerr is initialized, cerr.flags() & unitbuf is nonzero and cerr.tie() returns &cout. Its 
state is otherwise the same as required for basic_ios<char>::init (27.4.4.1). 

ostream clog ; 
6 The object clog controls output to a stream buffer associated with the object stderr, declared in <cstdio> 
(27.8.2). 

27.3.2 Wide stream objects [lib.wide.stream.objects] 
wistream wcin ; 

1 The object wcin controls input froma streambuffer associated with the object stdin, declared in <cstdio>. 

2 After the object wcin is initialized, wcin.tie() returns &wcout. Its state is otherwise the same as required for 
basic_ios<wchar_t>::init (27.4.4.1). 

wostream wcout ; 

3 The object wcout controls output toa streambuffer associated with the object stdout, declared in <cstdio> 
(27.8.2). 

wostream wcerr ; 

281) If it is possible for them to do so, implementations are encouraged to initialize the objects earlier than required.
282) Constructors and destructors for static objects can access these objects to read input from stdin or write output to stdout or stderr.


Draft 


27.4 Iostreams base classes Input/output library 706 
4 The object wcerr controls output toa streambuffer associated with the object stderr, declared in <cstdio> 
(27.8.2). 

5 After the object wcerr is initialized, wcerr.flags() & unitbuf is nonzero and wcerr.tie() returns &wcout. 
Its state is otherwise the same as required for basic_ios<wchar_t>::init (27.4.4.1). 

wostream wclog ; 

6 The object wclog controls output toa streambuffer associated with the object stderr, declared in <cstdio> 
(27.8.2). 

27.4 Iostreams base classes [lib.iostreams.base] 
Header <ios> synopsis 

# include < iosfwd > 

namespace std {
typedef OFF_T streamoff ;
typedef SZ_T streamsize ;
template < class stateT > class fpos ;


class ios_base ;
template < class charT , class traits = char _traits < charT > >
class basic_ios ;


// 27.4.5, manipulators: 

ios_base & boolalpha ( ios _base & str );
ios_base& noboolalpha(ios _base& str );


ios_base & showbase ( ios _base & str );
ios_base& noshowbase (ios _base& str );


ios_base & showpoint ( ios _base & str );
ios_base& noshowpoint(ios _base& str );


ios_base & showpos ( ios _base & str );
ios_base & noshowpos ( ios _base & str );


ios_base & skipws ( ios _base & str );
ios_base & noskipws ( ios _base & str );


ios_base & uppercase ( ios _base & str );
ios_base& nouppercase(ios _base& str );


ios_base & unitbuf ( ios _base & str );
ios_base & nounitbuf ( ios _base & str );


// 27.4.5.2 adjustfield: 

ios_base & internal ( ios _base & str ); 

Draft 


707 Input/output library 27.4 Iostreams base classes 

ios_base & left ( ios _base & str );
ios_base & right ( ios _base & str );


// 27.4.5.3 basefield: 

ios_base & dec ( ios _base & str );
ios_base & hex ( ios _base & str );
ios_base & oct ( ios _base & str );


// 27.4.5.4 floatfield: 

ios_base & fixed ( ios _base & str );
ios_base& scientific (ios _base& str );
}


27.4.1 Types [lib.stream.types] 
typedef OFF_T streamoff ; 

1 The type streamoff is an implementation-defined type that satisfies the requirements of 27.4.3.2. 

typedef SZ_T streamsize ; 

2 The type streamsize isasynonymforoneofthesignedbasicintegraltypes.Itisusedto representthenumber 
of characters transferredinanI/O operation,orthesizeofI/Obuffers.283) 

27.4.2 Class ios_base [lib.ios.base] 
namespace std {
class ios_base {
public :


class failure ; 

typedef T1 fmtflags ;
static const fmtflags boolalpha ;
static const fmtflags dec ;
static const fmtflags fixed ;
static const fmtflags hex ;
static const fmtflags internal ;
static const fmtflags left ;
static const fmtflags oct ;
static const fmtflags right ;
static const fmtflags scientific;
static const fmtflags showbase ;
static const fmtflags showpoint ;
static const fmtflags showpos ;
static const fmtflags skipws ;


283) streamsize is used in most places where ISO C would use size_t. Most of the uses of streamsize could use size_t, except for the 
strstreambuf constructors, which require negative values. It should probably be the signed type corresponding to size_t (which is what Posix.2 
calls ssize_t). 

Draft 


27.4 Iostreams base classes Input/output library 708 
static const fmtflags unitbuf ; 
static const fmtflags uppercase ; 
static const fmtflags adjustfield; 
static const fmtflags basefield ; 
static const fmtflags floatfield; 

typedef T2 iostate ; 
static const iostate badbit ; 
static const iostate eofbit ; 
static const iostate failbit ; 
static const iostate goodbit ; 

typedef T3 openmode ; 
static const openmode app ; 
static const openmode ate ; 
static const openmode binary ; 
static const openmode in; 
static const openmode out ; 
static const openmode trunc ; 

typedef T4 seekdir ; 
static const seekdir beg ; 
static const seekdir cur ; 
static const seekdir end ; 

class Init ; 

// 27.4.2.2 fmtflags state: 

fmtflags flags () const ;
fmtflags flags ( fmtflags fmtfl );
fmtflags setf ( fmtflags fmtfl );
fmtflags setf ( fmtflags fmtfl , fmtflags mask );
void unsetf ( fmtflags mask );


streamsize precision() const;
streamsize precision(streamsize prec );
streamsize width() const;
streamsize width(streamsize wide );


// 27.4.2.3 locales: 

locale imbue ( const locale & loc ); 
locale getloc () const ; 

// 27.4.2.5 storage: 

static int xalloc (); 
long & iword ( int index ); 
void *& pword ( int index ); 

// destructor 

virtual ~ ios_base (); 

Draft 


709 Input/output library 27.4 Iostreams base classes 

// 27.4.2.6 callbacks; 

enum event { erase_ event , imbue_event , copyfmt_event };
typedef void (*event_callback)(event, ios_base&, int index );
void register_callback(event_callback fn , int index );


static bool sync_with_stdio(bool sync = true ); 

protected :
ios_base ();


private : 

// static int index; exposition only 
// long*iarray; exposition only 
// void** parray; exposition only 

private :
ios_base ( const ios_base &);
ios_base & operator =( const ios_base &);


};
}


1 ios_base defines several member types: 

— a class failure derived from exception; 
— a class Init; 
— three bitmask types, fmtflags, iostate, and openmode; 
— an enumerated type, seekdir. 
2 It maintains several kinds of data: 
— state information that reflects the integrityof the streambuffer; 
— control information that influences how to interpret (format) input sequences and how to generate (format) output 
sequences; 
— additional information thatis stored by the program for its private use. 
3[Note: For the sake of exposition, the maintained data is presented here as: 
— static int index , specifies the nextavailable unique index for the integeror pointer arrays maintained for the 
private use of the program, initialized to an unspecified value; 
— long* iarray , points to the first element of an arbitrary-length long array maintained for the private use of the 
program; 
— void** parray , points to the first element of an arbitrary-length pointer array maintained for the private use of 
the program. — end note ] 
Draft 


27.4 Iostreams base classes Input/output library 710 
27.4.2.1 Types [lib.ios.types] 
27.4.2.1.1 Class ios_base::failure [lib.ios::failure] 
namespace std {
class ios_base :: failure : public exception {
public :


explicit failure ( const string & msg );
virtual const char * what () const throw ();
};
}


1 The class failure defines the base class for the types of all objects thrown as exceptions, by functions in the iostreams 
library, to report errors detected during streambuffer operations. 

explicit failure ( const string & msg ); 

2 Effects: Constructs an object of class failure. 
3 Postcondition:strcmp(what(), msg .c_str()) == 0 

const char * what () const ; 

4 Returns: The message msg with which the exception was created. 

27.4.2.1.2 Typeios_base::fmtflags [lib.ios::fmtflags] 
typedef T1 fmtflags ; 

1 The type fmtflags isa bitmask type(17.3.2.1.2). Setting its elements has theeffects indicatedinTable 86. 
2 Typefmtflags also defines the constants indicatedinTable 87. 

27.4.2.1.3 Typeios_base::iostate [lib.ios::iostate] 
typedef T2 iostate ; 

1 The type iostate isa bitmask type(17.3.2.1.2)that contains the elementsindicatedinTable88. 
2 Typeiostate also defines the constant: 

— goodbit, the value zero. 
27.4.2.1.4 Typeios_base::openmode [lib.ios::openmode] 
typedef T3 openmode ; 

1 The type openmode isa bitmasktype(17.3.2.1.2).It containsthe elements indicatedinTable 89. 

Draft 


711 Input/output library 27.4 Iostreams base classes 

Table 86:fmtflags effects 


Element Effect(s)if set 
boolalpha insert and extract bool type in alphabetic format 
dec converts integer input or generates integer output in decimal base 
fixed generate floating-point outputin fixed-point notation 
hex converts integer input or generates integer output in hexadecimal base 
internal adds fill characters at a designated internal point in certain generated output, or 
identical to right if no such point is designated 
left adds fill characters on the right (final positions) of certain generated output 
oct converts integer input or generates integer output in octal base 
right adds fill characters on the left (initial positions) of certain generated output 
scientific generates floating-point output in scientific notation 
showbase generates a prefix indicatingthe numeric base of generated integer output 
showpoint generates a decimal-point character unconditionally in generated floating-point 
output 
showpos generates a + sign in non-negative generated numeric output 
skipws skips leading whitespace before certain input operations 
unitbuf flushes output after each output operation 
uppercase replaces certain lowercase letters with their uppercase equivalents in generated 
output 


Table 87:fmtflags constants 


Constant Allowable values 
adjustfield left | right | internal 
basefield dec | oct | hex 
floatfield scientific | fixed 


Table 88:iostate effects 


Element Effect(s) if set 
badbit indicates aloss of integrity in an input or output sequence (such as an irrecoverable 
read error from a file); 
eofbit indicates that an input operation reached the end of an input sequence; 
failbit indicates that an input operation failed to read the expected characters, or that an 
output operation failed to generate the desired characters. 


Table 89:openmode effects 


Element Effect(s) if set 
app seek to end before each write 
ate open and seek to end immediately after opening 
binary perform input and output in binary mode (as opposed to text mode) 
in open for input 
out open for output 
trunc truncate an existing stream when opening 


Draft 


27.4 Iostreams base classes Input/output library 712 
27.4.2.1.5 Typeios_base::seekdir [lib.ios::seekdir] 
typedef T4 seekdir ; 

The type seekdir is an enumerated type(17.3.2.1.1)that contains the elements indicatedinTable90. 
Table 90:seekdir effects 

Element Meaning 

beg request a seek (for subsequent input or output) relative to the beginning of the 

stream 
cur request a seek relative to the current position within the sequence 
end request a seek relative to the current end of the sequence 

27.4.2.1.6 Class ios_base::Init [lib.ios::Init] 
namespace std {
class ios_base :: Init {
public :


Init (); 
~ Init (); 
private : 
// static int init_cnt; exposition only 
}; 
} 

1 The class Init describes an object whose construction ensures the construction of the eight objects declared in <iostream> (27.3)that associate file streambuffers withthe standardCstreams provided forby the functions declaredin 
<cstdio> (27.8.2). 

2 For the sake of exposition, the maintained data is presented here as: 

— static int init_cnt , counts the number of constructor and destructor calls for classInit, initialized to zero. 
Init (); 

3 Effects: Constructs an object of class Init. If init_cnt is zero, the function stores the value one in init_
cnt , then constructs and initializes the objects cin, cout, cerr, clog (27.3.1), wcin, wcout, wcerr, and wclog 
(27.3.2). In anycase, the function then adds one to the value stored in init_cnt . 

~ Init (); 

4 Effects: Destroys an object of class Init. The function subtracts one from the value stored ininit_cnt and, 
if the resulting stored value is one, calls cout.flush(), cerr.flush(), clog.flush(), wcout.flush(), 
wcerr.flush(), wclog.flush(). 

27.4.2.2 ios_base state functions [lib.fmtflags.state] 
fmtflags flags () const ; 

Draft 


713 Input/output library 27.4 Iostreams base classes 
1 Returns: The format control information for both input and output. 
f m t f l a g s f l a g s ( f m t f l a g s fmtfl ) ; 
2 Postcondition:fmtfl == flags(). 
3 Returns: The previous value of flags(). 
f m t f l a g s s e t f ( f m t f l a g s fmtfl ) ; 
4 Effects: Sets fmtfl in flags(). 
5 Returns: The previous value of flags(). 
f m t f l a g s s e t f ( f m t f l a g s fmtfl , f m t f l a g s mask ) ; 
6 Effects: Clears mask in flags(), sets fmtfl & mask in flags(). 
7 Returns: The previous value of flags(). 
v o i d u n s e t f ( f m t f l a g s mask ) ; 
8 Effects: Clears mask in flags(). 
s t r e a m s i z e p r e c i s i o n ( ) c o n s t ; 
9 Returns: The precision to generate on certain output conversions. 
s t r e a m s i z e p r e c i s i o n ( s t r e a m s i z e prec ) ; 
10 Postcondition:prec == precision(). 
11 Returns: The previous value of precision(). 
s t r e a m s i z e w i d t h ( ) c o n s t ; 
12 Returns: The minimum field width (number of characters) to generate on certain output conversions. 
s t r e a m s i z e w i d t h ( s t r e a m s i z e wide ) ; 
13 Postcondition:wide == width(). 
14 Returns: The previous value of width(). 
27.4.2.3 ios_base functions [lib.ios.base.locales] 
l o c a l e i m b u e ( c o n s t l o c a l e & loc ) ; 
1 Effects: Calls each registered callback pair (fn ,index ) (27.4.2.6)as(*fn )(imbue_event,*this,index ) at 
such a time that a call to ios_base::getloc() from within fn returns the new locale value loc . 
2 Returns: The previous value of getloc(). 
3 Postcondition:loc == getloc(). 
l o c a l e g e t l o c ( ) c o n s t ; 
Draft 


27.4 Iostreams base classes Input/output library 714 
4 Returns: If no locale has been imbued, a copy of the global C++ locale, locale(), in effect at the time of 
construction. Otherwise, returns the imbued locale, to be used to perform locale-dependent input and output 
operations. 

27.4.2.4 ios_base static members [lib.ios.members.static] 
bool sync_with_stdio(bool sync = true ); 

1 Returns: true iftheprevious stateofthe standard iostream objects(27.3)was synchronizedandotherwise returns 
false. The first time it is called, the function returns true. 

2 Effects: If any input or output operation has occurred using the standard streams prior to the call, the effect 
is implementation-defined. Otherwise, called with a false argument, it allows the standard streams to operate 
independentlyof the standardCstreams. 

3 When a standard iostream object str is synchronized with a standard stdio stream f , the effect of inserting a 
character c by 

fputc(f, c); 

is the same as the effect of 

str . rdbuf ()-> sputc (c); 

for anysequences of characters; the effect of extracting a character c by 

c = fgetc(f); 

is the same as the effect of 

c = str.rdbuf()->sbumpc(c); 

for anysequences of characters; and the effect of pushing back a character c by 

ungetc(c, f); 

is the same as the effect of 

str . rdbuf ()-> sputbackc (c); 

for anysequence of characters.284) 

27.4.2.5 ios_base storage functions [lib.ios.base.storage] 
static int xalloc (); 

1 Returns: index ++. 

284)This implies that operationsonastandard iostream object canbemixed arbitrarily with operationsonthe corresponding stdio stream.In practical 
terms, synchronization usually means thata standard iostream object anda standard stio object shareabuffer. 

Draft 


715 Input/output library 27.4 Iostreams base classes 

long & iword ( int idx ); 

2 Effects: If iarray is a null pointer, allocates an array of long of unspecified size and storesa pointerto its first 
element in iarray . Thefunctionthenextendsthe arraypointedatby iarray as necessary to include the element 
iarray [idx ]. Each newly allocated element of the array is initialized to zero. The reference returned is invalid 
afteranyother operationsontheobject.285)However,thevalueofthe storagereferredtois retained,sothat until 
the next call to copyfmt, calling iword with the same index yields another reference to the same value. If the 
functionfails286) and *this is a base subobject of a basic_ios<> object or subobject, the effect is equivalent to 
calling basic_ios<>::setstate(badbit) on the derived object (which may throw failure). 

3 Returns: On success iarray [idx ]. Onfailure,avalid long& initialized to 0. 

void* & pword(int idx ); 

4 Effects: If parray isanullpointer, allocatesanarrayof pointersto void of unspecified size and stores a pointer 
to its first element in parray . The function then extends the array pointed at by parray as necessary to include 
the element parray [idx ]. Each newly allocated element of the array is initialized to a null pointer. The 
reference returned is invalid after anyother operations on the object. However, the value of the storage referred 
to is retained, so that until the next call to copyfmt, calling pword with the same index yields another reference 
to the samevalue. If the functionfails287) and *this is a base subobject of a basic_ios<> object or subobject, 
the effect is equivalent to calling basic_ios<>::setstate(badbit) on the derived object (which may throw 
failure). 

5 Returns: On success parray [idx ]. Onfailureavalid void*& initialized to 0. 

6 Remarks: After a subsequent call to pword(int) for the same object, the earlier return value may no longer be 
valid. 

27.4.2.6 ios_base callbacks [lib.ios.base.callback] 
void register_callback(event_callback fn , int index ); 

1 Effects: Registers the pair (fn ,index ) such that during calls to imbue() (27.4.2.3), copyfmt(), or ~ios_
base() (27.4.2.7), the function fn is called with argument index . Functions registered are called when an event 
occurs, in opposite order of registration. Functions registered while a callback function is active are not called 
until the next event. 

2 Requires: The function fn shall not throw exceptions. 

Remarks: Identical pairs are not merged.Afunction registered twice willbe called twice. 

27.4.2.7 ios_base constructors/destructors [lib.ios.base.cons] 
ios _base (); 

285) An implementation is free to implement both the integer array pointed at by iarray and the pointer array pointed at by parray as sparse data 

structures, possibly with a one-element cache for each.
286) for example, because it cannot allocate space.
287) for example, because it cannot allocate space.


Draft 


27.4 Iostreams base classes Input/output library 716 
1 Effects: Each ios_base memberhasan indeterminatevalue after construction. These members shallbe initialized 
by calling basic_ios::init. If an ios_base object is destroyed before these initializations have taken place, 
the behavior is undefined. 

~ ios_base () 

2 Effects: Destroys an object of class ios_base. Calls each registered callback pair (fn , index ) (27.4.2.6)as 
(*fn )(erase_event, *this, index ) at such time that any ios_base member function called from within 
fn has well defined results. 

27.4.3 Class template fpos [lib.fpos] 
namespace std {
template < class stateT > class fpos {
public :


// 27.4.3.1 Members 

stateT state () const ;
void state ( stateT );
private ;


// stateT st; exposition only 

};
}


27.4.3.1 fpos Members [lib.fpos.members] 
void state ( stateT s ); 

1 Effects: Assign s to st . 

stateT state () const ; 

2 Returns: Current value of st . 

27.4.3.2 fpos requirements [lib.fpos.operations] 
1 Operations specifiedinTable 91 are permitted.In that table, 

— P refers to an instance of fpos, 
— p and q refer to values of type P, 
— O refers to type streamoff,
— o refers to a value of type streamoff,
— sz refers to a value of type streamsize and 
— i refers to a value of type int. 
Draft 


717 Input/output library 27.4 Iostreams base classes 

Table 91: Position type requirements 

expression return type operational 
semantics 
assertion/note 
pre/post-condition 
P(i) p == P(i) 
note: a destructor is assumed. 
P p(i); 
P p = i; 
post: p == P(i). 
P(o) fpos converts from offset 
O(p) OFF_T converts to offset P(O(p)) == p 
p == q convertible to bool == is an equivalence relation 
p != q convertible to bool !(p == q) 
q = p + o 
p += o 
fpos + offset q -o == p 
q = p -o 
p -= o 
fpos -offset q + o == p 
o = p -q OFF_T distance q + o == p 
streamsize(o) 
O(sz) 
streamsize 
OFF_T 
converts 
converts 
streamsize(O(sz)) == sz 
streamsize(O(sz)) == sz 

2 [Note: Every implementation is required to supply overloaded operators on fpos objects to satisfy the requirements of 

27.4.3.2. It is unspecified whether these operators are members of fpos, global operators, or provided in some other 
way. — end note ] 
3 Stream operations that return a value of type traits::pos_type return P(O(-1)) as an invalid value to signal an 
error.If thisvalueis usedasanargumenttoany istream, ostream, or streambuf member that acceptsavalueof type 
traits::pos_type then the behavior of that function is undefined. 

27.4.4 Class template basic_ios [lib.ios] 
namespace std { 

template < class charT , class traits = char _traits < charT > > 

class basic_ios : public ios_base { 

public : 

// Types: 

typedef charT char_type ; 

typedef typename traits :: int_type int_type ; 

typedef typename traits :: pos_type pos_type ; 

typedef typename traits :: off_type off_type ; 

typedef traits traits_type; 

operator void*unspecified-bool-type () const ;
bool operator !() const ;
iostate rdstate () const ;
void clear ( iostate state = goodbit );
Draft 


27.4 Iostreams base classes Input/output library 718 
void setstate ( iostate state );
bool good () const ;
bool eof () const ;
bool fail () const ;
bool bad () const ;


iostate exceptions() const;
void exceptions(iostate except );


// 27.4.4.1 Constructor/destructor: 

explicit basic_ios(basic_streambuf <charT ,traits >* sb );
virtual ~ basic_ios ();


// 27.4.4.2 Members: 

basic_ostream < charT , traits >* tie () const ;
basic_ostream <charT ,traits >* tie(basic_ostream <charT ,traits >* tiestr );


basic_streambuf < charT , traits >* rdbuf () const ;
basic_streambuf < charT , traits >* rdbuf ( basic_streambuf < charT , traits >* sb );


basic_ios& copyfmt(const basic_ios& rhs );


char_type fill() const;
char_type fill(char_type ch );


// 27.4.2.3 locales: 

locale imbue ( const locale & loc ); 

char narrow(char_type c , char dfault ) const ;
char_type widen(char c ) const ;


protected :
basic_ios ();
void init(basic_streambuf <charT ,traits >* sb );


private :
basic_ios(const basic_ios& ); // not defined
basic_ios& operator=(const basic_ios&); // not defined


};
}


27.4.4.1 basic_ios constructors [lib.basic.ios.cons] 
explicit basic_ios ( basic_streambuf < charT , traits >* sb ); 

Effects: Constructs an object of class basic_ios, assigning initial values to its member objects by calling 
init(sb ). 

basic_ios (); 

Draft 


719 Input/output library 27.4 Iostreams base classes 

2 Effects: Constructs an object of class basic_ios (27.4.2.7)leavingits member objects uninitialized. The object 
shallbe initializedbycallingits init member function. If it is destroyed before it has been initialized the behavior 
is undefined. 

~ basic_ios (); 

3 Remarks: The destructor does not destroy rdbuf(). 

void init(basic_streambuf <charT ,traits >* sb ); 

Postconditions:The postconditionsof this function are indicatedinTable 92. 

Table 92:basic_ios::init() effects 

Element Value 
rdbuf() 
tie() 
rdstate() 
exceptions() 
flags() 
width() 
precision() 
fill() 
getloc() 
iarray 
parray 
sb 
0 
goodbit if sb is not a null pointer, otherwise badbit. 
goodbit 
skipws | dec 
0 
6 
widen(’ ’); 
a copyof the value returned by locale() 
a null pointer 
a null pointer 

27.4.4.2 Member functions [lib.basic.ios.members] 
basic_ostream <charT ,traits >* tie() const; 

1 Returns: An output sequence that is tied to (synchronized with) the sequence controlledby the streambuffer. 

basic_ostream <charT ,traits >* tie(basic_ostream <charT ,traits >* tiestr ); 

2 Postcondition:tiestr == tie(). 

3 Returns: The previous value of tie(). 

basic _streambuf <charT ,traits >* rdbuf() const; 

4 Returns: Apointer to thestreambuf associated with the stream. 

basic _streambuf <charT ,traits >* rdbuf(basic_streambuf <charT ,traits >* sb ); 

5 Postcondition:sb == rdbuf(). 
6 Effects: Calls clear(). 
7 Returns: The previous value of rdbuf(). 

Draft 


27.4 Iostreams base classes Input/output library 720 
// 27.4.2.3 locales: 

locale imbue ( const locale & loc ); 

8 Effects: Calls ios_base::imbue(loc ) (27.4.2.3)and ifrdbuf()!=0 then rdbuf()->pubimbue(loc ) (27.5.2.2.1). 
9 Returns: The prior value of ios_base::imbue(). 

char narrow ( char_type c , char dfault ) const ; 
10 Returns: use_facet< ctype<char_type> >(getloc()).narrow(c ,dfault ) 
char_type widen(char c ) const ; 

11 Returns: use_facet< ctype<char_type> >(getloc()).widen(c ) 

char_type fill() const; 

12 Returns: The character used to pad (fill)an output conversion to the specified field width. 

char_type fill(char_type fillch ); 
13 Postcondition:traits::eq(fillch , fill()) 
14 Returns: The previous value of fill(). 

basic_ios& copyfmt(const basic_ios& rhs ); 

15 Effects: If (this == &rhs ) does nothing. Otherwise assigns to the member objects of *this the corresponding 
member objects of rhs , except that: 

— rdstate() and rdbuf() are left unchanged; 
— exceptions() is altered last by calling exceptions(rhs.except ). 
— The contentsof arrays pointedatby pword and iword are copied not the pointers themselves.288) 
16 If any newly stored pointer values in *this point at objects stored outside the object rhs , and those objects are destroyed when rhs is destroyed, the newly stored pointer values are altered to point at newly 
constructed copies of the objects. 

17 Before copying any parts of rhs , calls each registered callback pair (fn , index ) as (*fn )(erase_
event, *this, index ). After all partsbut exceptions() have been replaced, calls each callback pair 
that was copied from rhs as (*fn )(copyfmt_event,*this,index ). 

18 Remarks: The second pass permitsacopied pword value to be zeroed, or its referent deep copied or reference 
counted or have other special action taken. 

19 Returns: *this. 

27.4.4.3 basic_ios flags functions [lib.iostate.flags] 
operator void*unspecified-bool-type () const ; 
288)Thissuggestsan infiniteamountofcopying,butthe implementationcankeeptrackofthemaximumelementofthearraysthatis non-zero. 

Draft 


721 Input/output library 27.4 Iostreams base classes 

Returns: If fail() then a null pointer; otherwise some non-null pointer to indicate success.then a value that will 
evaluatefalseina boolean context; otherwiseavalue that willevaluate trueina boolean context. Thevalue type 

returned shall not be convertible to int. 

[Note: This conversion canbe usedin contexts wherea bool isexpected (e.g., an if condition); however, implicit 
conversions (e.g., to int)that can occur with bool are not allowed, eliminating some sources of user error. One 
possible implementation choice for this type is pointer-to-member. — end note ] 

bool operator !() const ; 

2 Returns: fail(). 

iostate rdstate () const ; 

3 Returns: The error stateof the streambuffer. 

void clear ( iostate state = goodbit ); 

4 Postcondition: If rdbuf()!=0 then state == rdstate(); otherwise rdstate()==(state | ios_base:: 
badbit). 

5 Effects: If ((state | (rdbuf() ? goodbit : badbit)) & exceptions()) == 0, returns. Otherwise, 
the function throws an object fail of class basic_ios::failure (27.4.2.1.1),constructed with implementation-
defined argument values. 

void setstate ( iostate state ); 

6 Effects: Calls clear(rdstate() | state ) (which may throw basic_ios::failure (27.4.2.1.1)). 

bool good () const ; 

7 Returns: rdstate() == 0 

bool eof () const ; 

8 Returns: true if eofbit is set in rdstate(). 

bool fail () const ; 

9 Returns: true if failbit or badbit is set in rdstate().289) 

bool bad () const ; 

10 Returns: true if badbit is set in rdstate(). 

iostate exceptions() const; 

11 Returns: Amask that determines what elements set inrdstate() cause exceptions to be thrown. 

void exceptions(iostate except ); 
12 Postcondition:except == exceptions(). 
13 Effects: Calls clear(rdstate()). 

289) Checking badbit also for fail() is historical practice. 

Draft 


27.4 Iostreams base classes Input/output library 722 
27.4.5 ios_base manipulators 
27.4.5.1 fmtflags manipulators 
[lib.std.ios.manip] 
[lib.fmtflags.manip] 
1 
2 
i o s _ b a s e & b o o l a l p h a ( i o s _ b a s e & str ) ; 
Effects: Calls str .setf(ios_base::boolalpha). 
Returns: str . 
3 
4 
i o s _ b a s e & n o b o o l a l p h a ( i o s _ b a s e & str ) ; 
Effects: Calls str .unsetf(ios_base::boolalpha). 
Returns: str . 
5 
6 
i o s _ b a s e & s h o w b a s e ( i o s _ b a s e & str ) ; 
Effects: Calls str .setf(ios_base::showbase). 
Returns: str . 
7 
8 
i o s _ b a s e & n o s h o w b a s e ( i o s _ b a s e & str ) ; 
Effects: Calls str .unsetf(ios_base::showbase). 
Returns: str . 
9 
10 
i o s _ b a s e & s h o w p o i n t ( i o s _ b a s e & str ) ; 
Effects: Calls str .setf(ios_base::showpoint). 
Returns: str . 
11 
12 
i o s _ b a s e & n o s h o w p o i n t ( i o s _ b a s e & str ) ; 
Effects: Calls str .unsetf(ios_base::showpoint). 
Returns: str . 
13 
14 
i o s _ b a s e & s h o w p o s ( i o s _ b a s e & str ) ; 
Effects: Calls str .setf(ios_base::showpos). 
Returns: str . 
15 
16 
i o s _ b a s e & n o s h o w p o s ( i o s _ b a s e & str ) ; 
Effects: Calls str .unsetf(ios_base::showpos). 
Returns: str . 
17 
18 
i o s _ b a s e & s k i p w s ( i o s _ b a s e & str ) ; 
Effects: Calls str .setf(ios_base::skipws). 
Returns: str . 
Draft 


723 Input/output library 27.4 Iostreams base classes 

ios _base & noskipws ( ios_base & str ); 

19 Effects: Calls str .unsetf(ios_base::skipws). 
20 Returns: str . 

ios _base & uppercase ( ios_base & str ); 

21 Effects: Calls str .setf(ios_base::uppercase). 
22 Returns: str . 

ios _base& nouppercase(ios_base& str ); 

23 Effects: Calls str .unsetf(ios_base::uppercase). 
24 Returns: str . 

ios _base & unitbuf ( ios_base & str ); 

25 Effects: Calls str .setf(ios_base::unitbuf). 
26 Returns: str . 

ios _base & nounitbuf ( ios_base & str ); 
27 Effects: Calls str .unsetf(ios_base::unitbuf). 
28 Returns: str . 

27.4.5.2 adjustfield manipulators [lib.adjustfield.manip] 
ios _base & internal ( ios_base & str ); 

1 Effects: Calls str .setf(ios_base::internal, ios_base::adjustfield). 

2 Returns: str . 

ios _base & left ( ios_base & str ); 

3 Effects: Calls str .setf(ios_base::left, ios_base::adjustfield).
4 Returns: str .


ios _base & right ( ios_base & str ); 

5 Effects: Calls str .setf(ios_base::right, ios_base::adjustfield).
6 Returns: str .


27.4.5.3 basefield manipulators [lib.basefield.manip] 
ios _base& dec(ios_base& str ); 

Draft 


27.5 Streambuffers Input/output library 724 
1 Effects: Calls str .setf(ios_base::dec, ios_base::basefield). 
2 Returns: str 290). 

ios _base& hex(ios_base& str ); 

3 Effects: Calls str .setf(ios_base::hex, ios_base::basefield). 
4 Returns: str . 

ios _base& oct(ios_base& str ); 
5 Effects: Calls str .setf(ios_base::oct, ios_base::basefield). 
6 Returns: str . 

27.4.5.4 floatfield manipulators [lib.floatfield.manip] 
ios _base & fixed ( ios_base & str ); 

1 Effects: Calls str .setf(ios_base::fixed, ios_base::floatfield). 
2 Returns: str . 

ios _base & scientific ( ios_base & str ); 
3 Effects: Calls str .setf(ios_base::scientific, ios_base::floatfield). 
4 Returns: str . 

27.5 Streambuffers [lib.stream.buffers] 
Header <streambuf> synopsis 
namespace std { 

template < class charT , class traits = char _traits < charT > > 

class basic_streambuf; 

typedef basic_streambuf <char > streambuf; 

typedef basic_streambuf < wchar _t > wstreambuf ; 

} 

1 The header <streambuf> defines types that controlinput from and output to character sequences. 

27.5.1 Streambufferrequirements [lib.streambuf.reqts] 
1 Streambuffers can imposevarious constraints on the sequences theycontrol. Some constraints are: 

— The controlled input sequence can be not readable. 
— The controlled output sequence can be not writable. 
290) The function signature dec(ios_base&) can be called by the function signature basic_ostream& stream::operator<<(ios_base& 
(*)(ios_base&)) to permit expressions of the form cout << dec to change the format flags stored in cout. 

Draft 


725 Input/output library 27.5 Streambuffers 

— The controlled sequences can be associated with the contents of other representations for character sequences, 
such as external files. 
— The controlled sequences can support operations directly to or from associated sequences. 
— The controlled sequences can impose limitations on how the program can read characters from a sequence, write 
characterstoa sequence,put charactersbackintoaninput sequence,oralterthestream position. 
2 Each sequence is characterized by three pointers which, if non-null, all point into the same charT array object. The 
array object represents, at anymoment, a (sub)sequence of characters from the sequence. Operations performed on a 
sequence alterthevaluesstoredin these pointers, perform readsand writesdirectlytoor from associated sequences,and 
alter “the stream position” and conversion state as needed to maintain this subsequence relationship. The three pointers 
are: 

— the beginning pointer, or lowest element address in the array (called xbeg here); 
— the next pointer, or next element address thatis a current candidate for reading or writing (called xnext here); 
— the end pointer, or first element address beyond the end of the array (called xend here). 
3 The following semantic constraints shall always apply for any set of three pointers for a sequence, using the pointer 
names given immediately above: 

— If xnext is not a null pointer, then xbeg and xend shall also be non-null pointers into the same charT array, as 
described above; otherwise, xbeg and xend shall also be null. 
— If xnext is not a null pointer and xnext < xend for an output sequence, then a write position is available. In 
this case, *xnext shall be assignable as the next element to write (to put, or to store a character value, into the 
sequence). 
— If xnext is not a null pointer and xbeg < xnext for an input sequence, then a putbackposition is available. In 
this case, xnext [-1] shall have a defined value and is the next (preceding) element to store a character that is 
put back into the input sequence. 
— If xnext is not a null pointer and xnext < xend for an input sequence, then a read position is available. In 
this case, *xnext shallhaveadefinedvalueandisthenextelementtoread(toget,orto obtaina charactervalue, 
from the sequence). 
27.5.2 Class template basic_streambuf<charT,traits> [lib.streambuf] 
namespace std { 

template < class charT , class traits = char _traits < charT > > 

class basic_streambuf { 

public : 

// Types: 

typedef charT char_type ; 

typedef typename traits :: int_type int_type ; 

typedef typename traits :: pos_type pos_type ; 

typedef typename traits :: off_type off_type ; 

typedef traits traits_type; 

Draft 


27.5 Streambuffers Input/output library 726 
virtual ~basic_streambuf(); 

// 27.5.2.2.1 locales: 

locale pubimbue ( const locale & loc );
locale getloc () const ;


// 27.5.2.2.2buffer and positioning: 

basic_streambuf < char_ type , traits >*
pubsetbuf(char_type * s , streamsize n );
pos_type pubseekoff(off_type off , ios_base :: seekdir way ,
ios_base :: openmode which =
ios_base :: in | ios_base :: out );
pos_type pubseekpos(pos_type sp ,
ios_base :: openmode which =
ios_base :: in | ios_base :: out );
int pubsync ();


// Get and put areas:
// 27.5.2.2.3 Get area:


streamsize in_avail ();
int_type snextc ();
int_type sbumpc ();
int_type sgetc ();
streamsize sgetn(char_type* s , streamsize n );


// 27.5.2.2.4 Putback: 

int_type sputbackc(char_type c );
int_type sungetc ();


// 27.5.2.2.5 Put area: 

int_type sputc ( char_type c );
streamsize sputn(const char_type* s , streamsize n );


protected : 
basic_streambuf (); 

// 27.5.2.3.1 Get area: 

char_type* eback() const;
char_type* gptr() const;
char_type* egptr() const;
void gbump ( int n );
void setg(char_type* gbeg , char_type * gnext , char_type * gend );


// 27.5.2.3.2 Put area: 

char_type* pbase() const;
char_type* pptr() const;
char_type* epptr() const;
void pbump ( int n );
void setp(char_type* pbeg , char_type * pend );


Draft 


727 Input/output library 27.5 Streambuffers 

// 27.5.2.4 virtual functions:
// 27.5.2.4.1 Locales:


virtual void imbue ( const locale & loc ); 

// 27.5.2.4.2 Buffer management and positioning: 

virtual basic_streambuf <char _type ,traits >* 
setbuf ( char_type * s , streamsize n ); 
virtual pos_type seekoff ( off_type off , ios_base :: seekdir way , 
ios_base :: openmode which = ios_base :: in | ios_base :: out ); 
virtual pos_type seekpos ( pos_type sp , 
ios_base :: openmode which = ios_base :: in | ios_base :: out ); 
virtual int sync (); 

// 27.5.2.4.3 Get area: 

virtual streamsize showmanyc ();
virtual streamsize xsgetn(char_type* s , streamsize n );
virtual int_type underflow ();
virtual int_type uflow ();


// 27.5.2.4.4 Putback: 

virtual int_type pbackfail ( int_type c = traits :: eof ()); 

// 27.5.2.4.5 Put area: 

virtual streamsize xsputn(const char_type* s , streamsize n );
virtual int_type overflow ( int_type c = traits :: eof ());
};
}


1 The class template basic_streambuf<charT,traits> serves as an abstract base class for deriving various stream 
bufferswhose objects each control two character sequences: 

— a character input sequence; 
— a character output sequence. 
2[Note: This paragraph is intentionallyempty. — end note ] 
3[Note: This paragraph is intentionallyempty. — end note ] 
27.5.2.1 basic_streambuf constructors [lib.streambuf.cons] 
basic_streambuf (); 

1 Effects: Constructs an object of class basic_streambuf<charT,traits> and initializes:291) 

— all its pointer member objects to null pointers, 
— the getloc() member to a copythe global locale, locale(), at the time of construction. 
291) The default constructor is protected for class basic_streambuf to assure that only objects for classes derived from this class may be constructed. 

Draft 


27.5 Streambuffers Input/output library 728 
2 Remarks: Once the getloc() member is initialized, results of calling locale member functions, and of members 
offacets so obtained, cansafelybe cached until the next time the member imbue is called. 

~basic_streambuf (); 

3 Effects: None. 

27.5.2.2 basic_streambuf public member functions [lib.streambuf.members] 
27.5.2.2.1 Locales [lib.streambuf.locales] 
locale pubimbue ( const locale & loc ); 
1 Postcondition:loc == getloc(). 
2 Effects: Calls imbue(loc ). 
3 Returns: Previous value of getloc(). 

locale getloc () const ; 

4 Returns: If pubimbue() has ever been called, then the last value of loc supplied, otherwise the current global 
locale, locale(), in effect at the time of construction. If called after pubimbue() has been calledbut before 
pubimbue has returned (i.e. from within the call of imbue())then it returns the previous value. 

27.5.2.2.2 Buffer managementand positioning [lib.streambuf.buffer] 
basic _streambuf < char _type , traits >* pubsetbuf ( char_type * s , streamsize n ); 

1 Returns: setbuf(s , n ). 

pos _type pubseekoff ( off_type off , ios_base :: seekdir way , 
ios_base :: openmode which = ios_base :: in | ios_base :: out ); 
2 Returns: seekoff(off , way , which ). 
pos _type pubseekpos ( pos_type sp , 
ios_base :: openmode which = ios_base :: in | ios_base :: out ); 
3 Returns: seekpos(sp , which ). 

int pubsync (); 

4 Returns: sync(). 

27.5.2.2.3 Get area [lib.streambuf.pub.get] 
streamsize in_avail (); 

1 Returns: Ifaread positionisavailable,returns egptr() -gptr(). Otherwise returns showmanyc() (27.5.2.4.3). 

int _type snextc (); 

Draft 


729 Input/output library 27.5 Streambuffers 

2 Effects: Calls sbumpc().
3 Returns: if that function returns traits::eof(), returns traits::eof(). Otherwise, returns sgetc().


int _type sbumpc (); 

4 Returns: Iftheinput sequenceread positionisnotavailable, returns uflow(). Otherwise, returns traits::to_
int_type(*gptr()) and increments the next pointer for the input sequence. 

int _type sgetc (); 

5 Returns: Iftheinput sequenceread positionisnotavailable, returns underflow(). Otherwise, returns traits:: 
to_int_type(*gptr()). 

streamsize sgetn ( char_type * s , streamsize n ); 

6 Returns: xsgetn(s , n ). 

27.5.2.2.4 Putback [lib.streambuf.pub.pback] 
int _type sputbackc ( char_type c ); 

1 Returns: If the input sequence putback position is not available, or if traits::eq(c ,gptr()[-1]) isfalse, returns pbackfail(traits::to_int_type(c )). Otherwise, decrements the next pointer for the input sequence 
and returns traits::to_int_type(*gptr()). 

int _type sungetc (); 

2 Returns: If the input sequence putback position is not available, returns pbackfail(). Otherwise, decrements 
the next pointer for the input sequence and returns traits::to_int_type(*gptr()). 

27.5.2.2.5 Put area [lib.streambuf.pub.put] 
int _type sputc ( char_type c ); 

1 Returns: If the output sequence write positionis notavailable, returns overflow(traits::to_int_type(c )). 
Otherwise, stores c at the next pointer for the output sequence, increments the pointer,and returns traits::to_
int_type(c ). 

streamsize sputn ( const char_type * s , streamsize n ); 

2 Returns: xsputn(s ,n ). 

27.5.2.3 basic_streambuf protected member functions [lib.streambuf.protected] 
27.5.2.3.1 Get area access [lib.streambuf.get.area] 
char_type* eback() const; 

1 Returns: The beginning pointer for the input sequence. 

Draft 


27.5 Streambuffers Input/output library 730 
char_type* gptr() const; 

2 Returns: The next pointer for the input sequence. 

char_type* egptr() const; 

3 Returns: The end pointer for the input sequence. 

void gbump ( int n ); 

4 Effects: Adds n to the next pointer for theinput sequence. 
void setg ( char_type * gbeg , char_type * gnext , char_type * gend ); 

5 Postconditions:gbeg == eback(), gnext == gptr(), and gend == egptr(). 

27.5.2.3.2 Put area access [lib.streambuf.put.area] 
char_type* pbase() const; 

1 Returns: The beginning pointer for the output sequence. 

char_type* pptr() const; 

2 Returns: The next pointer for the output sequence. 

char_type* epptr() const; 

3 Returns: The end pointer for the output sequence. 

void pbump ( int n ); 

4 Effects: Adds n to the next pointer for the output sequence. 
void setp ( char_type * pbeg , char_type * pend ); 

5 Postconditions:pbeg == pbase(), pbeg == pptr(), and pend == epptr(). 

27.5.2.4 basic_streambuf virtual functions [lib.streambuf.virtuals] 
27.5.2.4.1 Locales [lib.streambuf.virt.locales] 
void imbue ( const locale &) 

1 Effects: Change anytranslations based on locale. 

2 Remarks: Allows the derived class to be informed of changes in locale at the time theyoccur. Between invocations 
ofthis functionaclassderivedfrom streambufcansafelycache resultsofcallstolocale functionsandto members 
offacets so obtained. 

3 Default behavior: Does nothing. 

Draft 


731 Input/output library 27.5 Streambuffers 

27.5.2.4.2 Buffer managementand positioning [lib.streambuf.virt.buffer] 
basic_streambuf* setbuf(char_type* s , streamsize n ); 

1 Effects: Influences stream buffering in a way that is defined separately for each class derived from basic_
streambuf in this clause(27.7.1.3, 27.8.1.4). 

2 Default behavior: Does nothing. Returns this. 

pos _type seekoff ( off_type off , ios_base :: seekdir way ,
ios_base :: openmode which
= ios_base :: in | ios _base :: out );


3 Effects: Alters the stream positions within one or more of the controlled sequences in a way that is defined 
separately for each class derived from basic_streambuf in this clause(27.7.1.3, 27.8.1.4). 

4 Default behavior: Returns pos_type(off_type(-1)). 

pos _type seekpos ( pos_type sp ,
ios_base :: openmode which
= ios_base :: in | ios _base :: out );


5 Effects: Alters the stream positions within one or more of the controlled sequences in a way that is defined 
separately for each class derived from basic_streambuf in this clause(27.7.1, 27.8.1.1). 

6 Default behavior: Returns pos_type(off_type(-1)). 

int sync (); 

7 Effects: Synchronizes the controlled sequences with the arrays. That is, if pbase() is non-null the characters between pbase() and pptr() are written to the controlled sequence. The pointers may then be reset as appropriate. 
8 Returns: -1 onfailure. What constitutesfailureis determinedby each derived class(27.8.1.4). 
9 Default behavior: Returns zero. 

27.5.2.4.3 Get area [lib.streambuf.virt.get] 
streamsize showmanyc (); 292) 

1 Returns: an estimate of the number of characters available in the sequence, or -1. If it returns a positive value, 
then successive calls to underflow() will not return traits::eof() until at least that number of characters 
have been extracted from the stream. If showmanyc() returns -1, then calls to underflow() or uflow() will 
fail.293) 

2 Default behavior: Returns zero. 
3 Remarks: Uses traits::eof(). 

streamsize xsgetn ( char_type * s , streamsize n ); 

292)The morphemesof showmanyc are "es-how-many-see", not "show-manic". 
293) underflow or uflow mightfailbythrowinganexception prematurely.The intentionisnotonlythatthecallswillnot return eof() but that 
theywill return “immediately.” 

Draft 


27.5 Streambuffers Input/output library 732 
4 Effects: Assigns up to n characters to successive elements of the array whose first element is designated by s . 
The characters assigned are read from the input sequence as if by repeated calls to sbumpc(). Assigning stops 
when either n characters have been assigned or a call to sbumpc() would return traits::eof(). 

5 Returns: The number of characters assigned.294) 

6 Remarks: Uses traits::eof(). 

int _type underflow (); 

7 Remarks: The public members of basic_streambuf call this virtual function only if gptr() is null or gptr() 
>= egptr() 

8 Returns: traits::to_int_type(c ), where c is the first character of the pending sequence, without moving 
the input sequence position past it. If the pending sequence is null then the function returns traits::eof() to 
indicatefailure. 

9 The pending sequence of characters is defined as the concatenation of: 
a) If gptr() is non-NULL, then the egptr() -gptr() characters starting at gptr(), otherwise the empty 
sequence. 
b) Some sequence (possibly empty) of characters read from the input sequence. 

10 The result character is 
a) If the pending sequence is non-empty, the first character of the sequence. 
b) If the pending sequence is emptythen the next character that would be read from the input sequence. 

11 The backup sequence is defined as the concatenation of: 
a) If eback() is null then empty, 
b) Otherwise the gptr() -eback() characters beginning at eback(). 

12 Effects: The function sets up the gptr() and egptr() satisfying one of: 
a) If the pendingsequence is non-empty, egptr() is non-null and egptr() -gptr() characters starting at 
gptr() are the charactersin thepending sequence 
b) If the pending sequence is empty,eithergptr() is null or gptr() and egptr() are set to the same non-NULL 
pointer. 
13 If eback() and gptr() are non-nullthenthefunctionisnot constrainedastotheir contents,butthe“usualbackup 
condition” is that either: 
a) Ifthe backup sequence containsatleastgptr() -eback() characters, then the gptr() -eback() characters starting at eback() agree with the last gptr() -eback() characters of the backup sequence. 
b) Or the n characters starting at gptr() -n agree with the backup sequence (where n is the length of the 
backup sequence) 
14 Default behavior: Returns traits::eof(). 

294) Classes derived from basic_streambuf canprovide moreefficientwaysto implement xsgetn() and xsputn() byoverriding these definitions 
from the base class. 

Draft 


733 Input/output library 27.5 Streambuffers 

int _type uflow (); 

15 Requires: The constraints are the same as for underflow(), except that the result character is transferred from 
the pending sequence to the backup sequence, and the pending sequence may not be empty before the transfer. 

16 Default behavior: Calls underflow(). If underflow() returns traits::eof(), returnstraits::eof(). Otherwise, returns the value of traits::to_int_type(*gptr()) and increment the value of the next pointer for 
the input sequence. 

17 Returns: traits::eof() to indicatefailure. 

27.5.2.4.4 Putback [lib.streambuf.virt.pback] 
int _type pbackfail ( int_type c = traits :: eof ()); 

1 Remarks: Thepublic functionsof basic_streambuf call this virtual function only when gptr() is null, gptr() 
== eback(), or traits::eq(traits::to_char_type(c ),gptr()[-1]) returns false. Other calls shall 
also satisfy that constraint. 

The pending sequence is defined as for underflow(), with the modifications that 

— If traits::eq_int_type(c ,traits::eof()) returns true, then the input sequence isbacked up one 
character before the pending sequence is determined. 
— If traits::eq_int_type(c ,traits::eof()) returnfalse, then c is prepended. Whether the input sequenceis backedup or modifiedin anyotherwayis unspecified. 
2 Postcondition:On return, the constraints of gptr(), eback(), and pptr() are the same as for underflow(). 
3 Returns: traits::eof() to indicatefailure.Failure may occur because the input sequence couldnotbe backed 
up, or if for some other reason the pointers could not be set consistent with the constraints. pbackfail() is called 
only when put back has reallyfailed. 

4 Returns somevalue otherthan traits::eof() to indicate success.
5 Default behavior: Returns traits::eof().


27.5.2.4.5 Put area [lib.streambuf.virt.put] 
streamsize xsputn(const char_type* s , streamsize n ); 

1 Effects: Writes up to n characters to the output sequence as if by repeated calls to sputc(c ). The characters 
written are obtained from successive elements of the array whose first element is designated by s . Writing stops 
when either n characters have been written or a call to sputc(c ) would return traits::eof(). 

2 Returns: The number of characters written. 

int_type overflow ( int_type c = traits :: eof ()); 

3 Effects: Consumes some initial subsequence of the characters of the pending sequence. The pending sequence is 
defined as the concatenation of 

Draft 


27.6 Formatting and manipulators Input/output library 734 
a) ifpbase() is NULL then the empty sequence otherwise, pptr() -pbase() characters beginning at pbase(). 
b) if traits::eq_int_type(c ,traits::eof()) returns true, then the empty sequence otherwise, the sequence consisting of c . 
4 Remarks: The member functions sputc() and sputn() call this function in case that no room can be found in 
the putbuffer enough to accomodate the argument character sequence. 

5 Requires: Everyoverriding definitionofthis virtual function shall obeythe following constraints: 
1) The effect of consuming a character on the associated output sequence is specified295) 
2) Let r be the number of characters in the pending sequence not consumed. If r is non-zerothen pbase() 

and pptr() shall be set so that: pptr() -pbase() == r and the r characters starting at pbase() are 
the associated output stream. In case r is zero (all characters of the pending sequence have been consumed) 
then either pbase() is set to NULL, or pbase() and pptr() are both set to the same NULL non-value. 

3) The function may fail if either appending some character to the associated output stream fails or if it is 
unable to establish pbase() and pptr() according to the above rules. 
6 Returns: traits::eof() or throws anexceptionif the functionfails. 
Otherwise, returns some value other than traits::eof() to indicate success.296) 
7 Default behavior: Returns traits::eof(). 

27.6 Formatting and manipulators [lib.iostream.format] 
Header <istream> synopsis 

namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_istream;
typedef basic _istream <char > istream;


typedef basic _istream < wchar _t > wistream ; 

template < class charT , class traits = char _traits < charT > > 

class basic_iostream; 

typedef basic_iostream <char > iostream; 

typedef basic_iostream < wchar _t > wiostream ; 

template < class charT , class traits >
basic_istream <charT ,traits >& ws(basic_istream <charT ,traits >& is );
}


Header <ostream> synopsis 

namespace std {
template < class charT , class traits = char _traits < charT > >


295) That is, for each class derived from an instance of basic_streambuf in this clause(27.7.1, 27.8.1.1), a specification of how consuming a 
character effects the associated output sequence is given. There is no requirement on a program-defined class. 

296)Typically,overflow returns c to indicate success, except when traits::eq_int_type(c ,traits::eof()) returns true, in which caseit 
returns traits::not_eof(c ). 

Draft 


735 Input/output library 27.6 Formatting and manipulators 

class basic_ostream; 
typedef basic _ostream <char > ostream; 

typedef basic _ostream < wchar _t > wostream ; 

template < class charT , class traits >
basic_ostream <charT ,traits >& endl(basic_ostream <charT ,traits >& os );
template < class charT , class traits >
basic_ostream <charT ,traits >& ends(basic_ostream <charT ,traits >& os );
template < class charT , class traits >
basic_ostream < charT , traits >& flush ( basic_ostream < charT , traits >& os );
}


Header <iomanip> synopsis 

namespace std { 

// TypesT1, T2, ... are unspecified implementation types 

T1 resetiosflags(ios_base ::fmtflags mask ); 

T2 setiosflags (ios_base::fmtflags mask ); 

T3 setbase ( int base ); 

template <charT > T4 setfill ( charT c ); 

T5 setprecision ( int n ); 

T6 setw ( int n ); 

} 

27.6.1 Input streams [lib.input.streams] 
The header <istream> definestwotypesandafunctionsignaturethat controlinputfroma streambuffer. 

27.6.1.1 Class template basic_istream [lib.istream] 
namespace std { 

template < class charT , class traits = char _traits < charT > > 

class basic_istream : virtual public basic _ios <charT ,traits > { 

public : 

// Types (inherited frombasic_ios (27.4.4)): 

typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;


// 27.6.1.1.1 Constructor/destructor: 

explicit basic_istream(basic_streambuf <charT ,traits >* sb );
virtual ~basic_istream();


// 27.6.1.1.2 Prefix/suffix: 

class sentry ; 

// 27.6.1.2Formatted input: 

basic_istream <charT ,traits >& operator >> 
( basic _istream < charT , traits >& (* pf )( basic_ istream < charT , traits >&)); 

Draft 


27.6 Formatting and manipulators Input/output library 736 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & o p e r a t o r > > 
( b a s i c _ i o s < c h a r T , t r a i t s > & ( * pf ) ( b a s i c _ i o s < c h a r T , t r a i t s > & ) ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & o p e r a t o r > > 
( i o s _ b a s e & ( * pf ) ( i o s _ b a s e & ) ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
o p e r a t o r > > ( b o o l & n ) ; 
o p e r a t o r > > ( s h o r t & n ) ; 
o p e r a t o r > > ( u n s i g n e d s h o r t & n ) ; 
o p e r a t o r > > ( i n t & n ) ; 
o p e r a t o r > > ( u n s i g n e d i n t & n ) ; 
o p e r a t o r > > ( l o n g & n ) ; 
o p e r a t o r > > ( u n s i g n e d l o n g & n ) ; 
o p e r a t o r > > ( f l o a t & f ) ; 
o p e r a t o r > > ( d o u b l e & f ) ; 
o p e r a t o r > > ( l o n g d o u b l e & f ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & o p e r a t o r > > ( v o i d * & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & o p e r a t o r > > 
( b a s i c _ s t r e a m b u f < c h a r _ t y p e , t r a i t s > * sb ) ; 
p ) ; 
// 27.6.1.3 Unformatted input: 
s t r e a m s i z e g c o u n t ( ) c o n s t ; 
i n t _ t y p e g e t ( ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t ( c h a r _ t y p e & c ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t ( c h a r _ t y p e * s , s t r e a m s i z e n ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t ( c h a r _ t y p e * s , s t r e a m s i z e n , 
c h a r _ t y p e delim ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t ( b a s i c _ s t r e a m b u f < c h a r _ t y p e , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t ( b a s i c _ s t r e a m b u f < c h a r _ t y p e , t r a i t s > & 
c h a r _ t y p e delim ) ; 
sb ) ; 
sb , 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t l i n e ( c h a r _ t y p e * 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & g e t l i n e ( c h a r _ t y p e * 
c h a r _ t y p e delim ) ; 
s , 
s , 
s t r e a m s i z e 
s t r e a m s i z e 
n ) ; 
n , 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & i g n o r e 
( s t r e a m s i z e n = 1 , i n t _ t y p e delim = t r a i t s : : e o f ( ) ) ; 
i n t _ t y p e p e e k ( ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & r e a d ( c h a r _ t y p e * s , s t r e a m s i z e 
s t r e a m s i z e r e a d s o m e ( c h a r _ t y p e * s , s t r e a m s i z e 
n ) ; 
n ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
i n t s y n c ( ) ; 
p u t b a c k ( c h a r _ t y p e 
u n g e t ( ) ; 
c ) ; 
p o s _ t y p e t e l l g ( ) ; 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
b a s i c _ i s t r e a m < c h a r T , t r a i t s > & 
} ; 
s e e k g ( p o s _ t y p e ) ; 
s e e k g ( o f f _ t y p e , i o s _ b a s e : : s e e k d i r ) ; 
Draft 


737 Input/output library 27.6 Formatting and manipulators 

// 27.6.1.2.3 character extraction templates: 

template < class charT , class traits > 
basic_istream <charT ,traits >& operator >>(basic _istream <charT ,traits >&, 
charT &); 
template < class traits > 
basic_istream<char,traits>& operator>>(basic _istream<char,traits>&, 
unsigned char &); 
template < class traits > 
basic_istream<char,traits>& operator>>(basic _istream<char,traits>&, 
signed char &); 

template < class charT , class traits >
basic_istream <charT ,traits >& operator >>(basic _istream <charT ,traits >&,
charT *);
template < class traits >
basic_istream<char,traits>& operator>>(basic _istream<char,traits>&,
unsigned char *);
template < class traits >
basic_istream<char,traits>& operator>>(basic _istream<char,traits>&,
signed char *);
}


1 The class basic_istream definesa numberof member function signatures that assistin reading andinterpreting input 
from sequences controlledbya streambuffer. 

2 Two groups of member function signatures share common properties: the formatted input functions (or extractors) 
and the unformatted input functions. Both groups of input functions are described as if theyobtain (or extract)input 
characters by calling rdbuf()->sbumpc() or rdbuf()->sgetc(). Theymay use other public members of istream. 

3 If rdbuf()->sbumpc() or rdbuf()->sgetc() returns traits::eof(), then the input function, except as explicitly noted otherwise, completes its actions and does setstate(eofbit), which may throw ios_base::failure 
(27.4.4.3), before returning. 

4 If one of these called functions throws an exception, then unless explicitly noted otherwise, the input function sets 
badbit in error state. If badbit is on in exceptions(), the input function rethrows the exception without completing 
its actions, otherwiseit does not throw anything and proceeds asif the called function had returnedafailure indication. 

27.6.1.1.1 basic_istream constructors [lib.istream.cons] 
explicit basic_istream(basic_streambuf <charT ,traits >* sb ); 

1 Effects: Constructs an object of class basic_istream, assigning initial values to the base class by calling basic_ios::init(sb ) (27.4.4.1). 

2 Postcondition:gcount() == 0 

virtual ~basic_istream(); 

3 Effects: Destroys an object of class basic_istream. 
4 Remarks: Does not perform anyoperations of rdbuf(). 

Draft 


27.6 Formatting and manipulators Input/output library 738 
27.6.1.1.2 Class basic_istream::sentry [lib.istream::sentry] 
namespace std {
template <class charT ,class traits = char _traits <charT > >
class basic _istream < charT , traits >:: sentry {


typedef traits traits_type; 

// bool ok_; exposition only 

public : 
explicit sentry(basic_istream <charT ,traits >& is , bool noskipws = false ); 
~ sentry (); 

operator bool () const { return ok_ ;} 
private :
sentry ( const sentry &); // not defined
sentry & operator =( const sentry &); // not defined


};
}


1 The class sentry defines a class that is responsible for doing exception safe prefix and suffix operations. 

explicit sentry(basic_istream <charT ,traits >& is , bool noskipws = false ); 

2 Effects: If is .good() is true, prepares for formatted or unformatted input. First, if is .tie() is not a null 
pointer, the function calls is .tie()->flush() to synchronize the output sequence with anyassociated external 
Cstream. Except that this call can be suppressed if the put area of is .tie() is empty. Further an implementation is allowed to defer the call to flush until a call of is ->rdbuf()->underflow occurs. If no such call 
occurs before the sentry object is destroyed, the call to flush may be eliminated entirely.297) If noskipws 
is zero and is .flags() & ios_base::skipws is nonzero, the function extracts and discards each character as long as the next available input character c is a whitespace character. If is .rdbuf()->sbumpc() or 
is .rdbuf()->sgetc() returns traits::eof(), the function calls setstate(failbit | eofbit) (which 
may throw ios_base::failure). 

3 Remarks: The constructor explicit sentry(basic_istream<charT,traits>& is , bool noskipws = false) 
uses the currently imbuedlocalein is , to determine whether the next input character is whitespace or not. 

4 To decide if the characterc is a whitespace character, the constructor performs “as if” it executes the following 
code fragment: 

const ctype <charT >& ctype = use _facet <ctype <charT > >( is . getloc ()); 
if (ctype.is(ctype.space ,c )!=0) 
// c is a whitespace character. 

5 If, after anypreparation is completed, is .good() is true, ok_ != false otherwise, ok_ == false. During 
preparation, the constructor may call setstate(failbit) (which may throw ios_base::failure (27.4.4.3))298) 

6 [Note: This paragraph is intentionally empty. — end note ] 

~ sentry (); 

7 Effects: None. 

297) This will be possible only in functions that are part of the library. The semantics of the constructor used in user code is as specified.
298) The sentry constructor and destructor can also perform additional implementation-dependent operations.


Draft 


739 Input/output library 27.6 Formatting and manipulators 

operator bool () const ; 
8 Effects: Returns ok_. 

27.6.1.2 Formatted input functions [lib.istream.formatted] 
27.6.1.2.1 Commonrequirements [lib.istream.formatted.reqmts] 
1 Each formatted input function begins execution by constructing an object of class sentry with the noskipws (second) 
argument false. If the sentry object returns true, when converted to a value of type bool, the function endeavors to 
obtain the requested input. If an exception is thrown during input then ios::badbit is turned on299) in *this’s error 
state. If (exceptions()&badbit) != 0 then the exception is rethrown. In any case, the formatted input function 
destroys the sentry object. If no exception has been thrown, it returns *this. 

27.6.1.2.2 Arithmetic Extractors [lib.istream.formatted.arithmetic] 
operator > >( unsigned short & val ); 
operator > >( unsigned int & val ); 
operator > >( long & val ); 
operator > >( unsigned long & val ); 
operator > >( float & val ); 
operator > >( double & val ); 
operator > >( long double & val ); 
operator > >( bool & val ); 
operator > >( void *& val ); 
1 Asin the caseof the inserters, theseextractors depend on the locale’s num_get<> (22.2.2.1)object to perform 
parsing the input stream data. These extractors behave as formatted input functions (as described in 27.6.1.2.1). 
After a sentry object is constructed, the conversion occurs as if performed by the following code fragment: 

typedef num _get < charT ,istreambuf_iterator <charT ,traits > > numget;
iostate err = 0;
use _facet < numget >( loc ). get (* this , 0 , * this , err , val );
setstate ( err );


In the above fragment, loc stands for the private member of the basic_ios class. [Note: The first argument 
provides an object of the istreambuf_iterator class which is an iteratorpointed to an input stream. It bypasses 
istreams and uses streambufs directly. — end note ]Classlocale relies on this type as its interface to istream, 
sothatitdoesnotneedtodepend directlyon istream. 

operator > >( short & val ); 
2 Theconversion occursasifperformedbythefollowingcodefragment(usingthesame notationasforthepreceding code fragment): 

typedef num _get <charT ,istreambuf_iterator <charT ,traits > > numget;
iostate err = 0;
long lval ;
use _facet < numget >( loc ). get (* this , 0 , * this , err , lval );


299) This is done without causing an ios::failure to be thrown. 

Draft 


27.6 Formatting and manipulators Input/output library 740 
if (err == 0)
&& (lval < numeric_limits<short>::min()
|| numeric_limits <short >::max() < lval))
err = ios_base :: failbit ;
setstate ( err );


operator > >( int & val ); 
3 Theconversion occursasifperformedbythefollowingcodefragment(usingthesame notationasforthepreceding code fragment): 

typedef num _get <charT ,istreambuf_iterator <charT ,traits > > numget;
iostate err = 0;
long lval ;
use _facet < numget >( loc ). get (* this , 0 , * this , err , lval );
if (err == 0)


&& (lval < numeric_limits<int>::min()
|| numeric_limits <int >::max() < lval))
err = ios_base :: failbit ;
setstate ( err );


27.6.1.2.3 basic_istream::operator>> [lib.istream::extractors] 
basic_istream <charT ,traits >& operator >>
(basic_istream <charT ,traits >& (* pf )(basic_istream <charT ,traits >&))


1 Effects: None. This extractor does not behave as a formatted input function (as described in 27.6.1.2.1.) 

2 Returns: pf (*this).300) 

basic_ istream <charT ,traits >& operator >>
( basic _ios < charT , traits >& (* pf )( basic _ios < charT , traits >&));


3 Effects: Calls pf (*this). Thisextractordoesnotbehaveasaformattedinput function(as describedin 27.6.1.2.1). 
4 Returns: *this. 

basic_istream <charT ,traits >& operator >>
( ios_base & (* pf )( ios_base &));


5 Effects: Calls pf (*this).301) This extractor does not behave as a formatted input function (as described in 
27.6.1.2.1). 

6 Returns: *this. 

template < class charT , class traits >
basic_istream <charT ,traits >& operator >>(basic_istream <charT ,traits >& in ,
charT * s );
template < class traits >


300) See, for example, the function signature ws(basic_istream&) (27.6.1.4).
301) See, for example, the function signature dec(ios_base&) (27.4.5.3).


Draft 


741 Input/output library 27.6 Formatting and manipulators 

basic_istream <char ,traits >& operator >>(basic_istream <char ,traits >& in ,
unsigned char * s );
template < class traits >
basic_istream <char ,traits >& operator >>(basic_istream <char ,traits >& in ,
signed char * s );


7 Effects: Behaves like a formatted input member (as described in 27.6.1.2.1)of in . After a sentry object is 
constructed, operator>> extracts characters and stores them into successive locations of an array whose first 
element is designated by s . If width() is greater than zero, n is width(). Otherwise n is the the number of 
elements of the largest array of char_type that can store a terminating charT(). n is the maximum number of 
characters stored. 

8 Characters are extracted and stored until anyof the following occurs: 

— n -1 characters are stored; 
— end of file occurs on the input sequence; 
— ct.is(ct.space ,c ) is true for the next available input character c , where ct is use_facet<ctype< 
charT> >(in .getloc()). 
9 operator>> then storesanull byte(charT())inthenext position, whichmaybethe first positionifno characters 
were extracted. operator>> then calls width(0). 

10 If the function extracted no characters, it calls setstate(failbit), which may throw ios_base::failure 
(27.4.4.3). 

11 Returns: in. 

template < class charT , class traits >
basic_istream <charT ,traits >& operator >>(basic_istream <charT ,traits >& in ,
charT & c );
template < class traits >
basic_istream <char ,traits >& operator >>(basic_istream <char ,traits >& in ,
unsigned char & c );
template < class traits >
basic_istream <char ,traits >& operator >>(basic_istream <char ,traits >& in ,
signed char & c );


12 Effects: Behaves like a formatted input member (as described in 27.6.1.2.1)of in . After a sentry object is 
constructed a character is extracted from in , if one is available, and stored in c . Otherwise, the function calls 
in .setstate(failbit). 

13 Returns: in. 

basic_istream <charT ,traits >& operator >>
(basic_streambuf <charT ,traits >* sb );


14 Effects: Behaves as a formatted input function (as described in 27.6.1.2.1). If sb is null, calls setstate(failbit), which may throw ios_base::failure (27.4.4.3). Aftera sentry objectis constructed,extracts characters 
from *this and inserts themin the output sequence controlledby sb . Characters are extracted and inserted until 
anyof the following occurs: 

Draft 


27.6 Formatting and manipulators Input/output library 742 
— end-of-file occurs on the input sequence; 
— insertinginthe output sequencefails(in which casethe charactertobe insertedisnotextracted); 
— an exception occurs (in which case the exception is caught). 
15 If the function inserts no characters, it calls setstate(failbit), which may throw ios_base::failure 
(27.4.4.3). Ifit inserted no characters becauseit caught anexception thrown whileextracting characters from 
*this and failbit is onin exceptions() (27.4.4.3), then the caught exception is rethrown. 

16 Returns: *this. 

27.6.1.3 Unformatted inputfunctions [lib.istream.unformatted] 
1 Each unformatted input function begins execution by constructing an object of class sentry with the default argument 
noskipws (second) argument true. If the sentry object returns true, when converted to a value of type bool, the 
functionendeavorstoobtaintherequestedinput. Otherwise,ifthesentry constructorexitsbythrowinganexceptionorif 
thesentryobject returnsfalse,whenconvertedtoavalueoftype bool, the function returnswithout attempting to obtain 
anyinput. In either case the number of extracted characters is set to 0; unformatted input functions taking a character 
array of non-zero size as an argument shall also store a null character (using charT())in the first location of the array. 
If an exception is thrown during input then ios::badbit is turned on302) in *this’s error state. (Exceptions thrown 
from basic_ios<>::clear() are not caught or rethrown.) If (exceptions()&badbit) != 0 thentheexception is 
rethrown.Italso countsthenumberof charactersextracted.Ifnoexceptionhasbeenthrownitendsbystoringthe count 
in a member object and returning the value specified. In any event the sentry object is destroyed before leaving the 
unformatted input function. 

streamsize gcount () const ; 

2 Effects: None. This member function does not behave as an unformatted input function (as described in 27.6.1.3, 
paragraph 1). 

3 Returns: The number of characters extracted by the last unformatted input member function called for the object. 

int _type get (); 

4 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing 
a sentry object, extracts a character c , if one is available. Otherwise, the function calls setstate(failbit), 
which may throw ios_base::failure (27.4.4.3), 

5 Returns: c if available, otherwise traits::eof(). 

basic_istream <charT ,traits >& get(char_type& c ); 

6 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing 
a sentry object, extracts a character, if one is available, and assigns it to c .303) Otherwise, the function calls 
setstate(failbit) (which may throw ios_base::failure (27.4.4.3)). 

7 Returns: *this. 

302) This is done without causing an ios::failure to be thrown.
303) Note that this function is not overloaded on types signed char and unsigned char.


Draft 


743 Input/output library 27.6 Formatting and manipulators 

basic_istream <charT ,traits >& get(char_type* s , streamsize n ,
char_type delim );


8 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing
a sentry object, extracts characters and stores them into successive locations of an array whose first element is
designatedby s .304) Characters are extracted and stored until anyof the following occurs:


— n - 1 characters are stored; 
— end-of-file occurs on the input sequence (in which case the function calls setstate(eofbit)); 
— traits::eq(c , delim ) for the next available input character c (in which case c is not extracted). 
9 If the function stores no characters, it calls setstate(failbit) (which may throw ios_base::failure (27.4.4.3)). 
In anycase, it then stores a null character into the next successive location of the array. 
10 Returns: *this. 

basic_istream <charT ,traits >& get(char_type* s , streamsize n ) 

11 Effects: Calls get(s ,n ,widen(’\n’)) 
12 Returns: Value returnedby the call. 

basic_istream <charT ,traits >& get(basic _streambuf <char _type ,traits >& sb ,
char_type delim );


13 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing 
a sentry object, extracts characters and inserts them in the output sequence controlled by sb . Characters are 
extracted and inserted until anyof the following occurs: 

— end-of-file occurs on the input sequence; 
— insertinginthe output sequencefails(in which casethe charactertobe insertedisnotextracted); 
— traits::eq(c , delim ) for the next available input character c (in which case c is not extracted); 
— anexception occurs(in whichcase,theexceptionis caughtbutnot rethrown). 
14 If the function inserts no characters, it calls setstate(failbit), which may throw ios_base::failure 
(27.4.4.3). 
15 Returns: *this. 

basic_istream <charT ,traits >& get(basic _streambuf <char _type ,traits >& sb ); 

16 Effects: Calls get(sb , widen(’\n’)) 
17 Returns: Value returnedby the call. 

basic_istream<charT,traits>& getline(char_type* s , streamsize n ,
char_type delim );


304) Note that this function is not overloaded on types signed char and unsigned char. 

Draft 


27.6 Formatting and manipulators Input/output library 744 
18 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing 
a sentry object, extracts characters and stores them into successive locations of an array whose first element is 
designatedby s .305) Characters are extracted and stored until one of the following occurs: 

1. end-of-file occurs on the input sequence (in which case the function calls setstate(eofbit)); 
2. traits::eq(c , delim ) for the next available input character c (in which case the input character is 
extractedbut not stored);306) 
3. n -1 characters are stored (in which case the function calls setstate(failbit)). 
19 These conditions are testedin the order shown.307) 
20 If the function extracts no characters, it calls setstate(failbit) (which may throw ios_base::failure 
(27.4.4.3)).308) 
21 In anycase, it then stores a null character (using charT())into the next successivelocationof the array. 

22 Returns: *this. 

23 [Example: 

# include < iostream > 

int main () 

{
using namespace std;
const int line_buffer_size = 100;


char buffer[line_buffer_size];
int line_number = 0;
while (cin.getline(buffer, line_buffer _size , ’\n’) || cin.gcount()) {


int count = cin.gcount(); 
if (cin.eof()) 
cout << "Partial final line"; // cin.fail() is false 

else if (cin.fail()) { 
cout << "Partial long line"; 
cin.clear(cin.rdstate() & ~ios::failbit); 

} else { 
count --; // Don’tinclude newline in count 
cout << "Line " << ++line_number; 

} 
cout << " (" << count << " chars): " << buffer << endl; 
} 
} 

— end example ] 
305) Note that this function is not overloaded on types signed char and unsigned char.
306) Since the final input character is “extracted,” it is counted in the gcount(), even though it is not stored.
307) This allows an input line whichexactly fills thebuffer, without setting failbit. Thisis different behavior than the historicalAT&T implemen


tation.
308) This implies an empty input line will not cause failbit to be set.


Draft 


745 Input/output library 27.6 Formatting and manipulators 

basic_istream<charT,traits>& getline(char_type* s , streamsize n ); 

24 Returns: getline(s ,n ,widen(’\n’)) 

basic_istream <charT ,traits >&
ignore ( streamsize n = 1 , int_ type delim = traits :: eof ());


25 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing a 
sentry object, extracts characters and discards them. Characters are extracted until anyof the following occurs: 

— if n != numeric_limits<streamsize>::max() (18.2.1), n characters are extracted 
— end-of-file occurs on the input sequence (in which case the function calls setstate(eofbit), which may 
throw ios_base::failure (27.4.4.3)); 
— traits::eq_int_type(traits::to_int_type(c ), delim ) for the next available input character c 
(in which case c is extracted). 
26 Remarks: The last condition will never occur if traits::eq_int_type(delim , traits::eof()). 

27 Returns: *this. 

int _type peek (); 

28 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing a 
sentry object, readsbut does notextract the current input character. 

29 Returns: traits::eof() if good() is false. Otherwise, returns rdbuf()->sgetc(). 

basic_ istream < charT , traits >& read ( char_type * s , streamsize n ); 

30 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing 
a sentry object, if !good() calls setstate(failbit) which may throw an exception, and return. Otherwise 
extracts characters and stores them into successive locations of an array whose first element is designated by 
s .309) Characters are extracted and stored until either of the following occurs: 

— n characters are stored; 
— end-of-file occurs on the input sequence (in which case the function calls setstate(failbit|eofbit), 
which may throw ios_base::failure (27.4.4.3)). 
31 Returns: *this. 

streamsize readsome ( char_type * s , streamsize n ); 

32 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing 
a sentry object, if !good() calls setstate(failbit) which may throw an exception, and return. Otherwise 
extractscharactersand storestheminto successive locationsofanarraywhosefirst elementis designatedby s . If 
rdbuf()->in_avail() == -1,callssetstate(eofbit) (which may throw ios_base::failure (27.4.4.3)), 
and extracts no characters; 

— If rdbuf()->in_avail() == 0, extracts no characters 
309) Note that this function is not overloaded on types signed char and unsigned char. 

Draft 


27.6 Formatting and manipulators Input/output library 746 
— If rdbuf()->in_avail() > 0, extracts min(rdbuf()->in_avail(),n )). 
33 Returns: The number of characters extracted. 
basic_istream <charT ,traits >& putback(char_type c ); 

34 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing a 
sentry object, if !good() calls setstate(failbit) which may throw an exception, and return. If rdbuf() 
is not null, calls rdbuf->sputbackc(). If rdbuf() is null, or if sputbackc() returns traits::eof(), calls 
setstate(badbit) (which may throw ios_base::failure (27.4.4.3)).[ Note: this function extracts no characters,sothevalue returnedbythenextcallto gcount() is 0. — end note ] 

35 Returns: *this. 

basic_istream <charT ,traits >& unget (); 

36 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1). After constructing a 
sentry object, if !good() calls setstate(failbit) which may throw an exception, and return. If rdbuf() is 
not null, calls rdbuf()->sungetc(). If rdbuf() is null, or if sungetc() returns traits::eof(), calls set-
state(badbit) (which may throw ios_base::failure (27.4.4.3)).[ Note: this functionextracts no characters, 
so the value returned by the next call to gcount() is 0. — end note ] 

37 Returns: *this. 

int sync (); 

38 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1), except that it does 
not count the number of characters extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructinga sentry object,if rdbuf() isa null pointer, returns-1. Otherwise, calls rdbuf()
>pubsync() and, if that function returns -1 calls setstate(badbit) (which may throw ios_base::failure 
(27.4.4.3), and returns -1. Otherwise, returns zero. 

pos _type tellg (); 

39 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1), except that it does not 
countthe numberof charactersextractedanddoesnotaffectthevalue returnedby subsequent callsto gcount(). 

40 Returns: After constructing a sentry object, if fail() != false, returns pos_type(-1) to indicate failure. 
Otherwise, returns rdbuf()->pubseekoff(0, cur , in ). 

basic_istream <charT ,traits >& seekg(pos _type pos ); 

41 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1), except that it does 
not count the number of characters extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructing a sentry object, if fail() != true, executes rdbuf()->pubseekpos(pos , 
ios_base::in). In case of failure, the function calls setstate(failbit) (which may throw ios_base 
failure). 

42 Returns: *this. 

basic_istream <charT ,traits >& seekg(off _type& off , ios_base :: seekdir dir ); 

Draft 


747 Input/output library 27.6 Formatting and manipulators 

43 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1), except that it does not 
countthe numberof charactersextractedanddoesnotaffectthevalue returnedby subsequent callsto gcount(). 
After constructing a sentry object, if fail() != true, executes rdbuf()->pubseekoff(off , dir , ios_
base::in). 

44 Returns: *this. 

27.6.1.4 Standard basic_istream manipulators [lib.istream.manip] 
namespace std {
template < class charT , class traits >
basic_istream <charT ,traits >& ws(basic_istream <charT ,traits >& is );
}


1 Effects: Behaves as an unformatted input function (as described in 27.6.1.3, paragraph 1), except that it does not 
count the numberof charactersextracted and does notaffect thevalue returnedby subsequent callsto is.gcount(). 
After constructing a sentry object extracts characters as long as the next available character c is whitespace or 
untiltherearenomore charactersinthe sequence.Whitespace charactersare distinguishedwiththesame criterion 
as usedby sentry::sentry (27.6.1.1.2). If ws stops extracting characters because there are no more available it 
sets eofbit,but not failbit. 

2 Returns: is . 

27.6.1.5 Class template basic_iostream [lib.iostreamclass] 
namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_iostream :


public basic _istream < charT , traits >,
public basic _ostream < charT , traits > {
public :


// types: 

typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;


// constructor/destructor 

explicit basic_iostream(basic_streambuf <charT ,traits >* sb );
virtual ~basic_iostream();
};
}


1 The class basic_iostream inherits a number of functions that allow reading input and writing output to sequences 
controlledbya streambuffer. 

27.6.1.5.1 basic_iostream constructors [lib.iostream.cons] 
Draft 


27.6 Formatting and manipulators Input/output library 748 
explicit basic_iostream(basic_streambuf <charT ,traits >* sb ); 

1 Effects: Constructs an object of class basic_iostream, assigning initial values to the base classes by calling 
basic_istream<charT,traits>(sb ) (27.6.1.1)andbasic_ostream<charT,traits>(sb ) (27.6.2.1) 

2 Postcondition:rdbuf()==sb and gcount()==0. 

27.6.1.5.2 basic_iostream destructor [lib.iostream.dest] 
virtual ~ basic_iostream (); 
1 Effects: Destroys an object of class basic_iostream. 
2 Remarks: Does not perform anyoperations on rdbuf(). 

27.6.2 Output streams [lib.output.streams] 
1 The header <ostream> definesatypeandseveralfunction signaturesthat control outputtoa streambuffer. 

27.6.2.1 Class template basic_ostream [lib.ostream] 
namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_ostream : virtual public basic _ios <charT ,traits > {
public :


// Types (inherited frombasic_ios (27.4.4)): 

typedef charT char_type ; 

typedef typename traits :: int_type int_type ; 

typedef typename traits :: pos_type pos_type ; 

typedef typename traits :: off_type off_type ; 

typedef traits traits_type; 

// 27.6.2.2 Constructor/destructor: 

explicit basic_ostream(basic_streambuf <char _type ,traits >* sb );
virtual ~basic_ostream();


// 27.6.2.3 Prefix/suffix: 

class sentry ; 

// 27.6.2.5Formatted output: 

basic_ostream <charT ,traits >& operator << 

( basic _ostream < charT , traits >& (* pf )( basic_ ostream < charT , traits >&)); 

basic_ostream <charT ,traits >& operator << 

( basic _ios < charT , traits >& (* pf )( basic _ios < charT , traits >&)); 

basic_ostream <charT ,traits >& operator << 

( ios_base & (* pf )( ios_base &)); 

basic_ostream <charT ,traits >& operator <<(bool n );
basic_ostream <charT ,traits >& operator <<(short n );
basic_ostream <charT ,traits >& operator <<(unsigned short n );


Draft 


749 Input/output library 27.6 Formatting and manipulators 

basic_ostream <charT ,traits >& operator <<(int n );
basic_ostream <charT ,traits >& operator <<(unsigned int n );
basic_ostream <charT ,traits >& operator <<(long n );
basic_ostream <charT ,traits >& operator <<(unsigned long n );
basic_ostream <charT ,traits >& operator <<(float f );
basic_ostream <charT ,traits >& operator <<(double f );
basic_ostream <charT ,traits >& operator <<(long double f );


basic_ostream <charT ,traits >& operator <<(const void* p );
basic_ostream <charT ,traits >& operator <<
(basic_streambuf <char _type ,traits >* sb );


// 27.6.2.6 Unformatted output: 

basic_ostream <charT ,traits >& put(char_type c );
basic_ostream <charT ,traits >& write(const char_type* s , streamsize n );


basic_ostream < charT , traits >& flush ();


// 27.6.2.4 seeks: 

pos_type tellp ();
basic_ostream < charT , traits >& seekp ( pos_type );
basic_ostream < charT , traits >& seekp ( off _type , ios_base :: seekdir );


}; 

// 27.6.2.5.4 character inserters 

template < class charT , class traits >
basic_ostream <charT ,traits >& operator <<(basic _ostream <charT ,traits >&,


charT ); 
template < class charT , class traits > 
basic_ostream <charT ,traits >& operator <<(basic _ostream <charT ,traits >&, 

char ); 
template < class traits > 
basic_ostream<char,traits>& operator<<(basic _ostream<char,traits>&, 
char ); 

// signed and unsigned 

template < class traits > 
basic_ostream<char,traits>& operator<<(basic _ostream<char,traits>&, 
signed char ); 
template < class traits > 
basic_ostream<char,traits>& operator<<(basic _ostream<char,traits>&, 
unsigned char ) 

template < class charT , class traits > 
basic_ostream <charT ,traits >& operator <<(basic _ostream <charT ,traits >&, 
const charT *); 
template < class charT , class traits > 
basic_ostream <charT ,traits >& operator <<(basic _ostream <charT ,traits >&, 
const char *); 
template < class traits > 
basic_ostream<char,traits>& operator<<(basic _ostream<char,traits>&, 

Draft 


27.6 Formatting and manipulators Input/output library 750 
const char *); 

// signed and unsigned 

template < class traits > 
basic_ostream<char,traits>& operator<<(basic _ostream<char,traits>&, 
const signed char *); 
template < class traits > 
basic_ostream<char,traits>& operator<<(basic _ostream<char,traits>&, 
const unsigned char *); 

} 

1 The class basic_ostream defines a number of member function signatures that assist in formatting and writing output 
to output sequences controlledbya streambuffer. 

2 Two groups of member function signatures share common properties: theformatted output functions (or inserters)and 
the unformatted output functions. Both groups of output functions generate (or insert)output characters by actions 
equivalent to calling rdbuf()->sputc(int_type). Theymay use other public members of basic_ostream except 
that theyshall not invoke anyvirtual members of rdbuf() except overflow(), xsputn(), and sync(). 

3 If one of these called functions throws an exception, then unless explicitly noted otherwise the output function sets 
badbit in error state. If badbit is onin exceptions(), the output function rethrows theexception without completing 
its actions, otherwise it does not throw anything and treat as an error. 

27.6.2.2 basic_ostream constructors [lib.ostream.cons] 
explicit basic_ostream(basic_streambuf <charT ,traits >* sb ); 

1 Effects: Constructs an object of class basic_ostream, assigning initial values to the base class by calling basic_ios<charT,traits>::init(sb ) (27.4.4.1). 

2 Postcondition:rdbuf() == sb . 

virtual ~basic_ostream(); 

3 Effects: Destroys an object of class basic_ostream. 
4 Remarks: Does not perform anyoperations on rdbuf(). 

27.6.2.3 Class basic_ostream::sentry [lib.ostream::sentry] 
namespace std {
template <class charT ,class traits = char _traits <charT > >
class basic _ostream < charT , traits >:: sentry {


// bool ok_; exposition only 

public :
explicit sentry(basic_ostream <charT ,traits >& os );
~ sentry ();


operator bool () const { return ok_ ;} 
private :
sentry ( const sentry &); // not defined
sentry & operator =( const sentry &); // not defined


Draft 


751 Input/output library 27.6 Formatting and manipulators 

};
}


1 The class sentry defines a class that is responsible for doing exception safe prefix and suffix operations. 

explicit sentry(basic_ostream <charT ,traits >& os ); 

2 If os .good() is nonzero, prepares for formatted or unformatted output. If os .tie() is not a null pointer, calls 
os .tie()->flush().310) 

3 If, after anypreparation is completed, os .good() is true, ok_ == true otherwise, ok_ == false. During 
preparation, the constructor may call setstate(failbit) (which may throw ios_base::failure (27.4.4.3))311) 

~ sentry (); 

4 If ((os .flags() & ios_base::unitbuf) && !uncaught_exception()) is true, calls os .flush(). 

operator bool () const ; 
5 Effects: Returns ok_. 

27.6.2.4 basic_ostream seek members [lib.ostream.seeks] 
pos _type tellp (); 

1 Returns: if fail() != false, returns pos_type(-1) to indicatefailure. Otherwise, returns rdbuf()->pubseekoff(0, cur , out ). 

basic_ ostream < charT , traits >& seekp ( pos_type & pos ); 

2 Effects: If fail() != true,executes rdbuf()->pubseekpos(pos , ios_base::out).In caseoffailure, the 
function calls setstate(failbit) (which may throw ios_base::failure). 

3 Returns: *this. 

basic_ostream <charT ,traits >& seekp(off _type& off , ios_base :: seekdir dir ); 

4 Effects: If fail() != true, executes rdbuf()->pubseekoff(off , dir , ios_base::out). 
5 Returns: *this. 

27.6.2.5 Formatted output functions [lib.ostream.formatted] 
27.6.2.5.1 Commonrequirements [lib.ostream.formatted.reqmts] 
1 Each formatted output function begins execution by constructing an object of class sentry. If this object returns true 
when converted to a value of type bool, the function endeavors to generate the requested output. If the generationfails, 
then the formatted output function does setstate(ios::failbit), which might throw an exception. If an exception 
is thrown during output, then ios::badbit is turned on312) in *this’s error state. If (exceptions()&badbit) != 

310) The call os .tie()->flush() does not necessarily occur if the function can determine that no synchronization is necessary.
311) The sentry constructor and destructor can also perform additional implementation-dependent operations.
312) without causing an ios::failure to be thrown.


Draft 


27.6 Formatting and manipulators Input/output library 752 
0 then the exception is rethrown. Whether or not an exception is thrown, the sentry object is destroyed before leaving 
the formatted output function. If no exception is thrown, the result of the formattted output function is *this. 

2 The descriptions of the individual formatted output operations describe how theyperform output and do not mention the 
sentry object. 

27.6.2.5.2 Arithmetic Inserters [lib.ostream.inserters.arithmetic] 
operator < <( bool val ); 
operator < <( short val ); 
operator < <( unsigned short val ); 
operator < <( int val ); 
operator < <( unsigned int val ); 
operator < <( long val ); 
operator < <( unsigned long val ); 
operator < <( float val ); 
operator < <( double val ); 
operator < <( long double val ); 
operator < <( const void * val ); 
1 Effects: The classes num_get<> and num_put<> handle locale-dependent numeric formatting and parsing. These 
inserter functions use the imbued locale value to perform numeric formatting. When val is of type bool, long, 
unsigned long, double, long double, or const void*, the formatting conversion occurs as if it performed 
the following code fragment: 

bool failed = use_ facet < 
num _put <charT ,ostreambuf_iterator <charT ,traits > > 
>( getloc ()). put (* this , * this , fill () , val ). failed (); 

When val is of type short the formatting conversion occurs as if it performed the following code fragment: 

ios_base :: fmtflags baseflags = ios_ base :: flags () & ios_base :: basefield ; 
bool failed = use_ facet < 
num _put <charT ,ostreambuf_iterator <charT ,traits > > 
>(getloc()).put(*this, *this, fill(), 
baseflags == ios_base :: oct || baseflag == ios_base :: hex 
? static_cast <long >(static _cast <unsigned short >( val )) 
: static_cast <long >( val )). failed (); 

When val is of type int the formatting conversion occurs as if it performed the following code fragment: 

ios_base :: fmtflags baseflags = ios_ base :: flags () & ios_base :: basefield ; 
bool failed = use_ facet < 
num _put <charT ,ostreambuf_iterator <charT ,traits > > 
>(getloc()).put(*this, *this, fill(), 
baseflags == ios_base :: oct || baseflags == ios_base :: hex 
? static_cast <long >(static _cast <unsigned int >( val )) 
: static_cast <long >( val )). failed (); 

When val is of type unsigned short or unsigned int the formatting conversion occurs as if it performed the 
following code fragment: 

Draft 


753 Input/output library 27.6 Formatting and manipulators 

bool failed = use_ facet <
num _put <charT ,ostreambuf_iterator <charT ,traits > >
>(getloc()).put(*this, *this, fill(),
static_cast < unsigned long >( val )).failed();


When val is of type float the formatting conversion occurs as if it performed the following code fragment: 

bool failed = use_ facet <
num _put <charT ,ostreambuf_iterator <charT ,traits > >
>(getloc()).put(*this, *this, fill(),
static_cast <double >( val )).failed();


2 The first argument provides an object of the ostreambuf_iterator<> class which is an iterator for class basic_ostream<>. It bypasses ostreams and uses streambufs directly. Class locale relies on these types as its 
interface to iostreams, since for flexibility it has been abstracted away from direct dependence on ostream. The 
second parameterisareferencetothebase subobjectoftype ios_base. It provides formatting specifications such 
as field width,anda localefrom whichto obtain otherfacets.If failed is true then does setstate(badbit), 
which may throw an exception, and returns. 

3 Returns: *this. 

27.6.2.5.3 basic_ostream::operator<< [lib.ostream.inserters] 
basic_ostream <charT ,traits >& operator <<
(basic_ostream <charT ,traits >& (* pf )(basic_ostream <charT ,traits >&))


1 Effects: None. Does not behave as a formatted output function (as described in 27.6.2.5.1). 

2 Returns: pf (*this).313) 

basic_ostream <charT ,traits >& operator <<
(basic_ ios <charT ,traits >& (* pf )(basic_ ios <charT ,traits >&))


3 Effects: Calls pf (*this).This inserterdoesnotbehaveasaformattedoutput function(as describedin 27.6.2.5.1). 

4 Returns: *this.314) 

basic_ostream <charT ,traits >& operator <<
( ios_base & (* pf )( ios_base &))


5 Effects: Calls pf (*this).This inserterdoesnotbehaveasaformattedoutput function(as describedin 27.6.2.5.1). 
6 Returns: *this. 

basic_ostream <charT ,traits >& operator <<
(basic_streambuf <charT ,traits >* sb );


7 Effects: Behavesasa formatted output function(as describedin 27.6.2.5.1). Afterthe sentry objectis constructed, 
if sb is null calls setstate(badbit) (which may throw ios_base::failure). 

313) See, for example, the function signature endl(basic_ostream&) (27.6.2.7).
314) See, for example, the function signature dec(ios_base&) (27.4.5.3).


Draft 


27.6 Formatting and manipulators Input/output library 754 
8 Gets characters from sb and inserts them in *this. Characters are read from sb and inserted until anyof the 
following occurs: 

— end-of-file occurs on the input sequence; 
— insertinginthe output sequencefails(in which casethe charactertobe insertedisnotextracted); 
— an exception occurs while getting a character from sb . 
9 If the function inserts no characters, it calls setstate(failbit) (which may throw ios_base::failure 
(27.4.4.3)). If an exception was thrown while extracting a character, the function sets failbit in error state, 
and if failbit is onin exceptions() the caught exception is rethrown. 

10 Returns: *this. 

27.6.2.5.4 Character inserter function templates [lib.ostream.inserters.character] 
template < class charT , class traits >
basic_ostream <charT ,traits >& operator <<(basic_ostream <charT ,traits >& out ,
charT c );
template < class charT , class traits >
basic_ostream <charT ,traits >& operator <<(basic_ostream <charT ,traits >& out ,
char c );


// specialization 

template < class traits >
basic_ostream <char ,traits >& operator <<(basic_ostream <char ,traits >& out ,
char c );


// signed and unsigned 

template < class traits >
basic_ostream <char ,traits >& operator <<(basic_ostream <char ,traits >& out ,
signed char c );
template < class traits >
basic_ostream <char ,traits >& operator <<(basic_ostream <char ,traits >& out ,
unsigned char c );


1 Effects: Behaveslikeaformatted inserter(as describedin 27.6.2.5.1)ofout . Aftera sentry object is constructed 
it inserts characters. In case c has type char and the character type of the stream is not char, then the character to 
be inserted is out .widen(c );otherwise the character isc 315).Paddingis determinedas describedin 22.2.2.2.2. 
width(0) is called. The insertion character and anyrequired padding are inserted into out . 

2 Returns: out . 

template < class charT , class traits >
basic_ostream <charT ,traits >& operator <<(basic_ostream <charT ,traits >& out ,
const charT * s );
template < class charT , class traits >
basic_ostream <charT ,traits >& operator <<(basic_ostream <charT ,traits >& out ,
const char * s );
template < class traits >


315) In case the insertion is into a char stream, widen(c ) will usually be c . 

Draft 


755 Input/output library 27.6 Formatting and manipulators 

basic_ostream <char ,traits >& operator <<(basic_ostream <char ,traits >& out ,
const char * s );
template < class traits >
basic_ostream <char ,traits >& operator <<(basic_ostream <char ,traits >& out ,
const signed char * s );
template < class traits >
basic_ostream <char ,traits >& operator <<(basic_ostream <char ,traits >& out ,
const unsigned char * s );


3 Requires: s is non-null. 

4 Effects: Behaveslikeaformatted inserter(as describedin 27.6.2.5.1)ofout . Aftera sentry object is constructed 
it inserts n characters starting at s , where n is the number that would be computed as if by: 

— traits::length(s) fortheoverload wherethe firstargumentisoftype basic_ostream<charT, traits>& 
and the second is of type const charT*, and also for the overload where the first argument is of type basic_ostream<char, traits>& and the second is of type const char*, 
— std::char_traits<char>::length(s) for the overload where the first argument is of type basic_
ostream<charT, traits>& and the second is of type const char*, 
— traits::length(reinterpret_cast<const char*>(s)) for the other two overloads. 
5 Padding isdetermined as described in22.2.2.2.2. The n characters startingat s are widened using out .widen 
(27.4.4.2). The widened characters and anyrequired padding are inserted into out . Calls width(0). 
6 Returns: out . 

27.6.2.6 Unformatted output functions [lib.ostream.unformatted] 
1 Each unformatted output function begins execution by constructing an object of class sentry. If this object returns 
true, while converting to a value of type bool, the function endeavors to generate the requested output. If anexception 
is thrown during output, then ios::badbit is turned on316) in *this’s error state.If (exceptions() & badbit) != 
0 thentheexceptionis rethrown.Inanycase,the unformatted outputfunctionendsbydestroyingthe sentry object,then, 
if no exception was thrown, returning the value specified for the unformatted output function. 

basic_ostream <charT ,traits >& put(char_type c ); 

2 Effects: Behaves as an unformatted output function (as described in 27.6.2.6, paragraph 1). After constructing a 
sentry object, inserts the character c , if possible.317) 

3 Otherwise, calls setstate(badbit) (which may throw ios_base::failure (27.4.4.3)). 

4 Returns: *this. 

basic_ostream& write(const char_type* s , streamsize n ); 

316) without causing an ios::failure to be thrown.
317) Note that this function is not overloaded on types signed char and unsigned char.


Draft 


27.6 Formatting and manipulators Input/output library 756 
5 Effects: Behaves as an unformatted output function (as described in 27.6.2.6, paragraph 1). After constructing a 
sentry object, obtains characters to insert from successive locations of an array whose first element is designated 
by s .318) Characters are inserted until either of the following occurs: 

— n characters are inserted; 
— inserting in the output sequence fails (in which case the function calls setstate(badbit), which may 
throw ios_base::failure (27.4.4.3)). 
6 Returns: *this. 

basic_ostream & flush (); 

7 If rdbuf() is notanull pointer,calls rdbuf()->pubsync(). If that function returns -1 calls setstate(badbit) 
(which may throw ios_base::failure (27.4.4.3)). Does not behave as an unformatted output function (as 
described in 27.6.2.6, paragraph 1). 

8 Returns: *this. 

27.6.2.7 Standard basic_ostream manipulators [lib.ostream.manip] 
namespace std {
template < class charT , class traits >
basic_ostream <charT ,traits >& endl(basic_ostream <charT ,traits >& os );
}


1 Effects: Calls os .put(os .widen(’\n’)), then os .flush(). 

2 Returns: os . 

namespace std {
template < class charT , class traits >
basic_ostream <charT ,traits >& ends(basic_ostream <charT ,traits >& os );
}


3 Effects: Insertsa null character intothe output sequence: calls os .put(charT()). 

4 Returns: os . 

namespace std {
template < class charT , class traits >
basic_ostream <charT ,traits >& flush(basic_ostream <charT ,traits >& os );
}


5 Effects: Calls os .flush(). 
6 Returns: os . 
318) Note that this function is not overloaded on types signed char and unsigned char. 

Draft 


757 Input/output library 27.6 Formatting and manipulators 

27.6.3 Standard manipulators [lib.std.manip] 
1 The header <iomanip> defines a type and several related functions that use this type to provide extractors and inserters 
that alter information maintained by class ios_base and its derived classes. 

2 The type designated smanip in each of the following function descriptions is implementation-defined and may be 
different for each function. 

smanip resetiosflags(ios_base:: fmtflags mask ); 

3 Returns: An object s of unspecified type such that if out is an instance of basic_ostream<charT,traits> then 
theexpression out<<s behaves as if f(s , mask ) were called, or if in is an instance of basic_istream<charT, 
traits> then theexpression in>>s behavesasif f(s , mask ) were called. The function f can be defined as:319) 

ios _base & f ( ios_base & str , ios_base :: fmtflags mask ) 
{ 

// reset specified flags 

str . setf ( ios_base :: fmtflags (0) , mask );
return str ;


} 

The expression out<<s has type basic_ostream<charT,traits>& and value out. The expression in>>s has 
type basic_istream<charT,traits>& and value in. 

smanip setiosflags ( ios_base :: fmtflags mask ); 

4 Returns: An object s of unspecified type such that if out is an instance of basic_ostream<charT,traits> 
then the expression out<<s behaves as if f(s , mask ) were called, or if in is an instance of basic_istream< 
charT, traits> then the expression in>>s behaves as if f(s , mask ) were called. The function f can be 
defined as: 

ios _base & f ( ios_base & str , ios_base :: fmtflags mask ) 
{ 

// set specified flags 

str . setf (mask );
return str ;


} 

The expression out<<s has type basic_ostream<charT, traits>& and value out. The expression in>>s 
has type basic_istream<charT, traits>& and value in. 

smanip setbase ( int base ); 

5 Returns: An object s of unspecified type such that if out is an instance of basic_ostream<charT, traits> 
then the expression out<<s behaves as if f(s ) were called, or if in is an instance of basic_istream<charT, 
traits> then the expression in>>s behaves as if f(s , base ) were called. The function f can be defined as: 

ios _base & f ( ios_base & str , int base )
{


319) The expression cin >> resetiosflags(ios_base::skipws) clears ios_base::skipws in the format flags stored in the basic_

istream<charT,traits> object cin (the same as cin >> noskipws), and the expression cout << resetiosflags(ios_base::showbase) 

clears ios_base::showbase in the format flags stored in the basic_ostream<charT,traits> object cout (the same as cout << noshowbase). 

Draft 


27.6 Formatting and manipulators Input/output library 758 
// set basefield 

str . setf (base == 8 ? ios_base :: oct :
base == 10 ? ios _base :: dec :
base == 16 ? ios _base :: hex :


ios_base :: fmtflags (0) , ios _base :: basefield ); 
return str ; 
} 

The expression out<<s has type basic_ostream<charT, traits>& and value out. The expression in>>s 
has type basic_istream<charT, traits>& and value in. 

smanip setfill ( char_type c ); 

6 Returns: An object s of unspecified type such thatif out is (or is derived from) basic_ostream<charT,traits> 
and c has type charT then the expression out<<s behaves as if f(s , c ) were called. The function f can be 
defined as: 

template < class charT , class traits > 

basic _ios <charT ,traits >& f ( basic _ios < charT , traits >& str , charT c ) 

{ 

// set fill character 

str . fill (c );
return str ;


} 

The expression out<<s has type basic_ostream<charT, traits>& and value out. 

smanip setprecision ( int n ); 

7 Returns: An object s of unspecified type such that if out is an instance of basic_ostream<charT, traits> 
then theexpression out<<s behaves as if f(s , n ) were called, or if in is an instance of basic_istream<charT, 
traits> then the expression in>>s behaves as if f(s , n ) were called. The function f can be defined as: 

ios _base & f ( ios_base & str , int n )
{


// set precision 

str . precision (n );
return str ;


} 

The expression out<<s has type basic_ostream<charT, traits>& and value out. The expression in>>s 
has type basic_istream<charT, traits>& and value in. 

smanip setw ( int n ); 

8 Returns: An object s of unspecified type such that if out is an (instance of) basic_ostream<charT, traits> 
then theexpression out<<s behaves as if f(s , n ) were called, or if in is an instance of basic_istream<charT, 
traits> then the expression in>>s behaves as if f(s , n ) were called. The function f can be defined as: 

ios _base & f ( ios_base & str , int n )
{


// set width 

Draft 


759 Input/output library 27.7 String-based streams 

str . width (n );
return str ;
}


The expression out<<s has type basic_ostream<charT, traits>& and value out. The expression in>>s 
has type basic_istream<charT, traits>& and value in. 

27.7 String-based streams [lib.string.streams] 
1 The header <sstream> defines four class templates and eight types that associate streambuffers with objects of class 
basic_string, as described in 21.2. 

Header <sstream> synopsis 

namespace std {
template <class charT , class traits = char _traits <charT >,
class Allocator = allocator <charT > >
class basic_stringbuf;


typedef basic_stringbuf <char > stringbuf;
typedef basic_stringbuf < wchar _t > wstringbuf ;


template <class charT , class traits = char _traits <charT >,
class Allocator = allocator <charT > >
class basic_istringstream;


typedef basic_istringstream <char > istringstream;
typedef basic_istringstream <wchar _t > wistringstream;


template <class charT , class traits = char _traits <charT >,
class Allocator = allocator <charT > >


class basic_ostringstream;
typedef basic_ostringstream <char > ostringstream;
typedef basic_ostringstream <wchar _t > wostringstream;


template <class charT , class traits = char _traits <charT >,
class Allocator = allocator <charT > >


class basic_stringstream;
typedef basic_stringstream <char > stringstream;
typedef basic_stringstream <wchar _t > wstringstream;


} 

27.7.1 Class template basic_stringbuf [lib.stringbuf] 
namespace std {
template <class charT , class traits = char _traits <charT >,


class Allocator = allocator <charT > >
class basic_stringbuf : public basic_streambuf <charT ,traits > {
public :


typedef charT char_type ; 

Draft 


27.7 String-based streams Input/output library 760 
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;
typedef Allocator allocator_type ;


// 27.7.1.1 Constructors: 

explicit basic_stringbuf(ios_base::openmode which 

= ios _base :: in | ios_base :: out );
explicit basic_stringbuf
( const basic_string < charT , traits , Allocator >& str ,


ios_base :: openmode which = ios_ base :: in | ios_base :: out ); 

// 27.7.1.2 Get and set: 

basic_string < charT , traits , Allocator > str () const ; 
void str(const basic_string <charT ,traits ,Allocator >& s ); 

protected : 

// 27.7.1.3 Overridden virtual functions: 

virtual int_type underflow ();
virtual int_type pbackfail ( int_type c = traits :: eof ());
virtual int_type overflow ( int_type c = traits :: eof ());
virtual basic_streambuf<charT,traits>* setbuf(charT*, streamsize);


virtual pos_type seekoff ( off_type off , ios _base :: seekdir way , 
ios_base :: openmode which 
= ios_base :: in | ios_base :: out ); 
virtual pos_type seekpos ( pos_type sp , 
ios_base :: openmode which 
= ios_base :: in | ios_base :: out ); 

private : 
// ios_base::openmode mode; exposition only 
}; 
} 

1 The class basic_stringbuf is derived from basic_streambuf to associate possibly the input sequence and possibly 
the output sequence witha sequenceof arbitrary characters.The sequencecanbe initializedfrom,ormadeavailableas, 
an object of class basic_string. 

2 For the sake of exposition, the maintained data is presented here as: 

— ios_base::openmode mode , has in set if the input sequence can be read, and out set if the output sequence 
can be written. 
27.7.1.1 basic_stringbuf constructors [lib.stringbuf.cons] 
explicit basic_stringbuf(ios_base::openmode which = 

Draft 


761 Input/output library 27.7 String-based streams 

ios_base :: in | ios_base :: out ); 

1 Effects: Constructs an object of class basic_stringbuf, initializing the base class with basic_streambuf() 
(27.5.2.1), and initializing mode with which . 

2 Postcondition:str() == "". 

explicit basic_stringbuf(const basic_string <charT ,traits ,Allocator >& str ,
ios_base :: openmode which = ios_base :: in | ios_base :: out );


3 Effects: Constructs an object of class basic_stringbuf, initializing the base class with basic_streambuf() 
(27.5.2.1), and initializing mode with which . Then copies the content of str into the basic_stringbuf underlying character sequence. If which & ios_base::out is true, initializes the output sequence such that pbase() 
points to the first underlying character, epptr() points one past the last underlying character, and pptr() is 
equal to epptr() if which & ios_base::ate is true, otherwise pptr() is equal to pbase(). If which & 
ios_base::in is true, initializes the input sequence such that eback() and gptr() point to the first underlying 
character and egptr() points one past the last underlying character. 

27.7.1.2 Member functions [lib.stringbuf.members] 
basic _string <charT ,traits ,Allocator > str() const; 

1 Returns: A basic_string object whose content is equal to the basic_stringbuf underlying character sequence. If the basic_stringbuf was created only in input mode, the resultant basic_string contains the 
character sequence in the range [eback(),egptr()). If the basic_stringbuf was created with which & 
ios_base::out being true then the resultant basic_string contains the character sequence in the range [ 
pbase(),high_mark), where high_mark represents the position one past the highest initialized character in 
thebuffer. Characters canbe initializedby writingtothe stream,by constructingthe basic_stringbuf with a 
basic_string,orbycalling thestr(basic_string) member function. In the case of calling the str(basic_
string) member function, all characters initialized prior to the call are now considered uninitialized (except for 
those characters re-initializedby the new basic_string). Otherwise the basic_stringbuf has been created in 
neither input nor output mode and a zero length basic_string is returned. 

void str(const basic_string <charT ,traits ,Allocator >& s ); 

2 Effects: Copies the content of s into the basic_stringbuf underlying character sequence. If mode & ios_
base::out is true, initializes the output sequence such that pbase() points to the first underlying character, 
epptr() points one past the last underlying character,and pptr() is equal to epptr() if mode &ios_base::in 
is true, otherwise pptr() is equal to pbase(). If mode & ios_base::in istrue, initializes the input sequence 
such that eback() and gptr() point to the first underlying character and egptr() points one past the last 
underlying character. 

27.7.1.3 Overridden virtual functions [lib.stringbuf.virtuals] 
int _type underflow (); 

1 Returns: If the input sequence has a read position available, returns traits::to_int_type(*gptr()). Otherwise, returns traits::eof().Anycharacterinthe underlyingbuffer whichhasbeen initializedis consideredto 

Draft 


27.7 String-based streams Input/output library 762 
be part of the input sequence. 

int _type pbackfail ( int_type c = traits :: eof ()); 

2 Effects: Puts back the character designated by c to the input sequence, if possible, in one of three ways: 

— If traits::eq_int_type(c ,traits::eof()) returns false and if the input sequence has a putback 
position available, and if traits::eq(to_char_type(c ),gptr()[-1]) returns true, assigns gptr() 
-1 to gptr(). 
Returns: c . 

— If traits::eq_int_type(c ,traits::eof()) returns false and if the input sequence has a putback 
position available, and if mode & ios_base::out is nonzero, assigns c to *-gptr(). 
Returns: c . 

— If traits::eq_int_type(c ,traits::eof()) returns true and if the input sequence has a putback position available, assigns gptr() -1 to gptr(). 
Returns: traits::not_eof(c ). 
3 Returns: traits::eof() to indicatefailure.
4 Remarks: If the function can succeed in more than one of these ways, it is unspecified which wayis chosen.


int _type overflow ( int_type c = traits :: eof ()); 

5 Effects: Appends the character designatedby c to the output sequence, if possible, in one of two ways: 

— If traits::eq_int_type(c ,traits::eof()) returns false and if either the output sequence has a 
write position available or the function makes a write position available (as described below), the function 
calls sputc(c ). 
Signals success by returning c . 

— If traits::eq_int_type(c ,traits::eof()) returns true, there is no character to append. 
Signals success by returning a value other than traits::eof(). 

6 Remarks: The function can alter the number of write positions available as a result of anycall. 

7 Returns: traits::eof() to indicatefailure. 

8 The function can make a write position available only if (mode & ios_base::out) != 0. To make a write 

position available, the function reallocates (or initially allocates) an array object with a sufficient number of 
elements to hold the current array object (if any), plus at least one additional write position. If (mode & ios_
base::in) != 0, the function alters the read endpointer egptr() to point just past the new write position. 

pos _type seekoff ( off_type off , ios_base :: seekdir way ,
ios_base :: openmode which
= ios_base :: in | ios _base :: out );


9 Effects: Alters the stream positionwithin oneof the controlled sequences,if possible, as indicatedinTable 93. 

Draft 


763 Input/output library 27.7 String-based streams 

Table 93:seekoff positioning 

Conditions Result 
(which & ios_base::in) != 0 positions the input sequence 
(which & ios_base::out) != 0 positions the output sequence 
(which & (ios_base::in | 
ios_base::out)) == 
(ios_base::in) | 
ios_base::out)) 
and way == either 
ios_base::beg or 
ios_base::end 
positions both the input and the output sequences 
Otherwise the positioning operation fails. 

For a sequence to be positioned, if its next pointer (eithergptr() or pptr())is a null pointer and the new offset 
newoff is nonzero, the positioning operationfails. Otherwise, the function determines newoff as indicated in 
Table94. 

Table 94:newoff values 

Condition newoff Value 
way == ios_base::beg 0 
way == ios_base::cur the next pointer minus the beginning 
pointer (xnext -xbeg). 
way == ios_base::end the end pointer minus the beginning 
pointer (xend -xbeg). 

11 If (newoff + off )<0, or if newoff + off refers to an uninitialized character (as defined in 27.7.1.2 paragraph 1), the positioning operationfails. Otherwise, the function assigns xbeg + newoff + off to the next 
pointer xnext . 

12 Returns: pos_type(newoff ), constructed from the resultant offset newoff (of type off_type), that stores the 
resultant streamposition,if possible.Ifthe positioning operationfails,orifthe constructedobject cannot represent 
the resultant stream position, the return value is pos_type(off_type(-1)). 

pos _type seekpos ( pos_type sp , ios _base :: openmode which
= ios_base :: in | ios _base :: out );


13 Effects: Alters the stream position within the controlled sequences, if possible, to correspond to the stream position 
stored in sp (as described below). 

— If (which & ios_base::in) != 0, positions the input sequence. 
— If (which & ios_base::out) != 0, positions the output sequence. 
— If sp is an invalid stream position, or if the function positions neither sequence, the positioning operation 
fails. Ifsp hasnotbeenobtainedbyaprevious successfulcalltooneofthe positioningfunctions(seekoff, 
seekpos, tellg, tellp)the effect is undefined. 
Draft 


27.7 String-based streams Input/output library 764 
14 Returns: sp to indicate success, or pos_type(off_type(-1)) to indicate failure. 
15 
16 
b a s i c _ s t r e a m b u f < c h a r T , t r a i t s > * s e t b u f ( c h a r T * s , s t r e a m s i z e 
Effects: implementation-defined, exceptthat setbuf(0,0) has no effect. 
Returns: this. 
n ) ; 
27.7.2 Class template basic_istringstream 
n a m e s p a c e s t d { 
t e m p l a t e < c l a s s c h a r T , c l a s s t r a i t s = c h a r _ t r a i t s < c h a r T > , 
c l a s s A l l o c a t o r = a l l o c a t o r < c h a r T > > 
[lib.istringstream] 

class basic_istringstream : public 

public : 
typedef charT 
typedef typename traits :: int_type 
typedef typename traits :: pos_type 
typedef typename traits :: off_type 
typedef traits 
typedef Allocator 

// 27.7.2.1 Constructors: 

basic_istream <charT ,traits > { 

char_type ;
int_type ;
pos_type ;


off_type ;
traits_type ;
allocator_type ;
explicit basic_istringstream(ios_base::openmode which = ios_base :: in ); 

explicit basic_istringstream(
const basic _string <charT ,traits ,Allocator >& str ,
ios_base :: openmode which = ios_base :: in );


// 27.7.2.2 Members: 

basic_stringbuf < charT , traits , Allocator >* rdbuf () const ; 

basic_string < charT , traits , Allocator > str () const ; 
void str(const basic _string <charT ,traits ,Allocator >& s ); 
private : 
// basic_stringbuf<charT,traits,Allocator> sb; exposition only 
}; 
} 

The class basic_istringstream<charT, traits, Allocator> supports reading objects of class basic_string< 
charT, traits, Allocator>. It uses a basic_stringbuf<charT, traits, Allocator> object to control the 
associated storage.For thesakeofexposition, the maintained datais presented here as: 

— sb , the stringbuf object. 
27.7.2.1 basic_istringstream constructors [lib.istringstream.cons] 
explicit basic_istringstream(ios_base::openmode which = ios_base :: in ); 

Draft 


765 Input/output library 27.7 String-based streams 

1 Effects: Constructs an object of class basic_istringstream<charT, traits>, initializing the base class with 
basic_istream(&sb ) and initializing sb with basic_stringbuf<charT, traits, Allocator>(which | 
ios_base::in)) (27.7.1.1). 

explicit basic_istringstream(
const basic_string < charT , traits , allocator >& str ,
ios_base :: openmode which = ios_base :: in );


2 Effects: Constructs an object of class basic_istringstream<charT, traits>, initializing the base class with 
basic_istream(&sb ) and initializing sb with basic_stringbuf<charT, traits, Allocator>(str , which 
| ios_base::in)) (27.7.1.1). 

27.7.2.2 Member functions [lib.istringstream.members] 
basic _stringbuf <charT ,traits ,Allocator >* rdbuf() const; 

1 Returns: const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb ). 

basic _string <charT ,traits ,Allocator > str() const; 

2 Returns: rdbuf()->str(). 

void str(const basic_string <charT ,traits ,Allocator >& s ); 

3 Effects: Calls rdbuf()->str(s ). 

27.7.3 Class basic_ostringstream [lib.ostringstream] 
namespace std {
template <class charT , class traits = char _traits <charT >,


class Allocator = allocator <charT > >
class basic_ostringstream : public basic_ostream <charT ,traits > {
public :


// Types: 

typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;
typedef Allocator allocator_type ;


// 27.7.3.1 Constructors/destructor: 

explicit basic_ostringstream(ios_base::openmode which = ios_base :: out ); 

explicit basic_ostringstream(
const basic _string <charT ,traits ,Allocator >& str ,
ios_base :: openmode which = ios_base :: out );


// 27.7.3.2 Members: 

basic_stringbuf < charT , traits , Allocator >* rdbuf () const ; 

Draft 


27.7 String-based streams Input/output library 766 
basic_string < charT , traits , Allocator > str () const ;
void str(const basic _string <charT ,traits ,Allocator >& s );
private :


// basic_stringbuf<charT,traits,Allocator>sb; exposition only 

};
}


1 The class basic_ostringstream<charT, traits, Allocator> supports writing objects of class basic_string< 
charT, traits, Allocator>. It uses a basic_stringbuf object to control the associated storage. For the sake of 
exposition, the maintained data is presented here as: 

— sb , the stringbuf object. 
27.7.3.1 basic_ostringstream constructors [lib.ostringstream.cons] 
explicit basic_ostringstream(ios_base::openmode which = ios_base :: out ); 

1 Effects: Constructs an object of class basic_ostringstream, initializing the base class with basic_ostream( 
&sb ) and initializing sb with basic_stringbuf<charT, traits, Allocator>(which | ios_base::out)) 
(27.7.1.1). 

explicit basic_ostringstream(
const basic_string < charT , traits , Allocator >& str ,
ios_base :: openmode which = ios_ base :: out );


2 Effects: Constructs an object of class basic_ostringstream<charT, traits>, initializing the base class with 
basic_ostream(&sb ) and initializing sb with basic_stringbuf<charT, traits, Allocator>(str , which 
| ios_base::out)) (27.7.1.1). 

27.7.3.2 Member functions [lib.ostringstream.members] 
basic _stringbuf <charT ,traits ,Allocator >* rdbuf() const; 

1 Returns: const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb ). 

basic _string <charT ,traits ,Allocator > str() const; 

2 Returns: rdbuf()->str(). 

void str(const basic_string <charT ,traits ,Allocator >& s ); 

3 Effects: Calls rdbuf()->str(s ). 

27.7.4 Class template basic_stringstream [lib.stringstream] 
namespace std {
template <class charT , class traits = char _traits <charT >,
class Allocator = allocator <charT > >


Draft 


767 Input/output library 27.7 String-based streams 

class basic_stringstream
: public basic_iostream <charT ,traits > {
public :


// Types 

typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;
typedef Allocator allocator_type ;


// constructors/destructors 

explicit basic_stringstream(
ios_base :: openmode which = ios_ base :: out | ios_base :: in );
explicit basic_stringstream(
const basic_string < charT , traits , Allocator >& str ,
ios_base :: openmode which = ios_ base :: out | ios_base :: in );


// Members: 

basic_stringbuf < charT , traits , Allocator >* rdbuf () const ;
basic_string < charT , traits , Allocator > str () const ;
void str(const basic _string <charT ,traits ,Allocator >& str );


private : 

// basic_stringbuf<charT, traits>sb; exposition only 

};
}


1 The class template basic_stringstream<charT, traits> supports reading and writing from objects of class ba

sic_string<charT, traits, Allocator>. It uses a basic_stringbuf<charT, traits, Allocator> object 

to control the associated sequence.For the sakeofexposition, the maintained datais presented here as 

— sb , the stringbuf object. 
27.7.5 basic_stringstream constructors [lib.stringstream.cons] 
explicit basic_stringstream(
ios_base :: openmode which = ios_base :: out | ios_ base :: in );


1 Effects: Constructs an object of class basic_stringstream<charT,traits>,initializing the base class with 
basic_iostream(&sb ) and initializing sb with basic_stringbuf<charT,traits,Allocator>(which ). 

explicit basic_stringstream( 

const basic_ string<charT,traits,Allocator>& str, 

ios_base :: openmode which = ios_base :: out | ios_ base :: in ); 

2 Effects: Constructs an object of class basic_stringstream<charT, traits>, initializing the base class with 
basic_iostream(&sb ) and initializing sb with basic_stringbuf<charT, traits, Allocator>(str ,which ). 

Draft 


27.8 File-based streams Input/output library 768 
27.7.6 Member functions [lib.stringstream.members] 
basic _stringbuf <charT ,traits ,Allocator >* rdbuf() const; 

1 Returns: const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb ) 

basic _string <charT ,traits ,Allocator > str() const; 

2 Returns: rdbuf()->str(). 

void str(const basic_string <charT ,traits ,Allocator >& str ); 

3 Effects: Calls rdbuf()->str(str ). 

27.8 File-based streams [lib.file.streams] 
27.8.1 File streams [lib.fstreams] 
1 The header <fstream> defines four class templates and eight types that associate streambuffers with files and assist 
reading and writing files. 

Header <fstream> synopsis 

namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_filebuf;
typedef basic _filebuf <char > filebuf;


typedef basic _filebuf < wchar _t > wfilebuf ; 

template < class charT , class traits = char _traits < charT > > 
class basic_ifstream; 

typedef basic_ifstream <char > ifstream; 

typedef basic_ifstream < wchar _t > wifstream ; 

template < class charT , class traits = char _traits < charT > > 
class basic_ofstream; 

typedef basic_ofstream <char > ofstream; 

typedef basic_ofstream < wchar _t > wofstream ; 

template < class charT , class traits = char _traits < charT > > 
class basic_fstream; 

typedef basic _fstream <char > fstream; 

typedef basic _fstream < wchar _t > wfstream ;
}


In this subclause, the type name FILE refers to the type FILE declared in <cstdio> (27.8.2).320) 

File AFile provides an external source/sink stream whoseunderlaid character type is char (byte).321) 

320) InC FILE must be a typedef. InC++it maybea typedef or other type name. 

321) AFile is a sequence of multibyte characters. In order to provide the contents as a wide character sequence, filebuf should convert between 

wide character sequences and multibyte character sequences. 

Draft 


769 Input/output library 27.8 File-based streams 

Multibyte character and Files AFile provides byte sequences. So the streambuf (or its derived classes) treats a file 
as the external source/sink byte sequence. In a large character setenvironment, multibyte character sequences are 
heldinfiles.Inordertoprovidethe contentsofafileaswide character sequences, wide-orientedfilebuf,namely 
wfilebuf should convert wide character sequences. 

27.8.1.1 Class template basic_filebuf [lib.filebuf] 
namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_filebuf : public basic_streambuf <charT ,traits > {
public :


typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;


// 27.8.1.2 Constructors/destructor: 

basic_filebuf ();
virtual ~basic_filebuf();


// 27.8.1.3 Members: 

bool is_open () const ;
basic_filebuf < charT , traits >* open ( const char * s ,
ios_base :: openmode mode );
basic_filebuf < charT , traits >* close ();


protected : 

// 27.8.1.4 Overridden virtual functions: 

virtual streamsize showmanyc ();
virtual int_type underflow ();
virtual int_type uflow ();
virtual int_type pbackfail ( int_type c = traits :: eof ());
virtual int_type overflow ( int_type c = traits :: eof ());


virtual basic_streambuf < charT , traits >*
setbuf ( char_type * s , streamsize n );
virtual pos_type seekoff ( off_type off , ios_base :: seekdir way ,
ios_base :: openmode which = ios_base :: in | ios_base :: out );
virtual pos_type seekpos ( pos_type sp ,


ios_base :: openmode which = ios_base :: in | ios_base :: out );
virtual int sync ();
virtual void imbue ( const locale & loc );


};
}


1 The class basic_filebuf<charT,traits> associates both the input sequence and the output sequence with a file. 
2 The restrictions on reading and writing a sequence controlled by an object of class basic_filebuf<charT,traits> 

Draft 


27.8 File-based streams Input/output library 770 
are the same as for readingand writing with the StandardClibrary FILEs. 
3 In particular: 

— If the file is not open for reading the input sequence cannot be read. 
— If the file is not open for writing the output sequence cannot be written. 
— Ajoint file position is maintained for both the input sequence and the output sequence. 
4 An instance of basic_filebuf behaves as described in 27.8.1.1 provided traits::pos_type is fpos<traits:: 
state_type>. Otherwise the behavior is undefined. 

5 In order to support file I/O and multibyte/wide character conversion, conversions are performed using members of a 
facet, referred to asa_codecvt in following sections, obtained “asif”by 

codecvt<charT,char,typename traits::state _type> a_codecvt =
use _facet<codecvt<charT,char,typename traits::state_ type> >(getloc());


27.8.1.2 basic_filebuf constructors [lib.filebuf.cons] 
basic_filebuf (); 

1 Effects: Constructsanobjectof class basic_filebuf<charT,traits>,initializingthe base class withbasic_
streambuf<charT,traits>() (27.5.2.1). 

2 Postcondition:is_open() == false. 

virtual ~ basic_filebuf (); 

3 Effects: Destroys an object of class basic_filebuf<charT,traits>. Calls close(). 

27.8.1.3 Member functions [lib.filebuf.members] 
bool is_open () const ; 

1 Returns: true if a previous call to open succeeded (returned a non-null value) and there has been no intervening 
call to close. 

basic_filebuf <charT ,traits >* open(const char* s ,
ios_base :: openmode mode );


2 Effects: If is_open() != false, returns a null pointer. Otherwise, initializes the filebuf as required. It 
thenopensa file,ifpossible, whose nameisthe NTBS s (“asif”by calling std::fopen(s ,modstr )). The 
NTBS modstr is determined from mode & ios_base::ate as indicated inTable 95. If mode is not some 
combinationof flags shownin the table then the openfails. 

3 If the open operation succeeds and (mode & ios_base::ate) != 0, positions the file to the end (“as if”by 
calling std::fseek(file ,0,SEEK_END)).322) 

322) The macro SEEK_END is defined, and the function signatures fopen(const char*, const char*) and fseek(FILE*, long, int) are 
declared, in <cstdio> (27.8.2). 

Draft 


771 Input/output library 27.8 File-based streams 

Table 95: File open modes 

ios_base Flag combination 
binary in out trunc app 
stdio equivalent 
+ "w" 
+ + "a" 
+ + "w" 
+ "r" 
+ + "r+" 
+ + + "w+" 
+ + "wb" 
+ + + "ab" 
+ + + "wb" 
+ + "rb" 
+ + + "r+b" 
+ + + + "w+b" 

4 If the repositioning operationfails, calls close() and returnsa null pointerto indicatefailure. 
5 Returns: this if successful, a null pointer otherwise. 

basic_filebuf <charT ,traits >* close (); 

6 Effects: If is_open() == false, returns a null pointer. If a put area exists, calls overflow(traits::eof()) 
to flush characters. If the last virtual member function called on *this (between underflow, overflow, 
seekoff, and seekpos)was overflow then calls a_codecvt .unshift (possibly several times) to determine 
a termination sequence, inserts those characters and calls overflow(traits::eof()) again. Finally it closes 
the file (“asif”by calling std::fclose(file )).323) If anyof the calls to overflow or std::fclose fails then 
close fails. 

7 Returns: this on success, a null pointer otherwise. 

8 Postcondition:is_open() == false. 

27.8.1.4 Overridden virtualfunctions [lib.filebuf.virtuals] 
streamsize showmanyc (); 

1 Effects: Behaves the same as basic_streambuf::showmanyc() (27.5.2.4). 

2 Remarks: An implementation might well provide an overriding definition for this function signature if it can 
determine that more characters can be read from the input sequence. 

int _type underflow (); 

323) The function signature fclose(FILE*) is declared in <cstdio> (27.8.2). 

Draft 


27.8 File-based streams Input/output library 772 
3 Effects: Behaves according to the description of basic_streambuf<charT,traits>::underflow(), with the 
specializationthata sequenceof charactersisreadfromtheinput sequence“asif”byreadingfromthe associated 
file into an internalbuffer( extern_buf)and then “asif” doing 

char extern_buf[XSIZE]; 

char* extern_end; 

charT intern_buf[ISIZE]; 

charT* intern_end; 

codecvt_base::result r = 

a_codecvt . in(state , extern _buf , extern_buf+XSIZE , extern_end , 
intern _buf, intern_buf+ISIZE, intern_end); 

This shall be done in such a way that the class can recover the position(fpos_t)corresponding to each character 
between intern_buf and intern_end. If the value of r indicates that a_codecvt .in() ran out of space in 
intern_buf, retry with a larger intern_buf. 

int _type uflow (); 

4 Effects: Behaves according to the description of basic_streambuf<charT,traits>::uflow(), with the specialization thata sequenceof charactersis read from the input with the same method as usedby underflow. 

int _type pbackfail ( int_type c = traits :: eof ()); 

5 Effects: Puts back the character designated by c to the input sequence, if possible, in one of three ways: 

— If traits::eq_int_type(c ,traits::eof()) returns false and if the function makes a putback position available and if traits::eq(to_char_type(c ),gptr()[-1]) returns true, decrements the next 
pointer for the input sequence, gptr(). 
Returns: c . 

— If traits::eq_int_type(c ,traits::eof()) returns false and if the function makes a putback position available and if the function is permitted to assign to the putback position, decrements the nextpointer 
for the input sequence, and stores c there. 
Returns: c . 

— If traits::eq_int_type(c ,traits::eof()) returns true, and if either the input sequence has a put-
back position available or the function makes a putback position available, decrements the next pointer for 
the input sequence, gptr(). 
Returns: traits::not_eof(c ). 

6 Returns: traits::eof() to indicatefailure. 

7 Remarks: If is_open() == false, the functionalwaysfails. 

8 The function does not put back a character directly to the input sequence. 

9 If the function can succeed in more than one of these ways, it is unspecified which way is chosen. The function 

can alter the number of putback positions available as a result of anycall. 

int _type overflow ( int_type c = traits :: eof ()); 

Draft 


773 Input/output library 27.8 File-based streams 

10 Effects: Behaves according to the description of basic_streambuf<charT,traits>::overflow(c ), except 
that the behaviorof “consuming characters”is performedby first coverting “asif”by: 

charT * b = pbase ();
charT * p = pptr ();
charT * end ;
char xbuf [ XSIZE ];
char * xbuf_end ;
codecvt_base::result r =


a_codecvt . out(state , b, p, end , xbuf , xbuf+XSIZE , xbuf_end); 

and then 

— If r == codecvt_base::error thenfail. 
— If r == codecvt_base::noconv then output characters from b up to (and not including) p. 
— If r == codecvt_base::partial then output to the file characters from xbuf up to xbuf_end,and repeat 
using characters from end to p. If outputfails,fail (without repeating). 
— Otherwise output from xbuf to xbuf_end, andfail if outputfails. At this point if b != p and b == end 
(xbuf isn’tlarge enough) then increase XSIZE and repeat from the beginning. 
11 Returns: traits::not_eof(c ) to indicate success, and traits::eof() to indicatefailure. If is_open() == 
false, the functionalwaysfails. 

basic_streambuf* setbuf(char_type* s , streamsize n ); 

12 Effects: If setbuf(0,0) is called on a stream before anyI/O has occurred on that stream, the stream becomes 
unbuffered. Otherwise the results are implementation-defined. “Unbuffered” means that pbase() and pptr() 
always return null and output to the file should appear as soon as possible. 

pos _type seekoff ( off_type off , ios_base :: seekdir way ,
ios_base :: openmode which = ios_base :: in | ios_ base :: out );


13 Effects: Let width denote a_codecvt .encoding(). If is_open() == false, or off != 0 && width <= 
0, then the positioning operationfails. Otherwise, if way != basic_ios::cur or off != 0, and if the last 
operationwasoutput,thenupdatetheoutput sequenceandwriteanyunshiftsequence.Next,seektothenewposition: if width >0, call std::fseek(file , width * off , whence ), otherwise call std::fseek(file , 
0, whence ). 

14 Remarks: “Thelast operationwasoutput” means eitherthelast virtual operationwasoverflowortheputbufferis 
non-empty. “Write anyunshiftsequence” means, if width if less than zero then call a_codecvt .unshift(state , 
xbuf, xbuf+XSIZE, xbuf_end) and output the resulting unshift sequence. The function determines one of 
three values for the argument whence , of type int, as indicatedinTable 96. 

15 Returns: a newly constructed pos_type object that stores the resultant stream position, if possible. If the positioning operationfails, or if the object cannot represent the resultant stream position, returns pos_type(off_
type(-1)). 

pos _type seekpos ( pos_type sp ,
ios_base :: openmode which = ios_base :: in | ios_ base :: out );


Draft 


27.8 File-based streams Input/output library 774 
Table 96:seekoff effects 

way Value stdio Equivalent 
basic_ios::beg SEEK_SET 
basic_ios::cur SEEK_CUR 
basic_ios::end SEEK_END 

16 Alters the file position, if possible, to correspond to the position stored in sp (as described below). Altering the 
file position performs asfollows: 

1. if (om & ios_base::out) != 0, then update the output sequence and write anyunshift sequence; 
2. set the file position to sp ; 
3. if (om & ios_base::in) != 0, then update the input sequence; 
where om is the open mode passed tothe last call to open(). The operationfailsif is_open() returnsfalse. 
17 If sp isaninvalid stream position,orifthe function positions neither sequence,the positioning operationfails.If 
sp hasnotbeenobtainedbyaprevious successfulcalltooneofthe positioning functions(seekoff or seekpos) 
on the same file the effects are undefined. 
18 Returns: sp on success. Otherwise returns pos_type(off_type(-1)). 

int sync (); 

19 Effects: If a put area exists, calls filebuf::overflow to write the characters to the file. If a get area exists, the 
effect is implementation-defined. 

void imbue ( const locale & loc ); 

20 Precondition: If the file is not positioned at its beginning and the encoding of the current locale as determined by 
a_codecvt .encoding() is state-dependent(22.2.1.4.2)thenthatfacetisthe sameasthe correspondingfacetof 
loc . 

21 Effects: Causes characters inserted or extracted after this call to be converted according to loc until another call 
of imbue. 

22 Remark: This may require reconversion of previously converted characters. This in turn may require the implementation to be able to reconstruct the original contents of the file. 

27.8.1.5 Class template basic_ifstream [lib.ifstream] 
namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_ifstream : public basic_istream <charT ,traits > {
public :


typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;


Draft 


775 Input/output library 27.8 File-based streams 

typedef traits traits_type; 

// 27.8.1.6 Constructors: 

basic_ifstream ();
explicit basic_ifstream(const char* s ,
ios_base :: openmode mode = ios_base :: in );


// 27.8.1.7 Members: 

basic_filebuf < charT , traits >* rdbuf () const ;


bool is_open () const ;
void open ( const char * s , ios_base :: openmode mode = ios_base :: in );
void close ();


private : 

// basic_filebuf<charT,traits> sb; exposition only 

};
}


1 The class basic_ifstream<charT, traits> supports reading from named files. It uses a basic_filebuf<charT, 
traits> objectto controlthe associated sequence.Forthesakeofexposition,the maintaineddatais presentedhereas: 

— sb , the filebuf object. 
27.8.1.6 basic_ifstream constructors [lib.ifstream.cons] 
basic_ifstream (); 

1 Effects: Constructs an object of class basic_ifstream<charT,traits>, initializing the base class with basic_istream(&sb ) and initializing sb with basic_filebuf<charT,traits>()) (27.6.1.1.1, 27.8.1.2). 

explicit basic_ifstream(const char* s ,
ios_base :: openmode mode = ios_base :: in );


2 Effects: Constructs an object of class basic_ifstream, initializing the base class with basic_istream(&sb ) 
and initializing sb with basic_filebuf<charT, traits>()) (27.6.1.1.1, 27.8.1.2), then calls rdbuf()
>open(s , mode | ios_base::in). If that function returns a null pointer, calls setstate(failbit). 

27.8.1.7 Member functions [lib.ifstream.members] 
basic_filebuf<charT,traits>* rdbuf() const; 

1 Returns: const_cast<basic_filebuf<charT,traits>*>(&sb ). 

bool is_open () const ; 

2 Returns: rdbuf()->is_open(). 

void open ( const char * s , ios_base :: openmode mode = ios_base :: in ); 

Draft 


27.8 File-based streams Input/output library 776 
3 Effects: Calls rdbuf()->open(s , mode | ios_base::in). If that function does not return a null pointer 
calls clear(), otherwise calls setstate(failbit) (which may throw ios_base::failure (27.4.4.3)).324) 

void close (); 

4 Effects: Calls rdbuf()->close() and, if that function returns false, calls setstate(failbit) (which may 
throw ios_base::failure (27.4.4.3)). 

27.8.1.8 Class template basic_ofstream [lib.ofstream] 
namespace std {
template < class charT , class traits = char _traits < charT > >
class basic_ofstream : public basic_ostream <charT ,traits > {
public :


typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;


// 27.8.1.9 Constructors: 

basic_ofstream ();
explicit basic_ofstream(const char* s ,
ios_base :: openmode mode = ios_base :: out );


// 27.8.1.10 Members: 

basic_filebuf < charT , traits >* rdbuf () const ;


bool is_open () const ;
void open ( const char * s , ios_base :: openmode mode = ios_base :: out );
void close ();


private : 

// basic_filebuf<charT,traits> sb; exposition only 

};
}


1 The class basic_ofstream<charT, traits> supports writing to named files. It uses a basic_filebuf<charT, 
traits> objectto controlthe associated sequence.Forthesakeofexposition,the maintaineddatais presentedhereas: 

— sb , the filebuf object. 
27.8.1.9 basic_ofstream constructors [lib.ofstream.cons] 
basic_ofstream (); 

1 Effects: Constructs an object of class basic_ofstream<charT,traits>, initializing the base class with basic_ostream(&sb ) and initializing sb with basic_filebuf<charT,traits>()) (27.6.2.2, 27.8.1.2). 

324)Asuccessful open does not change the error state. 

Draft 


777 Input/output library 27.8 File-based streams 

explicit basic_ofstream(const char* s ,
ios_base :: openmode mode = ios_base :: out );


2 Effects: Constructs an object of class basic_ofstream<charT,traits>, initializing the base class with basic_ostream(&sb ) and initializing sb with basic_filebuf<charT,traits>()) (27.6.2.2, 27.8.1.2), then 
calls rdbuf()->open(s , mode |ios_base::out). If that function returns a null pointer, calls setstate( 
failbit). 

27.8.1.10 Member functions [lib.ofstream.members] 
basic_filebuf<charT,traits>* rdbuf() const; 

1 Returns: const_cast<basic_filebuf<charT,traits>*>(&sb ). 

bool is_open () const ; 

2 Returns: rdbuf()->is_open(). 

void open ( const char * s , ios_base :: openmode mode = ios_base :: out ); 

3 Effects: Calls rdbuf()->open(s , mode | ios_base::out). If that function does not return a null pointer 
calls clear(), otherwise calls setstate(failbit) (which may throw ios_base::failure (27.4.4.3)).325) 

void close (); 

4 Effects: Calls rdbuf()->close() and,if that functionfails (returnsa null pointer), calls setstate(failbit) 
(which may throw ios_base::failure (27.4.4.3)). 

27.8.1.11 Class template basic_fstream [lib.fstream] 
namespace std {
template <class charT , class traits=char _traits <charT > >
class basic_fstream


: public basic_iostream <charT ,traits > { 

public :
typedef charT char_type ;
typedef typename traits :: int_type int_type ;
typedef typename traits :: pos_type pos_type ;
typedef typename traits :: off_type off_type ;
typedef traits traits_type;


// constructors/destructor 

basic_fstream ();
explicit basic_fstream(const char* s ,
ios_base :: openmode mode = ios_base::in|ios_base::out);


// Members: 

325)Asuccessful open does not change the error state. 

Draft 


27.8 File-based streams Input/output library 778 
basic_filebuf < charT , traits >* rdbuf () const ;
bool is_open () const ;
void open ( const char * s ,


ios_base :: openmode mode = ios_base::in|ios_base::out);
void close ();


private : 

// basic_filebuf<charT,traits> sb; exposition only 

};
}


1 The class template basic_fstream<charT,traits> supports reading and writing from named files. It usesa basic_
filebuf<charT,traits> objectto controlthe associated sequences.Forthesakeofexposition,the maintaineddata 
is presented here as: 

— sb , the basic_filebuf object. 
27.8.1.12 basic_fstream constructors [lib.fstream.cons] 
basic_fstream (); 

1 Effects: Constructsanobjectof class basic_fstream<charT,traits>,initializingthe base class withbasic_
iostream(&sb ) and initializing sb with basic_filebuf<charT,traits>(). 

explicit basic_fstream(const char* s ,
ios_base :: openmode mode = ios_base :: in | ios_base :: out );


2 Effects: Constructs an object of class basic_fstream<charT, traits>, initializing the base class with basic_iostream(&sb ) and initializing sb with basic_filebuf<charT, traits>(). Then calls rdbuf()
>open(s , mode ).If that function returnsa nullpointer, calls setstate(failbit). 

27.8.1.13 Member functions [lib.fstream.members] 
basic_filebuf<charT,traits>* rdbuf() const; 

1 Returns: const_cast<basic_filebuf<charT,traits>*>(&sb ). 

bool is_open () const ; 

2 Returns: rdbuf()->is_open(). 

void open ( const char * s ,
ios_base :: openmode mode = ios_base :: in | ios_base :: out );


3 Effects: Calls rdbuf()->open(s ,mode ). If that function does not returnanull pointer calls clear(),otherwise 
calls setstate(failbit), (which may throw ios_base::failure)(27.4.4.3). 

void close (); 

4 Effects: Calls rdbuf()->close() and, if that function returns false, calls setstate(failbit)(27.4.4.3) 
(which may throw ios_base::failure). 

Draft 


779 Input/output library 27.8 File-based streams 
27.8.2 CLibrary files 
Table97 describes header <cstdio>. 
[lib.c.files] 
Table 97: Header<cstdio> synopsis 

Type Name(s) 
Macros: 
BUFSIZ FOPEN_MAX SEEK_CUR TMP_MAX _IONBF stdout 
EOF L_tmpnam SEEK_END _IOFBF stderr 
FILENAME_MAX NULL <cstdio> SEEK_SET _IOLBF stdin 
Types: FILE fpos_t size_t <cstdio> 
Functions: 
clearerr fgets fscanf gets rename tmpfile 
fclose fopen fseek perror rewind tmpnam 
feof fprintf fsetpos printf scanf ungetc 
ferror fputc ftell putc setbuf vfprintf 
fflush fputs fwrite putchar setvbuf vprintf 
fgetc fread getc puts sprintf vsprintf 
fgetpos freopen getchar remove sscanf 

SEEALSO: ISOCsubclause 7.9, Amendment1subclause 4.6.2. 

Draft 


27.8 File-based streams Input/output library 780 
Draft 


AppendixA
(informative)
Grammar summary [gram]


1 This summaryofC++ syntax is intended to be an aidto comprehension. It is not an exact statement of the language. In 
particular, the grammar described here acceptsa supersetofvalidC++ constructs. Disambiguation rules(6.8, 7.1, 10.2) 
must be applied to distinguish expressions from declarations. Further, access control, ambiguity, and type rules mustbe 
usedtoweedout syntacticallyvalidbut meaningless constructs. 

A.1 Keywords [gram.key] 
1 New context-dependentkeywords are introduced intoa programby typedef (7.1.3), namespace(7.3.1), class (clause 
9), enumeration(7.2), and template (clause 14)declarations. 

typedef-name:
identifier


namespace-name:
original-namespace-name
namespace-alias


original-namespace-name:
identifier


namespace-alias:
identifier


class-name:
identifier
template-id


enum-name:
identifier


template-name:
identifier


Note that a typedef-name naming a class is also a class-name (9.1). 

A.2 Lexical conventions [gram.lex] 
hex-quad:
hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit



A.2 Lexical conventions Grammar summary 782 
universal-character-name: 
\u hex-quad 
\U hex-quad hex-quad 

preprocessing-token: 
header-name 
identifier 
pp-number 
character-literal 
string-literal 
preprocessing-op-or-punc 

each non-white-space character that cannotbe one of the above 

token: 
identifier 
keyword 
literal 
operator 
punctuator 

header-name: 
< h-char-sequence > 
" q-char-sequence " 

h-char-sequence: 
h-char 
h-char-sequence h-char 

h-char: 

anymemberof the source character setexcept new-line and> 

q-char-sequence: 
q-char 
q-char-sequence q-char 

q-char: 

anymember of the source character set except new-line and " 

pp-number: 
digit 
. digit 
pp-number digit 
pp-number nondigit 
pp-number e sign 
pp-number E sign 
pp-number . 

identifier: 

nondigitidentifier-nondigit
identifier nondigitidentifier-nondigit
identifier digit


identifier-nondigit: 
nondigit 
universal-character-name 

other implementation-defined characters 

Draft 


783 Grammar summary A.2 Lexical conventions 

nondigit: one of 

universal-character-name 

abcdefghijklm
nopqrstuvwxyz
ABCDEFGHIJKLM
NOPQRSTUVWXYZ_


digit: one of 

0123456789 

literal: 
integer-literal 
character-literal 
floating-literal 
string-literal 
boolean-literal 

integer-literal: 
decimal-literal integer-suffixopt 
octal-literal integer-suffixopt 
hexadecimal-literal integer-suffixopt 

decimal-literal: 
nonzero-digit 
decimal-literal digit 

octal-literal: 

0 

octal-literal octal-digit 

hexadecimal-literal: 
0x hexadecimal-digit 
0X hexadecimal-digit 
hexadecimal-literal hexadecimal-digit 

nonzero-digit: one of 

123456789 

octal-digit: one of 

01234567 

hexadecimal-digit: one of 

0123456789
abcdef
ABCDEF


integer-suffix: 
unsigned-suffix long-suffixopt 

unsigned-suffix long-long-suffixopt 

long-suffix unsigned-suffixopt 

long-long-suffix unsigned-suffixopt 

unsigned-suffix: one of 

uU 

long-suffix: one of 

lL 

Draft 


A.2 Lexical conventions Grammar summary 784 
long-long-suffix: one of 

ll LL 

character-literal: 
’ c-char-sequence ’ 
L’ c-char-sequence ’ 

c-char-sequence: 
c-char 
c-char-sequence c-char 

c-char: 

anymember of the source character set except 
the single-quote ’, backslash \, or new-line character 

escape-sequence
universal-character-name


escape-sequence: 
simple-escape-sequence 
octal-escape-sequence 
hexadecimal-escape-sequence 

simple-escape-sequence: one of 

\’ \" \? \\
\a \b \f \n \r \t \v


octal-escape-sequence: 
\ octal-digit 
\ octal-digit octal-digit 
\ octal-digit octal-digit octal-digit 

hexadecimal-escape-sequence: 
\x hexadecimal-digit 
hexadecimal-escape-sequence hexadecimal-digit 

floating-literal: 
fractional-constant exponent-partopt floating-suffixopt 
digit-sequence exponent-part floating-suffixopt 

fractional-constant: 
digit-sequenceopt . digit-sequence 
digit-sequence . 

exponent-part: 
e signopt digit-sequence 
E signopt digit-sequence 

sign: one of 

+

digit-sequence: 
digit 
digit-sequence digit 

floating-suffix: one of 

flFL 

Draft 


785 Grammar summary A.3 Basic concepts 

string-literal:
"s-char-sequenceopt"
L"s-char-sequenceopt"


s-char-sequence:
s-char
s-char-sequence s-char


s-char: 

anymember of the source character set except
the double-quote ", backslash \, or new-line character


escape-sequence
universal-character-name


boolean-literal: 

false
true


A.3 Basic concepts [gram.basic] 
translation-unit:
declaration-seqopt


A.4 Expressions [gram.expr] 
primary-expression:
literal


this
( expression )
id-expression


id-expression:
unqualified-id
qualified-id


unqualified-id:
identifier
operator-function-id
conversion-function-id
~ class-name
template-id


qualified-id:
::opt nested-name-specifier templateopt unqualified-id
:: identifier
:: operator-function-id
:: template-id


nested-name-specifier:
type-name ::
namespace-name ::
nested-name-specifier identifier ::
nested-name-specifier templateopt template-id ::


Draft 


A.4 Expressions Grammar summary 786 
postfix-expression: 
primary-expression 
postfix-expression [ expression ] 
postfix-expression ( expression-listopt ) 
simple-type-specifier ( expression-listopt ) 
typename-specifier ( expression-listopt ) 
postfix-expression . templateopt id-expression 
postfix-expression -> templateopt id-expression 
postfix-expression . pseudo-destructor-name 
postfix-expression -> pseudo-destructor-name 
postfix-expression ++ 
postfix-expression -
dynamic_cast < type-id >( expression ) 
static_cast < type-id >( expression ) 
reinterpret_cast < type-id >( expression ) 
const_cast < type-id >( expression ) 
typeid ( expression ) 
typeid ( type-id ) 

expression-list: 
assignment-expression 
expression-list , assignment-expression 

pseudo-destructor-name: 
::opt nested-name-specifieropt type-name :: ~ type-name 
::opt nested-name-specifier template template-id :: ~ type-name 
::opt nested-name-specifieropt ~ type-name 

unary-expression: 
postfix-expression 
++ cast-expression 
--cast-expression 
unary-operator cast-expression 
sizeof unary-expression 
sizeof ( type-id ) 
new-expression 
delete-expression 

unary-operator: one of 

* &+-! ~ 
new-expression: 
::opt new new-placementopt new-type-id new-initializeropt 
::opt new new-placementopt ( type-id ) new-initializeropt 

new-placement: 
( expression-list ) 

new-type-id: 
type-specifier-seq new-declaratoropt 

new-declarator: 
ptr-operator new-declaratoropt 
direct-new-declarator 

Draft 


787 Grammar summary A.4 Expressions 

direct-new-declarator: 
[ expression ] 
direct-new-declarator [ constant-expression ] 

new-initializer: 
( expression-listopt ) 

delete-expression: 
::opt delete cast-expression 
::opt delete [ ] cast-expression 

cast-expression: 
unary-expression 
( type-id ) cast-expression 

pm-expression: 
cast-expression 
pm-expression .* cast-expression 
pm-expression ->* cast-expression 

multiplicative-expression: 
pm-expression 
multiplicative-expression * pm-expression 
multiplicative-expression / pm-expression 
multiplicative-expression % pm-expression 

additive-expression: 
multiplicative-expression 
additive-expression + multiplicative-expression 
additive-expression -multiplicative-expression 

shift-expression: 
additive-expression 
shift-expression << additive-expression 
shift-expression >> additive-expression 

relational-expression: 
shift-expression 
relational-expression < shift-expression 
relational-expression > shift-expression 
relational-expression <= shift-expression 
relational-expression >= shift-expression 

equality-expression: 
relational-expression 
equality-expression == relational-expression 
equality-expression != relational-expression 

and-expression: 
equality-expression 
and-expression & equality-expression 

Draft 


A.5 Statements Grammar summary 788 
exclusive-or-expression: 
and-expression 
exclusive-or-expression ^ and-expression 
inclusive-or-expression: 
exclusive-or-expression 
inclusive-or-expression | exclusive-or-expression 
logical-and-expression: 
inclusive-or-expression 
logical-and-expression && inclusive-or-expression 
logical-or-expression: 
logical-and-expression 
logical-or-expression || logical-and-expression 
conditional-expression: 
logical-or-expression 
logical-or-expression ? expression : assignment-expression 
assignment-expression: 
conditional-expression 
logical-or-expression assignment-operator assignment-expression 
throw-expression 
assignment-operator: one of 
= *= /= %= += -= >>= <<= &= ^= |= 
expression: 
assignment-expression 
expression , assignment-expression 
constant-expression: 
conditional-expression 
A.5 Statements [gram.stmt] 
statement: 
labeled-statement 
expression-statement 
compound-statement 
selection-statement 
iteration-statement 
jump-statement 
declaration-statement 
try-block 
labeled-statement: 
identifier : statement 
case constant-expression : statement 
default : statement 
expression-statement: 
expressionopt ; 
compound-statement: 
{ statement-seqopt } 
Draft 


789 Grammar summary A.6 Declarations 
statement-seq: 
statement 
statement-seq statement 
selection-statement: 
if ( condition ) statement 
if ( condition ) statement else statement 
switch ( condition ) statement 
condition: 
expression 
type-specifier-seq declarator = assignment-expression 
iteration-statement: 
while ( condition ) statement 
do statement while ( expression ) ; 
for ( for-init-statement conditionopt ; expressionopt ) statement 
for-init-statement: 
expression-statement 
simple-declaration 
jump-statement: 
break ; 
continue ; 
return expressionopt ; 
goto identifier ; 
declaration-statement: 
block-declaration 
A.6 Declarations [gram.dcl] 
declaration-seq: 
declaration 
declaration-seq declaration 
declaration: 
block-declaration 
function-definition 
template-declaration 
explicit-instantiation 
explicit-specialization 
linkage-specification 
namespace-definition 
block-declaration: 
simple-declaration 
asm-definition 
namespace-alias-definition 
using-declaration 
using-directive 
static_assert-declaration 
simple-declaration: 
decl-specifier-seqopt init-declarator-listopt ; 
Draft 


A.6 Declarations Grammar summary 790 
static_assert-declaration: 
static_assert ( constant-expression , string-literal ); 

decl-specifier: 
storage-class-specifier 
type-specifier 
function-specifier 

friend
typedef


decl-specifier-seq: 
decl-specifier-seqopt decl-specifier 

storage-class-specifier: 

auto
register
static
extern
mutable


function-specifier: 

inline
virtual
explicit


typedef-name: 
identifier 

type-specifier: 
simple-type-specifier 
class-specifier 
enum-specifier 
elaborated-type-specifier 
typename-specifier 
cv-qualifier 

simple-type-specifier: 
::opt nested-name-specifieropt type-name 
::opt nested-name-specifier template template-id 
char 
wchar_t 
bool 
short 
int 
long 
signed 
unsigned 
float 
double 
void 

type-name: 
class-name 
enum-name 
typedef-name 

Draft 


791 Grammar summary A.6 Declarations 

elaborated-type-specifier: 
class-key ::opt nested-name-specifieropt identifier 
class-key ::opt nested-name-specifieropt templateopt template-id 
enum ::opt nested-name-specifieropt identifier 

enum-name: 
identifier 
enum-specifier: 
enum identifieropt{ enumerator-listopt} 

enumerator-list: 
enumerator-definition 
enumerator-list , enumerator-definition 

enumerator-definition: 
enumerator 
enumerator = constant-expression 

enumerator: 
identifier 

namespace-name: 
original-namespace-name 
namespace-alias 

original-namespace-name: 
identifier 

namespace-definition: 
named-namespace-definition 
unnamed-namespace-definition 

named-namespace-definition: 
original-namespace-definition 
extension-namespace-definition 

original-namespace-definition: 
namespace identifier { namespace-body } 
extension-namespace-definition: 
namespace original-namespace-name { namespace-body } 
unnamed-namespace-definition: 
namespace { namespace-body } 
namespace-body: 
declaration-seqopt 

namespace-alias: 
identifier 
namespace-alias-definition: 
namespace identifier = qualified-namespace-specifier ; 
qualified-namespace-specifier: 
::opt nested-name-specifieropt namespace-name 

using-declaration: 
using typenameopt ::opt nested-name-specifier unqualified-id ; 
using :: unqualified-id ; 

using-directive: 
using namespace ::opt nested-name-specifieropt namespace-name ; 

asm-definition: 
asm ( string-literal ); 

Draft 


A.7 Declarators Grammar summary 792 
linkage-specification:
extern string-literal { declaration-seqopt }
extern string-literal declaration


A.7 Declarators [gram.decl] 
init-declarator-list:
init-declarator
init-declarator-list , init-declarator


init-declarator:
declarator initializeropt


declarator:
direct-declarator
ptr-operator declarator


direct-declarator:
declarator-id
direct-declarator ( parameter-declaration-clause ) cv-qualifier-seqopt exception-specificationopt
direct-declarator [ constant-expressionopt ]
( declarator )


ptr-operator: 

* cv-qualifier-seqopt
&
::opt nested-name-specifier * cv-qualifier-seqopt
cv-qualifier-seq:
cv-qualifier cv-qualifier-seqopt


cv-qualifier: 

const
volatile


declarator-id:
id-expression
::opt nested-name-specifieropt class-name


type-id:
type-specifier-seq abstract-declaratoropt


type-specifier-seq:
type-specifier type-specifier-seqopt


abstract-declarator:
ptr-operator abstract-declaratoropt
direct-abstract-declarator


direct-abstract-declarator:
direct-abstract-declaratoropt
( parameter-declaration-clause ) cv-qualifier-seqopt exception-specificationopt
direct-abstract-declaratoropt[ constant-expressionopt ]
( abstract-declarator )


parameter-declaration-clause:
parameter-declaration-listopt ...opt
parameter-declaration-list , ...


Draft 


793 Grammar summary A.8 Classes 
parameter-declaration-list: 
parameter-declaration 
parameter-declaration-list , parameter-declaration 
parameter-declaration: 
decl-specifier-seq declarator 
decl-specifier-seq declarator = assignment-expression 
decl-specifier-seq abstract-declaratoropt 
decl-specifier-seq abstract-declaratoropt = assignment-expression 
function-definition: 
decl-specifier-seqopt declarator ctor-initializeropt function-body 
decl-specifier-seqopt declarator function-try-block 
function-body: 
compound-statement 
initializer: 
= initializer-clause 
( expression-list ) 
initializer-clause: 
assignment-expression 
{ initializer-list ,opt } 
{ } 
initializer-list: 
initializer-clause 
initializer-list , initializer-clause 
A.8 Classes [gram.class] 
class-name: 
identifier 
template-id 
class-specifier: 
class-head { member-specificationopt } 
class-head: 
class-keyidentifieropt base-clauseopt 
class-keynested-name-specifier identifier base-clauseopt 
class-keynested-name-specifieropt template-id base-clauseopt 
class-key: 
class 
struct 
union 
member-specification: 
member-declaration member-specificationopt 
access-specifier : member-specificationopt 

Draft 


A.9 Derived classes Grammar summary 794 
member-declaration: 
decl-specifier-seqopt member-declarator-listopt ; 
function-definition ;opt 
::opt nested-name-specifier templateopt unqualified-id ; 
using-declaration 
static_assert-declaration 
template-declaration 
member-declarator-list: 
member-declarator 
member-declarator-list , member-declarator 
member-declarator: 
declarator pure-specifieropt 
declarator constant-initializeropt 
identifieropt : constant-expression 
pure-specifier: 
= 0 
constant-initializer: 
= constant-expression 
A.9 Derived classes [gram.derived] 
base-clause: 
: base-specifier-list 
base-specifier-list: 
base-specifier 
base-specifier-list , base-specifier 
base-specifier: 
::opt nested-name-specifieropt class-name 
virtual access-specifieropt ::opt nested-name-specifieropt class-name 
access-specifier virtualopt ::opt nested-name-specifieropt class-name 
access-specifier: 
private 
protected 
public 
A.10 Special member functions [gram.special] 
conversion-function-id: 
operator conversion-type-id 
conversion-type-id: 
type-specifier-seq conversion-declaratoropt 
conversion-declarator: 
ptr-operator conversion-declaratoropt 
ctor-initializer: 
: mem-initializer-list 

Draft 


795 Grammar summary A.11 Overloading 
mem-initializer-list: 
mem-initializer 
mem-initializer , mem-initializer-list 
mem-initializer: 
mem-initializer-id ( expression-listopt ) 
mem-initializer-id: 
::opt nested-name-specifieropt class-name 
identifier 
A.11 Overloading [gram.over] 
operator-function-id: 
operator operator 
operator operator < template-argument-listopt > 
A.12 Templates [gram.temp] 
template-declaration: 
exportopt template < template-parameter-list > declaration 
template-parameter-list: 
template-parameter 
template-parameter-list , template-parameter 
template-parameter: 
type-parameter 
parameter-declaration 
type-parameter: 
class identifieropt 
class identifieropt = type-id 
typename identifieropt 
typename identifieropt = type-id 
template < template-parameter-list > class identifieropt 
template < template-parameter-list > class identifieropt = id-expression 
template-id: 
template-name < template-argument-listopt > 
template-name: 
identifier 
template-argument-list: 
template-argument 
template-argument-list , template-argument 
template-argument: 
assignment-expression 
type-id 
id-expression 
typename-specifier: 
typename ::opt nested-name-specifier identifier 
typename ::opt nested-name-specifier templateopt template-id 
Draft 


A.13 Exception handling Grammar summary 796 
explicit-instantiation: 
template declaration 
explicit-specialization: 
template < > declaration 
A.13 Exception handling 
try-block: 
try compound-statement handler-seq 
function-try-block: 
try ctor-initializeropt function-body handler-seq 
handler-seq: 
handler handler-seqopt 
handler: 
catch ( exception-declaration ) compound-statement 
exception-declaration: 
type-specifier-seq declarator 
type-specifier-seq abstract-declarator 
type-specifier-seq 
... 
throw-expression: 
throw assignment-expressionopt 
exception-specification: 
throw ( type-id-listopt ) 
type-id-list: 
type-id 
type-id-list , type-id 
[gram.except] 
A.14 Preprocessing directives 
preprocessing-file: 
groupopt 
group: 
group-part 
group group-part 
group-part: 
pp-tokensopt new-line 
if-section 
control-line 
text-line 
#non-directive 
if-section: 
if-group elif-groupsopt else-groupopt endif-line 
[gram.cpp] 

Draft 


797 Grammar summary A.14 Preprocessing directives 

if-group: 
# if constant-expression new-line groupopt 
# ifdef identifier new-line groupopt 
# ifndef identifier new-line groupopt 

elif-groups: 
elif-group 
elif-groups elif-group 

elif-group: 
# elif constant-expression new-line groupopt 

else-group: 
# else new-line groupopt 

endif-line: 
# endif new-line 

control-line: 
# include pp-tokens new-line 
# define identifier replacement-list new-line 
# define identifier lparen identifier-listopt ) replacement-list new-line 

# define identifier lparen ... ) replacement-list new-line 
# define identifier lparen identifier-list, ... ) replacement-list new-line 

# undef identifier new-line
# line pp-tokens new-line
# error pp-tokensopt new-line
# pragma pp-tokensopt new-line
# new-line


text-line: 
pp-tokensopt new-line 

non-directive: 
pp-tokensopt new-line 

lparen: 

the left-parenthesis character without precedingwhite-space 

a ( character not immediately preceded by white-space 

identifier-list: 
identifier 
identifier-list , identifier 

replacement-list: 
pp-tokensopt 

pp-tokens: 
preprocessing-token 
pp-tokens preprocessing-token 

new-line: 

the new-line character 

Draft 


A.14 Preprocessing directives Grammar summary 798 
Draft 


AppendixB
(informative)
Implementation quantities [limits]


1 Because computers are finite,C++ implementations are inevitably limited in the size of the programs they can successfully process. Everyimplementation shall document those limitations where known. This documentation may cite fixed 
limits where they exist, say how to compute variable limits as a function of available resources, or say that fixed limits 
do not exist or are unknown. 

2 The limits may constrain quantities that include those described below or others. The bracketed number following each 

quantity is recommended as the minimum for that quantity. However, these quantities are only guidelines and do not 

determine compliance. 

— Nesting levels of compound statements, iteration control structures, and selection control structures [256]. 

— Nesting levels of conditional inclusion [256]. 

— Pointer, array, and function declarators (in anycombination) modifying an arithmetic, structure, union, or incomplete type in a declaration [256]. 

— Nesting levels of parenthesized expressions within a full expression [256]. 

— Number of characters in an internal identifier or macro name [1024]. 

— Numberof charactersinanexternal identifier[1024]. 

— External identifiers in one translation unit [65 536]. 

— Identifiers with block scope declared in one block [1024]. 

— Macro identifiers simultaneously defined in one translation unit [65 536]. 

— Parameters in one function definition [256]. 

— Arguments in one function call [256]. 

— Parameters in one macro definition [256]. 

— Arguments in one macro invocation [256]. 

— Characters in one logical source line [65 536]. 

— Characters in a character string literal or wide string literal (after concatenation) [65 536]. 


Implementation quantities 800 

— Size of an object [262 144]. 

— Nesting levels for #include files [256]. 

— Case labels for a switch statement (excluding those for anynested switch statements) [16 384]. 

— Data members in a single class, structure, or union [16 384]. 

— Enumeration constants in a single enumeration [4096]. 

— Levels of nested class, structure, or union definitions in a single struct-declaration-list [256]. 

— Functions registered by atexit()[32]. 

— Direct and indirect base classes [16 384]. 

— Direct base classes for a single class [1024]. 

— Members declared in a single class [4096]. 

— Final overriding virtual functions in a class, accessible or not [16 384]. 

— Direct and indirect virtualbases of a class [1024]. 

— Static members of a class [1024]. 

— Friend declarations in a class [4096]. 

— Access control declarationsina class[4096]. 

— Member initializers in a constructor definition [6144]. 

— Scope qualifications of one identifier [256]. 

— Nestedexternal specifications[1024]. 

—Templateargumentsinatemplate declaration[1024]. 

— Recursively nested template instantiations [17]. 

— Handlers per try block [256]. 

— Throw specifications on a single function declaration [256]. 

Draft 


AppendixC
(informative)
Compatibility [diff]


C.1 C++and ISOC [diff.iso] 
1 The subclausesof this subclause list the differences betweenC++ and ISOC,by the chaptersofthis document. 

C.1.1 Clause2: lexical conventions [diff.lex] 
2.3 

Change: C++ style comments(//)are added
Apair of slashes now introduce a one-line comment.
Rationale: This style of comments is a useful addition to the language.
Effect on original feature: Changeto semanticsof well-defined feature.AvalidISOCexpression containingadivision
operator followed immediatelybya C-style comment will nowbe treated asaC++style comment.Forexample:


{
int a =4;
int b =8 //* divide by a*/ a;


+a;
}
Difficulty of converting: Syntactic transformation. Just add white space after the division operator.
How widely used: The token sequence //* probably occurs very seldom.


2.11
Change: NewKeywordsNewkeywords areaddedtoC++;see 2.11.
Rationale: Thesekeywords were addedinorderto implementthenew semanticsofC++.
Effect on original feature: Change to semantics of well-defined feature. AnyISOCprograms that used anyof these
keywords as identifiers are notvalidC++ programs.
Difficulty of converting: Syntactic transformation. Convertingone specific programis easy.Convertinga large collec
tion of related programs takes more work.
How widely used: Common.

C.1 C++and ISOC Compatibility 802 
2.13.2 

Change: Type of character literal is changed fromint to char
Rationale: Thisis needed for improvedoverloaded function argument type matching.Forexample:


int function ( int i );
int function ( char c );


function( ’x’ ); 

It is preferable that this call match the second version of function rather than the first.
Effect on original feature: Changeto semanticsof well-defined feature.ISOCprograms whichdependon


sizeof(’x’) == sizeof(int) 

will notwork the same asC++programs.
Difficulty of converting: Simple.
How widely used: Programs which depend upon sizeof(’x’) are probably rare.


Subclause 2.13.4:
Change: String literals made const The type of a string literal is changed from “array of char ” to “array of const
char.” The type of a wide string literal is changed from “array of wchar_t ” to “array of const wchar_t.”
Rationale: Thisavoidscallingan inappropriateoverloadedfunction,whichmightexpecttobeabletomodifyitsargu
ment.
Effect on original feature: Change to semantics of well-defined feature.
Difficulty of converting: Simple syntactic transformation, because string literals can be converted to char*;(4.2). The
most common cases are handledbya newbut deprecated standard conversion:


char* p = "abc"; // validinC, deprecatedinC++
char* q = expr ? "abc" : "de"; // validinC,invalidinC++


How widely used: Programs that have a legitimate reason to treat string literals as pointers to potentially modifiable 
memory are probably rare. 

C.1.2 Clause3: basic concepts [diff.basic] 
3.1 
Change: C++ doesnothave “tentative definitions”asinCE.g.,atfile scope, 

int i;
int i;


isvalidinC, invalid inC++. This makes it impossible to define mutually referential file-local static objects, if initializers 
are restrictedtothe syntactic formsofC.Forexample, 

struct X { int i; struct X *next; }; 

static struct X a;
static struct X b = { 0, &a };
static struct X a = { 1, &b };


Draft 


803 Compatibility C.1 C++ and ISOC 

Rationale: Thisavoidshaving different initialization rules forbuilt-in types and user-defined types.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation.
Rationale: InC++,theinitializerforoneofasetof mutually-referential file-localstaticobjectsmustinvokeafunction
call to achieve the initialization.
How widely used: Seldom.


3.3 

Change: Astruct isa scopeinC++, notinC
Rationale: Class scopeis crucialtoC++, and a struct is a class.
Effect on original feature: Change to semantics of well-defined feature.
Difficulty of converting: Semantic transformation.
How widely used: C programs use struct extremely frequently, but the change is only noticeable when struct,
enumeration, or enumerator names are referred to outside the struct. The latter is probably rare.


3.5 [also 7.1.5] 
Change: Anameoffile scope thatisexplicitlydeclaredconst,and notexplicitlydeclaredextern,has internal linkage, 
whileinCitwouldhaveexternal linkage 
Rationale: Because const objectscanbeusedas compile-timevaluesinC++,this feature urges programmers to provide 
explicit initializer values for each const. This feature allows the user to put constobjects in header files that are 
included in manycompilation units. 
Effect on original feature: Change to semantics of well-defined feature. 
Difficulty of converting: Semantic transformation 
How widely used: Seldom 
3.6 
Change: Main cannot be called recursively and cannot have its address taken 
Rationale: The main function may require special actions. 
Effect on original feature: Deletion of semantically well-defined feature 
Difficulty of converting: Trivial: create an intermediary function such asmymain(argc, argv. 
How widely used: Seldom 

3.9 
Change: Callows “compatible types” in several places,C++ does notForexample, otherwise-identical struct types
withdifferenttag names are “compatible”inCbut are distinctlydifferent typesinC++.
Rationale: Stricter type checkingis essential forC++.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation. The “typesafe linkage” mechanism will find many,but not all, of
such problems. Those problems not found by typesafe linkage will continue to function properly, according to the
“layout compatibility rules” of this International Standard.
How widely used: Common.


4.10 
Change: Converting void* to a pointer-to-object type requires casting 

char a [10];
void *b=a;
void foo () {


Draft 


C.1 C++and ISOC Compatibility 804 
char *c=b;
}


ISOCwill accept this usageof pointertovoid being assignedtoa pointerto objecttype.C++ will not.
Rationale: C++tries harder thanCto enforce compile-time type safety.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Couldbe automated. Violations willbe diagnosedbytheC++ translator. The fix is to add a
castFor example:


char *c = (char *) b; 

Howwidely used: Thisisfairlywidelyusedbutitisgood programmingpracticetoaddthecastwhenassigningpointerto-voidtopointer-to-object.SomeISOCtranslatorswillgiveawarningifthecastisnotused. 

4.10 

Change: Only pointers to non-const and non-volatile objects may be implicitly converted to void*
Rationale: This improves type safety.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Couldbe automated.ACprogram containing suchan implicit conversion from (e.g.) pointer-
to-const-object to void* will receive a diagnostic message. The correction is to add an explicit cast.
How widely used: Seldom.


C.1.3 Clause5: expressions [diff.expr] 
5.2.2 

Change: Implicit declaration of functions is not allowed
Rationale: The type-safe natureofC++.
Effect on original feature: Deletion of semantically well-defined feature. Note: the original feature was labeled as
“obsolescent” in ISO C.
Difficulty of converting: Syntactic transformation. Facilities for producing explicit function declarations are fairly
widespread commercially.
How widely used: Common.


5.3.3, 5.4
Change: Types must be declared in declarations, not in expressions In C, a sizeof expression or cast expression may
createa new type.Forexample,


p = ( void *)( struct x { int i ;} *)0; 

declares a new type, struct x .
Rationale: This prohibition helps to clarify the location of declarations in the source code.
Effect on original feature: Deletion of a semantically well-defined feature.
Difficulty of converting: Syntactic transformation.
How widely used: Seldom.


5.16, 5.17, 5.18


Change: The result of a conditional expression, an assignment expression, or a comma expression may be an lvalue


Draft 


805 Compatibility C.1 C++ and ISOC 

Rationale: C++ is an object-oriented language, placing relatively more emphasis on lvalues. For example, functions
may return lvalues.
Effect on original feature: Changeto semanticsof well-defined feature. SomeC expressionsthat implicitlyrelyon
lvalue-to-rvalue conversionswill yield different results.Forexample,


char arr [100];
sizeof (0 , arr )


yields 100 inC++and sizeof(char*) in C.
Difficulty of converting: Programs must add explicit casts to the appropriate rvalue.
How widely used: Rare.


C.1.4 Clause6: statements [diff.stat] 
6.4.2, 6.6.4(switch and goto statements)
Change: It is now invalid to jump past a declaration with explicit or implicit initializer (except across entire block not
entered)
Rationale: Constructors used in initializers may allocate resources which need to be de-allocated upon leaving the block.
Allowing jump past initializers would require complicated run-time determination of allocation. Furthermore, any use
of the uninitialized object could be a disaster. With this simple compile-time rule, C++ assures that if an initialized
variableisin scope, thenithas assuredly been initialized.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation.
How widely used: Seldom.


6.6.3 

Change: It is now invalid to return (explicitly or implicitly) from a function which is declared to return a value without
actually returning a value
Rationale: The callerandcalleemay assumefairly elaborate return-value mechanismsforthe returnof class objects.
If some flow paths execute a return without specifying any value, the implementation must embody many more com
plications. Besides, promising to return a value of a given type, and then not returning such a value, has always been
recognizedtobea questionable practice, toleratedonly becausevery-oldChadno distinction betweenvoid functions
and int functions.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation. Add an appropriate return value to the source code, e.g. zero.
How widely used: Seldom.For several years,manyexistingCimplementationshave producedwarningsin this case.


C.1.5 Clause7: declarations [diff.dcl] 
7.1.1 
Change: InC++, the static or extern specifiers can only be applied to names of objects or functions Using these 
specifiers with type declarationsis illegalinC++.InC, these specifiers areignored when used on type declarations. 

Example: 

static struct S { // validC,invalidinC++
int i;


// ... 

}; 

Draft 


C.1 C++and ISOC Compatibility 806 
Rationale: Storageclass specifiersdon’thaveanymeaningwhen associatedwithatype.InC++, class members can be
declared with the static storage class specifier. Allowing storage class specifiers on type declarations could render the
code confusing for users.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Syntactic transformation.
How widely used: Seldom.


7.1.3 

Change: AC++ typedef name must be different from anyclass type name declared in the same scope (except if the 
typedefisasynonymoftheclassnamewiththesamename).InC,atypedefnameandastructtagname declaredinthe 
same scope can have the same name (because theyhave different name spaces) 

Example: 

typedef struct name1 { /* ... * / } name1 ; // validCandC++
struct name { /* ... * / };
typedef int name ; // validC,invalidC++


Rationale: For ease of use, C++ doesn’t require thata type namebe prefixed with thekeywords class, struct or 
union when used in object declarations or type casts. 

Example: 

class name { /* ... * / }; 
name i; // i has type class name 

Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation.Oneofthe2typeshastobe renamed.
How widely used: Seldom.


7.1.5 [see also 3.5]
Change: const objects mustbe initializedinC++ but canbe left uninitializedinC
Rationale: Aconst object cannot be assigned to so it must be initialized to hold a useful value.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation.
How widely used: Seldom.
7.1.5 (type specifiers)
Change: Banning implicit int
InC++ a decl-specifier-seq must contain a type-specifier.In the following example, the left-hand column presents valid
C; the right-hand column presents equivalentC++ :


v o i d f ( c o n s t p a r m ) ; v o i d f ( c o n s t i n t p a r m ) ; 
c o n s t n = 3 ; c o n s t i n t n = 3 ; 
m a i n ( ) i n t m a i n ( ) 
/* . . . * / /* . . . * / 

Draft 


807 Compatibility C.1 C++ and ISOC 

Rationale: InC++, implicit int creates several opportunities for ambiguity between expressions involving function-like
casts and declarations. Explicit declaration is increasingly considered to be proper style. Liaison with WG14 (C)
indicated support for (at least) deprecating implicit int in the next revision of C.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Syntactic transformation. Could be automated.
How widely used: Common.


7.2 

Change: C++ objects of enumeration type can only be assigned values of the same enumeration type. In C, objects of 
enumeration type can be assigned values of anyintegral type 

Example: 

enum color { red , blue , green };
color c =1; // validC,invalidC++


Rationale: The type-safe natureofC++.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Syntactic transformation. (The type error produced by the assignment can be automatically
corrected by applying an explicit cast.)
How widely used: Common.


7.2 
Change: InC++,thetypeofan enumeratorisits enumeration.InC,thetypeofan enumeratoris int. 
Example: 

enum e{ A };
sizeof (A ) == sizeof ( int ) // inC
sizeof(A) == sizeof(e) // inC++
/* and sizeof(int) is not necessarily equal to sizeof(e) * /


Rationale: InC++, an enumeration is a distinct type.
Effect on original feature: Change to semantics of well-defined feature.
Difficulty of converting: Semantic transformation.
Howwidely used: Seldom.TheonlytimethisaffectsexistingCcodeiswhenthesizeofan enumeratoristaken.Taking
the sizeof an enumeratoris nota commonCcoding practice.


C.1.6 Clause8: declarators [diff.decl] 
8.3.5 
Change: InC++, a function declared with an empty parameter list takes no arguments. In C, an empty parameter list 
means that the number and type of the function arguments are unknown" 

Example: 
i n t f ( ) ; // means int f(void) in C++ 
// int f( unknown ) in C 

Draft 


C.1 C++and ISOC Compatibility 808 
Rationale: This is to avoid erroneous function calls (i.e. function calls with the wrong number or type of arguments). 
Effect on original feature: Change to semantics of well-defined feature. This feature was marked as “obsolescent” in 

C.
Difficulty of converting: Syntactic transformation.ThefunctiondeclarationsusingCincompletedeclarationstylemust
be completed to become full prototype declarations. Aprogram may need to be updated further if different calls to the
same (non-prototype) function have different numbers of arguments or if the type of corresponding arguments differed.
How widely used: Common.
8.3.5 [see 5.3.3]
Change: InC++, types may not be defined in return or parameter types. In C, these type definitions are allowed
Example:


void f( struct S{int a; }arg ){} // validC,invalidC++
enum E{A, B, C } f() {} // validC,invalidC++


Rationale: When comparing types in different compilation units, C++ relies on name equivalence when C relies on
structural equivalence. Regarding parameter types: since the type defined in an parameter list would be in the scope of
the function, the onlylegal callsinC++would be from within the function itself.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation.Thetype definitionsmustbemovedtofilescope,orin header files.
How widely used: Seldom. This styleof typedefinitionsis seen as poor coding style.


8.4 

Change: In C++, the syntax for function definition excludes the “old-style” C function. In C, “old-style” syntax is
allowed,but deprecated as“obsolescent.”
Rationale: Prototypes are essential totype safety.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Syntactic transformation.
How widely used: Commoninold programs,but alreadyknowntobe obsolescent.


8.5.2 
Change: InC++, when initializing an array of character with a string, the number of characters in the string (including 
the terminating ’\0’)mustnotexceedthenumberof elementsinthearray.InC,anarraycanbe initializedwithastring 
even if the array is not large enough to contain the string-terminating ’\0’ 

Example: 

char array[4] = "abcd"; // validC,invalidC++ 

Rationale: When these non-terminatedarrays are manipulated by standard stringroutines, there is potential for major
catastrophe.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation. The arrays must be declared one element bigger to contain the string
terminating ’\0’.


Draft 


809 Compatibility C.1 C++ and ISOC 

How widely used: Seldom. This style of array initialization is seen as poor coding style. 

C.1.7 Clause9: classes [diff.class] 
9.1 [see also 7.1.3]
Change: InC++, a class declaration introduces the class name into the scope where it is declared and hides anyobject,
function or other declaration of that name in an enclosing scope. In C, an inner scope declaration of a struct tag name
never hides the name of an object or function in an outer scope
Example:


int x [99];
void f()
{


struct x { int a; };
sizeof (x ); /* sizeof the arrayinC * /
/* sizeof the structinC++ * /


} 

Rationale: Thisisoneofthefew incompatibilities betweenCandC++that canbe attributedtothenewC++name space
definition where a name can be declared as a type and as a non-type in a single scope causing the non-type name to
hide the type name and requiring that thekeywords class, struct, union or enum be used to refer to the type name.
This new name space definition provides important notational conveniences toC++ programmers and helps making the
useofthe user-defined typesas similaras possibletothe useofbuilt-in types. Theadvantagesofthenew name space
definition werejudgedtooutweighbyfarthe incompatibilitywithCdescribedabove.
Effect on original feature: Change to semantics of well-defined feature.
Difficulty of converting: Semantic transformation. If the hidden name that needs to be accessed is at global scope, the
:: C++operator can be used. If the hidden name is at block scope, either the type or the structtag has to be renamed.
How widely used: Seldom.


9.7 
Change: InC++,the nameofa nested classis localtoits enclosing class.InCthe nameofthe nested class belongsto 
the same scope as the name of the outermost enclosing class. 

Example: 
s t r u c t X { 
s t r u c t Y { /* . . . * / } y ; 
} ; 
s t r u c t Y y y ; // valid C, invalid C++ 

Rationale: C++ classeshave member functions which require that classes establish scopes. TheC rulewould leave 
classes as an incompletescope mechanism whichwould preventC++ programmers from maintaining locality within a 
class.Acoherentsetof scope rulesforC++basedontheCrulewouldbevery complicatedandC++programmerswould 
be unableto predict reliablythe meaningsof nontrivialexamplesinvolving nestedorlocal functions. 
Effect on original feature: Change of semantics of well-defined feature. 
Difficulty of converting: Semantic transformation. To make the struct type name visible in the scope of the enclosing 

Draft 


C.1 C++and ISOC Compatibility 810 
struct, the struct tag could be declared in the scope of the enclosing struct, before the enclosing struct is defined. 
Example: 

struct Y; // struct Y and struct X are at the same scope
struct X {
struct Y { /* ... * / } y;
};


1 Allthe definitionsofCstruct types enclosedinother struct definitionsand accessed outsidethe scopeofthe enclosing 
struct couldbeexportedtothe scopeofthe enclosing struct. Note: thisisa consequenceofthedifferencein scope rules, 
which is documented in 3.3. 
How widely used: Seldom. 

9.9 

Change: InC++, a typedef name may not be redeclared in a class definition after being used in that definition
Example:


typedef int I; 

struct S {
I i;
int I; // validC,invalidC++


}; 

Rationale: When classes become complicated, allowing such a redefinition after the type has been used can create
confusion forC++programmers as to what the meaning of ’I’ really is.
Effect on original feature: Deletion of semantically well-defined feature.
Difficulty of converting: Semantic transformation. Either the type or the struct member has to be renamed.
How widely used: Seldom.


C.1.8 Clause 12: special member functions [diff.special] 
12.8 (copying class objects)
Change: Copying volatile objects
1 The implicitly-declared copy constructor and implicitly-declared copy assignment operator cannot make a copy of a 
volatilelvalue.Forexample, the followingisvalidin ISOC: 

struct X { int i; };
struct X x1 , x2;
volatile struct X x3 = {0};
x1 = x3; // invalidC++
x2 = x3; // alsoinvalidC++


Rationale: Several alternatives were debated at length. Changing the parameter to volatile const X& would greatly 
complicate the generation of efficient code for class objects. Discussion of providing two alternative signatures for these 
implicitly-defined operations raised unanswered concerns about creating ambiguities and complicating the rules that 
specify the formation of these operators according to the bases and members. 
Effect on original feature: Deletion of semantically well-defined feature. 

Draft 


811 Compatibility C.2 StandardClibrary 

Difficulty of converting: Semantic transformation. If volatile semantics are required for the copy, a user-declared
constructor or assignment must be provided. If non-volatile semantics are required, an explicit const_cast can be
used.
How widely used: Seldom.


C.1.9 Clause 16: preprocessing directives [diff.cpp] 
16.8 (predefined names)
Change: Whether __STDC _ _ is defined and if so, what its value is, are implementation-defined
Rationale: C++is not identical to ISO C. Mandating that _ _ STDC__ be defined would require that translators make an
incorrect claim. Each implementation must choose the behavior that will be most useful to its marketplace.
Effect on original feature: Change to semantics of well-defined feature.
Difficulty of converting: Semantic transformation.
How widely used: Programs and headers that reference __STDC_ _ are quite common.
C.2 StandardClibrary [diff.library] 
1 This subclause summarizes the contents of the C++ Standard library included from the Standard C library. It also 
summarizes the explicit changes in definitions, declarations, or behavior from the ISO/IEC 9899:1990 and ISO/IEC 
9899:1990/DAM1notedin other subclauses(17.4.1.2, 18.1, 21.4). 

2 TheC++ Standard library provides54 standard macros from theClibrary, as showninTable 98. 

3 The header names (enclosed in < and >)indicate that the macromay be defined in more than one header. All such 
definitions are equivalent(3.2). 

Table 98: Standard Macros 

assert FOPEN_MAX NULL <cstdio> SIGFPE TMP_MAX 
BUFSIZ HUGE_VAL NULL <cstring> SIGILL va_arg 
CLOCKS_PER_SEC LC_ALL NULL <ctime> SIGINT va_end 
EDOM LC_COLLATE NULL <cwchar> SIGSEGV va_start 
EILSEQ LC_CTYPE offsetof SIGTERM WCHAR_MAX 
EOF LC_MONETARY RAND_MAX SIG_DFL WCHAR_MIN 
ERANGE LC_NUMERIC SEEK_CUR SIG_ERR WEOF <cwchar> 
errno LC_TIME SEEK_END SIG_IGN WEOF <cwctype> 
EXIT_FAILURE L_tmpnam SEEK_SET stderr _IOFBF 
EXIT_SUCCESS MB_CUR_MAX setjmp stdin _IOLBF 
FILENAME_MAX NULL <cstddef> SIGABRT stdout _IONBF 

4 TheC++ Standard library provides45standardvalues from theClibrary, as showninTable 99. 
5 TheC++ Standard library provides19standard types from theClibrary, as showninTable 100. 
6 TheC++ Standard library provides2standard structures from theClibrary, as showninTable 101. 
7 TheC++ Standard library provides 209 standard functions from theClibrary, as showninTable 102. 

Draft 


C.2 StandardClibrary Compatibility 812 
Table 99: StandardValues 

CHAR_BIT FLT_DIG INT_MIN MB_LEN_MAX 
CHAR_MAX FLT_EPSILON LDBL_DIG SCHAR_MAX 
CHAR_MIN FLT_MANT_DIG LDBL_EPSILON SCHAR_MIN 
DBL_DIG FLT_MAX LDBL_MANT_DIG SHRT_MAX 
DBL_EPSILON FLT_MAX_10_EXP LDBL_MAX SHRT_MIN 
DBL_MANT_DIG FLT_MAX_EXP LDBL_MAX_10_EXP UCHAR_MAX 
DBL_MAX FLT_MIN LDBL_MAX_EXP UINT_MAX 
DBL_MAX_10_EXP FLT_MIN_10_EXP LDBL_MIN ULONG_MAX 
DBL_MAX_EXP FLT_MIN_EXP LDBL_MIN_10_EXP USRT_MAX 
DBL_MIN FLT_RADIX LDBL_MIN_EXP 
DBL_MIN_10_EXP FLT_ROUNDS LONG_MAX 
DBL_MIN_EXP INT_MAX LONG_MIN 

Table 100: StandardTypes 

clock_t ldiv_t size_t <cstdio> va_list 
div_t mbstate_t size_t <cstdlib> wctrans_t 
FILE ptrdiff_t size_t <cstring> wctype_t 
fpos_t sig_atomic_t size_t <ctime> wint_t <cwchar> 
jmp_buf size_t <cstddef> time_t wint_t <cwctype> 

Table 101: Standard Structs 

lconv tm 

Draft 


813 Compatibility C.2 StandardClibrary 

Table 102: Standard Functions 

abort fmod isupper mktime strftime wcrtomb 
abs fopen iswalnum modf strlen wcscat 
acos fprintf iswalpha perror strncat wcschr 
asctime fputc iswcntrl pow strncmp wcscmp 
asin fputs iswctype printf strncpy wcscoll 
atan fputwc iswdigit putc strpbrk wcscpy 
atan2 fputws iswgraph putchar strrchr wcscspn 
atexit fread iswlower puts strspn wcsftime 
atof free iswprint putwc strstr wcslen 
atoi freopen iswpunct putwchar strtod wcsncat 
atol frexp iswspace qsort strtok wcsncmp 
bsearch fscanf iswupper raise strtol wcsncpy 
btowc fseek iswxdigit rand strtoul wcspbrk 
calloc fsetpos isxdigit realloc strxfrm wcsrchr 
ceil ftell labs remove swprintf wcsrtombs 
clearerr fwide ldexp rename swscanf wcsspn 
clock fwprintf ldiv rewind system wcsstr 
cos fwrite localeconv scanf tan wcstod 
cosh fwscanf localtime setbuf tanh wcstok 
ctime getc log setlocale time wcstol 
difftime getchar log10 setvbuf tmpfile wcstombs 
div getenv longjmp signal tmpnam wcstoul 
exit gets malloc sin tolower wcsxfrm 
exp getwc mblen sinh toupper wctob 
fabs getwchar mbrlen sprintf towctrans wctomb 
fclose gmtime mbrtowc sqrt towlower wctrans 
feof isalnum mbsinit srand towupper wctype 
ferror isalpha mbsrtowcs sscanf ungetc wmemchr 
fflush iscntrl mbstowcs strcat ungetwc wmemcmp 
fgetc isdigit mbtowc strchr vfprintf wmemcpy 
fgetpos isgraph memchr strcmp vfwprintf wmemmove 
fgets islower memcmp strcoll vprintf wmemset 
fgetwc isprint memcpy strcpy vsprintf wprintf 
fgetws ispunct memmove strcspn vswprintf wscanf 
floor isspace memset strerror vwprintf 

Draft 


C.2 StandardClibrary Compatibility 814 
C.2.1 Modifications to headers [diff.mods.to.headers] 
1 For compatibility with the StandardClibrary, theC++Standard libraryprovides the18 Cheaders(D.5),but their useis 
deprecated inC++. 

C.2.2 Modifications to definitions [diff.mods.to.definitions] 
C.2.2.1 Typewchar_t [diff.wchar.t] 
1 wchar_t isakeywordin this International Standard(2.11). It does not appear asa type name definedin anyof 
<cstddef>, <cstdlib>, or <cwchar> (21.4). 

C.2.2.2 Header <iso646.h> [diff.header.iso646.h] 
1 The tokens and, and_eq, bitand, bitor, compl, not_eq, not, or, or_eq, xor, and xor_eq arekeywords in this 
International Standard(2.11). Theydo not appear as macro names definedin <ciso646>. 

C.2.2.3 Macro NULL [diff.null] 
1 The macro NULL, defined in anyof <clocale>, <cstddef>, <cstdio>, <cstdlib>, <cstring>, <ctime>, or <cwchar>,is an implementation-definedC++ null pointer constant in this International Standard(18.1). 

C.2.3 Modifications to declarations [diff.mods.to.declarations] 
1 Header <cstring>: The following functionshavedifferent declarations: 

— strchr 
— strpbrk 
— strrchr 
— strstr 
— memchr 
21.4 describes the changes. 
C.2.4 Modifications to behavior [diff.mods.to.behavior] 
1 Header <cstdlib>: The following functionshavedifferent behavior: 

— atexit 
— exit 
— abort 
18.3 describes the changes. 
2 Header <csetjmp>: The following functionshavedifferent behavior: 
— longjmp 
18.7 describes the changes. 
Draft 


815 Compatibility C.2 StandardClibrary 

C.2.4.1 Macro offsetof(type,member-designator) [diff.offsetof] 
1 The macro offsetof, defined in <cstddef>, accepts a restricted set of type arguments in this International Standard. 
18.1 describes the change. 
C.2.4.2 Memory allocationfunctions [diff.malloc] 
1 The functions calloc, malloc, and realloc are restrictedin this International Standard. 20.4.6 describes the changes. 

Draft 


C.2 StandardClibrary Compatibility 816 
Draft 


AppendixD 
(normative) 
Compatibility features [depr] 

1 This clause describes featuresof theC++ Standard that are specified for compatibility with existing implementations. 

2 These are deprecated features, where deprecated is defined as: Normative for the current edition of the Standard,but 
not guaranteed to be part of the Standard in future revisions. 

D.1 Increment operator with bool operand [depr.incr.bool] 
1 The use of an operand of type bool with the ++ operator is deprecated (see 5.3.2 and 5.2.6). 
D.2 statickeyword [depr.static] 
1 The use of the static keyword is deprecated when declaring objects in namespace scope (see3.3.5). 

D.3 Access declarations [depr.access.dcl] 
1 Access declarations are deprecated (see 11.3). 

D.4 Implicit conversion from const strings [depr.string] 
1 The implicitconversionfrom constto non-const qualificationforstring literals(4.2)is deprecated. 

D.5 StandardClibrary headers [depr.c.headers] 
1 For compatibility with the StandardClibrary,theC++Standard library provides the 18 Cheaders,as showninTable103. 
Table 103:CHeaders 

<assert.h> <iso646.h> <setjmp.h> <stdio.h> <wchar.h>
<ctype.h> <limits.h> <signal.h> <stdlib.h> <wctype.h>
<errno.h> <locale.h> <stdarg.h> <string.h>
<float.h> <math.h> <stddef.h> <time.h>


EveryCheader, eachof which hasa nameof the form name .h,behaves as if each name placed in the Standard library 
namespace by the corresponding cname header is also placed within the namespace scope of the namespace std and is 
followed by an explicit using-declaration (7.3.3). 


D.6 Old iostreams members Compatibility features 818 
3[Example: The header <cstdlib> provides its declarations and definitions within the namespace std. The header 
<stdlib.h> makes theseavailable alsoin the global namespace, much asin theCStandard. — end example ] 

D.6 Old iostreams members [depr.ios.members] 
1 The following member names are in addition to names specified in clause 27: 

namespace std {
class ios_base {
public :


typedef T1 io_state ;
typedef T2 open_mode ;
typedef T3 seek_dir ;
typedef OFF_T streamoff ;
typedef POS_T streampos ;


// remainder unchanged 

};
}


2 The type io_state is a synonym for an integer type (indicated here as T1 )that permits certain member functions to 
overload others on parameters of type iostate and provide the same behavior. 
3 The type open_mode is a synonym for an integer type (indicated here as T2 )that permits certain member functions to 
overload others on parameters of type openmode and provide the same behavior. 
4 The type seek_dir is a synonym for an integer type (indicated here as T3 )that permits certain member functions to 
overload others on parameters of type seekdir and provide the same behavior. 
5 The type streamoff is an implementation-definedtype that satisfies the requirementsof type OFF_T (27.4.1). 
6 The type streampos is an implementation-definedtype that satisfies the requirementsof type POS_T (27.2). 
7 An implementation may provide the following additional member function, which has the effect of calling sbumpc() 
(27.5.2.2.3): 

namespace std {
template <class charT , class traits = char _traits <charT > >
class basic_streambuf {
public :


void stossc (); 

// remainder unchanged 

};
}


8 An implementation may provide the following member functions that overload signatures specified in clause 27: 

namespace std {
template < class charT , class Traits > class basic_ios {
public :


void clear ( io_state state );
void setstate ( io_state state );
void exceptions(io_ state);


Draft 


819 Compatibility features D.7 char* streams 

// remainder unchanged 

}; 

class ios_base {
public :


// remainder unchanged 

}; 

template <class charT , class traits = char _traits <charT > >
class basic_streambuf {
public :


pos_type pubseekoff(off_type off , ios_base :: seek_dir way , 
ios_base :: open_mode which = ios_base :: in | ios_base :: out ); 
pos_type pubseekpos(pos_type sp , 
ios_base :: open_mode which ); 

// remainder unchanged 

}; 

template < class charT , class traits = char _traits < charT > >
class basic_filebuf : public basic_streambuf <charT ,traits > {
public :


basic_filebuf < charT , traits >* open
( const char * s , ios _base :: open_mode mode );


// remainder unchanged 

}; 

template < class charT , class traits = char _traits < charT > >
class basic_ifstream : public basic_istream <charT ,traits > {
public :


void open ( const char * s , ios_base :: open_mode mode ); 

// remainder unchanged 

}; 

template < class charT , class traits = char _traits < charT > >
class basic_ofstream : public basic_ostream <charT ,traits > {
public :


void open ( const char * s , ios_base :: open_mode mode ); 

// remainder unchanged 

}; 

} 

9 The effects of these functions is to call the corresponding member function specified in clause 27. 

D.7 char* streams [depr.str.strstreams] 
1 The header <strstream> defines three types that associate streambuffers with character array objectsand assist reading 
and writing such objects. 

D.7.1 Class strstreambuf [depr.strstreambuf] 
Draft 


D.7 char* streams Compatibility features 820 
namespace std {
class strstreambuf : public basic_streambuf <char > {
public :


explicit strstreambuf(streamsize alsize_arg = 0); 
strstreambuf(void* (* palloc_arg )(size_t), void (* pfree_arg )( void *)); 
strstreambuf ( char * gnext_arg , streamsize n , char * pbeg_arg = 0); 
strstreambuf(const char* gnext_arg , streamsize n ); 

strstreambuf(signed char* gnext_arg , streamsize n , 

signed char * pbeg_arg = 0);
strstreambuf(const signed char* gnext_arg , streamsize n );
strstreambuf(unsigned char* gnext_arg , streamsize n ,


unsigned char * pbeg_arg = 0);
strstreambuf(const unsigned char* gnext_arg , streamsize n );


virtual ~strstreambuf(); 

void freeze ( bool freezefl = true );
char * str ();
int pcount ();


protected :
virtual int_type overflow ( int_type c = EOF );
virtual int_type pbackfail ( int_type c = EOF );
virtual int_type underflow ();
virtual pos_type seekoff ( off_type off , ios_base :: seekdir way ,


ios_base :: openmode which
= ios_base :: in | ios_base :: out );
virtual pos_type seekpos ( pos_type sp , ios_base :: openmode which
= ios_base :: in | ios_base :: out );
virtual streambuf * setbuf ( char * s , streamsize n );


private : 
// typedef T1 strstate; exposition only 
// static const strstate allocated ; exposition only 
// static const strstate constant ; exposition only 
// static const strstate dynamic ; exposition only 
// static const strstate frozen ; exposition only 
// strstate strmode ; exposition only 
// streamsize alsize ; exposition only 
// void* (*palloc )(size_t); exposition only 
// void (*pfree )(void*); exposition only 

};
}


1 The class strstreambuf associates the input sequence, and possibly the output sequence, with an object of some 
character array type, whose elements store arbitrary values. The array object has several attributes. 

2[Note: For the sake of exposition, these are represented as elements of a bitmask type (indicated here as T1 )called 
strstate . The elements are: 

Draft 


821 Compatibility features D.7 char* streams 

— allocated , set when a dynamic array object has been allocated, and hence should be freed by the destructor for 
the strstreambuf object; 
— constant , set when the array object has const elements, so the output sequence cannot be written; 
— dynamic , set when the array object is allocated (or reallocated) as necessary to hold a character sequence that 
can change in length; 
— frozen , set when the program has requested that the array object not be altered, reallocated, or freed. 
— end note ] 
3[Note: For the sake of exposition, the maintained data is presented here as: 
— strstate strmode , the attributes of the array object associated with the strstreambuf object; 
— int alsize , the suggested minimum size for a dynamic array object; 
— void* palloc )(size_t), points to the function to callto allocate a dynamic array object; 
— void (*pfree )(void*), points to the function to call to free a dynamic array object. 
— end note ] 
4 Each object of class strstreambuf has a seekable area, delimited by the pointers seeklow and seekhigh . If gnext 
is a null pointer, the seekable area is undefined. Otherwise, seeklow equals gbeg and seekhigh is either pend , if 
pend is not a null pointer, or gend . 

D.7.1.1 strstreambuf constructors [depr.strstreambuf.cons] 
explicit strstreambuf(streamsize alsize_arg = 0); 

1 Effects: Constructs an object of class strstreambuf, initializing the base class with streambuf(). The postconditionsof this function are indicatedinTable 104. 

Table 104:strstreambuf(streamsize) effects 

Element Value 

strmode dynamic 
alsize alsize_arg 
palloc a null pointer 
pfree a null pointer 

strstreambuf(void* (* palloc_arg )( size _t ) , void (* pfree_arg )( void *)); 

Effects: Constructs an object of class strstreambuf, initializing the base class with streambuf(). The postconditionsof this function are indicatedinTable 105. 

strstreambuf ( char * gnext_arg , streamsize n , char * pbeg_arg = 0);
strstreambuf(signed char* gnext_arg , streamsize n ,
signed char * pbeg_arg = 0);
strstreambuf(unsigned char* gnext_arg , streamsize n ,


Draft 


D.7 char* streams Compatibility features 822 
Table 105:strstreambuf(void* (*)(size_t), void (*)(void*)) effects 

Element Value 
strmode dynamic 
alsize an unspecified value 
palloc palloc_arg 
pfree pfree_arg 

unsigned char * pbeg_arg = 0); 

Effects: Constructs an object of class strstreambuf, initializing the base class with streambuf(). The postconditionsof this function are indicatedinTable 106. 

Table 106:strstreambuf(charT*, streamsize, charT*) effects 

Element Value 

strmode 0 
alsize an unspecified value 
palloc a null pointer 
pfree a null pointer 

4 gnext_arg shall point to the first element of an array object whose number of elements N is determined as 
follows: 

— If n >0, N is n . 
— If n == 0, N is std::strlen(gnext_arg ). 
— If n <0, N is INT_MAX.326) 
5 If pbeg_arg is a null pointer, the function executes: 
setg (gnext_arg , gnext_arg , gnext_arg + N ); 

6 Otherwise, the function executes: 

setg (gnext_arg , gnext_arg , pbeg_arg ); 

setp (pbeg_arg , pbeg_arg + N ); 

strstreambuf(const char* gnext_arg , streamsize n );
strstreambuf(const signed char* gnext_arg , streamsize n );
strstreambuf(const unsigned char* gnext_arg , streamsize n );


7 Effects: Behaves the same as strstreambuf((char*)gnext_arg ,n ), except that the constructor also sets 
constant in strmode . 

virtual ~ strstreambuf (); 

326) The function signature strlen(const char*) is declared in <cstring>.(21.4). The macro INT_MAX is defined in <climits> (18.2). 

Draft 


823 Compatibility features D.7 char* streams 

8 Effects: Destroys an object of class strstreambuf. The function frees the dynamically allocated array object 
only if strmode & allocated != 0 and strmode & frozen == 0.(D.7.1.3 describes how a dynamically 
allocated array objectisfreed.) 

D.7.1.2 Member functions [depr.strstreambuf.members] 
void freeze ( bool freezefl = true ); 

1 Effects: If strmode &dynamic is non-zero, alters the freeze status of the dynamic array object as follows: 

— If freezefl is true, the function sets frozen in strmode . 
— Otherwise, it clears frozen in strmode. 
char * str (); 

2 Effects: Calls freeze(), then returns the beginning pointer for the input sequence, gbeg . 
3 Remarks: The return value can be a nullpointer. 

int pcount () const ; 

4 Effects: If the next pointer for the output sequence, pnext , is a null pointer, returns zero. Otherwise, returns the 
current effective length of the array object as the next pointer minus the beginning pointer for the output sequence, 
pnext -pbeg . 

D.7.1.3 strstreambuf overridden virtual functions [depr.strstreambuf.virtuals] 
int _type overflow ( int_type c = EOF ); 

1 Effects: Appends the character designatedby c to the output sequence, if possible, in one of two ways: 

— If c != EOF andif eitherthe output sequencehasa writepositionavailableorthefunctionmakesa write 
position available (as describedbelow), assigns c to *pnext ++. 
2 Returns (unsigned char)c . 

— If c == EOF, there is no character to append. 
3 Returns a value other than EOF. 

4 Returns EOF to indicatefailure. 

5 Remarks: The function can alter the number of write positions available as a result of anycall. 

6 To make a write position available, the function reallocates (or initially allocates) an array object with a sufficient 
number of elements n to hold the current array object (if any), plus at least one additional write position. How 
manyadditional write positions are made available is otherwise unspecified.327) If palloc is not a null pointer, 
the function calls (*palloc )(n ) to allocatethenewdynamic arrayobject. Otherwise,itevaluatestheexpression 
new charT[n ]. In either case, if the allocationfails, the function returns EOF. Otherwise, it sets allocated in 
strmode . 

327) An implementation should consider alsize in making this decision. 

Draft 


D.7 char* streams Compatibility features 824 
7 To freeapreviouslyexisting dynamic array object whose first elementaddressisp : Ifpfree is nota null pointer, 
the function calls (*pfree )(p ). Otherwise, it evaluates the expression delete[] p . 

8 If strmode & dynamic == 0, or if strmode & frozen != 0, the function cannot extend the array (reallocate it with greater length) to make a write position available. 

int _type pbackfail ( int_type c = EOF ); 

9 Puts back the character designated by c to the input sequence, if possible, in one of three ways: 

— If c != EOF, if the input sequence has a putback position available, and if (char)c == gnext [-1], 
assigns gnext -1 to gnext . 
10 Returns c . 

— If c != EOF, if the input sequence has a putback position available, and if strmode &constant is zero, 
assigns c to *-gnext . 
11 Returns c . 

— If c == EOF and if the input sequence has a putback position available, assigns gnext -1 to gnext . 
12 Returns a value other than EOF. 
13 Returns EOF to indicatefailure. 

14 Remarks: If the function can succeed in more than one of these ways, it is unspecified which way is chosen. The 
function can alter the number of putback positions available as a result of anycall. 

int _type underflow (); 

15 Effects: Reads a character from the input sequence, if possible, without moving the stream position past it, as 
follows: 

— If the input sequence has a read position available, the function signals success by returning (unsigned 
char)*gnext . 
— Otherwise, if the current write next pointer pnext isnotanull pointerandisgreaterthanthe currentread 
end pointer gend , makes a read position available by assigning to gend a value greater than gnext and no 
greater than pnext . 
16 Returns (unsigned char*)gnext . 

17 Returns EOF to indicatefailure.
18 Remarks: The function can alter the number of read positions available as a result of anycall.


pos _type seekoff ( off_type off , seekdir way , openmode which = in | out); 

19 Effects: Alters the stream positionwithin oneof the controlled sequences,if possible, as indicatedinTable 107. 
20 Fora sequencetobe positioned,ifitsnext pointerisanull pointer,the positioning operationfails. Otherwise,the 
function determines newoff as indicatedinTable 108. 
21 Otherwise, the function assigns xbeg +newoff +off to the next pointer xnext . 

Draft 


825 Compatibility features D.7 char* streams 

Table 107:seekoff positioning 

Conditions Result 
(which & ios::in) != 0 positions the input sequence 
(which & ios::out) != 0 positions the output sequence 
(which & (ios::in | 
ios::out)) == (ios::in | 
ios::out)) and 
way == either 
ios::beg or 
ios::end 
positions both the input and the output sequences 
Otherwise the positioning operation fails. 

Table 108:newoff values 

Condition newoff Value 
way == ios::beg 0 
way == ios::cur the next pointer minus the beginning 
pointer (xnext -xbeg). 
way == ios::end seekhigh minus the beginning 
pointer (seekhigh -xbeg). 
If (newoff + off) < 
(seeklow -xbeg), 
or (seekhigh -xbeg) < 
(newoff + off) 
the positioning operation fails 

Draft 


D.7 char* streams Compatibility features 826 
22 Returns: pos_type(newoff ), constructed from the resultant offset newoff (of type off_type), that stores the 
resultant streamposition,if possible.Ifthe positioning operationfails,orifthe constructedobject cannot represent 
the resultant stream position, the return value is pos_type(off_type(-1)). 

pos _type seekpos ( pos_type sp , ios _base :: openmode which
= ios_base :: in | ios _base :: out );


23 Effects: Alters the stream position within one of the controlled sequences, if possible, to correspond to the stream 
position stored in sp (as described below). 

— If (which & ios::in) != 0, positions the input sequence. 
— If (which & ios::out) != 0, positions the output sequence. 
— If the function positions neither sequence, the positioning operationfails. 
24 Forasequencetobe positioned,ifitsnextpointerisanullpointer,the positioning operationfails. Otherwise, 
the function determines newoff from sp .offset(): 

— If newoff is an invalid stream position, has a negative value, or has a value greater than(seekhigh 
seeklow ), the positioning operationfails 
— Otherwise, the function adds newoff to the beginning pointer xbeg and stores the result in the next pointer 
xnext . 
25 Returns: pos_type(newoff ), constructed from the resultant offset newoff (of type off_type), that stores the 
resultant streamposition,if possible.Ifthe positioning operationfails,orifthe constructedobject cannot represent 
the resultant stream position, the return value is pos_type(off_type(-1)). 

streambuf < char >* setbuf ( char * s , streamsize n ); 

26 Effects: Implementation defined, except that setbuf(0, 0) has no effect. 

D.7.2 Class istrstream [depr.istrstream] 
namespace std {
class istrstream : public basic_istream <char > {
public :


explicit istrstream(const char* s );
explicit istrstream(char* s );
istrstream(const char* s , streamsize n );
istrstream ( char * s , streamsize n );
virtual ~istrstream();


strstreambuf* rdbuf() const;
char * str ();
private :


// strstreambuf sb; exposition only 

};
}


Draft 


827 Compatibility features D.7 char* streams 

1 The class istrstream supports the reading of objects of class strstreambuf. It supplies a strstreambuf object to 
control the associated array object.For the sakeofexposition, the maintained datais presented here as: 

— sb , the strstreambuf object. 
D.7.2.1 istrstream constructors [depr.istrstream.cons] 
explicit istrstream ( const char * s );
explicit istrstream ( char * s );


1 Effects: Constructs an object of class istrstream,initializing the base class withistream(&sb ) and initializing 
sb with strstreambuf(s ,0)). s shall designate the first elementof an NTBS. 

istrstream ( const char * s , streamsize n ); 

2 Effects: Constructs an object of class istrstream,initializing the base class withistream(&sb ) and initializing 
sb with strstreambuf(s ,n )). s shall designate the first element of an array whose length is n elements, and 
n shall be greater than zero. 

D.7.2.2 Member functions [depr.istrstream.members] 
strstreambuf* rdbuf() const; 

1 Returns: const_cast<strstreambuf*>(&sb ). 

char * str (); 

2 Returns: rdbuf()->str(). 

D.7.3 Class ostrstream [depr.ostrstream] 
namespace std {
class ostrstream : public basic_ostream <char > {
public :


ostrstream (); 
ostrstream ( char * s , int n , ios_base :: openmode mode = ios_base :: out ); 
virtual ~ostrstream(); 
strstreambuf* rdbuf() const;
void freeze ( bool freezefl = true );
char * str ();
int pcount () const ;


private : 

// strstreambuf sb; exposition only 

};
}


1 The class ostrstream supports the writing of objects of class strstreambuf. It supplies a strstreambuf object to 
control the associated array object.For the sakeofexposition, the maintained datais presented here as: 

Draft 


D.7 char* streams Compatibility features 828 
— sb , the strstreambuf object. 
D.7.3.1 ostrstream constructors [depr.ostrstream.cons] 
ostrstream (); 
1 Effects: Constructs an object of class ostrstream,initializing the base class withostream(&sb ) and initializing 
sb with strstreambuf()). 

ostrstream ( char * s , int n , ios_ base :: openmode mode = ios_base :: out ); 
2 Effects: Constructs an object of class ostrstream,initializing the base class withostream(&sb ),and initializing 
sb with one of two constructors: 

— If (mode & app) == 0, then s shall designate the first element of an array of n elements. 
The constructor is strstreambuf(s , n , s ). 
— If (mode & app) != 0, then s shall designate the first element of an array of n elements that contains an NTBS whose first element is designated by s . The constructor is strstreambuf(s , n , s + 
std::strlen(s )).328) 
D.7.3.2 Member functions [depr.ostrstream.members] 
strstreambuf* rdbuf() const; 

1 Returns: (strstreambuf*)&sb . 
void freeze ( bool freezefl = true ); 
2 Effects: Calls rdbuf()->freeze(freezefl ). 

char * str (); 

3 Returns: rdbuf()->str(). 

int pcount () const ; 

4 Returns: rdbuf()->pcount(). 

D.7.4 Class strstream [depr.strstream] 
namespace std {
class strstream
: public basic_iostream <char > {
public :


// Types 

typedef char char_type ;
typedef typename char_traits < char >:: int_type int_type ;


328) The function signature strlen(const char*) is declared in <cstring> (21.4). 

Draft 


829 Compatibility features D.7 char* streams 

typedef typename char_traits < char >:: pos_type pos_type ;
typedef typename char_traits < char >:: off_type off_type ;


// constructors/destructor 

strstream (); 
strstream(char* s, int n, 
ios_base::openmode mode = ios_base::in|ios_ base::out); 
virtual ~ strstream (); 

// Members: 

strstreambuf* rdbuf() const;
void freeze ( bool freezefl = true );
int pcount () const ;
char * str ();


private : 

// strstreambuf sb; exposition only 

};
}


1 The class strstream supports reading and writing from objects of classs strstreambuf. It suppliesa strstreambuf 
objectto controlthe associatedarrayobject.Forthesakeofexposition,the maintaineddatais presentedhereas 

— sb , the strstreambuf object. 
D.7.4.1 strstream constructors [depr.strstream.cons] 
strstream (); 

1 Effects: Constructs an object of class strstream, initializing the base class with iostream(&sb ). 

strstream(char* s, int n,
ios_base::openmode mode = ios _base::in|ios_base::out);


2 Effects: Constructs an object of class strstream,initializing the base class withiostream(&sb ) and initializing 
sb with one of the two constructors: 

— If (mode & app) == 0, then s shall designate the first element of an array of n elements. The constructor 
is strstreambuf(s ,n ,s ). 
— If (mode & app) != 0, then s shall designate the first element of an array of n elements that contains an NTBS whose first element is designated by s . The constructor is strstreambuf(s ,n ,s + 
std::strlen(s )). 
D.7.4.2 strstream destructor [depr.strstream.dest] 
virtual ~ strstream () 

1 Effects: Destroys an object of class strstream. 

Draft 


D.7 char* streams Compatibility features 830 
2 
s t r s t r e a m b u f * r d b u f ( ) 
Returns: &sb. 
c o n s t ; 
1 
2 
3 
D.7.4.3 strstream operations 
v o i d f r e e z e ( b o o l f r e e z e f l = t r u e ) ; 
Effects: Calls rdbuf()->freeze(freezefl). 
c h a r * s t r ( ) ; 
Returns: rdbuf()->str(). 
i n t p c o u n t ( ) c o n s t ; 
Returns: rdbuf()->pcount(). 
[depr.strstream.oper] 

Draft 


AppendixE 
(normative) 
Universal-character-names [extendid] 

1 Thisclauseliststhecompletesetofhexadecimalcodevaluesthatarevalidinuniversal-character-namesinC++ identifiers(2.10). 

2 This table is reproduced unchanged from ISO/IEC PDTR 10176, produced by ISO/IEC JTC1/SC22/WG20, except that 
the ranges 0041–005a and 0061–007a designate the upper and lower case English alphabets, which are part of the basic 
source character set, and are not repeated in the table below. 

Latin: 00c0–00d6, 00d8–00f6, 00f8–01f5, 01fa–0217, 0250–02a8, 1e00–1e9a, 1ea0–1ef9
Greek: 0384, 0388–038a, 038c, 038e–03a1, 03a3–03ce, 03d0–03d6, 03da, 03dc, 03de, 03e0, 03e2–03f3, 1f00–1f15,


1f18–1f1d, 1f20–1f45, 1f48–1f4d, 1f50–1f57, 1f59, 1f5b, 1f5d, 1f5f–1f7d, 1f80–1fb4, 1fb6–1fbc, 1fc2–1fc4, 1fc6–
1fcc, 1fd0–1fd3, 1fd6–1fdb, 1fe0–1fec, 1ff2–1ff4, 1ff6–1ffc
Cyrillic: 0401–040d, 040f–044f, 0451–045c, 045e–0481, 0490–04c4, 04c7–04c8, 04cb–04cc, 04d0–04eb, 04ee–04f5,


04f8–04f9
Armenian: 0531–0556, 0561–0587
Hebrew: 05d0–05ea, 05f0–05f4
Arabic: 0621–063a, 0640–0652,0670–06b7, 06ba–06be, 06c0–06ce, 06e5–06e7
Devanagari: 0905–0939, 0958–0962
Bengali: 0985–098c, 098f–0990, 0993–09a8, 09aa–09b0, 09b2, 09b6–09b9, 09dc–09dd, 09df–09e1, 09f0–09f1
Gurmukhi: 0a05–0a0a, 0a0f–0a10, 0a13–0a28, 0a2a–0a30, 0a32–0a33, 0a35–0a36, 0a38–0a39, 0a59–0a5c, 0a5e
Gujarati: 0a85–0a8b, 0a8d, 0a8f–0a91, 0a93–0aa8, 0aaa–0ab0, 0ab2–0ab3, 0ab5–0ab9, 0ae0
Oriya: 0b05–0b0c, 0b0f–0b10, 0b13–0b28, 0b2a–0b30, 0b32–0b33, 0b36–0b39, 0b5c–0b5d, 0b5f–0b61
Tamil: 0b85–0b8a, 0b8e–0b90, 0b92–0b95, 0b99–0b9a, 0b9c, 0b9e–0b9f, 0ba3–0ba4, 0ba8–0baa, 0bae–0bb5, 0bb7–


0bb9
Telugu: 0c05–0c0c, 0c0e–0c10, 0c12–0c28, 0c2a–0c33, 0c35–0c39, 0c60–0c61
Kannada: 0c85–0c8c, 0c8e–0c90, 0c92–0ca8, 0caa–0cb3, 0cb5–0cb9, 0ce0–0ce1



Universal-character-names 832 

Malayalam: 0d05–0d0c, 0d0e–0d10, 0d12–0d28, 0d2a–0d39, 0d60–0d61 
Thai: 0e01–0e30, 0e32–0e33, 0e40–0e46, 0e4f–0e5b 
Lao: 0e81–0e82, 0e84, 0e87, 0e88, 0e8a, 0e8d, 0e94–0e97, 0e99–0e9f, 0ea1–0ea3, 0ea5, 0ea7, 0eaa, 0eab, 0ead–0eb0, 

0eb2, 0eb3, 0ebd, 0ec0–0ec4, 0ec6 
Georgian: 10a0–10c5, 10d0–10f6 
Hiragana: 3041–3094, 309b–309e 
Katakana: 30a1–30fe 
Bopmofo: 3105–312c 
Hangul: 1100–1159, 1161–11a2,11a8–11f9 
CJK Unified Ideographs: f900–fa2d, fb1f–fb36, fb38–fb3c, fb3e, fb40–fb41, fb42–fb44, fb46–fbb1, fbd3–fd3f, fd50– 

fd8f, fd92–fdc7, fdf0–fdfb, fe70–fe72, fe74, fe76–fefc,ff21–ff3a,ff41–ff5a,ff66–ffbe,ffc2–ffc7,ffca–ffcf,ffd2–ffd7, 

ffda–ffdc, 4e00–9fa5 

Draft 


Index 

!, see logical negation operator 
!=, see inequality operator 
(), see function call operator 

function declarator, 158 
*, see indirection operator, see multiplication operator 

pointer declarator, 153 
+, see unary plus operator, see addition operator 
++, see increment operator 
,, see comma operator 
-, see unary minus operator, see subtraction operator 
->, see class member access operator 
->*, see pointer to member operator 
-, see decrement operator 
., see class member access operator 
.*, see pointer to member operator 
..., see ellipsis 
/, see division operator 
: 

field declaration, 187 

label specifier, 107 
::, see scope resolution operator 
::* 

pointer to member declarator, 156 
<, see less than operator 

template and, 279, 280 
<<, see left shift operator 
<=, see less than or equal to operator 
=, see assignment operator 
==, see equality operator 
>, see greater than operator 
>=, see greater than or equal operator 
>>, see right shift operator 
?:, see conditional expression operator 
[], see subscripting operator 

array declarator, 156 
#define, 362 
#elif, 359 

#else, 360 
#endif, 360 
#error, 367 
#if, 359, 387 
#ifdef, 360 
#ifndef, 360 
#include, 360, 382 
#line, 367 
#pragma, 367 
#undef, 364, 383 
%, see modulus operator 
&, see address-of operator, see bitwise AND operator 

reference declarator, 154 
&&, see logical AND operator 
^, see bitwise exclusive OR operator 
## operator, 363 
# operator, 363 
basic_ios::failure argument 

implementation-defined, 721 
const object 
undefined change to, 125 
exception::what message 
implementation-defined, 409 
friend function 

nested class, 189 
delete, 91, 95 
new, 91 
operator bool 

basic_ios, 720 
\, see backslash 
_ _cplusplus, 368 
__DATE _ _, 368 
__FILE _ _, 368 
__LINE _ _, 368 
_ _ STDC_HOSTED _ _, 368 

implementation-defined, 368 
_ _ STDC_ISO_10646 _ _, 368 


INDEX INDEX 834 

implementation-defined, 368 
_ _ STDC_VERSION _ _, 368 
implementation-defined, 368 
__STDC _ _, 368 

implementation-defined, 368 
__TIME _ _, 368 
{} 

block statement, 107
class declaration, 175
class definition, 175
enum declaration, 128
initializer list, 168


, see one’s complement operator, see destructor 
Init 
ios_base::Init, 712 
auto_ptr 
auto_ptr, 443 
basic_filebuf 
basic_filebuf, 770 
basic_iostream 
basic_iostream, 748 
basic_ostream 
basic_ostream, 750 
ctype<char> 
ctype<char>, 500 
exception 
exception, 409 
locale 
locale, 492 

sentry 
basic_istream, 738 
basic_ostream, 751 

strstream 
strstream, 829 
strstreambuf 
strstreambuf, 822 
valarray 

valarray, 678 
_, see character, underscore 
|, 101 

0, see also zero, null 
null character, 23 
string terminator, 23 

abort, 53, 112, 382, 399, 405, 410 

abs, 684, 698 

complex, 671 
abstract-declarator, 150, 792 
access 

struct default member, 175 
union default member, 175 
adjusting base class member, 210 
base class, 208 
base class member, 191 
class member, 79 
member name, 205 
overloading and, 248 
virtual function, 216 

access-specifier, 191, 794 

access control, 205 
anonymous union, 186 
member function and, 219 
overloading resolution and, 195 

access specifier, 207, 208 
accumulate, 695 
acos, 684, 698 
addition operator, 97, 787 
additive-expression, 97, 787 
address, 64, 100 
address of member function 

unspecified, 387 
adjacent_difference, 696 
adjacent_find, 638 
advance, 608 
aggregate, 168 
algorithm 

stable, 373
<algorithm>, 627
alias, 134
alignment requirement


implementation-defined, 61 

allocation 
alignment storage, 92 
implementation defined bit-field, 187 
unspecified, 179, 207 

allocator, 437
always_noconv
codecvt, 504


ambiguity 
base class member, 194 
class conversion, 197 

Draft 


835 INDEX INDEX 

declaration type, 119
declaration versus cast, 151
declaration versus expression, 114
function declaration, 166
member access, 194
parentheses and, 91


ambiguity detection 
overloaded function, 249 
Amendment 1, 384 

any 
bitset, 595 
append 
basic_string, 464 
apply 
valarray, 682 
arg 

complex, 671 
argc, 51 
argument, 2, 386, 387, 417 

access checking and default, 206
binding of default, 162
evaluation of default, 162, 163
example of default, 161, 162
overloaded operator and default, 268
reference, 78
scope of default, 163
template, 281
type checking of default, 162


arguments 
implementation-defined orderofevaluationof function, 163 
argument and name hiding 
default, 163 
argument and virtual function 
default, 164 

argument list 
empty, 158 
variable, 158 

argument passing, 78 

reference and, 172 
argument substitution, 362 
argument type 

unknown, 158 
argv, 51 
arithmetic 

pointer, 97, 98 

Draft 

unsigned, 62 

array, 159 
bound, 157 
const, 64 
delete, 94 
multidimensional, 157 
new, 91 
overloading and pointer versus, 246 
sizeof, 90 
storage of, 158 

array size 

default, 157 
arrow operator, see class member access operator 
asin, 684, 698 
asm 

implementation-defined, 144 
assembler, 144 
<assert.h>, 382 
assign 

basic_string, 465
deque, 554
list, 559
vector, 569


assignment 
and lvalue, 103 
conversion by, 104 
reference, 172 

assignment-expression, 103, 788 
assignment-operator, 103, 788 
assignment operator 

copy, 242
overloaded, 268


at 
basic_string, 463 
map, 579 

atan, 684, 698 
atan2, 684, 698 
atexit, 53, 382, 400 
auto, 119 

destruction of, 112, 113 
auto_ptr, 441 
auto_ptr, 442 

back_insert_iterator, 615 
back_insert_iterator, 615 
back_inserter, 616 


INDEX INDEX 836 

backslash character, 21 

bad 

basic_ios, 721 
bad_alloc, 92, 401, 405 
bad_alloc, 405 

bad_alloc::what 

implementation-defined, 405 
bad_cast, 82, 407 
bad_cast, 407 
bad_cast::what 

implementation-defined, 407 
bad_exception, 354, 409 

bad_exception, 409 
bad_exception::what 

implementation-defined, 410 
bad_typeid, 83, 407 

bad_typeid, 407, 408 
bad_typeid::what 

implementation-defined, 408 
base-specifier, 191, 794 
base-specifier-list, 191, 794 
base class, 191, 192 

direct, 191 

indirect, 191 

private, 208 

protected, 208 

public, 208 
base class virtual, see virtual base class 
basic_filebuf, 701, 769 

basic_filebuf, 770 
basic_filebuf<char>, 768 
basic_filebuf<wchar_t>, 768 
basic_fstream, 701, 777 

basic_fstream, 778 
basic_ifstream, 701, 774 

basic_ifstream, 775 
basic_ifstream<char>, 768 
basic_ifstream<wchar_t>, 768 
basic_ios, 701, 717 

basic_ios, 718 
basic_ios<char>, 707 
basic_ios<wchar_t>, 707 
basic_iostream, 747 

basic_iostream, 747 
basic_istream, 701, 735 

basic_istream, 737 

basic_istream<char>, 734 
basic_istream<wchar_t>, 734 
basic_istreambuf_iterator, 701 
basic_istringstream, 701, 764 
basic_istringstream, 764 
basic_istringstream<char>, 759 
basic_istringstream<wchar_t>, 759 
basic_ofstream, 701, 776 
basic_ofstream, 776 
basic_ofstream<char>, 768 
basic_ofstream<wchar_t>, 768 
basic_ostream, 701 
basic_ostream, 750 
basic_ostream<char>, 735 
basic_ostream<wchar_t>, 735 
basic_ostreambuf_iterator, 701 
basic_ostringstream, 701, 765 
basic_ostringstream, 766 
basic_ostringstream<char>, 759 
basic_ostringstream<wchar_t>, 759 
basic_streambuf, 701, 725 
basic_streambuf, 727 
basic_streambuf<char>, 724 
basic_streambuf<wchar_t>, 724 
basic_string, 454, 475, 759 
basic_string, 459 
basic_stringbuf, 701, 759 
basic_stringbuf, 760 
basic_stringbuf<char>, 759 
basic_stringbuf<wchar_t>, 759 
basic_stringstream, 701, 766 
basic_stringstream, 767 
before 
type_info, 406 
begin 
basic_string, 462 
behavior 
conditionally-supported,2,4 
default, 372, 376 
implementation-defined,2, 524 
locale-specific,2 
required, 373, 376 
undefined,3 
unspecified,3 
Ben, 248 
bidirectional_iterator_tag, 607 

Draft 


837 INDEX INDEX 

binary_function, 429 basic_string, 470 
binary_negate, 432 call, see also function call, member function call, over-
binary_search, 652 loaded function call, virtual function call 
binary operator operator function, 267 
interpretation of, 268 pseudo destructor, 79 
overloaded, 268 calloc, 444, 815 
bind1st, 433 capacity 
bind2nd, 433 basic_string, 463 
binder1st, 432 vector, 570 
binder2nd, 433 <cassert>, 382 
binding cast 
reference, 172 base class, 84 
bit-field, 187 const, 86 
address of, 187 derived class, 84 
alignment of, 187 dynamic, 81, 407 
implementation-defined sign of, 187 integer to pointer, 85 
implementation defined alignment of, 187 lvalue, 83, 85 
type of, 187 pointer to function, 85 
unnamed, 187 pointer to integer, 85 
zero width of, 187 pointer to member, 85, 86 
<bitset>, 589 reference, 83, 86 
bitset, 589 reinterpret, 85 
bitset, 591 reinterpret_cast 
block lvalue, 85 
initialization in, 113 reference, 86 
block scope; see local scope, 31 static, 83 
block structure, 113 static_cast 
body lvalue, 83 
function, 164 reference, 83 
bool() undefined pointer to function, 85 
basic_istream operator, 739 cast-expression, 95, 787 
basic_ostream operator, 751 casting, 79, 95 
boolalpha, 722 catch, 345, 796 
Boolean, 187 category 
Boolean literal, 23 locale, 488 
boolean-literal, 23, 785 ceil, 698 
Boolean type, 62 cerr, 705 
bound, of array, 157 <cerrno>, 384 
built-in type; see fundamental type,62 char 
byte, 89 implementation-defined sign of, 62 
character, 371 
decimal-point, 378 
linkage to, 145 multibyte,2 
c-char, 19, 784 set 
c-char-sequence,19, 784 basicexecution, 5 
c_str basic source, 12 

Draft 


INDEX INDEX 838 

signed, 62 
underscore, 383, 384 
in identifier, 17 
character-literal, 19, 784 
character string, 22 
checking 
point of error, 303 
syntax, 303 
cin, 705 
<ciso646>, 814 
class, 63, 175 
abstract, 202 
base, 384, 388 
cast to incomplete, 96 
constructor and abstract, 203 
definition, 27 
derived, 388 
linkage of, 49 
linkage specification, 146 
pointer to abstract, 203 
polymorphic, 198 
scope of enumerator, 130 
template, 591 
unnamed, 123 
class-key, 175, 793 
class-name, 175, 793 
class-specifier, 175, 793 
classes 
narrow-oriented iostream, 372 
wide-oriented iostream, 373 

classic 
locale, 493 
classic_table 
ctype<char>, 502 
class base, see base class 
class derived, see derived class 
class local, see local class 
class member, see also member 
class name, 150 
elaborated, 127, 177 
point of declaration, 178 
scope of, 176 
typedef, 123, 178 
class nested, see nested class 
class object 
assignment to, 104 

const, 64 
member, 179 
operations on, 175 
sizeof, 89 
class object copy, see also copyconstructor 
class object initialization, see also constructor 

clear 
basic_ios, 721 
basic_string, 463 
<climits>, 822 
<clocale>, 814 
<clocale>, 378 
clog, 705 
close 
basic_filebuf, 771, 778 
basic_ifstream, 776 
basic_ofstream, 777 
messages, 532 
codecvt, 502 
codecvt_byname, 506 
collate, 518 
collate_byname, 519 
combine 
locale, 492 
comment, 14 
/* */, 15 
//, 15 
compare 
basic_string, 474 
collate, 519 
comparison 
pointer, 100 
pointer to function, 100 
undefined pointer, 98, 100 
unspecified pointer, 100 
void* pointer, 99 
compilation 
separate, 11 
compiler control line, see preprocessing directive 
completely defined, 178 
<complex>, 664 
complex, 666 
complex, 668 
component, 372 
compound-statement, 108, 788 
concatenation 

Draft 


839 INDEX INDEX 

string, 23 
undefined string literal, 23 
condition, 108, 789 
conditions 
rules for, 108 
conditional-expression 
throw-expression in, 102 

conj 
complex, 671 
consistency 
linkage, 120 
linkage specification, 146 
type declaration, 51 
const, 64 
constructor and, 184, 220 
destructor and, 184, 226 
linkage of, 48, 120 
overloading and, 247 
const_mem_fun1_ref_t, 436 
const_mem_fun1_t, 436 
const_mem_fun_ref_t, 436 
const_mem_fun_t, 435 
constant, 18, 75 
enumeration, 128 
null pointer, 71 
constant-expression, 104, 788 
constant-initializer, 178, 794 
constructor, 219 
address of, 220 
array of class objects and, 232 
conversion by, 224 
copy, 220, 222, 239, 380 
exception handling, 348 
inheritance of, 220 
non-trivial, 220 
type of, 220 
union, 186 
unspecified argument to, 94 
constructor call 
explicit, 220 
constructor conversionby, see also user-defined conversion 
constructor default, see default constructor 
context 
non-deduced, 338 
control line, see preprocessing directive 

convention, 376 
conversion 
argument, 158 
array pointer, 68 
array-to-pointer, 68 
Boolean, 72 
class, 223 
derived-to-base, 260 
floating point, 70 
floating-integral, 71 
function-to-pointer, 68 
implementation-defined floating point, 70 
implementation defined pointer integer, 85 
implicit, 67, 223 
implicit user-defined, 223 
inheritance of user-defined, 226 
integer, 70 
lvalue-to-rvalue, 68, 804 
overload resolution and, 257 
overload resolution and pointer, 266 
pointer, 71 
pointer to function, 68 
pointer to member, 71 
void*, 72 
return type, 113 
reverse_iterator, 611 
signed unsigned integer, 70 
standard, 67 
static user-defined, 226 
type of, 225 
user-defined, 223–225 
virtual user-defined, 226 
conversion operator, see conversion function 
conversion rank, 261 
conversion-function-id, 225, 794 
conversions 
qualification, 68 
usual arithmetic, 74 
conversion explicit type, see casting 
conversion function, see also user-defined conversion 
copy 
class object, 239 
copy, 640 
basic_string, 469 
copy_backward, 641 
copyfmt 

Draft 


INDEX INDEX 840 

basic_ios, 720 
copyassignment operator 
implicitly-declared, 242 
copyconstructor 
implicitly-declared, 240 
cos, 684, 698 
complex, 671 
cosh, 684, 698 
complex, 671 
count, 638 
bitset, 594 
count_if, 638 
cout, 705 
<csetjmp>, 384 
cshift 
valarray, 681 
<cstdarg>, 159 
<cstdarg>, 384 
<cstddef>, 90, 98, 814, 815 
<cstdio>, 705, 706, 768, 770, 814 
<cstdio>, 771 
<cstdlib>, 51, 53, 382, 814, 818 
<cstring>, 379, 814 
<cstring>, 379, 822, 828 
<ctime>, 814 
<ctime>, 486 
ctor-initializer, 232, 794 
ctype, 495 
ctype<char> 
ctype<char>, 500 
ctype_byname, 499 
cv-qualifier, 64 
cv-qualifier, 150, 792 
<cwchar>, 379, 384, 814 
<cwctype>, 384 

DAG 
multiple inheritance, 193, 194 
non-virtual base class, 194 
virtual base class, 193, 194 

data 
basic_string, 470 
vector, 571 
data member, see member 
static, 184 
date_order 

time_get, 521
deallocation, see delete
dec, 723
dec, 753
decimal-literal, 18, 783


decimal_point 

numpunct, 517 

decl-specifier, 118, 790 

declaration, 25, 117 

extern reference, 172 

typedef as type, 122 

access, 210 

array, 157 

asm, 144 

bit-field, 187 

class member, 178, 794 

class name, 26 

constant pointer, 153 

default argument, 161 

definition versus, 25 

ellipsis in function, 78, 158 

enumerator point of, 30 

extern, 25 

forward, 121 

forward class, 177 

function, 25, 158 

member, 178 

multiple, 51 

name, 25 

overloaded, 245 

overloaded name and friend, 213 

parameter, 158 

parentheses in, 151, 153 

pointer, 153 

reference, 155 

register, 119 

static member, 26 

storage class, 119 

type, 152 

typedef, 26 

declaration, 117, 789 

declaration-statement, 113, 789 

declaration hiding, see name hiding 

declaration matching 

overloaded function, 248 

declarator, 118, 149 

Draft 


841 INDEX INDEX 

meaning of, 152 
multidimensional array, 157 
declarator, 149, 792 
declarator-id, 150, 792 
decrement operator 
overloaded, 269 
default 
access control, 205 
default-initialization, 166 
default argument 
overload resolution and, 257 
default constructor, 220 
default initializers 
overloading and, 247 
definition, 25, 371 
static member, 185 
altermate, 384 
class, 175, 178 
class name as type, 176 
constructor, 165 
declaration as, 118 
empty class, 175 
enumerator point of, 128 
function, 164 
local class, 189 
member function, 180 
namespace, 130 
nested class, 188 
pure virtual function, 202 
scope of class, 176 
virtual function, 200 
delete, 54, 94, 229 
operator, 444 
destructor and, 94, 227 
operator, 385, 402, 403 
overloading and, 56 
type of, 229 
undefined, 94 
delete-expression, 94, 787 
deprecated features, 81, 89 
<deque>, 549 
deque, 551 
dereferencing, see also indirection 
derivation, see inheritance 
derived class, 191 
most,6 

overloading and, 248 
derived object 
most,6 
destructor, 226, 380 
default, 226 
exception handling, 348 
non-trivial, 226 
program termination and, 227 
pure virtual, 227 
union, 186 
virtual, 227 
destructor call 
explicit, 227 
implicit, 227 
digit, 16, 783 
digit-sequence, 22, 784 
digraph, 15 
direct-abstract-declarator, 150, 792 
direct-declarator, 149, 792 
direct-new-declarator, 90, 787 
directed acyclic graph, see DAG 
directive 
error, 367 
null, 368 
pragma, 367 
preprocessing, 357 
distance, 608 
div, 698 
divides, 430 
division 
implementation defined, 97 

do_always_noconv 
codecvt, 506 
do_close 
messages, 533 
do_compare 
collate, 519 
do_curr_symbol 
moneypunct, 531 
do_date_order 
time_get, 521 
do_decimal_point 
moneypunct, 530 
numpunct, 517 
do_encoding 
codecvt, 505 

Draft 


INDEX INDEX 842 

do_falsename 
numpunct, 517 
do_frac_digits 
moneypunct, 531 

do_get 
messages, 532, 533 
money_get, 526 
num_get, 508 

do_get_date 
time_get, 522 
do_get_monthname 
time_get, 522 
do_get_time 
time_get, 522 
do_get_weekday 
time_get, 522 
do_get_year 
time_get, 522 

do_grouping 
moneypunct, 530 
numpunct, 517 

do_hash 
collate, 519 
do_in 
codecvt, 504 
do_is 
ctype, 497 
do_length 
codecvt, 506 
do_max_length 
codecvt, 506 
do_narrow, 501 
ctype, 498 
do_neg_format 
moneypunct, 531 
do_negative_sign 
moneypunct, 531 
do_open 
messages, 532 
do_out 
codecvt, 504 
do_pos_format 
moneypunct, 531 
do_positive_sign 
moneypunct, 531 
do_put 

money_put, 528
num_put, 512
time_put, 524


do_scan_is
ctype, 497
do_scan_not
ctype, 497


do_thousands_sep
moneypunct, 530
numpunct, 517


do_tolower
ctype, 498
do_toupper
ctype, 498
do_transform
collate, 519
do_truename
numpunct, 517
do_unshift
codecvt, 505
do_widen, 501
ctype, 498
domain_error, 416
domain_error, 416
dominance


virtual base class, 196 
dot operator, see class member access operator 
dynamic binding, see virtual function 

eback
basic_streambuf, 729
egptr


basic_streambuf, 730 
elaborated-type-specifier, 127, 791 
elaborated type specifier, see elaborated class name 
elision 

copyconstructor, 244
ellipsis


overload resolution and, 257
else, 108, 789
empty, 607


basic_string, 463
encoding
multibyte, 23


encoding
codecvt, 504


Draft 


843 INDEX INDEX 

end 
basic_string, 462 
end-of-file, 596 
endl, 756 
endl, 753 
ends, 756 
entity, 25 
enum, 63 
overloading and, 246 
type of, 128, 129 
enumeration, 128 
linkage of, 49 
enumeration type 
conversion to, 84 

static_cast 

conversion to, 84 
enumerator 
definition, 27 
value of, 128 
enumerator, 128, 791 
enum name 
typedef, 123 
environment 
program, 51 

eof 
basic_ios, 721 
epptr 
basic_streambuf, 730 
eq 
char_traits, 470–473 
equal, 639 
istreambuf_iterator, 625 
equal_range, 652 
equal_to, 430 
equality-expression, 100, 787 
equivalence 
template type, 286 
type, 122, 176 
equivalent parameter declarations, 246 
overloading and, 246 

erase 
basic_string, 467 
deque, 555 
list, 559 
vector, 571 
escape-sequence, 20, 784 

escape character, see backslash 
escape sequence 
undefined, 21 
evaluation 
order of argument, 79 
unspecified order of, 52, 73 
unspecified order of argument, 79 
unspecified order of function call, 79 
example 
*const, 153 
static member, 185 
array, 157 
class definition, 179 
const, 153 
constant pointer, 153 
constructor, 220 
constructor and initialization, 231 
declaration, 26, 160 
declarator, 150 
definition, 26 
delete, 229 
derived class, 191 
destructor and delete, 230 
ellipsis, 158 
enumeration, 129 
explicit destructor call, 228 
explicit qualification, 195 
friend, 177 
friend function, 211 
function declaration, 159 
function definition, 164 
linkage consistency, 120 
local class, 189 
member function, 182, 211 
member name access, 210 
nested type name, 190 
nested class, 188 
nested class definition, 188, 217 
nested class forward declaration, 189 
pointer to member, 156 
pure virtual function, 202 
scope of delete, 230 
scope resolution operator, 195 
subscripting, 157 
typedef, 122 
type name, 150 

Draft 


INDEX INDEX 844 

unnamed parameter, 165 
variable parameter list, 158 
virtual function, 199, 200 
exception 
allowing an, 352 
arithmetic, 73 
handling, 345 
object, 347 
undefined arithmetic, 73 
<exception>, 408 
exception 
exception, 408 
exception-declaration, 345, 796 
exception-specification, 351, 796 

exceptions 
basic_ios, 721 
exit, 51, 53, 112, 382, 400, 405 
exp, 684, 698 
complex, 671 
explanation 
subscripting, 157 
explicit-specialization, 321 
explicit type conversion, see casting 
exponent-part, 22, 784 
export, 275 
expression, 73 
arithmetic constant, 105 
constant, 104 
orderofevaluation of, 8 
parenthesized, 75 
pointer to member constant, 88 
postfix, 76 
primary, 74 
reference, 73 
unary, 88, 786 
expression, 104, 788 
expression-list, 77, 786 
expression-statement, 107, 788 
extern, 119 
linkage of, 120 
extern "C", 382, 384 
extern "C++", 382, 384 

facet 
locale, 489 
fail 

basic_ios, 721 
failed 
ostreambuf_iterator, 626 
failure 
ios_base::failure, 710 
falsename 
numpunct, 517 
fclose, 771 
fclose, 771 
file, 11 
source, 11, 382, 384 
filebuf, 701, 768 
implementation-defined, 774 
fill, 643 
basic_ios, 720 
gslice_array, 690 
indirect_array, 694 
mask_array, 692 
slice_array, 687 
fill_n, 643 
find, 637 
basic_string, 470 
find_end, 637 
find_first_not_of 
basic_string, 472 
find_first_of, 638 
basic_string, 471 
find_if, 637 
find_last_not_of 
basic_string, 473 
find_last_of 
basic_string, 472 
fixed, 724 
flags 
ios_base, 495, 712 
flip 
bitset, 593 
float_round_style, 396 
floating-literal, 21, 784 
floating-suffix, 22, 784 
floating point type, 63 
implementation-defined, 63 
floor, 698 
flush, 712, 738, 751, 756 
basic_ostream, 756 
fmtflags 

Draft 


845 INDEX INDEX 

ios_base, 710 linkage specification overloaded, 146 

ios, 757 modifier, 372 
fopen, 770 observer, 373 
fopen, 770 operator, 267 
for plain old, 413 

scope of declaration in, 112 pointer to member, 97 
for_each, 637 replacement, 373 
formal argument, see parameter reserved, 373 
forward_iterator_tag, 607 viable, 249 
fpos, 707, 716 virtual member, 384, 387 
fractional-constant, 22, 784 function-body, 164, 793 
free, 444 function-definition, 164, 793 
freeze function-specifier, 121, 790 

ostrstream, 828 function-try-block, 345, 796
strstreambuf, 823 <functional>, 427
strstream, 830 functions


free store, see also new, delete candidate, 313 
frexp, 698 function argument, see argument 
friend function call, 78 

virtual and, 200 recursive, 79
access specifier and, 214 undefined, 85
class access and, 212 function call operator
inheritance and, 214 overloaded, 269
local class and, 215 function overloaded, see overloading
template and, 291 function parameter, see parameter


friend function function prototype, 32 
access and, 211 function return, see return 
inline, 214 function return type, see return type 
linkage of, 213 function virtual, see virtual function 
member function and, 211 fundamental type 

front_insert_iterator, 616 destructor and, 228 

front_insert_iterator, 617 fundamental type conversion, see conversion, user-defined 
front_inserter, 617 conversion 
fseek, 770 
<fstream>, 768 gbump 

fstream, 701 basic_streambuf, 730 
full-expression, 7 gcount 
function, see also friend function, member function, in-basic_istream, 742 
line function, virtual function, 159 generate, 643 

allocation, 55, 91 generate_n, 643
comparison, 372 generated destructor, see default destructor
conversion, 225 get


deallocation, 56, 94, 229 auto_ptr, 443
definition, 27 basic_istream, 742
global, 384, 387 money_get, 525
handler, 372 num_get, 508


Draft 


INDEX INDEX 846 

get_date 
time_get, 521 
get_monthname 

time_get, 521 
get_temporary_buffer, 440 
get_time 

time_get, 521 
get_weekday 
time_get, 521 
get_year 
time_get, 521 

getline 
basic_istream, 743, 744 
basic_string, 478 

getloc 
basic_streambuf, 728 
ios_base, 713 

global 
locale, 493 
good 
basic_ios, 721 
goto 

initialization and, 113 

gptr 

basic_streambuf, 729 
grammar, 781 
greater, 430 
greater_equal, 431 
grouping 

numpunct, 517 

gslice 
gslice, 689 
class, 687 

gslice__array, 690 
gslice_array, 689 
gslice_array, 690 

handler 
exception, 349, 388 
incomplete type in exception, 349 

handler, 345, 796 
handler-seq, 345, 796 

has_facet 
locale, 494 
hash 
collate, 519 

header 

C, 382, 384, 387, 817
header-name, 15, 782
headers


C++ , 381
hex, 724
hex-quad, 13, 781
hexadecimal-digit, 18, 783
hexadecimal-escape-sequence, 20, 784
hexadecimal-literal, 18, 783
hiding; see name hiding, 34


id
qualified, 76


id 

locale, 491
id-expression, 75
id-expression, 75, 785
identifier, 17, 75, 118
identifier, 16, 782
identifier-nondigit, 16, 782
ifstream, 701, 768
ignore


basic_istream, 745
imag
complex, 671


imbue
basic_filebuf, 774
basic_ios, 719
basic_streambuf, 730
ios_base, 713


immolation
self, 323


implementation
freestanding, 381
hosted, 381


implementation-defined, 70, 381, 384, 388, 389, 400, 

405, 407, 409, 714, 764, 773, 814 
implementation-dependent, 738, 751 
implementation-generated, 26 
implicitly-declared defaultconstructor, 220,see also de

fault constructor
implicit object argument, 250
implied object parameter, 250


implicit conversion sequences, 250 

in 

Draft 


847 INDEX INDEX 

codecvt, 503 member, 232 
in_avail member object, 233 
basic_streambuf, 728 order of, 52, 192 
includes, 654 order of base class, 234 
inclusion order of member, 234 
conditional, 359 order of virtual base class, 234 
source file, 360 overloaded assignment and, 232 
incomplete, 97 parameter, 78 
increment reference, 155, 172 
bool, 81, 89 reference member, 234 
increment operator run-time, 52 
overloaded, 269 static object, 52, 165 
indirect_array, 692 struct, 168 
indirect_array, 693 union, 171, 186 
indirection, 88 virtual base class, 234, 242 
inheritance, 191, see also multiple inheritance initialization class object, see also constructor 
Init initializer 
ios_base::Init, 712 base class, 165 
init constant, 178, 794 
basic_ios, 737, 750 member, 165 
init-declarator, 149, 792 scope of member, 235 
init-declarator-list, 149, 792 temporary and declarator, 222 
initialization, 165 initializer, 165, 793 
static member, 185 initializer-clause, 165, 793 
static object, 166 initializer-list, 165, 793 
array, 168 injected-class-name, 175 
array of class objects, 171, 232 inline, 387 
auto, 114 inline 
auto object, 165 linkage of, 48 
automatic, 113, 114 inline function, 121 
base class, 232, 233 inner_product, 695 
character array, 171 inplace_merge, 653 
class member, 167 input_iterator_tag, 607 
class object, 168, 231 insert 
const, 125, 168 basic_string, 466 
const member, 234 deque, 555 
constant, 52 list, 559 
constructor and, 231 vector, 571 
copy, 167 insert_iterator, 617 
default, 166 insert_iterator, 618 
default constructor and, 231 inserter, 619 
definition and, 118 instantiation 
direct, 167 explicit, 319 
dynamic, 52 point of, 313 
jump past, 110, 113 template implicit, 316 
local static, 114 int 
Draft 


INDEX INDEX 848 

bool promotion to, 70 
integer-literal, 18, 783 
integer-suffix, 19, 783 
integer type, 63 
integral type, 63 

sizeof, 62 
internal, 723 
invalid_argument, 416, 591, 592 

invalid_argument, 416 
invocation 

macro, 362 
<iomanip>, 735 
<ios>, 706 
ios, 701, 707 
ios_base, 707 

ios_base, 715 
ios_base::failure, 710 
ios_base::Init, 712 
<iosfwd>, 701 
iostate 

ios_base, 710 
<iostream>, 704 
is 

ctype<char>, 500
ctype, 496


is_open 
basic_filebuf, 770, 778 
basic_ifstream, 775 
basic_ofstream, 777 

isalnum, 494 
isalpha, 494 
iscntrl, 494 
isdigit, 494 
isgraph, 494 
islower, 494 
<iso646.h>, 814 
isprint, 494 
ispunct, 494 
isspace, 494 
<istream>, 734 
istream, 701, 734 
istream_iterator, 619 

operator!=, 621 
operator==, 621 
istreambuf_iterator, 622 
istreambuf_iterator, 624 

istringstream, 701, 759 
istrstream, 826 

istrstream, 827 
isupper, 494 
isxdigit, 494 
iter_swap, 642 
iteration-statement, 110, 112, 789 
<iterator>, 602 
iword 

ios_base, 715 

Jessie, 224 
jump-statement, 112, 789 

keyword,781 

label, 113 
case, 107, 109 
default, 107, 109 
scope of, 32, 107 

lattice; seeDAG 
subobject, 192 

layout 
access specifier and object, 207 
bit-field, 187 
class object, 179, 192 

layout-compatible type, 62 
left, 723 
left shift 

undefined, 99 
left shift operator, 99, 787 

length 
char_traits, 460, 462, 464–466, 468, 471–473, 

475, 476
codecvt, 504
valarray, 681


length_error, 417, 455 

length_error, 417 
less, 430 
less_equal, 431 
lexical conventions, 11 
lexicographical_compare, 659 
library 

C++ Standard, 371, 384, 386, 388 
Standard C, 371, 378, 381, 382, 811, 814, 817 
limits 

Draft 


849 INDEX INDEX 

implementation,2 
<limits>, 390 
linkage, 25, 48 

external, 48, 382, 384 

implementation-defined object, 147 

internal, 48 
linkage-specification, 144, 792 
linkage specification, 144 

extern, 144, 792 

implementation-defined, 145 
list 

operator, 17, 267 
<list>, 549 
list, 556 
literal, 18, 75 

base of integer, 19 

character, 20 

decimal, 19 

double, 22 

float, 22 

floating point, 22 

hexadecimal, 19 

char, 21 

implementation-definedvalueof multicharacter, 20 

integer, 19 

long, 19 

long double, 22 

multicharacter, 20 

narrow-character, 20 

octal, 19 

type of character, 20 

type of floating point, 22 

type of integer, 19 

unsigned, 19 
literal, 18, 783 
<locale>, 485 
locale 

locale, 491 
local class 

friend, 215 

member function in, 181 

scope of, 189 
local variable 

destruction of, 112, 113 
log, 684, 698 

complex, 672 

Draft 

log10, 684, 698 
complex, 672 
logic_error, 415 

logic_error, 416 
logical_and, 431 
logical_not, 431 
logical_or, 431 
long 

typedef and, 119 
long-long-suffix, 19, 784 
long-suffix, 19, 783 
longjmp, 413 
lookup 

argument-dependent, 38
member name, 194
name, 25, 34
template name, 301


lower_bound, 651 
lowercase, 378 
lvalue, 65, 804 

modifiable, 65 

macro 
function-like, 361 
masking, 387 
object-like, 361 

main(), 51 
implementation-defined linkage of, 51 
implementation-defined parameters to, 51 
parameters to, 51 
return from, 51, 53 

make_heap, 657 
make_pair, 427 
malloc, 444, 815 
<map>, 574 
map, 576 

operator<, 578 
operator==, 578 
mask_array, 691 
mask_array, 691 
max, 658 

valarray, 681 
max_element, 658 
max_length 

codecvt, 504 
max_size 


INDEX INDEX 850 

basic_string, 462 
mem-initializer, 232, 795 
mem-initializer-id, 232, 795 
mem_fun, 435, 436 
mem_fun1_ref_t, 435 
mem_fun1_t, 435 
mem_fun_ref, 435, 436 
mem_fun_ref_t, 435 
mem_fun_t, 434 
member, see also base class member 

class static, 54
enumerator, 130
static, 184
template and static, 289
static, 88


member-declaration, 178, 794 
member-declarator, 178, 794 
member-specification, 178, 793 
member access operator 

overloaded, 269 

member function 
class, 180 
const, 183 
constructor and, 221 
destructor and, 227 
friend, 213 
inline, 180 
local class, 190 
nested class, 217 
overload resolution and, 250 
static, 184, 185 
union, 186 
volatile, 183 

member function call 

undefined, 182 
member pointer to; see pointer to member, 63 
member use 

static, 184 
memchr, 482 
<memory>, 437 
memory model, 5 
memory management, see also new, delete 
merge, 653 

list, 561 
message 
diagnostic,2 

messages, 531 
messages_byname, 533 
min, 658 

valarray, 681 
min_element, 658 
minus, 430 
mismatch, 639 
mod, 698 
modf, 698 
modulus 

implementation defined, 97 
modulus, 430 
money_get, 525 
money_put, 527 
moneypunct, 528 
moneypunct_byname, 531 
multimap, 580 

operator<, 582 
operator==, 582 
multiple inheritance, 191, 192 

virtual and, 200 
multiplicative-expression, 97, 787 
multiplies, 430 
multiset, 586 

operator<, 589 
operator==, 589 
mutable, 119 

name, 17, 25, 75 
address of cv-qualified, 88 
dependent, 307, 313 
elaborated enum, 127 
global, 33 
length of, 17 
macro, 362 
overloaded function, 245 
overloaded member, 179 
point of declaration, 30 
predefined macro, 368 
qualified, 40 
reserved, 383 
scope of, 29 
unqualified, 35 

name 
locale, 492 
type_info, 406 

Draft 


851 INDEX INDEX 

namespace, 380, 817 
global, 384 
unnamed, 132 
namespaces, 130 
name class, see class name 
name hiding, 30, 34, 75, 76, 113, 785 
class definition, 176 
function, 248 
overloading versus, 248 
user-defined conversion and, 223 
name space 
label, 107 

narrow 
basic_ios, 720 
ctype<char>, 501 
ctype, 497 
NDEBUG, 382 
negate, 430 
nested-name-specifier, 76, 785 
nested class 
local class, 190 
scope of, 188 
<new>, 385, 401 
new, 54, 90, 91 
operator, 401, 404, 444 
array of class objects and, 92 
constructor and, 92 
default constructor and, 92 
exception and, 93 
initialization and, 92 
operator, 385, 402–404 
scoping and, 90 
storage allocation, 90 
type of, 229 
unspecified constructor and, 94 
unspecified order of evaluation, 94 
new-declarator, 90, 786 
new-expression, 90, 786 
new-initializer, 90, 787 
new-placement, 90, 786 
new-type-id, 90, 786 
new_handler, 55, 405 
next_permutation, 659 
noboolalpha, 722 
nondigit, 16, 783 

none 

bitset, 595
nonzero-digit, 18, 783


norm 
complex, 671 
noshowbase, 722 
noshowpoint, 722 
noshowpos, 722 
noskipws, 723 
not1, 432 
not2, 432 
not_equal_to, 430 
notation 
syntax,5 
nounitbuf, 723 
nouppercase, 723 
NTBS, 379, 770, 827, 828 
static, 379 
NTCTS, 373 
nth_element, 650 
NTMBS, 379 
static, 379 
NTWCS, 379 
static, 379 
NULL, 389 
num_get, 507 
num_put, 511 
number 
hex, 21 
octal, 21 
<numeric>, 694 
numeric_limits, 63, 391 
numpunct, 516 
numpunct_byname, 518 

object,5, 25, 65 
complete,5 
definition, 27 
delete, 94 
static, 53 
destructor and placement of, 228 
linkage specification, 147 
local static, 54 
undefined deleted, 56 
unnamed, 220 
object-expression, 74 
object class, see also class object 

Draft 


INDEX INDEX 852 

object lifetime, 56 
object temporary, see temporary 
object type, 62 
oct, 724 
octal-digit, 18, 783 
octal-escape-sequence, 20, 784 
octal-literal, 18, 783 
offsetof, 815 
ofstream, 701, 768 
open 

basic_filebuf, 770, 778 
basic_ifstream, 775 
basic_ofstream, 777 
messages, 532 

openmode 
ios_base, 710 

operator, 268, 682, 683 
*=, 103 
+=, 89, 103 
-=, 103 
/=, 103 
%=, 103 
&=, 103 
^=, 103 
<<=, 103 
>>=, 103 
|=, 103 
additive, 97 
address-of, 88, 786 
assignment, 103, 380 
bitwise, 101 
bitwise AND, 101 
bitwise exclusive OR, 101 
bitwise inclusive OR, 101 
cast, 88, 95, 150, 786 
class member access, 79 
comma, 104 
conditional expression, 102 
copyassignment, 239 
decrement, 81, 88, 89, 786 
division, 97, 787 
equality, 100, 787 
function call, 77, 267 
greater than, 99, 787 
greater than or equal to, 99, 787 
increment, 81, 88, 89, 786 

indirection, 88, 786 
inequality, 100, 787 
less than, 99, 787 
less than or equal to, 99, 787 
logical AND, 101 
logical negation, 88, 89, 786 
logical OR, 102 
modulus, 97, 787 
multiplication, 97, 787 
multiplicative, 97 
one’s complement, 88, 89, 786 
overloaded, 73 
pointer to member, 96 
pragma, 369 
precedence of, 8 
relational, 99 
scope resolution, 75, 76, 91, 181, 191, 202, 785 
side effects and comma, 104 
side effects and logical AND, 101 
side effects and logical OR, 102 
sizeof, 88, 89, 786 
subscripting, 77, 267 
unary, 88, 786 
unary minus, 88, 89, 786 
unary plus, 88, 89, 786 

operator 

overloaded, 267 

operator, 267 

operator delete, 91, see also delete, 95, 229 

operator new, see also new, 91 

operator! 

basic_ios, 721 

valarray, 680 

operator!=, 425 

basic_string, 476 

complex, 670 

istreambuf_iterator, 625 

locale, 493 

reverse_iterator, 613 

type_info, 406 

bitset, 594 

queue, 563 

stack, 566 

valarray, 683 

operator() 

locale, 493 

Draft 


853 INDEX INDEX 

operator* gslice_array, 690 
auto_ptr, 443 indirect_array, 693 
back_insert_iterator, 616 mask_array, 692 
complex, 670 reverse_iterator, 613 
front_insert_iterator, 617 slice_array, 687 
insert_iterator, 618 valarray, 680 
istreambuf_iterator, 624 operator-> 
ostreambuf_iterator, 626 auto_ptr, 443 
reverse_iterator, 611 reverse_iterator, 611 
valarray, 682 operator-function-id, 267, 795 
operator*= operator/ 
complex, 668, 669 valarray, 682 
gslice_array, 690 operator/= 
indirect_array, 693 complex, 669 
mask_array, 692 gslice_array, 690 
slice_array, 687 indirect_array, 693 
valarray, 680 mask_array, 692 
operator+ slice_array, 687 
basic_string, 475 valarray, 680 
complex, 669 operator< 
reverse_iterator, 612, 614 basic_string, 476 
valarray, 680 pair, 427 
valarray, 682 reverse_iterator, 613 
operator++ queue, 563 
back_insert_iterator, 616 stack, 566 
front_insert_iterator, 617 valarray, 683 
insert_iterator, 618 operator<< 
istreambuf_iterator, 624 basic_ostream, 752, 753 
ostreambuf_iterator, 626 basic_string, 478 
reverse_iterator, 612 complex, 670 
operator+= bitset, 595, 596 
basic_string, 464 valarray, 682 
complex, 668, 669 operator<<= 
gslice_array, 690 gslice_array, 690 
indirect_array, 693 indirect_array, 693 
mask_array, 692 mask_array, 692 
reverse_iterator, 612 slice_array, 687 
slice_array, 687 bitset, 592 
valarray, 680 valarray, 680 
operator-operator<=, 426 
complex, 669 basic_string, 477 
reverse_iterator, 613, 614 reverse_iterator, 614 
valarray, 680 queue, 563 
valarray, 682 stack, 566 
operator-= valarray, 683 
complex, 668, 669 operator= 
Draft 


INDEX INDEX 854 

auto_ptr, 443 istream, 739 
back_insert_iterator, 616 bitset, 595, 596 
bad_alloc, 405 valarray, 682 
bad_cast, 407 operator>>= 
bad_exception, 409 gslice_array, 690 
bad_typeid, 408 indirect_array, 693 
basic_string, 461 mask_array, 692 
exception, 409 slice_array, 687 
front_insert_iterator, 617 bitset, 593 
gslice_array, 690 valarray, 680 
indirect_array, 693 operator[] 
insert_iterator, 618 basic_string, 463 
mask_array, 691 map, 579 
ostreambuf_iterator, 626 reverse_iterator, 613 
reverse_iterator, 611 valarray, 679 
slice_array, 686 operator% 
type_info, 406 valarray, 682 
valarray, 678 operator%= 
operator== gslice_array, 690 
basic_string, 476 indirect_array, 693 
complex, 670 mask_array, 692 
istreambuf_iterator, 625 slice_array, 687 
locale, 492 valarray, 680 
pair, 426 operator& 
reverse_iterator, 613 bitset, 595 
type_info, 406 valarray, 682 
bitset, 594 operator&= 
queue, 563 gslice_array, 690 
stack, 566 indirect_array, 693 
valarray, 683 mask_array, 692 
operator>, 426 slice_array, 687 
basic_string, 477 bitset, 592 
reverse_iterator, 614 valarray, 680 
queue, 563 operator&& 
stack, 567 valarray, 682, 683 
valarray, 683 operator^ 
operator>=, 426 bitset, 595 
basic_string, 478 valarray, 682 
reverse_iterator, 614 operator^= 
queue, 564 gslice_array, 690 
stack, 567 indirect_array, 693 
valarray, 683 mask_array, 692 
operator>> slice_array, 687 
basic_istream, 740 bitset, 592 
basic_string, 478 valarray, 680 
complex, 670 operator-
Draft 


855 INDEX INDEX 

reverse_iterator, 612 

operator~ 
valarray, 680 
bitset, 593 

operator| 
bitset, 595 
valarray, 682 

operator|= 
gslice_array, 690 
indirect_array, 693 
mask_array, 692 
slice_array, 687 
bitset, 592 
valarray, 680 

operator left shift, see left shift operator 
operator overloading, see also overloaded operator 
operator right shift; right shift operator, 98 
operator shift, see left shift operator, right shift operator 
operator use 

scope resolution, 185 
optimization of temporary, see elimination of temporary 
ordering 
function template partial, 300 

order of execution 
base class constructor, 220 
base class destructor, 227 
constructor and static objects, 232 
constructor and array, 231 
destructor, 227 
destructor and array, 227 
member constructor, 220 
member destructor, 227 

<ostream>, 734 
ostream, 701, 735 
ostream_iterator, 621 
ostreambuf_iterator, 625 

ostreambuf_iterator, 626 
ostringstream, 701, 759 
ostrstream, 827 

ostrstream, 828 
out 
codecvt, 503 
out_of_range, 417, 455, 591–595 
out_of_range, 417 
output_iterator_tag, 607 

overflow, 73
undefined, 73


overflow 
basic_filebuf, 772 
basic_streambuf, 733 
basic_stringbuf, 762 
strstreambuf, 823 

overflow_error, 418, 591, 594 
overflow_error, 418 
overloaded function 
address of, 89, 265 
overloaded operator, 267 
inheritance of, 268 
overloading, 159, 176, 245, 298 

example of, 245 
overload resolution contexts, 249 
overrider 

final, 198 

pair, 426 

parameter, 2 
reference, 155 
scope of, 31 
void, 158 

parameter-declaration, 158, 793 
parameterized type, see template 
parameters 

macro, 362
parameter list


variable, 78, 158 
parameter type list, 159 
partial_sort, 649 
partial_sort_copy, 650 
partial_sum, 696 
partition, 647 
pbackfail 

basic_filebuf, 772 
basic_streambuf, 733 
basic_stringbuf, 762 
strstreambuf, 824 

pbase 
basic_streambuf, 730 
pbump 
basic_streambuf, 730 
pcount 
ostrstream, 828 

Draft 


INDEX INDEX 856 

strstreambuf, 823 prev_permutation, 660 
strstream, 830 priority_queue, 564 
peek priority_queue, 564 
basic_istream, 745 private, 205 
period, 378 program, 48 
phases ill-formed, 2 
translation, 11 well-formed, 3 
placement syntax promotion 
new, 92 floating point, 70 
plus, 429 integral, 70 
pm-expression, 96, 787 protected, 205 
POD-struct, 175 protection, see access control, 388 
POD class type, 92 proxy 
POD type, 92 istreambuf_iterator, 623 
POF, 413 pseudo-destructor-name, 79 
pointer pseudo-destructor-name, 77, 786 
zero, 71 ptr-operator, 150, 792 
void*, 64 ptr_fun, 434 
pointer_to_binary_function, 434 ptrdiff_t, 98 
pointer_to_unary_function, 434 implementation defined type of, 98 
pointer to member, 63, 96 pubimbue 
polar basic_streambuf, 728 
complex, 671 public, 205 
pop pubseekoff 
priority_queue, 565 basic_streambuf, 728 
pop_heap, 657 pubseekpos 
postfix ++ and basic_streambuf, 728 
overloading, 269 pubsetbuf 
postfix ++ and -, 81 basic_streambuf, 728 
pow, 684, 698 pubsync 
complex, 672 basic_streambuf, 728 
pp-number, 16, 782 punctuators, 17 
pptr pure-specifier, 178, 794 
basic_streambuf, 730 pure specifier, 178, 794 
precision push 
ios_base, 495, 713 priority_queue, 565 
prefix push_heap, 657 
L, 20, 22 put 
prefix ++ and basic_ostream, 755 
overloading, 269 money_put, 527 
prefix ++ and -, 89 num_put, 512 
preprocessing, 357 time_put, 523 
preprocessing-op-or-punc, 18 putback 
preprocessing-token, 14, 782 basic_istream, 746 
preprocessor pword 
macro, 357 ios_base, 715 
Draft 


857 INDEX INDEX 

qualification 

explicit, 40 
qualified-id, 75, 785 
<queue>, 549 
queue, 562 

random_access_iterator_tag, 607 
random_shuffle, 647 
range_error, 418 

range_error, 418 
rbegin 
basic_string, 462 

rdbuf 
basic_filebuf, 778 
basic_ifstream, 775 
basic_ios, 719 
basic_istringstream, 765 
basic_ofstream, 777 
basic_ostringstream, 766 
basic_stringstream, 768 
istrstream, 827 
ostrstream, 828 
strstream, 829 

rdstate 
basic_ios, 721 
read 
basic_istream, 745 
readsome 
basic_istream, 745 
real 

complex, 671 
realloc, 444 
redefinition 

enumerator, 128 

typedef, 122 
reentrancy, 388 
reference, 63 

assignment to, 104
call by, 78
const, 173
direct binding of, 173
null, 155
sizeof, 89


reference-compatible, 172 
reference-related, 172 
region 

declarative, 25, 29
register, 119
register_callback


ios_base, 715 
rel_ops, 425 
relational-expression, 99, 787 

release 

auto_ptr, 443 
remainder operator, see modulus operator 
remove, 644 

list, 561
remove_copy, 644
remove_copy_if, 644
remove_if, 644
rend


basic_string, 462
replace, 642


basic_string, 468
replace_copy, 643
replace_copy_if, 643
replace_if, 642
replacement


macro, 361 

representation
object, 60
value, 60


requirements, 375 
Allocator, 423 
container, 539 
CopyConstructible, 422 
EqualityComparable, 421 
iterator, 597 
LessThanComparable, 422 
numeric type, 663 
Swappable, 422 

reraise, 348 
rescanning and replacement, 364 

reserve
basic_string, 463
vector, 570


reserved identifier, 17 

reset
auto_ptr, 443
bitset, 593


resetiosflags, 757
resize


Draft 


INDEX INDEX 858 

basic_string, 462
deque, 554
list, 559
vector, 570
valarray, 682


resolution 
argument matching, see overload 
function template overload, 343 
overload, 249 
overloaded function call resolution, see also argu

ment matching, overload
resolution overloading, see overload
scoping ambiguity, 195
template name, 301
template overload, 300


restriction, 386–388 
static member local class, 185 
address of bit-field, 187 
anonymous union, 186 
auto, 119 
bit-field, 187 
constructor, 220 
copyassignment operator, 243 
copyconstructor, 241 
destructor, 226, 227 
enumerator, 128 
extern, 120 
local class, 190 
overloading, 268 
pointer to bit-field, 187 
reference, 155 
register, 119 
static, 120 
union, 186, 220 

restrictions 

operator overloading, 267 
rethrow, 348 
return, 112, 113, 789 

constructor and, 113 

reference and, 172 
return statement, see also return 
return type, 159 

overloading and, 245 
reverse, 645 
list, 561 
reverse_copy, 646 

reverse_iterator, 608 
reverse_iterator, 610 
rfind 

basic_string, 471
right, 723
right shift


implementation defined, 99 
right shift operator, 99, 787 
rotate, 646 
rotate_copy, 646 
rounding, 71 
rule 

as-if,6
one-definition, 27
runtime_error, 417
runtime_error, 417


rvalue, 65 
lvalue conversion to, 68 
lvalue conversion to, 804 

s-char, 22, 785
s-char-sequence, 22, 785


sbumpc 
basic_streambuf, 729 
scalar type, 62 

scan_is
ctype<char>, 501
ctype, 496


scan_not
ctype<char>, 501
ctype, 497


scientific, 724 

scope, 25, 29 
anonymous union at namespace, 186 
class, 33 
destructor and exit from, 112 
exception declaration, 31 
function, 32 
global, 33 
global namespace, 33 
iteration-statement, 110 
local, 31 
macro definition, 364 
namespace, 32 
overloading and, 248 
potential, 29 

Draft 


859 INDEX INDEX 

selection-statement, 108 
scope resolution operator, 41 
search, 640 
seekdir 

ios_base, 712 
seekg 
basic_istream, 746 

seekoff 
basic_filebuf, 773 
basic_streambuf, 731 
basic_stringbuf, 762 
strstreambuf, 824 

seekp 
basic_ostream, 751 

seekpos 
basic_filebuf, 773 
basic_streambuf, 731 
basic_stringbuf, 763 
strstreambuf, 826 

selection-statement, 108, 789 
semantics 
class member, 79 

sentry 
basic_istream, 738 
basic_ostream, 750 

sequence 
ambiguous conversion, 260 
implicit conversion, 259 
standard conversion, 67 
statement, 107 

sequence point, 7 
sequence point, 73 
sequencing operator, see comma operator 
<set>, 575 
set, 583 

operator<, 586
operator==, 586
bitset, 593


set_difference, 655 
set_intersection, 655 
set_new_handler, 385, 405 
set_symmetric_difference, 656 
set_terminate, 385, 411 
set_unexpected, 385, 410 
set_union, 654 
setbase, 757 

setbuf
basic_filebuf, 773
basic_streambuf, 731
streambuf, 826
strstreambuf, 826


setf 

ios_base, 713
setfill, 758
setg


basic_streambuf, 730
setiosflags, 757
setjmp, 384
setlocale, 378
setp


basic_streambuf, 730
setprecision, 758
setstate


basic_ios, 721
setw, 758
sgetc


basic_streambuf, 729
sgetn
basic_streambuf, 729
shift


valarray, 681 
shift-expression, 99, 787 
shift operator, see left shift operator, right shiftoperator 

short 

typedef and, 119
showbase, 722
showmanyc


basic_filebuf, 771 

basic_streambuf, 731, 771
showpoint, 722
showpos, 722
side,7
side effects, 73
sign, 22, 784
signature,3


signed 

typedef and, 119
simple-escape-sequence, 20, 784
simple-type-specifier, 126, 790
sin, 684, 698


complex, 672
sinh, 684, 698


Draft 


INDEX INDEX 860 

complex, 672 

size 
basic_string, 462 
gslice, 689 
slice, 685 
bitset, 594 

size_t, 90 
sizeof 

empty class, 175 
skipws, 722 
slice, 685 

slice, 685 
slice_array, 686 
slice_array, 686 
smanip 

implementation-defined, 757 

snextc 
basic_streambuf, 728 
sort, 649 

list, 561 
sort_heap, 658 
space 

white, 14 

specialization 
class template, 281 
class template partial, 293 
template, 314 
template explicit, 321 

special member function, see constructor, destructor, 
inline function, user-defined conversion, virtual function 

specification 
template argument, 327 

specifications 
C++ Standard Library exception, 388 
implementation-defined exception, 388 
StandardClibraryexception, 388 

specifier 
auto, 119 
declaration, 118 
explicit, 122 
friend, 388 
friend, 124 
function, 121 
inline, 121 
missing storage class, 120 

static, 119 
storage class, 119 
typedef, 122 
virtual, 122 

specifier access, see access specifier 
specifier type, see type specifier 

splice 
list, 560 
sputbackc 
basic_streambuf, 729 
sputc 
basic_streambuf, 729 
sputn 
basic_streambuf, 729 
sqrt, 684, 698 

complex, 672 
<sstream>, 759 
stable algorithm, 373 
stable_partition, 647 
stable_sort, 649 
<stack>, 550 
stack, 565 
standard 

structure of, 4
start
program, 51, 52


start
gslice, 689
slice, 685


startup 
program, 383, 385 
state 
object, 372 

state
fpos, 716


statement, 107 
continue in for, 111 
break, 112, 789 
compound, 107 
continue, 112, 789 
declaration, 113 
declaration in for, 112 
declaration in switch, 110 
do, 110, 111, 789 
empty, 107 
expression, 107 

Draft 


861 INDEX INDEX 

for, 110, 111, 789 
goto, 107, 112, 113, 789 
if, 108, 109, 789 
iteration, 110 
jump, 112 
labeled, 107 
null, 107 
selection, 108 
switch, 108, 109, 112, 789 
while, 110, 789 
statement, 107, 788 
static, 119 
destruction of local, 114 
linkage of, 48, 120 
overloading and, 245 
static_assert, 117, 118, 790 
<stddef.h>, 20, 22 
<stdexcept>, 415 
<stdlib.h>, 818 
storage class, 25 
storage duration, 54 
auto, 54 
class member, 56 
dynamic, 54, 90 
local object, 54 
storage management, see new, delete 
str 
basic_istringstream, 765 
basic_ostringstream, 766 
basic_stringbuf, 761 
basic_stringstream, 768 
istrstream, 827 
ostrstream, 828 
strstreambuf, 823 
strstream, 830 
strchr, 480 
stream 
arbitrary-positional, 371 
repositional, 373 
<streambuf>, 724 
streambuf, 701, 724 
implementation-defined, 701 
streamoff, 707, 716, 818 
implementation-defined, 707, 818 

streampos 

implementation-defined, 818 

streamsize, 707 
strftime, 524 
stride 
gslice, 689 
slice, 685 
string 
distinct, 22 
null-terminated byte, 379 
null-terminated character type, 373 
null-terminated multibyte, 379 
null-terminated wide-character, 379 
sizeof, 23 
type of, 22 
<string>, 452 
string-literal, 22, 785 
stringbuf, 701, 759 
stringstream, 701 
string literal, 22 
implementation-defined, 22 
narrow, 22 
type of, 22 
undefined change to, 22 
wide, 22 
strlen, 822 
strlen, 822, 828 
strpbrk, 482 
strrchr, 482 
strstr, 482 
strstream, 828 
strstream, 829 
strstreambuf, 819 
strstreambuf, 821 
struct 
class versus, 175 
structure, 175 
structure tag, see class name 
subobject,5 
subscripting operator 
overloaded, 269 
subsequence rule 
overloading, 263 

substr 
basic_string, 474 
subtraction 
implementation defined pointer, 98 
subtraction operator, 97, 787 

Draft 


INDEX INDEX 862 

suffix 
E, 22 
F, 22 
f, 22 
L, 19, 22 
l, 19, 22 
U, 19 
u, 19 

sum 
valarray, 681 

summary 
compatibility with ISO C, 801 
scope rules, 34 

summary, syntax, 781 

sungetc 
basic_streambuf, 729 

swap, 641 
basic_string, 470, 478 
vector, 570 

swap_ranges, 641 

sync 
basic_filebuf, 774 
basic_istream, 746 
basic_streambuf, 731 

sync_with_stdio 
ios_base, 714 
synonym, 134 
type name as, 122 
syntax 
class member, 79 

table 
ctype<char>, 501 
tan, 684, 698 
complex, 672 
tanh, 684, 698 
complex, 672 
tellg 
basic_istream, 746 
tellp 
basic_ostream, 751 

template, 275 
definition of, 275 
function, 327 
member function, 288 
primary, 293 

template, 275, 795
template-argument, 280, 795
template-argument-list, 279, 795
template-declaration, 275, 795
template-id, 279, 795
template-name, 279, 795
template-parameter, 276, 795
template-parameter-list, 275, 795
template name


linkage of, 275 

temporary, 221 
constructor for, 222 
destruction of, 222 
destructor for, 222 
elimination of, 221, 244 
implementation-defined generation of, 221 
order of destruction of, 222 

terminate, 53, 400, 410, 411
terminate(), 354
terminate_handler, 385, 410
termination


program, 51, 53
terminology
pointer, 64


test
bitset, 595
this, 75


type of, 183
this pointer, see this
thousands_sep


numpunct, 517
throw, 345, 796
throw-expression, 345, 796
throwing


exception, 346 

tie 

basic_ios, 719
time_get, 520
time_get_byname, 523
time_put, 523
time_put_byname, 524
to_string


bitset, 594
to_ulong
bitset, 594
token, 15, 18


Draft 


863 INDEX INDEX 

token, 15, 782 

tolower, 494 

ctype<char>, 501 

ctype, 497 
toupper, 494 

ctype<char>, 501 

ctype, 497 
traits, 373 
transform, 642 

collate, 519 
translation 

separate, 11 
translation unit, 11, 48 

name and, 25 
trigraph, 11 
truename 

numpunct, 517 
truncation, 71 
try, 345, 796 
try-block, 345, 796 
type, 25 

arithmetic, 63 

array, 63, 159 

bitmask, 377, 378 

Boolean, 62 

char, 62 

character, 62 

character container, 372 

class and, 175 

compound, 63 

const, 124, 790 

destination, 167 

double, 63 

dynamic,2 

enumerated, 63, 377 

enumeration underlying, 129 

example of incomplete, 61 

float, 63 

floating point, 62 

function, 63, 158, 159 

fundamental, 62 

sizeof, 62 

incomplete, 27, 31, 61, 68, 77–79, 81, 83, 88–90, 

94, 104, 191 

int, 62 

integral, 62 

long, 62 
long double, 63 
multi-level mixed pointer and pointer to member, 

69 
multi-level pointer to member, 69 
object,5 
POD, 62 
pointer, 63 
polymorphic, 198 
short, 62 
signed char, 62 
static,3 
underlying wchar_t, 62 
unsigned, 62 
unsigned char, 62 
unsigned int, 62 
unsigned long, 62 
unsigned short, 62 
void, 63 
volatile, 124, 790 
wchar_t, 62 

type-id, 150, 792
type-id-list, 351, 796
type-name, 126
type-parameter, 276, 795
type-specifier


bool, 126 

wchar_t, 126
type-specifier, 124, 790
type_info, 82, 406


type_info, 406
type_info::name


implementation-defined, 406
typedef
function, 160


typedef 

overloading and, 246
typedef-name, 122, 790
typeid, 82
<typeinfo>, 405
typename, 127, 791
types


implementation-defined, 377 
implementation-defined exception, 388 
type checking 
argument, 78 

Draft 


INDEX INDEX 864 

type conversion, explicit, see casting 
type generator, see template 
type name, 150 
nested, 190 
scope of nested, 190 
type pun, 86 
type specifier 
char, 126 
class, 175, 793 
double, 126 
enum, 127, 791 
float, 126 
int, 126 
long, 126 
short, 126 
struct, 175, 793 
union, 175, 793 
unsigned, 126 
void, 126 
volatile, 126 

uflow 
basic_filebuf, 772 
basic_streambuf, 733 
unary-expression, 88, 786 
unary-operator, 88, 786 
unary_function, 429 
unary_negate, 431 
unary operator 
interpretation of, 268 
overloaded, 268 
uncaught_exception, 411 
undefined, 70, 373, 383, 384, 386, 413, 463, 678–682, 
684, 689, 693, 694, 717 
undefined behavior, 623 

underflow 
basic_filebuf, 771 
basic_streambuf, 732 
basic_stringbuf, 761 
strstreambuf, 824 
underflow_error 
underflow_error, 418 
unexpected, 410 
unexpected(), 354 
unexpected_handler, 385, 410 
unget 

basic_istream, 746
uninitialized_copy, 441
uninitialized_fill, 441
uninitialized_fill_n, 441
union, 63, 186
class versus, 175
anonymous, 186
global anonymous, 186
unique, 645
list, 561
unique_copy, 645
unit
instantiation, 12
translation, 382, 383
unitbuf, 723
universal-character-name, 13, 782
unqualified-id, 75, 785


unsetf 
ios_base, 713 
unshift 
codecvt, 503 
unsigned 
typedef and, 119 
unsigned-suffix, 19, 783 
unspecified, 401–403, 406, 460, 650, 762, 821, 823, 
824 
unspecified behavior, 681 
unwinding 
stack, 349 
upper_bound, 651 
uppercase, 378, 383 
uppercase, 723 
use_facet 
locale, 494 
using-declaration, 135 
using-directive, 141 
<utility>, 425 

va_end, 384
va_list, 384
<valarray>, 672
valarray, 676, 690
valarray, 677
value
call by, 78
null member pointer, 71


Draft 


865 INDEX INDEX 

null pointer, 71 
undefined unrepresentable integral, 71 
value-initialization, 166 
variable 
indeterminate uninitialized, 166 
<vector>, 550 
vector, 567 
operator<, 569 
operator==, 569 
vector, 569 
vector<bool>, 572 
operator<, 574 
operator==, 574 
virtual base class, 193 
virtual function, 198 
pure, 202, 203 
virtual function call, 202 
constructor and, 237 
destructor and, 237 
undefined pure, 203 
visibility, 34 

void* 

type, 64 
void&, 155 
volatile, 64 
constructor and, 184, 220 
destructor and, 184, 226 
implementation-defined, 126 
overloading and, 247 

wcerr, 705 
wchar_t, 20, 22, 379, 480 
implementation-defined, 62 
wcin, 705 
wclog, 706 
wcout, 705 
wcschr, 482 
wcspbrk, 482 
wcsrchr, 482 
wcsstr, 482 
wfilebuf, 701, 768 
wfstream, 701 
what 
bad_alloc, 405 
bad_cast, 407 
bad_exception, 409 

bad_typeid, 408 
exception, 409 
ios_base::failure, 710 
white space, 15 
wide-character, 20 

widen 
basic_ios, 720 
ctype<char>, 501 
ctype, 497 
width 
ios_base, 495, 713 
wifstream, 701, 768 
wios, 707 
wistream, 701, 734 
wistringstream, 701, 759 
wmemchr, 483 
wofstream, 701, 768 
wostream, 701, 735 
wostringstream, 701, 759 
write 
basic_ostream, 755 
ws, 747 
ws, 740 
wstreambuf, 701, 724 
wstringbuf, 701, 759 
wstringstream, 701 

X(X&), see copyconstructor 
xalloc 
ios_base, 714 
xsgetn 
basic_streambuf, 731 
xsputn 
basic_streambuf, 733 

zero 
undefined division by, 73, 97 
undefined modulus, 73 
zero-initialization, 166 

Draft 


